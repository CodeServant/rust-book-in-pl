[
    {
        "file_path": "title-page.md",
        "content": "# JÄ™zyk programowania Rust\n\n_autorzy: Steve Klabnik, Carol Nichols i Chris Krycho, Maciej Ostrowski (przekÅ‚ad pl gemini-2.5-pro sty 26 r.), przy\nkontrybucjach SpoÅ‚ecznoÅ›ci Rusta_\n\nTa wersja tekstu zakÅ‚ada, Å¼e uÅ¼ywasz Rusta w wersji 1.90.0 (wydanie 2025-09-18)\nlub nowszej z `edition = \"2024\"` w pliku *Cargo.toml* wszystkich projektÃ³w, aby\nskonfigurowaÄ‡ je do uÅ¼ywania idiomÃ³w wydania Rust 2024. Zobacz [sekcjÄ™ â€Instalacjaâ€\nw Rozdziale 1][install]<!-- ignore -->, aby uzyskaÄ‡ instrukcje dotyczÄ…ce instalacji lub\naktualizacji Rusta, oraz [Dodatek E][appendix-e]<!-- ignore -->, aby uzyskaÄ‡ informacje\no wydaniach.\n\nFormat HTML jest dostÄ™pny online pod adresem\n[https://doc.rust-lang.org/stable/book/](https://doc.rust-lang.org/stable/book/)\noraz offline z instalacjami Rusta wykonanymi za pomocÄ… `rustup`; uruchom `rustup doc\n--book`, aby otworzyÄ‡.\n\nDostÄ™pne sÄ… rÃ³wnieÅ¼ liczne [tÅ‚umaczenia] spoÅ‚ecznoÅ›ci.\n\nTen tekst jest dostÄ™pny w [formacie papierowym i ebooku od No Starch\nPress][nsprust].\n\n[install]: ch01-01-installation.html\n[appendix-e]: appendix-05-editions.html\n[nsprust]: https://nostarch.com/rust-programming-language-3rd-edition\n[translations]: appendix-06-translation.html\n\n> **ğŸš¨ Chcesz bardziej interaktywnego doÅ›wiadczenia edukacyjnego? WyprÃ³buj innÄ… wersjÄ™\n> KsiÄ…Å¼ki o RuÅ›cie, zawierajÄ…cÄ…: quizy, wyrÃ³Å¼nienia, wizualizacje i\n> wiele wiÄ™cej**: <https://rust-book.cs.brown.edu>\n",
        "chapter_title": "JÄ™zyk programowania Rust"
    },
    {
        "file_path": "foreword.md",
        "content": "# Przedmowa\n\nJÄ™zyk programowania Rust przeszedÅ‚ dÅ‚ugÄ… drogÄ™ w ciÄ…gu kilku krÃ³tkich lat, od\njego stworzenia i inkubacji przez maÅ‚Ä… i rodzÄ…cÄ… siÄ™ spoÅ‚ecznoÅ›Ä‡ entuzjastÃ³w,\naÅ¼ po stanie siÄ™ jednym z najbardziej lubianych i poszukiwanych jÄ™zykÃ³w\nprogramowania na Å›wiecie. Z perspektywy czasu byÅ‚o nieuniknione, Å¼e moc i obietnica\nRusta przyciÄ…gnÄ… uwagÄ™ i zakorzeniÄ… siÄ™ w programowaniu systemowym. To, co nie\nbyÅ‚o nieuniknione, to globalny wzrost zainteresowania i innowacji, ktÃ³ry\nprzeniknÄ…Å‚ przez spoÅ‚ecznoÅ›ci open source i katalizowaÅ‚ szeroko zakrojonÄ…\nadopcjÄ™ w rÃ³Å¼nych branÅ¼ach.\n\nW tym momencie Å‚atwo jest wskazaÄ‡ wspaniaÅ‚e cechy, ktÃ³re Rust ma do zaoferowania,\naby wyjaÅ›niÄ‡ ten wybuch zainteresowania i adopcji. Kto nie chce bezpieczeÅ„stwa\npamiÄ™ci *i* szybkiej wydajnoÅ›ci, *i* przyjaznego kompilatora, *i*\nwspaniaÅ‚ych narzÄ™dzi, poÅ›rÃ³d wielu innych wspaniaÅ‚ych funkcji? JÄ™zyk Rust,\nktÃ³ry widzisz dzisiaj, Å‚Ä…czy lata badaÅ„ w programowaniu systemowym z praktycznÄ…\nmÄ…droÅ›ciÄ… tÄ™tniÄ…cej Å¼yciem i peÅ‚nej pasji spoÅ‚ecznoÅ›ci. Ten jÄ™zyk zostaÅ‚\nzaprojektowany z myÅ›lÄ… o celu i starannie wykonany, oferujÄ…c deweloperom\nnarzÄ™dzie, ktÃ³re uÅ‚atwia pisanie bezpiecznego, szybkiego i niezawodnego kodu.\n\nAle to, co czyni Rusta naprawdÄ™ wyjÄ…tkowym, to jego korzenie w umoÅ¼liwianiu\ntobie, uÅ¼ytkownikowi, osiÄ…gania twoich celÃ³w. Jest to jÄ™zyk, ktÃ³ry chce, abyÅ›\nodniÃ³sÅ‚ sukces, a zasada wzmacniania pozycji przeplata siÄ™ przez rdzeÅ„\nspoÅ‚ecznoÅ›ci, ktÃ³ra buduje, utrzymuje i promuje ten jÄ™zyk. Od poprzedniego\nwydania tego definitywnego tekstu, Rust rozwinÄ…Å‚ siÄ™ w prawdziwie globalny i\nzaufany jÄ™zyk. Projekt Rust jest teraz solidnie wspierany przez FundacjÄ™ Rust,\nktÃ³ra rÃ³wnieÅ¼ inwestuje w kluczowe inicjatywy, aby zapewniÄ‡, Å¼e Rust jest\nbezpieczny, stabilny i zrÃ³wnowaÅ¼ony.\n\nNiniejsze wydanie ksiÄ…Å¼ki *JÄ™zyk programowania Rust* jest kompleksowÄ…\naktualizacjÄ…, odzwierciedlajÄ…cÄ… ewolucjÄ™ jÄ™zyka na przestrzeni lat i dostarczajÄ…cÄ…\ncennych nowych informacji. Ale to nie tylko przewodnik po skÅ‚adni i bibliotekach\nâ€” to zaproszenie do przyÅ‚Ä…czenia siÄ™ do spoÅ‚ecznoÅ›ci, ktÃ³ra ceni jakoÅ›Ä‡,\nwydajnoÅ›Ä‡ i przemyÅ›lany projekt. NiezaleÅ¼nie od tego, czy jesteÅ› doÅ›wiadczonym\ndeweloperem, ktÃ³ry po raz pierwszy chce poznaÄ‡ Rusta, czy doÅ›wiadczonym\nRustaceanem, ktÃ³ry chce udoskonaliÄ‡ swoje umiejÄ™tnoÅ›ci, to wydanie oferuje\ncoÅ› dla kaÅ¼dego.\n\nPodrÃ³Å¼ z Rustem to podrÃ³Å¼ wspÃ³Å‚pracy, nauki i iteracji. RozwÃ³j jÄ™zyka i jego\nekosystemu jest bezpoÅ›rednim odzwierciedleniem tÄ™tniÄ…cej Å¼yciem, rÃ³Å¼norodnej\nspoÅ‚ecznoÅ›ci, ktÃ³ra za nim stoi. Kontrybucje tysiÄ™cy deweloperÃ³w, od\nprojektantÃ³w podstawowych jÄ™zykÃ³w po okazjonalnych kontrybutorÃ³w, sprawiajÄ…,\nÅ¼e Rust jest tak wyjÄ…tkowym i potÄ™Å¼nym narzÄ™dziem. BiorÄ…c tÄ™ ksiÄ…Å¼kÄ™ do rÄ™ki,\nnie tylko uczysz siÄ™ nowego jÄ™zyka programowania â€” doÅ‚Ä…czasz do ruchu, ktÃ³ry\nma na celu ulepszanie oprogramowania, czynienie go bezpieczniejszym i przyjemniejszym\nw obsÅ‚udze.\n\nWitaj w spoÅ‚ecznoÅ›ci Rusta!\n\n- Bec Rumbul, dyrektor wykonawcza Fundacji Rust\n",
        "chapter_title": "Przedmowa"
    },
    {
        "file_path": "ch00-00-introduction.md",
        "content": "# Wprowadzenie\n\n> Uwaga: To wydanie ksiÄ…Å¼ki jest takie samo jak [JÄ™zyk programowania Rust][nsprust]\ndostÄ™pny w formie drukowanej i ebooka od [No Starch Press][nsp].\n\n[nsprust]: https://nostarch.com/rust-programming-language-3rd-edition\n[nsp]: https://nostarch.com/\n\nWitaj w _JÄ™zyku programowania Rust_, ksiÄ…Å¼ce wprowadzajÄ…cej do Rusta.\nJÄ™zyk programowania Rust pomaga pisaÄ‡ szybsze, bardziej niezawodne\noprogramowanie. Wysoka ergonomia i niska kontrola sÄ… czÄ™sto sprzeczne w\nprojektowaniu jÄ™zykÃ³w programowania; Rust kwestionuje ten konflikt. Poprzez\nrÃ³wnowaÅ¼enie potÄ™Å¼nych moÅ¼liwoÅ›ci technicznych i wspaniaÅ‚ego doÅ›wiadczenia\ndeweloperskiego, Rust daje moÅ¼liwoÅ›Ä‡ kontrolowania niskopoziomowych szczegÃ³Å‚Ã³w\n(takich jak uÅ¼ycie pamiÄ™ci) bez wszystkich kÅ‚opotÃ³w tradycyjnie\nzwiÄ…zanych z takÄ… kontrolÄ….\n\n## Dla kogo jest Rust\n\nRust jest idealny dla wielu osÃ³b z rÃ³Å¼nych powodÃ³w. Przyjrzyjmy siÄ™ kilku\nnajwaÅ¼niejszym grupom.\n\n### ZespoÅ‚y deweloperskie\n\nRust okazuje siÄ™ byÄ‡ produktywnym narzÄ™dziem do wspÃ³Å‚pracy miÄ™dzy duÅ¼ymi\nzespoÅ‚ami deweloperÃ³w o rÃ³Å¼nym poziomie znajomoÅ›ci programowania systemowego.\nNiskopoziomowy kod jest podatny na rÃ³Å¼ne subtelne bÅ‚Ä™dy, ktÃ³re w wiÄ™kszoÅ›ci\ninnych jÄ™zykÃ³w moÅ¼na wykryÄ‡ jedynie poprzez obszerne testy i\nstarannÄ… weryfikacjÄ™ kodu przez doÅ›wiadczonych deweloperÃ³w. W RuÅ›cie\nkompilator peÅ‚ni rolÄ™ straÅ¼nika, odmawiajÄ…c kompilacji kodu z tymi\nnieuchwytnymi bÅ‚Ä™dami, w tym bÅ‚Ä™dami wspÃ³Å‚bieÅ¼noÅ›ci. PracujÄ…c obok\nkompilatora, zespÃ³Å‚ moÅ¼e poÅ›wiÄ™ciÄ‡ swÃ³j czas na skupienie siÄ™ na logice\nprogramu, zamiast Å›cigaÄ‡ bÅ‚Ä™dy.\n\nRust wprowadza rÃ³wnieÅ¼ nowoczesne narzÄ™dzia dla deweloperÃ³w do Å›wiata\nprogramowania systemowego:\n\n- Cargo, doÅ‚Ä…czony menedÅ¼er zaleÅ¼noÅ›ci i narzÄ™dzie do budowania, sprawia, Å¼e\n  dodawanie, kompilowanie i zarzÄ…dzanie zaleÅ¼noÅ›ciami jest bezbolesne i\n  spÃ³jne w caÅ‚ym ekosystemie Rusta.\n- NarzÄ™dzie formatujÄ…ce `rustfmt` zapewnia spÃ³jny styl kodowania wÅ›rÃ³d\n  deweloperÃ³w.\n- Rust Language Server zasila integracjÄ™ ze zintegrowanymi Å›rodowiskami\n  deweloperskimi (IDE) dla uzupeÅ‚niania kodu i wbudowanych komunikatÃ³w o\n  bÅ‚Ä™dach.\n\nDziÄ™ki tym i innym narzÄ™dziom w ekosystemie Rusta, deweloperzy mogÄ… byÄ‡\nproduktywni podczas pisania kodu na poziomie systemowym.\n\n### Studenci\n\nRust jest dla studentÃ³w i tych, ktÃ³rzy sÄ… zainteresowani naukÄ… koncepcji\nsystemowych. UÅ¼ywajÄ…c Rusta, wiele osÃ³b uczyÅ‚o siÄ™ tematÃ³w takich jak rozwÃ³j\nsystemÃ³w operacyjnych. SpoÅ‚ecznoÅ›Ä‡ jest bardzo otwarta i chÄ™tnie odpowiada na\npytania studentÃ³w. Poprzez wysiÅ‚ki takie jak ta ksiÄ…Å¼ka, zespoÅ‚y Rusta chcÄ…\nuczyniÄ‡ koncepcje systemowe bardziej dostÄ™pnymi dla wiÄ™kszej liczby osÃ³b,\nszczegÃ³lnie dla tych, ktÃ³rzy dopiero zaczynajÄ… programowaÄ‡.\n\n### Firmy\n\nSetki firm, duÅ¼ych i maÅ‚ych, uÅ¼ywajÄ… Rusta w produkcji do rÃ³Å¼nych zadaÅ„,\nw tym narzÄ™dzi wiersza poleceÅ„, usÅ‚ug sieciowych, narzÄ™dzi DevOps,\nurzÄ…dzeÅ„ wbudowanych, analizy i transkodowania audio i wideo,\nkryptowalut, bioinformatyki, wyszukiwarek, aplikacji Internetu Rzeczy,\nuczenia maszynowego, a nawet gÅ‚Ã³wnych czÄ™Å›ci przeglÄ…darki internetowej\nFirefox.\n\n### Deweloperzy open source\n\nRust jest dla ludzi, ktÃ³rzy chcÄ… budowaÄ‡ jÄ™zyk programowania Rust, spoÅ‚ecznoÅ›Ä‡,\nnarzÄ™dzia deweloperskie i biblioteki. ChcielibyÅ›my, abyÅ› wniÃ³sÅ‚ swÃ³j wkÅ‚ad w\nrozwÃ³j jÄ™zyka Rust.\n\n### Ludzie ceniÄ…cy szybkoÅ›Ä‡ i stabilnoÅ›Ä‡\n\nRust jest dla ludzi, ktÃ³rzy pragnÄ… szybkoÅ›ci i stabilnoÅ›ci w jÄ™zyku. Przez\nszybkoÅ›Ä‡ rozumiemy zarÃ³wno to, jak szybko moÅ¼e dziaÅ‚aÄ‡ kod Rusta, jak i szybkoÅ›Ä‡,\nz jakÄ… Rust pozwala pisaÄ‡ programy. Kontrole kompilatora Rusta zapewniajÄ…\nstabilnoÅ›Ä‡ poprzez dodawanie funkcji i refaktoryzacjÄ™. Jest to przeciwieÅ„stwo\nkruchego starego kodu w jÄ™zykach bez tych kontroli, ktÃ³rego deweloperzy czÄ™sto\nobawiajÄ… siÄ™ modyfikowaÄ‡. DÄ…Å¼Ä…c do abstrakcji zerokosztowych â€” funkcji\nwyÅ¼szego poziomu, ktÃ³re kompilujÄ… siÄ™ do kodu niÅ¼szego poziomu tak szybko, jak\nkod napisany rÄ™cznie â€” Rust stara siÄ™, aby bezpieczny kod byÅ‚ rÃ³wnieÅ¼ szybkim\nkodem.\n\nJÄ™zyk Rust ma nadziejÄ™ wspieraÄ‡ rÃ³wnieÅ¼ wielu innych uÅ¼ytkownikÃ³w; ci\nwspomniani tutaj to tylko niektÃ³rzy z najwiÄ™kszych interesariuszy. OgÃ³lnie\nrzecz biorÄ…c, najwiÄ™kszÄ… ambicjÄ… Rusta jest wyeliminowanie kompromisÃ³w,\nktÃ³re programiÅ›ci akceptowali przez dziesiÄ™ciolecia, zapewniajÄ…c bezpieczeÅ„stwo\n_i_ produktywnoÅ›Ä‡, szybkoÅ›Ä‡ _i_ ergonomiÄ™. SprÃ³buj Rusta i zobacz, czy jego\nwybory sprawdzÄ… siÄ™ dla Ciebie.\n\n## Dla kogo jest ta ksiÄ…Å¼ka\n\nTa ksiÄ…Å¼ka zakÅ‚ada, Å¼e pisaÅ‚eÅ› juÅ¼ kod w innym jÄ™zyku programowania, ale nie\nczyni Å¼adnych zaÅ‚oÅ¼eÅ„ co do tego, w jakim. StaraliÅ›my siÄ™, aby materiaÅ‚ byÅ‚\nszeroko dostÄ™pny dla osÃ³b z rÃ³Å¼nych Å›rodowisk programistycznych. Nie spÄ™dzamy\nwielu czasu na mÃ³wieniu o tym, czym _jest_ programowanie ani jak o nim myÅ›leÄ‡.\nJeÅ›li jesteÅ› zupeÅ‚nie poczÄ…tkujÄ…cy w programowaniu, lepiej bÄ™dzie, jeÅ›li\nprzeczytasz ksiÄ…Å¼kÄ™, ktÃ³ra specjalnie wprowadza w programowanie.\n\n## Jak korzystaÄ‡ z tej ksiÄ…Å¼ki\n\nOgÃ³lnie rzecz biorÄ…c, ta ksiÄ…Å¼ka zakÅ‚ada, Å¼e czytasz jÄ… sekwencyjnie od poczÄ…tku\ndo koÅ„ca. PÃ³Åºniejsze rozdziaÅ‚y bazujÄ… na koncepcjach z wczeÅ›niejszych\nrozdziaÅ‚Ã³w, a wczeÅ›niejsze rozdziaÅ‚y mogÄ… nie zagÅ‚Ä™biaÄ‡ siÄ™ w szczegÃ³Å‚y\nkonkretnego tematu, ale powrÃ³cÄ… do niego w pÃ³Åºniejszym rozdziale.\n\nW tej ksiÄ…Å¼ce znajdziesz dwa rodzaje rozdziaÅ‚Ã³w: rozdziaÅ‚y koncepcyjne i\nrozdziaÅ‚y projektowe. W rozdziaÅ‚ach koncepcyjnych dowiesz siÄ™ o pewnym\naspekcie Rusta. W rozdziaÅ‚ach projektowych bÄ™dziemy wspÃ³lnie budowaÄ‡ maÅ‚e\nprogramy, stosujÄ…c to, czego nauczyÅ‚eÅ› siÄ™ do tej pory. RozdziaÅ‚ 2, RozdziaÅ‚\n12 i RozdziaÅ‚ 21 to rozdziaÅ‚y projektowe; pozostaÅ‚e to rozdziaÅ‚y koncepcyjne.\n\n**RozdziaÅ‚ 1** wyjaÅ›nia, jak zainstalowaÄ‡ Rusta, jak napisaÄ‡ program â€Witaj,\nÅ›wiecie!â€ i jak uÅ¼ywaÄ‡ Cargo, menedÅ¼era pakietÃ³w i narzÄ™dzia do budowania\nRusta. **RozdziaÅ‚ 2** to praktyczne wprowadzenie do pisania programu w RuÅ›cie,\npolegajÄ…ce na budowaniu gry w zgadywanie liczb. Tutaj omawiamy koncepcje na\nwysokim poziomie, a pÃ³Åºniejsze rozdziaÅ‚y dostarczÄ… dodatkowych szczegÃ³Å‚Ã³w.\nJeÅ›li chcesz od razu zabraÄ‡ siÄ™ do pracy, RozdziaÅ‚ 2 jest do tego idealnym\nmiejscem. JeÅ›li jesteÅ› szczegÃ³lnie skrupulatnym uczniem, ktÃ³ry woli poznaÄ‡\nkaÅ¼dy szczegÃ³Å‚ przed przejÅ›ciem do nastÄ™pnego, moÅ¼esz pominÄ…Ä‡ RozdziaÅ‚ 2 i\nprzejÅ›Ä‡ bezpoÅ›rednio do **RozdziaÅ‚u 3**, ktÃ³ry obejmuje funkcje Rusta\npodobne do tych z innych jÄ™zykÃ³w programowania; nastÄ™pnie moÅ¼esz wrÃ³ciÄ‡ do\nRozdziaÅ‚u 2, kiedy bÄ™dziesz chciaÅ‚ popracowaÄ‡ nad projektem, stosujÄ…c poznane\nszczegÃ³Å‚y.\n\nW **Rozdziale 4** dowiesz siÄ™ o systemie wÅ‚asnoÅ›ci Rusta. **RozdziaÅ‚ 5**\nomawia struktury i metody. **RozdziaÅ‚ 6** obejmuje typy wyliczeniowe,\nwyraÅ¼enia `match` oraz konstrukcje przepÅ‚ywu sterowania `if let` i `let...else`.\nUÅ¼yjesz struktur i typÃ³w wyliczeniowych do tworzenia wÅ‚asnych typÃ³w.\n\nW **Rozdziale 7** dowiesz siÄ™ o systemie moduÅ‚Ã³w Rusta i zasadach prywatnoÅ›ci\ndotyczÄ…cych organizacji kodu i jego publicznego interfejsu programistycznego\n(API). **RozdziaÅ‚ 8** omawia niektÃ³re popularne struktury danych kolekcji\ndostÄ™pne w standardowej bibliotece: wektory, ciÄ…gi znakÃ³w i mapy haszujÄ…ce.\n**RozdziaÅ‚ 9** bada filozofiÄ™ i techniki obsÅ‚ugi bÅ‚Ä™dÃ³w Rusta.\n\n**RozdziaÅ‚ 10** zagÅ‚Ä™bia siÄ™ w generyki, cechy i czasy Å¼ycia, ktÃ³re dajÄ… ci\nmoÅ¼liwoÅ›Ä‡ definiowania kodu, ktÃ³ry stosuje siÄ™ do wielu typÃ³w. **RozdziaÅ‚ 11**\npolega na testowaniu, ktÃ³re nawet przy gwarancjach bezpieczeÅ„stwa Rusta jest\nkonieczne, aby upewniÄ‡ siÄ™, Å¼e logika programu jest poprawna. W **Rozdziale\n12** zbudujemy naszÄ… wÅ‚asnÄ… implementacjÄ™ podzbioru funkcjonalnoÅ›ci narzÄ™dzia\nwiersza poleceÅ„ `grep`, ktÃ³re wyszukuje tekst w plikach. W tym celu uÅ¼yjemy\nwielu koncepcji, ktÃ³re omÃ³wiliÅ›my w poprzednich rozdziaÅ‚ach.\n\n**RozdziaÅ‚ 13** bada domkniÄ™cia i iteratory: cechy Rusta pochodzÄ…ce z\nfunkcyjnych jÄ™zykÃ³w programowania. W **Rozdziale 14** dokÅ‚adniej zbadamy Cargo\ni porozmawiamy o najlepszych praktykach udostÄ™pniania bibliotek innym.\n**RozdziaÅ‚ 15** omawia inteligentne wskaÅºniki dostÄ™pne w standardowej bibliotece\noraz cechy, ktÃ³re umoÅ¼liwiajÄ… ich funkcjonalnoÅ›Ä‡.\n\nW **Rozdziale 16** omÃ³wimy rÃ³Å¼ne modele programowania wspÃ³Å‚bieÅ¼nego i\nporozmawiamy o tym, jak Rust pomaga programowaÄ‡ w wielu wÄ…tkach bez obaw. W\n**Rozdziale 17** rozbudujemy to, badajÄ…c skÅ‚adniÄ™ `async` i `await` Rusta, wraz\nz zadaniami, futures i streams, oraz lekki model wspÃ³Å‚bieÅ¼noÅ›ci, ktÃ³ry\numoÅ¼liwiajÄ….\n\n**RozdziaÅ‚ 18** przyglÄ…da siÄ™, jak idiomy Rusta porÃ³wnujÄ… siÄ™ z zasadami\nprogramowania obiektowego, ktÃ³re moÅ¼esz znaÄ‡. **RozdziaÅ‚ 19** to odniesienie do\nwzorcÃ³w i dopasowywania wzorcÃ³w, ktÃ³re sÄ… potÄ™Å¼nymi sposobami wyraÅ¼ania idei\nw programach Rusta. **RozdziaÅ‚ 20** zawiera zbiÃ³r zaawansowanych tematÃ³w\ninteresujÄ…cych, w tym niebezpieczny Rust, makra i wiÄ™cej o czasach Å¼ycia,\ncechach, typach, funkcjach i domkniÄ™ciach.\n\nW **Rozdziale 21** ukoÅ„czymy projekt, w ktÃ³rym zaimplementujemy niskopoziomowy,\nwielowÄ…tkowy serwer WWW!\n\nNa koniec, kilka dodatkÃ³w zawiera uÅ¼yteczne informacje o jÄ™zyku w formacie\nbardziej przypominajÄ…cym referencje. **Dodatek A** obejmuje sÅ‚owa kluczowe\nRusta, **Dodatek B** obejmuje operatory i symbole Rusta, **Dodatek C** obejmuje\ncechy moÅ¼liwe do wyprowadzenia dostarczane przez standardowÄ… bibliotekÄ™,\n**Dodatek D** obejmuje niektÃ³re uÅ¼yteczne narzÄ™dzia programistyczne, a **Dodatek E**\nwyjaÅ›nia wydania Rusta. W **Dodatku F** znajdziesz tÅ‚umaczenia ksiÄ…Å¼ki, a w\n**Dodatku G** omÃ³wimy, jak powstaje Rust i czym jest Nightly Rust.\n\nNie ma zÅ‚ego sposobu na czytanie tej ksiÄ…Å¼ki: JeÅ›li chcesz przeskoczyÄ‡ do przodu,\nzrÃ³b to! MoÅ¼e bÄ™dziesz musiaÅ‚ wrÃ³ciÄ‡ do wczeÅ›niejszych rozdziaÅ‚Ã³w, jeÅ›li\nspotkasz siÄ™ z jakimkolwiek zamieszaniem. Ale rÃ³b to, co dziaÅ‚a dla ciebie.\n\n<span id=\"ferris\"></span>\n\nWaÅ¼nÄ… czÄ™Å›ciÄ… procesu nauki Rusta jest nauka czytania komunikatÃ³w o bÅ‚Ä™dach\nwyÅ›wietlanych przez kompilator: BÄ™dÄ… one prowadziÄ‡ CiÄ™ do dziaÅ‚ajÄ…cego kodu.\nW zwiÄ…zku z tym, przedstawimy wiele przykÅ‚adÃ³w, ktÃ³re siÄ™ nie kompilujÄ…,\nwraz z komunikatem o bÅ‚Ä™dzie, ktÃ³ry kompilator wyÅ›wietli w kaÅ¼dej sytuacji.\nPamiÄ™taj, Å¼e jeÅ›li wpiszesz i uruchomisz przypadkowy przykÅ‚ad, moÅ¼e siÄ™ on\nnie skompilowaÄ‡! Upewnij siÄ™, Å¼e przeczytaÅ‚eÅ› otaczajÄ…cy tekst, aby sprawdziÄ‡,\nczy przykÅ‚ad, ktÃ³ry prÃ³bujesz uruchomiÄ‡, ma celowo wyÅ›wietliÄ‡ bÅ‚Ä…d. W wiÄ™kszoÅ›ci\nsytuacji poprowadzimy CiÄ™ do poprawnej wersji kodu, ktÃ³ry siÄ™ nie kompiluje.\nFerris rÃ³wnieÅ¼ pomoÅ¼e Ci rozrÃ³Å¼niÄ‡ kod, ktÃ³ry nie ma dziaÅ‚aÄ‡:\n\n| Ferris                                                                                                           | Znaczenie                                          |\n| ---------------------------------------------------------------------------------------------------------------- | -------------------------------------------------- |\n| <img src=\"img/ferris/does_not_compile.svg\" class=\"ferris-explain\" alt=\"Ferris ze znakiem zapytania\"/>            | Ten kod siÄ™ nie kompiluje!                         |\n| <img src=\"img/ferris/panics.svg\" class=\"ferris-explain\" alt=\"Ferris z rÄ™kami uniesionymi w gÃ³rÄ™\"/>                | Ten kod panikuje!                                  |\n| <img src=\"img/ferris/not_desired_behavior.svg\" class=\"ferris-explain\" alt=\"Ferris z jednym uniesionym pazurem, wzruszajÄ…cy ramionami\"/> | Ten kod nie daje poÅ¼Ä…danego zachowania.            |\n\nW wiÄ™kszoÅ›ci sytuacji poprowadzimy CiÄ™ do poprawnej wersji kodu, ktÃ³ry siÄ™ nie\nkompiluje.\n\n## Kod ÅºrÃ³dÅ‚owy\n\nPliki ÅºrÃ³dÅ‚owe, z ktÃ³rych generowana jest ta ksiÄ…Å¼ka, moÅ¼na znaleÅºÄ‡ na\n[GitHubie][book].\n\n[book]: https://github.com/rust-lang/book/tree/main/src\n",
        "chapter_title": "Wprowadzenie"
    },
    {
        "file_path": "ch01-00-getting-started.md",
        "content": "# Pierwsze kroki\n\nRozpocznij swojÄ… podrÃ³Å¼ z Rustem! Wiele jest do nauczenia, ale kaÅ¼da podrÃ³Å¼\nzaczyna siÄ™ gdzieÅ›. W tym rozdziale omÃ³wimy:\n\n- InstalacjÄ™ Rusta na Linuksie, macOS i Windows\n- Pisanie programu, ktÃ³ry wypisuje `Witaj, Å›wiecie!`\n- UÅ¼ywanie `cargo`, menedÅ¼era pakietÃ³w i systemu budowania Rusta\n",
        "chapter_title": "Pierwsze kroki"
    },
    {
        "file_path": "ch01-01-installation.md",
        "content": "## Instalacja\n\nPierwszym krokiem jest zainstalowanie Rusta. Pobierzemy Rusta za poÅ›rednictwem\n`rustup`, narzÄ™dzia wiersza poleceÅ„ do zarzÄ…dzania wersjami Rusta i\npowiÄ…zanymi narzÄ™dziami. Do pobrania bÄ™dziesz potrzebowaÄ‡ poÅ‚Ä…czenia z\ninternetem.\n\n> Uwaga: JeÅ›li z jakiegoÅ› powodu wolisz nie uÅ¼ywaÄ‡ `rustup`, zapoznaj siÄ™ z\n> [stronÄ… Inne metody instalacji Rusta][otherinstall] w celu uzyskania\n> dodatkowych opcji.\n\nPoniÅ¼sze kroki instalujÄ… najnowszÄ… stabilnÄ… wersjÄ™ kompilatora Rusta.\nGwarancje stabilnoÅ›ci Rusta zapewniajÄ…, Å¼e wszystkie przykÅ‚ady w ksiÄ…Å¼ce,\nktÃ³re siÄ™ kompilujÄ…, bÄ™dÄ… nadal kompilowaÄ‡ siÄ™ z nowszymi wersjami Rusta.\nWynik moÅ¼e nieznacznie rÃ³Å¼niÄ‡ siÄ™ miÄ™dzy wersjami, poniewaÅ¼ Rust czÄ™sto\npoprawia komunikaty o bÅ‚Ä™dach i ostrzeÅ¼enia. Innymi sÅ‚owy, kaÅ¼da nowsza,\nstabilna wersja Rusta zainstalowana za pomocÄ… tych krokÃ³w powinna dziaÅ‚aÄ‡\nzgodnie z oczekiwaniami z treÅ›ciÄ… tej ksiÄ…Å¼ki.\n\n> ### Notacja wiersza poleceÅ„\n>\n> W tym rozdziale i w caÅ‚ej ksiÄ…Å¼ce bÄ™dziemy pokazywaÄ‡ niektÃ³re polecenia\n> uÅ¼ywane w terminalu. Wiersze, ktÃ³re powinieneÅ› wpisaÄ‡ w terminalu, zaczynajÄ…\n> siÄ™ od `$`. Nie musisz wpisywaÄ‡ znaku `$`; jest to znak zachÄ™ty wiersza\n> poleceÅ„, ktÃ³ry wskazuje poczÄ…tek kaÅ¼dego polecenia. Wiersze, ktÃ³re nie\n> zaczynajÄ… siÄ™ od `$`, zazwyczaj pokazujÄ… wynik poprzedniego polecenia.\n> Dodatkowo, przykÅ‚ady specyficzne dla PowerShell bÄ™dÄ… uÅ¼ywaÄ‡ `>` zamiast `$`. \n\n### Instalacja `rustup` na Linuksie lub macOS\n\nJeÅ›li uÅ¼ywasz Linuksa lub macOS, otwÃ³rz terminal i wprowadÅº nastÄ™pujÄ…ce\npolecenie:\n\n```console\n$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\n```\n\nPolecenie pobiera skrypt i rozpoczyna instalacjÄ™ narzÄ™dzia `rustup`, ktÃ³re\ninstaluje najnowszÄ… stabilnÄ… wersjÄ™ Rusta. MoÅ¼e zostaÄ‡ wyÅ›wietlony monit o\nhasÅ‚o. JeÅ›li instalacja zakoÅ„czy siÄ™ pomyÅ›lnie, pojawi siÄ™ nastÄ™pujÄ…cy wiersz:\n\n```text\nRust jest juÅ¼ zainstalowany. Åšwietnie!\n```\n\nBÄ™dziesz takÅ¼e potrzebowaÅ‚ _linkera_, czyli programu, ktÃ³rego Rust uÅ¼ywa do\nÅ‚Ä…czenia skompilowanych wynikÃ³w w jeden plik. Prawdopodobnie juÅ¼ go masz.\nJeÅ›li otrzymasz bÅ‚Ä™dy linkera, powinieneÅ› zainstalowaÄ‡ kompilator C, ktÃ³ry\nzazwyczaj zawiera linker. Kompilator C jest rÃ³wnieÅ¼ przydatny, poniewaÅ¼\nniektÃ³re popularne pakiety Rusta zaleÅ¼Ä… od kodu C i bÄ™dÄ… wymagaÅ‚y kompilatora C.\n\nNa macOS moÅ¼esz uzyskaÄ‡ kompilator C, uruchamiajÄ…c:\n\n```console\n$ xcode-select --install\n```\n\nUÅ¼ytkownicy Linuksa powinni zazwyczaj instalowaÄ‡ GCC lub Clang, zgodnie z\ndokumentacjÄ… swojej dystrybucji. Na przykÅ‚ad, jeÅ›li uÅ¼ywasz Ubuntu, moÅ¼esz\nzainstalowaÄ‡ pakiet `build-essential`.\n\n### Instalacja `rustup` na Windows\n\nNa Windows, przejdÅº na [https://www.rust-lang.org/tools/install][install]<!--\nignore --> i postÄ™puj zgodnie z instrukcjami instalacji Rusta. W pewnym\nmomencie instalacji zostaniesz poproszony o zainstalowanie Visual Studio.\nZapewnia to linker i natywne biblioteki potrzebne do kompilowania programÃ³w.\nJeÅ›li potrzebujesz wiÄ™cej pomocy w tym kroku, zobacz\n[https://rust-lang.github.io/rustup/installation/windows-msvc.html][msvc]<!--\nignore -->.\n\nReszta tej ksiÄ…Å¼ki uÅ¼ywa poleceÅ„, ktÃ³re dziaÅ‚ajÄ… zarÃ³wno w _cmd.exe_, jak i\nPowerShell. JeÅ›li wystÄ…piÄ… specyficzne rÃ³Å¼nice, wyjaÅ›nimy, ktÃ³rego uÅ¼yÄ‡.\n\n### RozwiÄ…zywanie problemÃ³w\n\nAby sprawdziÄ‡, czy Rust jest poprawnie zainstalowany, otwÃ³rz powÅ‚okÄ™ i\nwrowadÅº ten wiersz:\n\n```console\n$ rustc --version\n```\n\nPpowinien pojawiÄ‡ siÄ™ numer wersji, skrÃ³t commita i data commita dla\nnajnowszej stabilnej wersji, ktÃ³ra zostaÅ‚a wydana, w nastÄ™pujÄ…cym formacie:\n\n```text\nrustc x.y.z (abcabcabc yyyy-mm-dd)\n```\n\nJeÅ›li widzisz te informacje, pomyÅ›lnie zainstalowaÅ‚eÅ› Rusta! JeÅ›li ich nie\nwidzisz, sprawdÅº, czy Rust znajduje siÄ™ w zmiennej systemowej `%PATH%` w\nnastÄ™pujÄ…cy sposÃ³b.\n\nW systemie Windows CMD uÅ¼yj:\n\n```console\n> echo %PATH%\n```\n\nW PowerShellu uÅ¼yj:\n\n```powershell\n> echo $env:Path\n```\n\nNa Linuksie i macOS uÅ¼yj:\n\n```console\n$ echo $PATH\n```\n\nJeÅ›li wszystko jest w porzÄ…dku, a Rust nadal nie dziaÅ‚a, istnieje wiele miejsc,\nw ktÃ³rych moÅ¼esz uzyskaÄ‡ pomoc. Dowiedz siÄ™, jak skontaktowaÄ‡ siÄ™ z innymi\nRustaceanami (tak siÄ™ nazywamy) na [stronie spoÅ‚ecznoÅ›ci][community].\n\n### Aktualizacja i deinstalacja\n\nPo zainstalowaniu Rusta za pomocÄ… `rustup`, aktualizacja do nowo wydanej\nwersji jest Å‚atwa. Z poziomu powÅ‚oki uruchom nastÄ™pujÄ…cy skrypt aktualizacji:\n\n```console\n$ rustup update\n```\n\nAby odinstalowaÄ‡ Rusta i `rustup`, uruchom nastÄ™pujÄ…cy skrypt odinstalowujÄ…cy\nz poziomu powÅ‚oki:\n\n```console\n$ rustup self uninstall\n```\n\n<!-- Old headings. Do not remove or links may break. -->\n<a id=\"local-documentation\"></a>\n\n### Czytanie lokalnej dokumentacji\n\nInstalacja Rusta zawiera rÃ³wnieÅ¼ lokalnÄ… kopiÄ™ dokumentacji, dziÄ™ki czemu\nmoÅ¼esz czytaÄ‡ jÄ… offline. Uruchom `rustup doc`, aby otworzyÄ‡ lokalnÄ…\ndokumentacjÄ™ w przeglÄ…darce.\n\nZawsze, gdy typ lub funkcja jest dostarczana przez bibliotekÄ™ standardowÄ…, a\nnie masz pewnoÅ›ci, co robi lub jak jej uÅ¼ywaÄ‡, skorzystaj z dokumentacji\ninterfejsu programowania aplikacji (API), aby siÄ™ dowiedzieÄ‡!\n\n<!-- Old headings. Do not remove or links may break. -->\n<a id=\"text-editors-and-integrated-development-environments\"></a>\n\n### UÅ¼ywanie edytorÃ³w tekstu i Å›rodowisk IDE\n\nTa ksiÄ…Å¼ka nie czyni Å¼adnych zaÅ‚oÅ¼eÅ„ co do narzÄ™dzi, ktÃ³rych uÅ¼ywasz do\npisania kodu Rusta. Niemal kaÅ¼dy edytor tekstu speÅ‚ni swoje zadanie! JednakÅ¼e\nwiele edytorÃ³w tekstu i zintegrowanych Å›rodowisk programistycznych (IDE)\nposiada wbudowane wsparcie dla Rusta. Zawsze moÅ¼esz znaleÅºÄ‡ doÅ›Ä‡ aktualnÄ…\nlistÄ™ wielu edytorÃ³w i Å›rodowisk IDE na [stronie z narzÄ™dziami][tools] na\nstronie internetowej Rusta.\n\n### Praca offline z tÄ… ksiÄ…Å¼kÄ…\n\nW kilku przykÅ‚adach bÄ™dziemy uÅ¼ywaÄ‡ pakietÃ³w Rusta poza bibliotekÄ… standardowÄ….\nAby przeÄ‡wiczyÄ‡ te przykÅ‚ady, bÄ™dziesz potrzebowaÄ‡ poÅ‚Ä…czenia z internetem\nlub wczeÅ›niejszego pobrania tych zaleÅ¼noÅ›ci. Aby pobraÄ‡ zaleÅ¼noÅ›ci wczeÅ›niej,\nmoÅ¼esz uruchomiÄ‡ nastÄ™pujÄ…ce polecenia. (WyjaÅ›nimy, czym jest `cargo` i co robi\nkaÅ¼de z tych poleceÅ„ szczegÃ³Å‚owo pÃ³Åºniej.)\n\n```console\n$ cargo new get-dependencies\n$ cd get-dependencies\n$ cargo add rand@0.8.5 trpl@0.2.0\n```\n\nSpowoduje to buforowanie pobraÅ„ tych pakietÃ³w, dziÄ™ki czemu nie bÄ™dziesz\nmusiaÅ‚ ich pÃ³Åºniej pobieraÄ‡. Po uruchomieniu tego polecenia nie musisz\nzatrzymywaÄ‡ folderu `get-dependencies`. JeÅ›li uruchomiÅ‚eÅ› to polecenie,\nmoÅ¼esz uÅ¼yÄ‡ flagi `--offline` ze wszystkimi poleceniami `cargo` w pozostaÅ‚ej\nczÄ™Å›ci ksiÄ…Å¼ki, aby uÅ¼yÄ‡ tych buforowanych wersji zamiast prÃ³bowaÄ‡ uÅ¼ywaÄ‡\nsieci.\n\n[otherinstall]: https://forge.rust-lang.org/infra/other-installation-methods.html\n[install]: https://www.rust-lang.org/tools/install\n[msvc]: https://rust-lang.github.io/rustup/installation/windows-msvc.html\n[community]: https://www.rust-lang.org/community\n[tools]: https://www.rust-lang.org/tools\n",
        "chapter_title": "Instalacja"
    },
    {
        "file_path": "ch01-02-hello-world.md",
        "content": "## Witaj, Å›wiecie!\n\nSkoro zainstalowaÅ‚eÅ› Rusta, czas napisaÄ‡ swÃ³j pierwszy program w tym jÄ™zyku.\nTradycyjnie, uczÄ…c siÄ™ nowego jÄ™zyka, pisze siÄ™ maÅ‚y program, ktÃ³ry wyÅ›wietla\ntekst `Witaj, Å›wiecie!` na ekranie, wiÄ™c zrobimy to samo i tutaj!\n\n> Uwaga: Ta ksiÄ…Å¼ka zakÅ‚ada podstawowÄ… znajomoÅ›Ä‡ wiersza poleceÅ„. Rust nie\n> stawia Å¼adnych specyficznych wymagaÅ„ dotyczÄ…cych edycji, narzÄ™dzi ani\n> miejsca przechowywania kodu, wiÄ™c jeÅ›li wolisz uÅ¼ywaÄ‡ IDE zamiast wiersza\n> poleceÅ„, Å›miaÅ‚o korzystaj ze swojego ulubionego IDE. Wiele Å›rodowisk IDE ma\n> obecnie pewne wsparcie dla Rusta; sprawdÅº dokumentacjÄ™ IDE, aby uzyskaÄ‡\n> szczegÃ³Å‚owe informacje. ZespÃ³Å‚ Rusta skupia siÄ™ na zapewnieniu\n> doskonaÅ‚ego wsparcia IDE za poÅ›rednictwem `rust-analyzer`. WiÄ™cej\n> szczegÃ³Å‚Ã³w znajdziesz w [Dodatku D][devtools]<!-- ignore -->.\n\n<!-- Old headings. Do not remove or links may break. -->\n<a id=\"creating-a-project-directory\"></a>\n\n### Konfiguracja katalogu projektu\n\nZaczniesz od utworzenia katalogu do przechowywania kodu Rusta. Dla Rusta nie ma\nznaczenia, gdzie znajduje siÄ™ TwÃ³j kod, ale dla Ä‡wiczeÅ„ i projektÃ³w w tej\nksiÄ…Å¼ce sugerujemy utworzenie katalogu _projects_ w katalogu domowym i\nprzechowywanie tam wszystkich swoich projektÃ³w.\n\nOtwÃ³rz terminal i wprowadÅº nastÄ™pujÄ…ce polecenia, aby utworzyÄ‡ katalog\n_projects_ i katalog dla projektu â€Witaj, Å›wiecie!â€ w katalogu _projects_.\n\nNa Linuksie, macOS i w PowerShell na Windows, wprowadÅº:\n\n```console\n$ mkdir ~/projects\n$ cd ~/projects\n$ mkdir hello_world\n$ cd hello_world\n```\n\nW systemie Windows CMD wprowadÅº:\n\n```cmd\n> mkdir \"%USERPROFILE%\\projects\"\n> cd /d \"%USERPROFILE%\\projects\"\n> mkdir hello_world\n> cd hello_world\n```\n\n<!-- Old headings. Do not remove or links may break. -->\n<a id=\"writing-and-running-a-rust-program\"></a>\n\n### Podstawy programu w RuÅ›cie\n\nNastÄ™pnie utwÃ³rz nowy plik ÅºrÃ³dÅ‚owy i nazwij go _main.rs_. Pliki Rusta zawsze\nkoÅ„czÄ… siÄ™ rozszerzeniem _.rs_. JeÅ›li uÅ¼ywasz wiÄ™cej niÅ¼ jednego sÅ‚owa w\nnazwie pliku, konwencjÄ… jest uÅ¼ywanie podkreÅ›lenia do ich rozdzielania.\nNa przykÅ‚ad uÅ¼yj _hello_world.rs_ zamiast _helloworld.rs_.\n\nTeraz otwÃ³rz nowo utworzony plik _main.rs_ i wprowadÅº kod z Listingu 1-1.\n\n<Listing number=\"1-1\" file-name=\"main.rs\" caption=\"Program, ktÃ³ry wypisuje `Witaj, Å›wiecie!`\">\n\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n</Listing>\n\nZapisz plik i wrÃ³Ä‡ do okna terminala w katalogu _~/projects/hello_world_. Na\nLinuksie lub macOS wprowadÅº nastÄ™pujÄ…ce polecenia, aby skompilowaÄ‡ i uruchomiÄ‡\nplik:\n\n```console\n$ rustc main.rs\n$ ./main\nHello, world!\n```\n\nNa Windows wprowadÅº polecenie `.\\main` zamiast `./main`:\n\n```powershell\n> rustc main.rs\n> .\\main\nHello, world!\n```\n\nNiezaleÅ¼nie od systemu operacyjnego, w terminalu powinno pojawiÄ‡ siÄ™\n`Witaj, Å›wiecie!`. JeÅ›li nie widzisz tego wyjÅ›cia, wrÃ³Ä‡ do [czÄ™Å›ci â€RozwiÄ…zywanie\nproblemÃ³wâ€][troubleshooting]<!-- ignore --> w sekcji Instalacja, aby uzyskaÄ‡ pomoc.\n\nJeÅ›li `Witaj, Å›wiecie!` zostaÅ‚o wypisane, gratulacje! Oficjalnie napisaÅ‚eÅ›\nprogram w RuÅ›cie. To czyni CiÄ™ programistÄ… Rusta â€“ witaj!\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"anatomy-of-a-rust-program\"></a>\n\n### Anatomia programu w RuÅ›cie\n\nPrzejrzyjmy szczegÃ³Å‚owo ten program â€Witaj, Å›wiecie!â€. Oto pierwszy element\nukÅ‚adanki:\n\n```rust\nfn main() {\n\n}\n```\n\nTe wiersze definiujÄ… funkcjÄ™ o nazwie `main`. Funkcja `main` jest specjalna:\nZawsze jest pierwszym kodem, ktÃ³ry jest uruchamiany w kaÅ¼dym wykonywalnym\nprogramie w RuÅ›cie. Tutaj pierwszy wiersz deklaruje funkcjÄ™ o nazwie `main`,\nktÃ³ra nie ma parametrÃ³w i nic nie zwraca. Gdyby byÅ‚y parametry, znalazÅ‚yby siÄ™\nw nawiasach `()`.\n\nCiaÅ‚o funkcji jest ujÄ™te w `{}`. Rust wymaga nawiasÃ³w klamrowych wokÃ³Å‚\nwszystkich ciaÅ‚ funkcji. Dobrym stylem jest umieszczanie otwierajÄ…cego nawiasu\nklamrowego w tym samym wierszu co deklaracja funkcji, dodajÄ…c jeden odstÄ™p\npomiÄ™dzy nimi.\n\n> Uwaga: JeÅ›li chcesz trzymaÄ‡ siÄ™ standardowego stylu w projektach Rusta,\n> moÅ¼esz uÅ¼yÄ‡ automatycznego narzÄ™dzia formatujÄ…cego o nazwie `rustfmt` do\n> formatowania kodu w okreÅ›lonym stylu (wiÄ™cej o `rustfmt` w [Dodatku\n> D][devtools]<!-- ignore -->). ZespÃ³Å‚ Rusta doÅ‚Ä…czyÅ‚ to narzÄ™dzie do\n> standardowej dystrybucji Rusta, podobnie jak `rustc`, wiÄ™c powinno byÄ‡ juÅ¼\n> zainstalowane na Twoim komputerze!\n\nCiaÅ‚o funkcji `main` zawiera nastÄ™pujÄ…cy kod:\n\n```rust\nprintln!(\"Hello, world!\");\n```\n\nTen wiersz wykonuje caÅ‚Ä… pracÄ™ w tym maÅ‚ym programie: wyÅ›wietla tekst na\nekranie. NaleÅ¼y zwrÃ³ciÄ‡ uwagÄ™ na trzy waÅ¼ne szczegÃ³Å‚y.\n\nPo pierwsze, `println!` wywoÅ‚uje makro Rusta. Gdyby wywoÅ‚ywaÅ‚o funkcjÄ™, byÅ‚oby\nwpisane jako `println` (bez `!`). Makra Rusta to sposÃ³b na pisanie kodu, ktÃ³ry\ngeneruje kod w celu rozszerzenia skÅ‚adni Rusta, a omÃ³wimy je bardziej\nszczegÃ³Å‚owo w [Rozdziale 20][ch20-macros]<!-- ignore -->. Na razie wystarczy\nwiedzieÄ‡, Å¼e uÅ¼ycie `!` oznacza wywoÅ‚anie makra zamiast normalnej funkcji, a\nmakra nie zawsze przestrzegajÄ… tych samych zasad co funkcje.\n\nPo drugie, widzisz ciÄ…g znakÃ³w `\"Hello, world!\"`. Przekazujemy ten ciÄ…g jako\nargument do `println!`, a ciÄ…g jest wyÅ›wietlany na ekranie.\n\nPo trzecie, koÅ„czymy wiersz Å›rednikiem (`;`), co oznacza, Å¼e to wyraÅ¼enie\nzostaÅ‚o zakoÅ„czone, a nastÄ™pne jest gotowe do rozpoczÄ™cia. WiÄ™kszoÅ›Ä‡ wierszy\nkodu Rusta koÅ„czy siÄ™ Å›rednikiem.\n\n<!-- Old headings. Do not remove or links may break. -->\n<a id=\"compiling-and-running-are-separate-steps\"></a>\n\n### Kompilacja i wykonanie\n\nWÅ‚aÅ›nie uruchomiÅ‚eÅ› nowo utworzony program, wiÄ™c przyjrzyjmy siÄ™ kaÅ¼demu\nkrokowi w tym procesie.\n\nPrzed uruchomieniem programu w RuÅ›cie musisz go skompilowaÄ‡ za pomocÄ…\nkompilatora Rusta, wpisujÄ…c polecenie `rustc` i podajÄ…c nazwÄ™ pliku ÅºrÃ³dÅ‚owego,\nw ten sposÃ³b:\n\n```console\n$ rustc main.rs\n```\n\nJeÅ›li masz doÅ›wiadczenie z C lub C++, zauwaÅ¼ysz, Å¼e jest to podobne do `gcc`\nlub `clang`. Po pomyÅ›lnej kompilacji Rust wypisuje plik wykonywalny.\n\nNa Linuksie, macOS i w PowerShell na Windows, moÅ¼esz zobaczyÄ‡ plik wykonywalny,\nwpisujÄ…c polecenie `ls` w swojej powÅ‚oce:\n\n```console\n$ ls\nmain  main.rs\n```\n\nNa Linuksie i macOS zobaczysz dwa pliki. W PowerShell na Windows zobaczysz te\nsame trzy pliki, ktÃ³re zobaczyÅ‚byÅ› uÅ¼ywajÄ…c CMD. W CMD na Windows\nwypisaÅ‚byÅ› nastÄ™pujÄ…ce polecenie:\n\n```cmd\n> dir /B %= opcja /B wyÅ›wietla tylko nazwy plikÃ³w =%\nmain.exe\nmain.pdb\nmain.rs\n```\n\nPokazuje to plik kodu ÅºrÃ³dÅ‚owego z rozszerzeniem _.rs_, plik wykonywalny\n(_main.exe_ na Windows, ale _main_ na wszystkich innych platformach) oraz, w\nprzypadku uÅ¼ywania Windows, plik zawierajÄ…cy informacje debugowania z\nrozszerzeniem _.pdb_. StÄ…d uruchamiasz plik _main_ lub _main.exe_, w ten sposÃ³b:\n\n```console\n$ ./main # lub .\\main na Windows\n```\n\nJeÅ›li twÃ³j _main.rs_ to program â€Witaj, Å›wiecie!â€, ten wiersz wypisze `Witaj,\nÅ›wiecie!` w twoim terminalu.\n\nJeÅ›li jesteÅ› bardziej zaznajomiony z jÄ™zykami dynamicznymi, takimi jak Ruby,\nPython lub JavaScript, moÅ¼esz nie byÄ‡ przyzwyczajony do kompilowania i\nuruchamiania programu jako oddzielnych krokÃ³w. Rust jest jÄ™zykiem\n_kompilowanym z wyprzedzeniem_, co oznacza, Å¼e moÅ¼esz skompilowaÄ‡ program i\nprzekazaÄ‡ plik wykonywalny komuÅ› innemu, a ta osoba moÅ¼e go uruchomiÄ‡ nawet\nbez zainstalowanego Rusta. JeÅ›li przekaÅ¼esz komuÅ› plik _.rb_, _.py_ lub\n_.js_, ta osoba musi mieÄ‡ zainstalowanÄ… (odpowiednio) implementacjÄ™ Ruby,\nPythona lub JavaScriptu. Ale w tych jÄ™zykach potrzebujesz tylko jednego\npolecenia, aby skompilowaÄ‡ i uruchomiÄ‡ program. Wszystko jest kompromisem w\nprojektowaniu jÄ™zyka.\n\nSamo kompilowanie za pomocÄ… `rustc` jest wystarczajÄ…ce dla prostych programÃ³w,\nale w miarÄ™ rozrostu projektu bÄ™dziesz chciaÅ‚ zarzÄ…dzaÄ‡ wszystkimi opcjami i\nuÅ‚atwiÄ‡ udostÄ™pnianie kodu. NastÄ™pnie przedstawimy narzÄ™dzie Cargo, ktÃ³re pomoÅ¼e\nCi pisaÄ‡ rzeczywiste programy w RuÅ›cie.\n\n[troubleshooting]: ch01-01-installation.html#troubleshooting\n[devtools]: appendix-04-useful-development-tools.html\n[ch20-macros]: ch20-05-macros.html\n",
        "chapter_title": "Witaj, Å›wiecie!"
    },
    {
        "file_path": "ch01-03-hello-cargo.md",
        "content": "## Witaj, Cargo!\n\nCargo to system budowania i menedÅ¼er pakietÃ³w Rusta. WiÄ™kszoÅ›Ä‡ RustaceanÃ³w\nuÅ¼ywa tego narzÄ™dzia do zarzÄ…dzania swoimi projektami w RuÅ›cie, poniewaÅ¼ Cargo\nobsÅ‚uguje wiele zadaÅ„ za Ciebie, takich jak budowanie kodu, pobieranie\nbibliotek, od ktÃ³rych zaleÅ¼y TwÃ³j kod, i budowanie tych bibliotek. (Biblioteki,\nktÃ³rych potrzebuje TwÃ³j kod, nazywamy _zaleÅ¼noÅ›ciami_.)\n\nNajprostsze programy w RuÅ›cie, takie jak ten, ktÃ³ry do tej pory napisaliÅ›my,\nnie majÄ… Å¼adnych zaleÅ¼noÅ›ci. GdybyÅ›my zbudowali projekt â€Witaj, Å›wiecie!â€ za\npomocÄ… Cargo, uÅ¼ywaÅ‚by on tylko czÄ™Å›ci Cargo, ktÃ³ra obsÅ‚uguje budowanie kodu.\nW miarÄ™ pisania bardziej zÅ‚oÅ¼onych programÃ³w w RuÅ›cie, bÄ™dziesz dodawaÄ‡\nzaleÅ¼noÅ›ci, a jeÅ›li rozpoczniesz projekt za pomocÄ… Cargo, dodawanie zaleÅ¼noÅ›ci\nbÄ™dzie znacznie Å‚atwiejsze.\n\nPoniewaÅ¼ zdecydowana wiÄ™kszoÅ›Ä‡ projektÃ³w w RuÅ›cie uÅ¼ywa Cargo, reszta tej\nksiÄ…Å¼ki zakÅ‚ada, Å¼e Ty rÃ³wnieÅ¼ uÅ¼ywasz Cargo. Cargo jest instalowane wraz z\nRustem, jeÅ›li uÅ¼yÅ‚eÅ› oficjalnych instalatorÃ³w omÃ³wionych w [sekcji\nâ€Instalacjaâ€][installation]<!-- ignore -->. JeÅ›li zainstalowaÅ‚eÅ› Rusta innymi\nsposobami, sprawdÅº, czy Cargo jest zainstalowane, wpisujÄ…c w terminalu:\n\n```console\n$ cargo --version\n```\n\nJeÅ›li widzisz numer wersji, masz go! JeÅ›li widzisz bÅ‚Ä…d, taki jak `command\nnot found`, poszukaj w dokumentacji swojej metody instalacji, aby ustaliÄ‡, jak\nzainstalowaÄ‡ Cargo oddzielnie.\n\n### Tworzenie projektu za pomocÄ… Cargo\n\nUtwÃ³rzmy nowy projekt za pomocÄ… Cargo i przyjrzyjmy siÄ™, jak rÃ³Å¼ni siÄ™ od\nnaszego oryginalnego projektu â€Witaj, Å›wiecie!â€. WrÃ³Ä‡ do katalogu _projects_\n(lub gdziekolwiek zdecydowaÅ‚eÅ› siÄ™ przechowywaÄ‡ swÃ³j kod). NastÄ™pnie, na\nkaÅ¼dym systemie operacyjnym, uruchom:\n\n```console\n$ cargo new hello_cargo\n$ cd hello_cargo\n```\n\nPierwsze polecenie tworzy nowy katalog i projekt o nazwie _hello_cargo_.\nNazwaliÅ›my nasz projekt _hello_cargo_, a Cargo tworzy swoje pliki w katalogu\no tej samej nazwie.\n\nPrzejdÅº do katalogu _hello_cargo_ i wypisz pliki. Zobaczysz, Å¼e Cargo\nwygenerowaÅ‚o dla nas dwa pliki i jeden katalog: plik _Cargo.toml_ i katalog\n_src_ z plikiem _main.rs_ w Å›rodku.\n\nZainicjowaÅ‚o rÃ³wnieÅ¼ nowe repozytorium Git wraz z plikiem _.gitignore_.\nPliki Git nie zostanÄ… wygenerowane, jeÅ›li uruchomisz `cargo new` w istniejÄ…cym\nrepozytorium Git; moÅ¼esz nadpisaÄ‡ to zachowanie, uÅ¼ywajÄ…c `cargo new --vcs=git`.\n\n> Uwaga: Git to popularny system kontroli wersji. MoÅ¼esz zmieniÄ‡ `cargo new`,\n> aby uÅ¼ywaÄ‡ innego systemu kontroli wersji lub Å¼adnego, uÅ¼ywajÄ…c flagi\n> `--vcs`. Uruchom `cargo new --help`, aby zobaczyÄ‡ dostÄ™pne opcje.\n\nOtwÃ³rz _Cargo.toml_ w swoim ulubionym edytorze tekstu. Powinien wyglÄ…daÄ‡\npodobnie do kodu z Listingu 1-2.\n\n<Listing number=\"1-2\" file-name=\"Cargo.toml\" caption=\"ZawartoÅ›Ä‡ *Cargo.toml* wygenerowana przez `cargo new`\">\n\n```toml\n[package]\nname = \"hello_cargo\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\n```\n\n</Listing>\n\nTen plik jest w formacie [_TOML_][toml]<!-- ignore --> (_Tomâ€™s Obvious, Minimal\nLanguage_), ktÃ³ry jest formatem konfiguracyjnym Cargo.\n\nPierwszy wiersz, `[package]`, to nagÅ‚Ã³wek sekcji wskazujÄ…cy, Å¼e nastÄ™pne\ninstrukcje konfigurujÄ… pakiet. W miarÄ™ dodawania kolejnych informacji do tego\npliku, bÄ™dziemy dodawaÄ‡ inne sekcje.\n\nTrzy nastÄ™pne wiersze ustawiajÄ… informacje konfiguracyjne, ktÃ³rych Cargo\npotrzebuje do skompilowania programu: nazwÄ™, wersjÄ™ i wydanie Rusta do\nuÅ¼ycia. OmÃ³wimy klucz `edition` w [Dodatku E][appendix-e]<!-- ignore -->.\n\nOstatni wiersz, `[dependencies]`, to poczÄ…tek sekcji, w ktÃ³rej moÅ¼esz wymieniÄ‡\nwszystkie zaleÅ¼noÅ›ci swojego projektu. W RuÅ›cie pakiety kodu sÄ… nazywane\n_skrzynkami_. Nie bÄ™dziemy potrzebowaÄ‡ Å¼adnych innych skrzynek do tego projektu,\nale bÄ™dziemy potrzebowaÄ‡ ich w pierwszym projekcie w Rozdziale 2, wiÄ™c\nskorzystamy z tej sekcji zaleÅ¼noÅ›ci wtedy.\n\nTeraz otwÃ³rz _src/main.rs_ i przyjrzyj siÄ™:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\nCargo wygenerowaÅ‚o dla Ciebie program â€Witaj, Å›wiecie!â€, dokÅ‚adnie taki jak ten,\nktÃ³ry napisaliÅ›my w Listingu 1-1! Do tej pory rÃ³Å¼nice miÄ™dzy naszym projektem\na projektem wygenerowanym przez Cargo polegaÅ‚y na tym, Å¼e Cargo umieÅ›ciÅ‚o\nkod w katalogu _src_, a my mamy plik konfiguracyjny _Cargo.toml_ w\nnajwyÅ¼szym katalogu.\n\nCargo oczekuje, Å¼e Twoje pliki ÅºrÃ³dÅ‚owe bÄ™dÄ… znajdowaÄ‡ siÄ™ w katalogu _src_.\nKatalog projektu najwyÅ¼szego poziomu jest przeznaczony tylko na pliki README,\ninformacje licencyjne, pliki konfiguracyjne i wszystko inne, co nie jest\nzwiÄ…zane z Twoim kodem. Korzystanie z Cargo pomaga w organizacji projektÃ³w.\nWszystko ma swoje miejsce i wszystko jest na swoim miejscu.\n\nJeÅ›li rozpoczÄ…Å‚eÅ› projekt, ktÃ³ry nie uÅ¼ywa Cargo, tak jak to zrobiliÅ›my z\nprojektem â€Witaj, Å›wiecie!â€, moÅ¼esz przekonwertowaÄ‡ go na projekt, ktÃ³ry uÅ¼ywa\nCargo. PrzenieÅ› kod projektu do katalogu _src_ i utwÃ³rz odpowiedni plik\n_Cargo.toml_. Åatwym sposobem na uzyskanie pliku _Cargo.toml_ jest uruchomienie\n`cargo init`, ktÃ³re utworzy go dla Ciebie automatycznie.\n\n### Budowanie i uruchamianie projektu Cargo\n\nTeraz przyjrzyjmy siÄ™, co siÄ™ zmieni, gdy zbudujemy i uruchomimy program\nâ€Witaj, Å›wiecie!â€ za pomocÄ… Cargo! Z katalogu _hello_cargo_ zbuduj swÃ³j projekt,\nwypisujÄ…c nastÄ™pujÄ…ce polecenie:\n\n```console\n$ cargo build\n   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs\n```\n\nTo polecenie tworzy plik wykonywalny w _target/debug/hello_cargo_ (lub\n_target\\debug\\hello_cargo.exe_ na Windows), a nie w bieÅ¼Ä…cym katalogu.\nPoniewaÅ¼ domyÅ›lna kompilacja jest kompilacjÄ… debugowÄ…, Cargo umieszcza\nplik binarny w katalogu o nazwie _debug_. MoÅ¼esz uruchomiÄ‡ plik wykonywalny\nza pomocÄ… tego polecenia:\n\n```console\n$ ./target/debug/hello_cargo # lub .\\target\\debug\\hello_cargo.exe na Windows\nHello, world!\n```\n\nJeÅ›li wszystko pÃ³jdzie dobrze, w terminalu powinno zostaÄ‡ wyÅ›wietlone\n`Witaj, Å›wiecie!`. Uruchomienie `cargo build` po raz pierwszy powoduje rÃ³wnieÅ¼,\nÅ¼e Cargo tworzy nowy plik na najwyÅ¼szym poziomie: _Cargo.lock_. Ten plik Å›ledzi\ndokÅ‚adne wersje zaleÅ¼noÅ›ci w Twoim projekcie. Ten projekt nie ma zaleÅ¼noÅ›ci,\nwiÄ™c plik jest nieco skÄ…py. Nigdy nie bÄ™dziesz musiaÅ‚ rÄ™cznie zmieniaÄ‡ tego\npliku; Cargo zarzÄ…dza jego zawartoÅ›ciÄ… za Ciebie.\n\nWÅ‚aÅ›nie zbudowaliÅ›my projekt za pomocÄ… `cargo build` i uruchomiliÅ›my go za\npomocÄ… `./target/debug/hello_cargo`, ale moÅ¼emy rÃ³wnieÅ¼ uÅ¼yÄ‡ `cargo run`,\naby skompilowaÄ‡ kod, a nastÄ™pnie uruchomiÄ‡ wynikowy plik wykonywalny za\njednym poleceniem:\n\n```console\n$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/hello_cargo`\nHello, world!\n```\n\nUÅ¼ywanie `cargo run` jest wygodniejsze niÅ¼ koniecznoÅ›Ä‡ pamiÄ™tania o\nuruchamianiu `cargo build`, a nastÄ™pnie uÅ¼ywaniu peÅ‚nej Å›cieÅ¼ki do pliku\nbinearnego, wiÄ™c wiÄ™kszoÅ›Ä‡ deweloperÃ³w uÅ¼ywa `cargo run`.\n\nZauwaÅ¼, Å¼e tym razem nie widzieliÅ›my wyjÅ›cia wskazujÄ…cego, Å¼e Cargo kompiluje\n`hello_cargo`. Cargo ustaliÅ‚o, Å¼e pliki nie ulegÅ‚y zmianie, wiÄ™c nie\nprzebudowywaÅ‚o, a jedynie uruchomiÅ‚o plik binarny. GdybyÅ› zmodyfikowaÅ‚ swÃ³j kod\nÅºrÃ³dÅ‚owy, Cargo przebudowaÅ‚oby projekt przed jego uruchomieniem, a Ty\nzobaczyÅ‚byÅ› takie wyjÅ›cie:\n\n```console\n$ cargo run\n   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs\n     Running `target/debug/hello_cargo`\nHello, world!\n```\n\nCargo udostÄ™pnia rÃ³wnieÅ¼ polecenie `cargo check`. To polecenie szybko\nsprawdza TwÃ³j kod, aby upewniÄ‡ siÄ™, Å¼e kompiluje siÄ™, ale nie tworzy pliku\nwykonywalnego:\n\n```console\n$ cargo check\n   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs\n```\n\nDlaczego nie chciaÅ‚byÅ› pliku wykonywalnego? CzÄ™sto `cargo check` jest\nzauwaÅ¼alnie szybsze niÅ¼ `cargo build`, poniewaÅ¼ pomija krok tworzenia pliku\nwykonywalnego. JeÅ›li stale sprawdzasz swojÄ… pracÄ™ podczas pisania kodu,\nuÅ¼ycie `cargo check` przyspieszy proces informowania CiÄ™, czy TwÃ³j projekt\nnadal siÄ™ kompiluje! W zwiÄ…zku z tym wielu RustaceanÃ³w uruchamia `cargo check`\nperiodycznie podczas pisania programu, aby upewniÄ‡ siÄ™, Å¼e siÄ™ kompiluje.\nNastÄ™pnie uruchamiajÄ… `cargo build`, gdy sÄ… gotowi do uÅ¼ycia pliku\nwykonywalnego.\n\nPodsumujmy, czego do tej pory nauczyliÅ›my siÄ™ o Cargo:\n\n- MoÅ¼emy utworzyÄ‡ projekt za pomocÄ… `cargo new`.\n- MoÅ¼emy zbudowaÄ‡ projekt za pomocÄ… `cargo build`.\n- MoÅ¼emy zbudowaÄ‡ i uruchomiÄ‡ projekt w jednym kroku za pomocÄ… `cargo run`.\n- MoÅ¼emy zbudowaÄ‡ projekt bez tworzenia pliku binarnego, aby sprawdziÄ‡ bÅ‚Ä™dy,\n  za pomocÄ… `cargo check`.\n- Zamiast zapisywaÄ‡ wynik kompilacji w tym samym katalogu co nasz kod, Cargo\n  przechowuje go w katalogu _target/debug_.\n\nDodatkowÄ… zaletÄ… uÅ¼ywania Cargo jest to, Å¼e polecenia sÄ… takie same,\nniezaleÅ¼nie od systemu operacyjnego, na ktÃ³rym pracujesz. Tak wiÄ™c, w tym\nmomencie nie bÄ™dziemy juÅ¼ podawaÄ‡ konkretnych instrukcji dla Linuksa i macOS\nw stosunku do Windows.\n\n### Budowanie do wersji produkcyjnej\n\nKiedy TwÃ³j projekt jest wreszcie gotowy do wydania, moÅ¼esz uÅ¼yÄ‡ `cargo build\n--release`, aby skompilowaÄ‡ go z optymalizacjami. To polecenie utworzy plik\nwykonywalny w _target/release_ zamiast _target/debug_. Optymalizacje sprawiajÄ…,\nÅ¼e kod Rusta dziaÅ‚a szybciej, ale ich wÅ‚Ä…czenie wydÅ‚uÅ¼a czas kompilacji\nprogramu. Dlatego istniejÄ… dwa rÃ³Å¼ne profile: jeden do rozwoju, gdy chcesz\nszybko i czÄ™sto przebudowywaÄ‡, a drugi do budowania ostatecznego programu,\nktÃ³ry przekaÅ¼esz uÅ¼ytkownikowi, ktÃ³ry nie bÄ™dzie wielokrotnie przebudowywany i\nktÃ³ry bÄ™dzie dziaÅ‚aÅ‚ tak szybko, jak to moÅ¼liwe. JeÅ›li mierzysz czas\nuruchamiania kodu, upewnij siÄ™, Å¼e uruchamiasz `cargo build --release` i\nmierzysz wydajnoÅ›Ä‡ z plikiem wykonywalnym w _target/release_.\n\n<!-- Old headings. Do not remove or links may break. -->\n<a id=\"cargo-as-convention\"></a>\n\n### Wykorzystanie konwencji Cargo\n\nW przypadku prostych projektÃ³w Cargo nie zapewnia duÅ¼ej wartoÅ›ci w porÃ³wnaniu\nz samym uÅ¼ywaniem `rustc`, ale udowodni swojÄ… wartoÅ›Ä‡, gdy Twoje programy\nstanÄ… siÄ™ bardziej zÅ‚oÅ¼one. Gdy programy rozrosnÄ… siÄ™ do wielu plikÃ³w lub\nbÄ™dÄ… wymagaÅ‚y zaleÅ¼noÅ›ci, znacznie Å‚atwiej jest pozwoliÄ‡ Cargo\nkoordynowaÄ‡ budowanie.\n\nMimo Å¼e projekt `hello_cargo` jest prosty, wykorzystuje teraz wiele\nrzeczywistych narzÄ™dzi, ktÃ³rych bÄ™dziesz uÅ¼ywaÄ‡ w pozostaÅ‚ej czÄ™Å›ci swojej\nkariery z Rustem. W rzeczywistoÅ›ci, aby pracowaÄ‡ nad istniejÄ…cymi projektami,\nmoÅ¼esz uÅ¼yÄ‡ nastÄ™pujÄ…cych poleceÅ„, aby pobraÄ‡ kod za pomocÄ… Git, przejÅ›Ä‡ do\nkatalogu tego projektu i zbudowaÄ‡:\n\n```console\n$ git clone example.org/someproject\n$ cd someproject\n$ cargo build\n```\n\nWiÄ™cej informacji na temat Cargo znajdziesz w [jego dokumentacji][cargo].\n\n## Podsumowanie\n\nJuÅ¼ Å›wietnie zaczÄ…Å‚eÅ› swojÄ… podrÃ³Å¼ z Rustem! W tym rozdziale nauczyÅ‚eÅ› siÄ™:\n\n- Jak zainstalowaÄ‡ najnowszÄ… stabilnÄ… wersjÄ™ Rusta za pomocÄ… `rustup`.\n- Jak zaktualizowaÄ‡ Rusta do nowszej wersji.\n- Jak otworzyÄ‡ lokalnie zainstalowanÄ… dokumentacjÄ™.\n- Jak napisaÄ‡ i uruchomiÄ‡ program â€Witaj, Å›wiecie!â€ bezpoÅ›rednio za pomocÄ…\n  `rustc`.\n- Jak utworzyÄ‡ i uruchomiÄ‡ nowy projekt, korzystajÄ…c z konwencji Cargo.\n\nTo Å›wietny moment, aby zbudowaÄ‡ bardziej rozbudowany program, aby przyzwyczaiÄ‡\nsiÄ™ do czytania i pisania kodu w RuÅ›cie. Tak wiÄ™c, w Rozdziale 2 zbudujemy\nprogram do zgadywania liczb. JeÅ›li wolisz zaczÄ…Ä‡ od nauki, jak dziaÅ‚ajÄ…\npowszechne koncepcje programistyczne w RuÅ›cie, zobacz RozdziaÅ‚ 3, a nastÄ™pnie\nwrÃ³Ä‡ do RozdziaÅ‚u 2.\n\n[installation]: ch01-01-installation.html#installation\n[toml]: https://toml.io\n[appendix-e]: appendix-05-editions.html\n[cargo]: https://doc.rust-lang.org/cargo/\n",
        "chapter_title": "Witaj, Cargo!"
    },
    {
        "file_path": "ch03-00-common-programming-concepts.md",
        "content": "# Podstawowe koncepcje programowania\n\nTen rozdziaÅ‚ obejmuje koncepcje, ktÃ³re pojawiajÄ… siÄ™ w prawie kaÅ¼dym jÄ™zyku\nprogramowania i sposÃ³b, w jaki dziaÅ‚ajÄ… w RuÅ›cie. Wiele jÄ™zykÃ³w\nprogramowania ma ze sobÄ… wiele wspÃ³lnego w swoim rdzeniu. Å»adna z koncepcji\nprzedstawionych w tym rozdziale nie jest unikalna dla Rusta, ale omÃ³wimy je w\nkontekÅ›cie Rusta i wyjaÅ›nimy konwencje dotyczÄ…ce ich uÅ¼ywania.\n\nKonkretnie, dowiesz siÄ™ o zmiennych, podstawowych typach, funkcjach,\nkomentarzach i przepÅ‚ywie sterowania. Te podstawy znajdÄ… siÄ™ w kaÅ¼dym\nprogramie Rusta, a wczesne ich poznanie da Ci solidny rdzeÅ„, od ktÃ³rego moÅ¼esz\nzaczÄ…Ä‡.\n\n> #### SÅ‚owa kluczowe\n>\n> JÄ™zyk Rust ma zestaw _sÅ‚Ã³w kluczowych_, ktÃ³re sÄ… zarezerwowane wyÅ‚Ä…cznie dla\n> jÄ™zyka, podobnie jak w innych jÄ™zykach. PamiÄ™taj, Å¼e nie moÅ¼esz uÅ¼ywaÄ‡ tych\n> sÅ‚Ã³w jako nazw zmiennych ani funkcji. WiÄ™kszoÅ›Ä‡ sÅ‚Ã³w kluczowych ma\n> specjalne znaczenia, a bÄ™dziesz ich uÅ¼ywaÄ‡ do wykonywania rÃ³Å¼nych zadaÅ„ w\n> swoich programach w RuÅ›cie; kilka nie ma obecnie Å¼adnej zwiÄ…zanej z nimi\n> funkcjonalnoÅ›ci, ale zostaÅ‚y zarezerwowane dla funkcjonalnoÅ›ci, ktÃ³ra moÅ¼e\n> zostaÄ‡ dodana do Rusta w przyszÅ‚oÅ›ci. ListÄ™ sÅ‚Ã³w kluczowych znajdziesz w\n> [Dodatku A][appendix_a]<!-- ignore -->.\n\n[appendix_a]: appendix-01-keywords.md\n",
        "chapter_title": "Podstawowe koncepcje programowania"
    },
    {
        "file_path": "ch03-01-variables-and-mutability.md",
        "content": "## Zmienne i mutowalnoÅ›Ä‡\n\nJak wspomniano w [sekcji â€Przechowywanie wartoÅ›ci w\nzmiennychâ€][storing-values-with-variables]<!-- ignore -->, zmienne sÄ… domyÅ›lnie\nniezmienne. Jest to jedna z wielu wskazÃ³wek, ktÃ³re Rust daje Ci, abyÅ› pisaÅ‚\nswÃ³j kod w sposÃ³b, ktÃ³ry wykorzystuje bezpieczeÅ„stwo i Å‚atwÄ… wspÃ³Å‚bieÅ¼noÅ›Ä‡,\njakie oferuje Rust. Jednak nadal masz moÅ¼liwoÅ›Ä‡ uczynienia swoich zmiennych\nmutowalnymi. Przyjrzyjmy siÄ™, jak i dlaczego Rust zachÄ™ca do preferowania\nniezmiennoÅ›ci i dlaczego czasami moÅ¼esz chcieÄ‡ zrezygnowaÄ‡ z tej opcji.\n\nKiedy zmienna jest niezmienna, po powiÄ…zaniu wartoÅ›ci z nazwÄ… nie moÅ¼na\nzmieniÄ‡ tej wartoÅ›ci. Aby to zilustrowaÄ‡, wygeneruj nowy projekt o nazwie\n_variables_ w swoim katalogu _projects_ za pomocÄ… `cargo new variables`.\n\nNastÄ™pnie, w nowym katalogu _variables_, otwÃ³rz _src/main.rs_ i zastÄ…p jego\nkod nastÄ™pujÄ…cym kodem, ktÃ³ry jeszcze siÄ™ nie skompiluje:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust,ignore,does_not_compile\nfn main() {\n    let x = 5;\n    println!(\"WartoÅ›Ä‡ x to: {x}\");\n    x = 6;\n    println!(\"WartoÅ›Ä‡ x to: {x}\");\n}\n```\n\nZapisz i uruchom program za pomocÄ… `cargo run`. PowinieneÅ› otrzymaÄ‡ komunikat\no bÅ‚Ä™dzie dotyczÄ…cy bÅ‚Ä™du niezmiennoÅ›ci, jak pokazano w tym wyjÅ›ciu:\n\n```console\n$ cargo run\n   Compiling variables v0.1.0 (file:///projects/variables)\nerror[E0384]: cannot assign twice to immutable variable `x`\n --> src/main.rs:4:5\n  |\n2 |     let x = 5;\n  |         - first assignment to `x`\n3 |     println!(\"The value of x is: {x}\");\n4 |     x = 6;\n  |     ^^^^^ cannot assign twice to immutable variable\n  |\nhelp: consider making this binding mutable\n  |\n2 |     let mut x = 5;\n  |         +++\n\nFor more information about this error, try `rustc --explain E0384`.\nerror: could not compile `variables` (bin \"variables\") due to 1 previous error\n```\n\nTen przykÅ‚ad pokazuje, jak kompilator pomaga znaleÅºÄ‡ bÅ‚Ä™dy w Twoich\nprogramach. BÅ‚Ä™dy kompilatora mogÄ… byÄ‡ frustrujÄ…ce, ale tak naprawdÄ™\noznaczajÄ… tylko, Å¼e TwÃ³j program nie dziaÅ‚a jeszcze bezpiecznie tak, jak\nchcesz; nie oznaczajÄ…, Å¼e nie jesteÅ› dobrym programistÄ…! DoÅ›wiadczeni\nRustaceanie nadal otrzymujÄ… bÅ‚Ä™dy kompilatora.\n\nOtrzymaÅ‚eÅ› komunikat o bÅ‚Ä™dzie `` cannot assign twice to immutable variable `x` ``\n(nie moÅ¼na przypisaÄ‡ dwa razy do niezmiennej zmiennej `x`), poniewaÅ¼ prÃ³bowaÅ‚eÅ›\nprzypisaÄ‡ drugÄ… wartoÅ›Ä‡ do niezmiennej zmiennej `x`.\n\nWaÅ¼ne jest, abyÅ›my otrzymywali bÅ‚Ä™dy kompilacji, gdy prÃ³bujemy zmieniÄ‡ wartoÅ›Ä‡,\nktÃ³ra zostaÅ‚a oznaczona jako niezmienna, poniewaÅ¼ ta wÅ‚aÅ›nie sytuacja moÅ¼e\nprowadziÄ‡ do bÅ‚Ä™dÃ³w. JeÅ›li jedna czÄ™Å›Ä‡ naszego kodu dziaÅ‚a w oparciu o\nzaÅ‚oÅ¼enie, Å¼e wartoÅ›Ä‡ nigdy siÄ™ nie zmieni, a inna czÄ™Å›Ä‡ naszego kodu zmienia\ntÄ™ wartoÅ›Ä‡, moÅ¼liwe jest, Å¼e pierwsza czÄ™Å›Ä‡ kodu nie wykona tego, do czego\nzostaÅ‚a zaprojektowana. PrzyczynÄ™ tego rodzaju bÅ‚Ä™du moÅ¼e byÄ‡ trudno\nwyÅ›ledziÄ‡ po fakcie, zwÅ‚aszcza gdy druga czÄ™Å›Ä‡ kodu zmienia wartoÅ›Ä‡ tylko\n_czasami_. Kompilator Rusta gwarantuje, Å¼e gdy zadeklarujesz, Å¼e wartoÅ›Ä‡ siÄ™\nnie zmieni, to naprawdÄ™ siÄ™ nie zmieni, wiÄ™c nie musisz sam tego Å›ledziÄ‡.\nTwÃ³j kod jest dziÄ™ki temu Å‚atwiejszy do przemyÅ›lenia.\n\nAle mutowalnoÅ›Ä‡ moÅ¼e byÄ‡ bardzo przydatna i moÅ¼e sprawiÄ‡, Å¼e kod bÄ™dzie\nwygodniejszy w pisaniu. ChociaÅ¼ zmienne sÄ… domyÅ›lnie niezmienne, moÅ¼esz\nuczyniÄ‡ je mutowalnymi, dodajÄ…c `mut` przed nazwÄ… zmiennej, tak jak to\nzrobiÅ‚eÅ› w [Rozdziale 2][storing-values-with-variables]<!-- ignore -->.\nDodanie `mut` rÃ³wnieÅ¼ przekazuje intencjÄ™ przyszÅ‚ym czytelnikom kodu,\nwskazujÄ…c, Å¼e inne czÄ™Å›ci kodu bÄ™dÄ… zmieniaÄ‡ wartoÅ›Ä‡ tej zmiennej.\n\nNa przykÅ‚ad, zmieÅ„my _src/main.rs_ na nastÄ™pujÄ…cy kod:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust\nfn main() {\n    let mut x = 5;\n    println!(\"WartoÅ›Ä‡ x to: {x}\");\n    x = 6;\n    println!(\"WartoÅ›Ä‡ x to: {x}\");\n}\n```\n\nKiedy uruchomimy program teraz, otrzymamy:\n\n```console\n$ cargo run\n   Compiling variables v0.1.0 (file:///projects/variables)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s\n     Running `target/debug/variables`\nWartoÅ›Ä‡ x to: 5\nWartoÅ›Ä‡ x to: 6\n```\n\nMoÅ¼emy zmieniÄ‡ wartoÅ›Ä‡ przypisanÄ… do `x` z `5` na `6`, gdy uÅ¼yto `mut`.\nOstatecznie, decyzja o uÅ¼yciu mutowalnoÅ›ci zaleÅ¼y od Ciebie i od tego, co\nuwaÅ¼asz za najbardziej przejrzyste w danej sytuacji.\n\n<!-- Old headings. Do not remove or links may break. -->\n<a id=\"constants\"></a>\n\n### Deklarowanie staÅ‚ych\n\nPodobnie jak niezmienne zmienne, _staÅ‚e_ to wartoÅ›ci, ktÃ³re sÄ… powiÄ…zane z\nnazwÄ… i nie mogÄ… byÄ‡ zmieniane, ale istniejÄ… pewne rÃ³Å¼nice miÄ™dzy staÅ‚ymi a\nzmiennymi.\n\nPo pierwsze, nie wolno uÅ¼ywaÄ‡ `mut` ze staÅ‚ymi. StaÅ‚e sÄ… nie tylko domyÅ›lnie\nniezmienne â€” sÄ… zawsze niezmienne. StaÅ‚e deklaruje siÄ™ za pomocÄ… sÅ‚owa\nkluczowego `const` zamiast sÅ‚owa kluczowego `let`, a typ wartoÅ›ci _musi_ byÄ‡\nannotowany. Typy i adnotacje typÃ³w omÃ³wimy w nastÄ™pnej sekcji, [â€Typy\ndanychâ€][data-types]<!-- ignore -->, wiÄ™c na razie nie martw siÄ™ szczegÃ³Å‚ami.\nWystarczy wiedzieÄ‡, Å¼e zawsze musisz podawaÄ‡ typ.\n\nStaÅ‚e mogÄ… byÄ‡ deklarowane w dowolnym zasiÄ™gu, w tym w zasiÄ™gu globalnym, co\nczyni je uÅ¼ytecznymi dla wartoÅ›ci, o ktÃ³rych wiele czÄ™Å›ci kodu musi wiedzieÄ‡.\n\nOstatnia rÃ³Å¼nica polega na tym, Å¼e staÅ‚e mogÄ… byÄ‡ ustawiane tylko na wyraÅ¼enie\nstaÅ‚e, a nie na wynik wartoÅ›ci, ktÃ³ra mogÅ‚aby byÄ‡ obliczona tylko w czasie\nuruchamiania.\n\nOto przykÅ‚ad deklaracji staÅ‚ej:\n\n```rust\nconst THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;\n```\n\nNazwa staÅ‚ej to `THREE_HOURS_IN_SECONDS`, a jej wartoÅ›Ä‡ jest ustawiona na\nwynik pomnoÅ¼enia 60 (liczby sekund w minucie) przez 60 (liczby minut w\ngodzinie) przez 3 (liczby godzin, ktÃ³re chcemy policzyÄ‡ w tym programie).\nKonwencjÄ… nazewniczÄ… Rusta dla staÅ‚ych jest uÅ¼ywanie samych duÅ¼ych liter z\npodkreÅ›leniami miÄ™dzy sÅ‚owami. Kompilator jest w stanie oceniÄ‡ ograniczony\nzestaw operacji w czasie kompilacji, co pozwala nam zapisaÄ‡ tÄ™ wartoÅ›Ä‡ w sposÃ³b\nÅ‚atwiejszy do zrozumienia i weryfikacji, zamiast ustawiaÄ‡ tÄ™ staÅ‚Ä… na wartoÅ›Ä‡\n10 800. WiÄ™cej informacji na temat operacji, ktÃ³re moÅ¼na stosowaÄ‡ przy\ndeklarowaniu staÅ‚ych, znajdziesz w [sekcji Rust Reference dotyczÄ…cej\newaluacji staÅ‚ych][const-eval].\n\nStaÅ‚e sÄ… waÅ¼ne przez caÅ‚y czas dziaÅ‚ania programu, w zasiÄ™gu, w ktÃ³rym zostaÅ‚y\nzadeklarowane. Ta wÅ‚aÅ›ciwoÅ›Ä‡ sprawia, Å¼e staÅ‚e sÄ… przydatne dla wartoÅ›ci w\ndomenie aplikacji, o ktÃ³rych wiele czÄ™Å›ci programu moÅ¼e potrzebowaÄ‡ wiedzieÄ‡,\ntakich jak maksymalna liczba punktÃ³w, jakÄ… kaÅ¼dy gracz moÅ¼e zdobyÄ‡, lub\nprÄ™dkoÅ›Ä‡ Å›wiatÅ‚a.\n\nNazywanie zakodowanych wartoÅ›ci uÅ¼ywanych w caÅ‚ym programie jako staÅ‚ych jest\nprzydatne w przekazywaniu znaczenia tej wartoÅ›ci przyszÅ‚ym utrzymujÄ…cym kod.\nPomaga rÃ³wnieÅ¼ mieÄ‡ tylko jedno miejsce w kodzie, ktÃ³re trzeba by zmieniÄ‡,\ngdyby zakodowana wartoÅ›Ä‡ wymagaÅ‚a aktualizacji w przyszÅ‚oÅ›ci.\n\n### PrzesÅ‚anianie\n\nJak widziaÅ‚eÅ› w samouczku gry w zgadywanie w [Rozdziale\n2][comparing-the-guess-to-the-secret-number]<!-- ignore -->, moÅ¼esz\nzadeklarowaÄ‡ nowÄ… zmiennÄ… o tej samej nazwie co poprzednia zmienna. Rustaceanie\nmÃ³wiÄ…, Å¼e pierwsza zmienna jest _przesÅ‚oniÄ™ta_ przez drugÄ…, co oznacza, Å¼e druga\nzmienna jest tym, co kompilator bÄ™dzie widziaÅ‚, gdy uÅ¼yjesz nazwy zmiennej.\nW efekcie druga zmienna przysÅ‚ania pierwszÄ…, przejmujÄ…c wszelkie uÅ¼ycia nazwy\nzmiennej na siebie, dopÃ³ki sama nie zostanie przesÅ‚oniÄ™ta lub zasiÄ™g siÄ™ nie\nzakoÅ„czy. MoÅ¼emy przesÅ‚oniÄ‡ zmiennÄ…, uÅ¼ywajÄ…c tej samej nazwy zmiennej i\npowtarzajÄ…c uÅ¼ycie sÅ‚owa kluczowego `let` w nastÄ™pujÄ…cy sposÃ³b:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust\nfn main() {\n    let x = 5;\n\n    let x = x + 1;\n\n    {\n        let x = x * 2;\n        println!(\"WartoÅ›Ä‡ x w wewnÄ™trznym zasiÄ™gu to: {x}\");\n    }\n\n    println!(\"WartoÅ›Ä‡ x to: {x}\");\n}\n```\n\nTen program najpierw wiÄ…Å¼e `x` z wartoÅ›ciÄ… `5`. NastÄ™pnie tworzy nowÄ… zmiennÄ…\n`x`, powtarzajÄ…c `let x =`, biorÄ…c oryginalnÄ… wartoÅ›Ä‡ i dodajÄ…c `1` tak, aby\nwartoÅ›Ä‡ `x` wynosiÅ‚a `6`. NastÄ™pnie, wewnÄ…trz wewnÄ™trznego zasiÄ™gu\nutworzonego za pomocÄ… nawiasÃ³w klamrowych, trzecia instrukcja `let` rÃ³wnieÅ¼\nprzesÅ‚ania `x` i tworzy nowÄ… zmiennÄ…, mnoÅ¼Ä…c poprzedniÄ… wartoÅ›Ä‡ przez `2`, aby\nnadaÄ‡ `x` wartoÅ›Ä‡ `12`. Gdy ten zasiÄ™g siÄ™ koÅ„czy, wewnÄ™trzne przesÅ‚anianie\nzakoÅ„czy siÄ™, a `x` powrÃ³ci do `6`. Kiedy uruchomimy ten program, wyÅ›wietli\nsiÄ™ nastÄ™pujÄ…cy wynik:\n\n```console\n$ cargo run\n   Compiling variables v0.1.0 (file:///projects/variables)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s\n     Running `target/debug/variables`\nWartoÅ›Ä‡ x w wewnÄ™trznym zasiÄ™gu to: 12\nWartoÅ›Ä‡ x to: 6\n```\n\nPrzesÅ‚anianie rÃ³Å¼ni siÄ™ od oznaczania zmiennej jako `mut`, poniewaÅ¼\notrzymamy bÅ‚Ä…d kompilacji, jeÅ›li przypadkowo sprÃ³bujemy przypisaÄ‡ nowÄ… wartoÅ›Ä‡\ndo tej zmiennej bez uÅ¼ycia sÅ‚owa kluczowego `let`. UÅ¼ywajÄ…c `let`,\nmoÅ¼emy wykonaÄ‡ kilka transformacji na wartoÅ›ci, ale po tych transformacjach\nzmienna pozostanie niezmienna.\n\nInna rÃ³Å¼nica miÄ™dzy `mut` a przesÅ‚anianiem polega na tym, Å¼e poniewaÅ¼\nefektywnie tworzymy nowÄ… zmiennÄ…, gdy ponownie uÅ¼ywamy sÅ‚owa kluczowego `let`,\nmoÅ¼emy zmieniÄ‡ typ wartoÅ›ci, ale ponownie uÅ¼yÄ‡ tej samej nazwy. Na przykÅ‚ad,\npowiedzmy, Å¼e nasz program prosi uÅ¼ytkownika o podanie liczby spacji,\njakie chce miÄ™dzy tekstem, wprowadzajÄ…c spacje, a nastÄ™pnie chcemy\nprzechowywaÄ‡ te dane wejÅ›ciowe jako liczbÄ™:\n\n```rust\n# fn main() {\n    let spaces = \"   \";\n    let spaces = spaces.len();\n# }\n```\n\nPierwsza zmienna `spaces` jest typu string, a druga zmienna `spaces` jest\ntypu liczbowego. PrzesÅ‚anianie pozwala nam uniknÄ…Ä‡ wymyÅ›lania rÃ³Å¼nych nazw,\ntakich jak `spaces_str` i `spaces_num`; zamiast tego moÅ¼emy ponownie uÅ¼yÄ‡\nprostszej nazwy `spaces`. JednakÅ¼e, jeÅ›li sprÃ³bujemy uÅ¼yÄ‡ `mut` w tym\nprzypadku, jak pokazano tutaj, otrzymamy bÅ‚Ä…d kompilacji:\n\n```rust,ignore,does_not_compile\n# fn main() {\n    let mut spaces = \"   \";\n    spaces = spaces.len();\n# }\n```\n\nBÅ‚Ä…d mÃ³wi, Å¼e nie wolno nam mutowaÄ‡ typu zmiennej:\n\n```console\n$ cargo run\n   Compiling variables v0.1.0 (file:///projects/variables)\nerror[E0308]: mismatched types\n --> src/main.rs:3:14\n  |\n2 |     let mut spaces = \"   \";\n  |                      ----- expected due to this value\n3 |     spaces = spaces.len();\n  |              ^^^^^^^^^^^^ expected `&str`, found `usize`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `variables` (bin \"variables\") due to 1 previous error\n```\n\nTeraz, gdy zbadaliÅ›my, jak dziaÅ‚ajÄ… zmienne, przyjrzyjmy siÄ™ innym typom\ndanych, ktÃ³re mogÄ… mieÄ‡.\n\n[comparing-the-guess-to-the-secret-number]: ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number\n[data-types]: ch03-02-data-types.html#data-types\n[storing-values-with-variables]: ch02-00-guessing-game-tutorial.html#storing-values-with-variables\n[const-eval]: ../reference/const_eval.html\n",
        "chapter_title": "Zmienne i mutowalnoÅ›Ä‡"
    },
    {
        "file_path": "ch03-03-how-functions-work.md",
        "content": "## Funkcje\n\nFunkcje sÄ… powszechne w kodzie Rusta. WidziaÅ‚eÅ› juÅ¼ jednÄ… z\nnajwaÅ¼niejszych funkcji w jÄ™zyku: funkcjÄ™ `main`, ktÃ³ra jest punktem wejÅ›cia\nwielu programÃ³w. WidziaÅ‚eÅ› rÃ³wnieÅ¼ sÅ‚owo kluczowe `fn`, ktÃ³re pozwala\ndeklarowaÄ‡ nowe funkcje.\n\nKod Rusta uÅ¼ywa _snake case_ jako konwencjonalnego stylu dla nazw funkcji i\nzmiennych, w ktÃ³rym wszystkie litery sÄ… maÅ‚e, a podkreÅ›lenia oddzielajÄ… sÅ‚owa.\nOto program, ktÃ³ry zawiera przykÅ‚adowÄ… definicjÄ™ funkcji:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n\n    another_function();\n}\n\nfn another_function() {\n    println!(\"Inna funkcja.\");\n}\n```\n\nDefiniujemy funkcjÄ™ w RuÅ›cie, wpisujÄ…c `fn` po ktÃ³rej nastÄ™puje nazwa funkcji i\nzestaw nawiasÃ³w. Nawiasy klamrowe informujÄ… kompilator, gdzie zaczyna siÄ™ i\nkoÅ„czy ciaÅ‚o funkcji.\n\nMoÅ¼emy wywoÅ‚aÄ‡ dowolnÄ… zdefiniowanÄ… przez nas funkcjÄ™, wpisujÄ…c jej nazwÄ™,\na nastÄ™pnie zestaw nawiasÃ³w. PoniewaÅ¼ `another_function` jest zdefiniowana w\nprogramie, moÅ¼e byÄ‡ wywoÅ‚ana z wewnÄ…trz funkcji `main`. ZauwaÅ¼, Å¼e zdefiniowaliÅ›my\n`another_function` _po_ funkcji `main` w kodzie ÅºrÃ³dÅ‚owym; mogliÅ›my jÄ… rÃ³wnieÅ¼\nzdefiniowaÄ‡ wczeÅ›niej. Rust nie dba o to, gdzie definiujesz swoje funkcje,\na jedynie o to, czy sÄ… zdefiniowane w zasiÄ™gu, ktÃ³ry moÅ¼e byÄ‡ widoczny dla\nwywoÅ‚ujÄ…cego.\n\nUtwÃ³rzmy nowy projekt binarny o nazwie _functions_, aby dokÅ‚adniej zbadaÄ‡\nfunkcje. UmieÅ›Ä‡ przykÅ‚ad `another_function` w _src/main.rs_ i uruchom go.\nPpowinien pojawiÄ‡ siÄ™ nastÄ™pujÄ…cy wynik:\n\n```console\n$ cargo run\n   Compiling functions v0.1.0 (file:///projects/functions)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.28s\n     Running `target/debug/functions`\nHello, world!\nInna funkcja.\n```\n\nWiersze wykonujÄ… siÄ™ w kolejnoÅ›ci, w jakiej pojawiajÄ… siÄ™ w funkcji `main`.\nNajpierw wypisuje siÄ™ komunikat â€Witaj, Å›wiecie!â€, a nastÄ™pnie wywoÅ‚ywana jest\n`another_function` i wypisuje siÄ™ jej komunikat.\n\n### Parametry\n\nMoÅ¼emy definiowaÄ‡ funkcje tak, aby miaÅ‚y _parametry_, ktÃ³re sÄ… specjalnymi\nzmiennymi bÄ™dÄ…cymi czÄ™Å›ciÄ… sygnatury funkcji. Gdy funkcja ma parametry, moÅ¼na\npodaÄ‡ jej konkretne wartoÅ›ci dla tych parametrÃ³w. Technicznie, konkretne\nwartoÅ›ci nazywane sÄ… _argumentami_, ale w potocznej rozmowie ludzie majÄ…\nskÅ‚onnoÅ›Ä‡ do uÅ¼ywania sÅ‚Ã³w _parametr_ i _argument_ zamiennie dla zmiennych w\ndefinicji funkcji lub konkretnych wartoÅ›ci przekazywanych podczas wywoÅ‚ywania\nfunkcji.\n\nW tej wersji `another_function` dodajemy parametr:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust\nfn main() {\n    another_function(5);\n}\n\nfn another_function(x: i32) {\n    println!(\"WartoÅ›Ä‡ x to: {x}\");\n}\n```\n\nSprÃ³buj uruchomiÄ‡ ten program; powinieneÅ› uzyskaÄ‡ nastÄ™pujÄ…cy wynik:\n\n```console\n$ cargo run\n   Compiling functions v0.1.0 (file:///projects/functions)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.21s\n     Running `target/debug/functions`\nWartoÅ›Ä‡ x to: 5\n```\n\nDeklaracja `another_function` ma jeden parametr o nazwie `x`. Typ `x` jest\nokreÅ›lony jako `i32`. Kiedy przekazujemy `5` do `another_function`, makro\n`println!` umieszcza `5` tam, gdzie w ciÄ…gu formatujÄ…cym znajdowaÅ‚y siÄ™ nawiasy\nklemrowe zawierajÄ…ce `x`.\n\nW sygnaturach funkcji _musisz_ zadeklarowaÄ‡ typ kaÅ¼dego parametru. Jest to\nÅ›wiadoma decyzja w projekcie Rusta: Wymaganie adnotacji typÃ³w w definicjach\nfunkcji oznacza, Å¼e kompilator prawie nigdy nie potrzebuje, abyÅ› uÅ¼ywaÅ‚ ich\nw innym miejscu w kodzie, aby zrozumieÄ‡, jaki typ masz na myÅ›li. Kompilator\njest rÃ³wnieÅ¼ w stanie dostarczyÄ‡ bardziej pomocne komunikaty o bÅ‚Ä™dach, jeÅ›li\nwie, jakich typÃ³w oczekuje funkcja.\n\nPodczas definiowania wielu parametrÃ³w, oddziel deklaracje parametrÃ³w przecinkami,\nw ten sposÃ³b:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust\nfn main() {\n    print_labeled_measurement(5, 'h');\n}\n\nfn print_labeled_measurement(value: i32, unit_label: char) {\n    println!(\"Pomiar to: {value}{unit_label}\");\n}\n```\n\nTen przykÅ‚ad tworzy funkcjÄ™ o nazwie `print_labeled_measurement` z dwoma\nparametrami. Pierwszy parametr ma nazwÄ™ `value` i jest typu `i32`. Drugi ma\nnazwÄ™ `unit_label` i jest typu `char`. Funkcja nastÄ™pnie wypisuje tekst\nzawierajÄ…cy zarÃ³wno `value`, jak i `unit_label`.\n\nSprÃ³buj uruchomiÄ‡ ten kod. ZastÄ…p program znajdujÄ…cy siÄ™ obecnie w pliku\n_src/main.rs_ projektu _functions_ poprzednim przykÅ‚adem i uruchom go za\npomocÄ… `cargo run`:\n\n```console\n$ cargo run\n   Compiling functions v0.1.0 (file:///projects/functions)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s\n     Running `target/debug/functions`\nPomiar to: 5h\n```\n\nPoniewaÅ¼ wywoÅ‚aliÅ›my funkcjÄ™ z `5` jako wartoÅ›ciÄ… dla `value` i `'h'` jako\nwartoÅ›ciÄ… dla `unit_label`, wyjÅ›cie programu zawiera te wartoÅ›ci.\n\n### Instrukcje i wyraÅ¼enia\n\nCiaÅ‚a funkcji skÅ‚adajÄ… siÄ™ z serii instrukcji, opcjonalnie zakoÅ„czonych\nwyraÅ¼eniem. Do tej pory omÃ³wione przez nas funkcje nie zawieraÅ‚y koÅ„cowego\nwyraÅ¼enia, ale widziaÅ‚eÅ› wyraÅ¼enie jako czÄ™Å›Ä‡ instrukcji. PoniewaÅ¼ Rust jest\njÄ™zykiem opartym na wyraÅ¼eniach, jest to waÅ¼ne rozrÃ³Å¼nienie do zrozumienia.\nInne jÄ™zyki nie majÄ… tych samych rozrÃ³Å¼nieÅ„, wiÄ™c przyjrzyjmy siÄ™, czym sÄ…\ninstrukcje i wyraÅ¼enia oraz jak ich rÃ³Å¼nice wpÅ‚ywajÄ… na ciaÅ‚a funkcji.\n\n- _Instrukcje_ to polecenia, ktÃ³re wykonujÄ… jakÄ…Å› akcjÄ™ i nie zwracajÄ…\n  wartoÅ›ci.\n- _WyraÅ¼enia_ obliczajÄ… siÄ™ do wartoÅ›ci wynikowej.\n\nPrzyjrzyjmy siÄ™ kilku przykÅ‚adom.\n\nW rzeczywistoÅ›ci juÅ¼ uÅ¼ywaliÅ›my instrukcji i wyraÅ¼eÅ„. Tworzenie zmiennej i\nprzypisywanie jej wartoÅ›ci za pomocÄ… sÅ‚owa kluczowego `let` jest instrukcjÄ….\nW Listingu 3-1, `let y = 6;` to instrukcja.\n\n<Listing number=\"3-1\" file-name=\"src/main.rs\" caption=\"Deklaracja funkcji `main` zawierajÄ…ca jednÄ… instrukcjÄ™\">\n\n```rust\nfn main() {\n    let y = 6;\n}\n```\n\n</Listing>\n\nDefinicje funkcji to rÃ³wnieÅ¼ instrukcje; caÅ‚y poprzedni przykÅ‚ad sam w sobie\njest instrukcjÄ…. (Jak wkrÃ³tce zobaczymy, wywoÅ‚ywanie funkcji nie jest\ninstrukcjÄ….)\n\nInstrukcje nie zwracajÄ… wartoÅ›ci. Dlatego nie moÅ¼esz przypisaÄ‡ instrukcji\n`let` do innej zmiennej, tak jak prÃ³buje to zrobiÄ‡ poniÅ¼szy kod; otrzymasz bÅ‚Ä…d:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust,ignore,does_not_compile\nfn main() {\n    let x = (let y = 6);\n}\n```\n\nPo uruchomieniu tego programu otrzymasz nastÄ™pujÄ…cy bÅ‚Ä…d:\n\n```console\n$ cargo run\n   Compiling functions v0.1.0 (file:///projects/functions)\nerror: expected expression, found `let` statement\n --> src/main.rs:2:14\n  |\n2 |     let x = (let y = 6);\n  |              ^^^\n  |\n  = note: only supported directly in conditions of `if` and `while` expressions\n\nwarning: unnecessary parentheses around assigned value\n --> src/main.rs:2:13\n  |\n2 |     let x = (let y = 6);\n  |             ^         ^\n  |\n  = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n  |\n2 -     let x = (let y = 6);\n2 +     let x = let y = 6;\n  |\n\nwarning: `functions` (bin \"functions\") generated 1 warning\nerror: could not compile `functions` (bin \"functions\") due to 1 previous error; 1 warning emitted\n```\n\nInstrukcja `let y = 6` nie zwraca wartoÅ›ci, wiÄ™c nie ma nic, do czego `x`\nmogÅ‚oby siÄ™ zwiÄ…zaÄ‡. RÃ³Å¼ni siÄ™ to od tego, co dzieje siÄ™ w innych jÄ™zykach,\ntakich jak C i Ruby, gdzie przypisanie zwraca wartoÅ›Ä‡ przypisania. W tych\njÄ™zykach moÅ¼na napisaÄ‡ `x = y = 6` i sprawiÄ‡, Å¼e zarÃ³wno `x`, jak i `y` bÄ™dÄ…\nmiaÅ‚y wartoÅ›Ä‡ `6`; tak nie jest w RuÅ›cie.\n\nWyraÅ¼enia obliczajÄ… siÄ™ do wartoÅ›ci i stanowiÄ… wiÄ™kszoÅ›Ä‡ pozostaÅ‚ego kodu,\nktÃ³ry bÄ™dziesz pisaÄ‡ w RuÅ›cie. RozwaÅ¼ operacjÄ™ matematycznÄ…, takÄ… jak `5 + 6`,\nktÃ³ra jest wyraÅ¼eniem, ktÃ³re oblicza siÄ™ do wartoÅ›ci `11`. WyraÅ¼enia mogÄ… byÄ‡\nczÄ™Å›ciÄ… instrukcji: W Listingu 3-1, `6` w instrukcji `let y = 6;` jest\nwyraÅ¼eniem, ktÃ³re oblicza siÄ™ do wartoÅ›ci `6`. WywoÅ‚ywanie funkcji jest\nwyraÅ¼eniem. WywoÅ‚ywanie makra jest wyraÅ¼eniem. Nowy blok zasiÄ™gu utworzony za\npomocÄ… nawiasÃ³w klamrowych jest wyraÅ¼eniem, na przykÅ‚ad:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust\nfn main() {\n    let y = {\n        let x = 3;\n        x + 1\n    };\n\n    println!(\"WartoÅ›Ä‡ y to: {y}\");\n}\n```\n\nTo wyraÅ¼enie:\n\n```rust,ignore\n{\n    let x = 3;\n    x + 1\n}\n```\n\njest blokiem, ktÃ³ry w tym przypadku oblicza siÄ™ do `4`. Ta wartoÅ›Ä‡ zostaje\nzwiÄ…zana z `y` jako czÄ™Å›Ä‡ instrukcji `let`. ZauwaÅ¼ wiersz `x + 1` bez Å›rednika\nna koÅ„cu, co rÃ³Å¼ni siÄ™ od wiÄ™kszoÅ›ci dotychczas widzianych wierszy. WyraÅ¼enia\nnie zawierajÄ… koÅ„cowych Å›rednikÃ³w. JeÅ›li dodasz Å›rednik na koÅ„cu wyraÅ¼enia,\nzmienisz je w instrukcjÄ™, a wtedy nie zwrÃ³ci ono wartoÅ›ci. Miej to na uwadze,\ngdy bÄ™dziesz dalej poznawaÄ‡ wartoÅ›ci zwracane przez funkcje i wyraÅ¼enia.\n\n### Funkcje zwracajÄ…ce wartoÅ›ci\n\nFunkcje mogÄ… zwracaÄ‡ wartoÅ›ci do wywoÅ‚ujÄ…cego je kodu. Nie nazywamy wartoÅ›ci\nzwracanych, ale musimy zadeklarowaÄ‡ ich typ po strzaÅ‚ce (`->`). W RuÅ›cie,\nwartoÅ›Ä‡ zwracana przez funkcjÄ™ jest synonimem wartoÅ›ci ostatniego wyraÅ¼enia w\nbloku ciaÅ‚a funkcji. MoÅ¼esz zwrÃ³ciÄ‡ wartoÅ›Ä‡ wczeÅ›niej z funkcji, uÅ¼ywajÄ…c\nsÅ‚owa kluczowego `return` i okreÅ›lajÄ…c wartoÅ›Ä‡, ale wiÄ™kszoÅ›Ä‡ funkcji zwraca\nostatnie wyraÅ¼enie niejawnie. Oto przykÅ‚ad funkcji, ktÃ³ra zwraca wartoÅ›Ä‡:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust\nfn five() -> i32 {\n    5\n}\n\nfn main() {\n    let x = five();\n\n    println!(\"WartoÅ›Ä‡ x to: {x}\");\n}\n```\n\nNie ma wywoÅ‚aÅ„ funkcji, makr, ani nawet instrukcji `let` w funkcji `five` â€”\ntylko sama liczba `5`. To jest caÅ‚kowicie poprawna funkcja w RuÅ›cie.\nZauwaÅ¼, Å¼e typ zwracany funkcji jest rÃ³wnieÅ¼ okreÅ›lony jako `-> i32`.\nSprÃ³buj uruchomiÄ‡ ten kod; wyjÅ›cie powinno wyglÄ…daÄ‡ tak:\n\n```console\n$ cargo run\n   Compiling functions v0.1.0 (file:///projects/functions)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s\n     Running `target/debug/functions`\nWartoÅ›Ä‡ x to: 5\n```\n\n`5` w `five` jest wartoÅ›ciÄ… zwracanÄ… przez funkcjÄ™, dlatego typ zwracany to\n`i32`. Zbadajmy to bardziej szczegÃ³Å‚owo. SÄ… tu dwa waÅ¼ne aspekty:\nPo pierwsze, wiersz `let x = five();` pokazuje, Å¼e uÅ¼ywamy wartoÅ›ci\nzwracanej przez funkcjÄ™ do inicjalizacji zmiennej. PoniewaÅ¼ funkcja `five`\nzwraca `5`, ten wiersz jest rÃ³wnowaÅ¼ny z nastÄ™pujÄ…cym:\n\n```rust\nlet x = 5;\n```\n\nPo drugie, funkcja `five` nie ma parametrÃ³w i definiuje typ wartoÅ›ci\nzwracanej, ale ciaÅ‚o funkcji to samotne `5` bez Å›rednika, poniewaÅ¼ jest to\nwyraÅ¼enie, ktÃ³rego wartoÅ›Ä‡ chcemy zwrÃ³ciÄ‡.\n\nPrzyjrzyjmy siÄ™ innemu przykÅ‚adowi:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust\nfn main() {\n    let x = plus_one(5);\n\n    println!(\"WartoÅ›Ä‡ x to: {x}\");\n}\n\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n```\n\nUruchomienie tego kodu wypisze `WartoÅ›Ä‡ x to: 6`. Ale co siÄ™ stanie, jeÅ›li\numieÅ›cimy Å›rednik na koÅ„cu wiersza zawierajÄ…cego `x + 1`, zmieniajÄ…c go z\nwyraÅ¼enia w instrukcjÄ™?\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust,ignore,does_not_compile\nfn main() {\n    let x = plus_one(5);\n\n    println!(\"WartoÅ›Ä‡ x to: {x}\");\n}\n\nfn plus_one(x: i32) -> i32 {\n    x + 1;\n}\n```\n\nSkompilowanie tego kodu spowoduje bÅ‚Ä…d, jak nastÄ™puje:\n\n```console\n$ cargo run\n   Compiling functions v0.1.0 (file:///projects/functions)\nerror[E0308]: mismatched types\n --> src/main.rs:7:24\n  |\n7 | fn plus_one(x: i32) -> i32 {\n  |    --------            ^^^ expected `i32`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n8 |     x + 1;\n  |          - help: remove this semicolon to return this value\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `functions` (bin \"functions\") due to 1 previous error\n```\n\nGÅ‚Ã³wny komunikat o bÅ‚Ä™dzie, `mismatched types` (niezgodne typy), ujawnia\nsedno problemu z tym kodem. Definicja funkcji `plus_one` mÃ³wi, Å¼e zwrÃ³ci `i32`,\nale instrukcje nie obliczajÄ… siÄ™ do wartoÅ›ci, co jest wyraÅ¼one przez `()`,\ntyp jednostkowy. Dlatego nic nie jest zwracane, co jest sprzeczne z definicjÄ…\nfunkcji i skutkuje bÅ‚Ä™dem. W tym wyjÅ›ciu Rust dostarcza komunikat, ktÃ³ry byÄ‡\nmoÅ¼e pomoÅ¼e rozwiÄ…zaÄ‡ ten problem: sugeruje usuniÄ™cie Å›rednika, co naprawiÅ‚oby\nbÅ‚Ä…d.\n",
        "chapter_title": "Funkcje"
    },
    {
        "file_path": "ch03-04-comments.md",
        "content": "## Komentarze\n\nWszyscy programiÅ›ci dÄ…Å¼Ä… do tego, aby ich kod byÅ‚ Å‚atwy do zrozumienia, ale\nczasami wymagane jest dodatkowe wyjaÅ›nienie. W takich przypadkach programiÅ›ci\npozostawiajÄ… _komentarze_ w swoim kodzie ÅºrÃ³dÅ‚owym, ktÃ³re kompilator zignoruje,\nale ktÃ³re osoby czytajÄ…ce kod ÅºrÃ³dÅ‚owy mogÄ… uznaÄ‡ za przydatne.\n\nOto prosty komentarz:\n\n```rust\n// witaj, Å›wiecie\n```\n\nW RuÅ›cie idiomatyczny styl komentarzy rozpoczyna komentarz dwoma ukoÅ›nikami,\na komentarz trwa do koÅ„ca linii. W przypadku komentarzy, ktÃ³re rozciÄ…gajÄ… siÄ™\npoza jednÄ… liniÄ™, naleÅ¼y umieÅ›ciÄ‡ `//` na kaÅ¼dej linii, w ten sposÃ³b:\n\n```rust\n// WiÄ™c robimy tutaj coÅ› skomplikowanego, na tyle dÅ‚ugiego, Å¼e potrzebujemy\n// wielu linii komentarzy, Å¼eby to zrobiÄ‡! Uff! Mamy nadziejÄ™, Å¼e ten komentarz\n// wyjaÅ›ni, co siÄ™ dzieje.\n```\n\nKomentarze mogÄ… byÄ‡ rÃ³wnieÅ¼ umieszczane na koÅ„cu wierszy zawierajÄ…cych kod:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust\nfn main() {\n    let lucky_number = 7; // CzujÄ™ siÄ™ dzisiaj szczÄ™Å›ciarzem\n}\n```\n\nAle czÄ™Å›ciej zobaczysz je uÅ¼ywane w tym formacie, z komentarzem w osobnej linii\npowyÅ¼ej kodu, ktÃ³ry opisuje:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust\nfn main() {\n    // CzujÄ™ siÄ™ dzisiaj szczÄ™Å›ciarzem\n    let lucky_number = 7;\n}\n```\n\nRust ma rÃ³wnieÅ¼ inny rodzaj komentarzy, komentarze dokumentacyjne, ktÃ³re omÃ³wimy\nw [sekcji â€Publikowanie skrzynki na Crates.ioâ€][publishing]<!-- ignore -->\nw Rozdziale 14.\n\n[publishing]: ch14-02-publishing-to-crates-io.html\n",
        "chapter_title": "Komentarze"
    },
    {
        "file_path": "ch03-05-control-flow.md",
        "content": "## PrzepÅ‚yw sterowania\n\nMoÅ¼liwoÅ›Ä‡ uruchomienia czÄ™Å›ci kodu w zaleÅ¼noÅ›ci od tego, czy warunek jest\n`true`, oraz moÅ¼liwoÅ›Ä‡ wielokrotnego uruchamiania czÄ™Å›ci kodu, dopÃ³ki warunek\njest `true`, to podstawowe bloki konstrukcyjne w wiÄ™kszoÅ›ci jÄ™zykÃ³w\nprogramowania. NajczÄ™stsze konstrukcje, ktÃ³re pozwalajÄ… kontrolowaÄ‡ przepÅ‚yw\nwykonania kodu Rusta, to wyraÅ¼enia `if` i pÄ™tle.\n\n### WyraÅ¼enia `if`\n\nWyraÅ¼enie `if` pozwala rozgaÅ‚Ä™ziaÄ‡ kod w zaleÅ¼noÅ›ci od warunkÃ³w. Podajesz\nwarunek, a nastÄ™pnie stwierdzasz: â€JeÅ›li ten warunek jest speÅ‚niony, uruchom\nten blok kodu. JeÅ›li warunek nie jest speÅ‚niony, nie uruchamiaj tego bloku\nkodu.â€\n\nUtwÃ³rz nowy projekt o nazwie _branches_ w katalogu _projects_, aby zbadaÄ‡\nwyraÅ¼enie `if`. W pliku _src/main.rs_ wprowadÅº nastÄ™pujÄ…cy kod:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust\nfn main() {\n    let number = 3;\n\n    if number < 5 {\n        println!(\"warunek byÅ‚ prawdziwy\");\n    } else {\n        println!(\"warunek byÅ‚ faÅ‚szywy\");\n    }\n}\n```\n\nWszystkie wyraÅ¼enia `if` zaczynajÄ… siÄ™ od sÅ‚owa kluczowego `if`, po ktÃ³rym\nnastÄ™puje warunek. W tym przypadku warunek sprawdza, czy zmienna `number` ma\nwartoÅ›Ä‡ mniejszÄ… niÅ¼ 5. Blok kodu do wykonania, jeÅ›li warunek jest `true`,\numieszczamy bezpoÅ›rednio po warunku w nawiasach klamrowych. Bloki kodu\npowiÄ…zane z warunkami w wyraÅ¼eniach `if` sÄ… czasami nazywane _ramionami_,\npodobnie jak ramiona w wyraÅ¼eniach `match`, ktÃ³re omÃ³wiliÅ›my w sekcji\n[â€PorÃ³wnywanie zgadywanej liczby z tajnÄ…\nliczbÄ…â€][comparing-the-guess-to-the-secret-number]<!-- ignore --> w\nRozdziale 2.\n\nOpcjonalnie moÅ¼emy rÃ³wnieÅ¼ doÅ‚Ä…czyÄ‡ wyraÅ¼enie `else`, co tutaj zrobiliÅ›my, aby\npodaÄ‡ programowi alternatywny blok kodu do wykonania, jeÅ›li warunek oceni siÄ™\nna `false`. JeÅ›li nie podasz wyraÅ¼enia `else`, a warunek jest `false`,\nprogram po prostu pominie blok `if` i przejdzie do nastÄ™pnej czÄ™Å›ci kodu.\n\nSprÃ³buj uruchomiÄ‡ ten kod; powinieneÅ› zobaczyÄ‡ nastÄ™pujÄ…cy wynik:\n\n```console\n$ cargo run\n   Compiling branches v0.1.0 (file:///projects/branches)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s\n     Running `target/debug/branches`\nwarunek byÅ‚ prawdziwy\n```\n\nSprÃ³bujmy zmieniÄ‡ wartoÅ›Ä‡ `number` na takÄ…, ktÃ³ra sprawi, Å¼e warunek bÄ™dzie\n`false`, aby zobaczyÄ‡, co siÄ™ stanie:\n\n```rust,ignore\n# fn main() {\n    let number = 7;\n# \n#     if number < 5 {\n#         println!(\"condition was true\");\n#     } else {\n#         println!(\"condition was false\");\n#     }\n# }\n```\n\nUruchom program ponownie i spÃ³jrz na wynik:\n\n```console\n$ cargo run\n   Compiling branches v0.1.0 (file:///projects/branches)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s\n     Running `target/debug/branches`\nwarunek byÅ‚ faÅ‚szywy\n```\n\nWarto rÃ³wnieÅ¼ zauwaÅ¼yÄ‡, Å¼e warunek w tym kodzie _musi_ byÄ‡ typu `bool`.\nJeÅ›li warunek nie jest typu `bool`, otrzymamy bÅ‚Ä…d. Na przykÅ‚ad, sprÃ³buj\nuruchomiÄ‡ nastÄ™pujÄ…cy kod:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust,ignore,does_not_compile\nfn main() {\n    let number = 3;\n\n    if number {\n        println!(\"number was three\");\n    }\n}\n```\n\nWarunek `if` tym razem oblicza siÄ™ do wartoÅ›ci `3`, a Rust zwraca bÅ‚Ä…d:\n\n```console\n$ cargo run\n   Compiling branches v0.1.0 (file:///projects/branches)\nerror[E0308]: mismatched types\n --> src/main.rs:4:8\n  |\n4 |     if number {\n  |        ^^^^^^ expected `bool`, found integer\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `branches` (bin \"branches\") due to 1 previous error\n```\n\nBÅ‚Ä…d wskazuje, Å¼e Rust oczekiwaÅ‚ `bool`, ale otrzymaÅ‚ liczbÄ™ caÅ‚kowitÄ….\nW przeciwieÅ„stwie do jÄ™zykÃ³w takich jak Ruby i JavaScript, Rust nie bÄ™dzie\nautomatycznie prÃ³bowaÅ‚ konwertowaÄ‡ typÃ³w niebÄ™dÄ…cych `bool` na `bool`.\nMusisz byÄ‡ jawny i zawsze dostarczaÄ‡ `if` z wartoÅ›ciÄ… `bool` jako warunkiem.\nJeÅ›li chcemy, aby blok kodu `if` byÅ‚ uruchamiany tylko wtedy, gdy liczba nie\njest rÃ³wna `0`, na przykÅ‚ad, moÅ¼emy zmieniÄ‡ wyraÅ¼enie `if` na nastÄ™pujÄ…ce:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust\nfn main() {\n    let number = 3;\n\n    if number != 0 {\n        println!(\"number byÅ‚o czymÅ› innym niÅ¼ zero\");\n    }\n}\n```\n\nUruchomienie tego kodu wypisze `number byÅ‚o czymÅ› innym niÅ¼ zero`.\n\n#### ObsÅ‚uga wielu warunkÃ³w za pomocÄ… `else if`\n\nMoÅ¼esz uÅ¼yÄ‡ wielu warunkÃ³w, Å‚Ä…czÄ…c `if` i `else` w wyraÅ¼eniu `else if`.\nNa przykÅ‚ad:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust\nfn main() {\n    let number = 6;\n\n    if number % 4 == 0 {\n        println!(\"liczba jest podzielna przez 4\");\n    } else if number % 3 == 0 {\n        println!(\"liczba jest podzielna przez 3\");\n    } else if number % 2 == 0 {\n        println!(\"liczba jest podzielna przez 2\");\n    } else {\n        println!(\"liczba nie jest podzielna przez 4, 3 ani 2\");\n    }\n}\n```\n\nTen program moÅ¼e podÄ…Å¼yÄ‡ czterema moÅ¼liwymi Å›cieÅ¼kami. Po jego uruchomieniu\npowinieneÅ› zobaczyÄ‡ nastÄ™pujÄ…cy wynik:\n\n```console\n$ cargo run\n   Compiling branches v0.1.0 (file:///projects/branches)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s\n     Running `target/debug/branches`\nliczba jest podzielna przez 3\n```\n\nKiedy ten program siÄ™ wykonuje, sprawdza kolejno kaÅ¼de wyraÅ¼enie `if` i\nwykonuje pierwszy blok, dla ktÃ³rego warunek ocenia siÄ™ na `true`. ZauwaÅ¼, Å¼e\nmimo Å¼e 6 jest podzielne przez 2, nie widzimy wyjÅ›cia `liczba jest podzielna\nprzez 2`, ani tekstu `liczba nie jest podzielna przez 4, 3 ani 2` z bloku\n`else`. Dzieje siÄ™ tak, poniewaÅ¼ Rust wykonuje blok tylko dla pierwszego\nwarunku `true`, a gdy tylko znajdzie taki, nie sprawdza juÅ¼ reszty.\n\nZbyt wiele wyraÅ¼eÅ„ `else if` moÅ¼e zaÅ›miecaÄ‡ kod, wiÄ™c jeÅ›li masz ich wiÄ™cej niÅ¼\njeden, moÅ¼esz chcieÄ‡ refaktoryzowaÄ‡ swÃ³j kod. RozdziaÅ‚ 6 opisuje potÄ™Å¼nÄ…\nkonstrukcjÄ™ rozgaÅ‚Ä™ziajÄ…cÄ… Rusta o nazwie `match` dla takich przypadkÃ³w.\n\n#### UÅ¼ywanie `if` w instrukcji `let`\n\nPoniewaÅ¼ `if` jest wyraÅ¼eniem, moÅ¼emy go uÅ¼yÄ‡ po prawej stronie instrukcji\n`let`, aby przypisaÄ‡ wynik do zmiennej, jak w Listingu 3-2.\n\n<Listing number=\"3-2\" file-name=\"src/main.rs\" caption=\"Przypisywanie wyniku wyraÅ¼enia `if` do zmiennej\">\n\n```rust\nfn main() {\n    let condition = true;\n    let number = if condition { 5 } else { 6 };\n\n    println!(\"WartoÅ›Ä‡ liczby to: {number}\");\n}\n```\n\n</Listing>\n\nZmienna `number` zostanie zwiÄ…zana z wartoÅ›ciÄ… na podstawie wyniku wyraÅ¼enia\n`if`. Uruchom ten kod, aby zobaczyÄ‡, co siÄ™ stanie:\n\n```console\n$ cargo run\n   Compiling branches v0.1.0 (file:///projects/branches)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s\n     Running `target/debug/branches`\nWartoÅ›Ä‡ liczby to: 5\n```\n\nPamiÄ™taj, Å¼e bloki kodu oceniajÄ… siÄ™ do ostatniego w nich wyraÅ¼enia, a same\nliczby sÄ… rÃ³wnieÅ¼ wyraÅ¼eniami. W tym przypadku wartoÅ›Ä‡ caÅ‚ego wyraÅ¼enia `if`\nzaleÅ¼y od tego, ktÃ³ry blok kodu zostanie wykonany. Oznacza to, Å¼e wartoÅ›ci,\nktÃ³re potencjalnie mogÄ… byÄ‡ wynikami z kaÅ¼dego ramienia `if`, muszÄ… byÄ‡ tego\nsamego typu; w Listingu 3-2 wyniki zarÃ³wno ramienia `if`, jak i ramienia\n`else` byÅ‚y liczbami caÅ‚kowitymi `i32`. JeÅ›li typy nie pasujÄ… do siebie, jak w\nnastÄ™pujÄ…cym przykÅ‚adzie, otrzymamy bÅ‚Ä…d:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust,ignore,does_not_compile\nfn main() {\n    let condition = true;\n\n    let number = if condition { 5 } else { \"szeÅ›Ä‡\" };\n\n    println!(\"WartoÅ›Ä‡ liczby to: {number}\");\n}\n```\n\nKiedy sprÃ³bujemy skompilowaÄ‡ ten kod, otrzymamy bÅ‚Ä…d. Ramiona `if` i `else`\nmajÄ… niezgodne typy wartoÅ›ci, a Rust dokÅ‚adnie wskazuje, gdzie znaleÅºÄ‡ problem\nw programie:\n\n```console\n$ cargo run\n   Compiling branches v0.1.0 (file:///projects/branches)\nerror[E0308]: `if` and `else` have incompatible types\n --> src/main.rs:4:44\n  |\n4 |     let number = if condition { 5 } else { \"six\" };\n  |                                 -          ^^^^^ expected integer, found `&str`\n  |                                 |\n  |                                 expected because of this\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `branches` (bin \"branches\") due to 1 previous error\n```\n\nWyraÅ¼enie w bloku `if` oblicza siÄ™ do liczby caÅ‚kowitej, a wyraÅ¼enie w bloku\n`else` oblicza siÄ™ do ciÄ…gu znakÃ³w. To nie zadziaÅ‚a, poniewaÅ¼ zmienne muszÄ…\nmieÄ‡ pojedynczy typ, a Rust musi wiedzieÄ‡ jednoznacznie w czasie kompilacji,\njakiego typu jest zmienna `number`. ZnajomoÅ›Ä‡ typu `number` pozwala\nkompilatorowi sprawdziÄ‡, czy typ jest prawidÅ‚owy wszÄ™dzie tam, gdzie uÅ¼ywamy\n`number`. Rust nie byÅ‚by w stanie tego zrobiÄ‡, gdyby typ `number` byÅ‚\nokreÅ›lany tylko w czasie dziaÅ‚ania; kompilator byÅ‚by bardziej zÅ‚oÅ¼ony i dawaÅ‚by\nmniej gwarancji co do kodu, gdyby musiaÅ‚ Å›ledziÄ‡ wiele hipotetycznych typÃ³w\ndla dowolnej zmiennej.\n\n### Powtarzanie z pÄ™tlami\n\nCzÄ™sto przydatne jest wielokrotne wykonanie bloku kodu. Do tego zadania Rust\nudostÄ™pnia kilka _pÄ™tli_, ktÃ³re bÄ™dÄ… wykonywaÄ‡ kod wewnÄ…trz ciaÅ‚a pÄ™tli do\nkoÅ„ca, a nastÄ™pnie natychmiast wrÃ³cÄ… na poczÄ…tek. Aby poeksperymentowaÄ‡ z\npÄ™tlami, utwÃ³rzmy nowy projekt o nazwie _loops_.\n\nRust ma trzy rodzaje pÄ™tli: `loop`, `while` i `for`. SprÃ³bujmy kaÅ¼dej z nich.\n\n#### Powtarzanie kodu za pomocÄ… `loop`\n\nSÅ‚owo kluczowe `loop` mÃ³wi Rustowi, aby wykonywaÅ‚ blok kodu w kÃ³Å‚ko, albo w\nnieskoÅ„czonoÅ›Ä‡, albo dopÃ³ki jawnie nie powiesz mu, aby siÄ™ zatrzymaÅ‚.\n\nJako przykÅ‚ad, zmieÅ„ plik _src/main.rs_ w katalogu _loops_ tak, aby wyglÄ…daÅ‚\ntak:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust,ignore\nfn main() {\n    loop {\n        println!(\"znowu!\");\n    }\n}\n```\n\nKiedy uruchomimy ten program, bÄ™dziemy widzieÄ‡ `znowu!` wypisywane w kÃ³Å‚ko\nnieprzerwanie, dopÃ³ki nie zatrzymamy programu rÄ™cznie. WiÄ™kszoÅ›Ä‡ terminali\nobsÅ‚uguje skrÃ³t klawiaturowy <kbd>ctrl</kbd>-<kbd>C</kbd> do przerwania\nprogramu, ktÃ³ry utknÄ…Å‚ w nieustannej pÄ™tli. SprÃ³buj:\n\n<!-- manual-regeneration\ncd listings/ch03-common-programming-concepts/no-listing-32-loop\ncargo run\nCTRL-C\n-->\n\n```console\n$ cargo run\n   Compiling loops v0.1.0 (file:///projects/loops)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s\n     Running `target/debug/loops`\nznowu!\nznowu!\nznowu!\nznowu!\n^Cznowu!\n```\n\nSymbol `^C` reprezentuje miejsce, w ktÃ³rym naciÅ›nÄ…Å‚eÅ› <kbd>ctrl</kbd>-<kbd>C</kbd>.\n\nMoÅ¼esz, ale nie musisz, zobaczyÄ‡ sÅ‚owo `znowu!` wypisane po `^C`, w zaleÅ¼noÅ›ci\nod tego, w ktÃ³rym miejscu pÄ™tli znajdowaÅ‚ siÄ™ kod, gdy otrzymaÅ‚ sygnaÅ‚\nprzerwania.\n\nNa szczÄ™Å›cie Rust udostÄ™pnia rÃ³wnieÅ¼ sposÃ³b na wyjÅ›cie z pÄ™tli za pomocÄ… kodu.\nMoÅ¼esz umieÅ›ciÄ‡ sÅ‚owo kluczowe `break` w pÄ™tli, aby powiedzieÄ‡ programowi,\nkiedy ma zakoÅ„czyÄ‡ wykonywanie pÄ™tli. Przypomnij sobie, Å¼e zrobiliÅ›my to w\ngrze w zgadywanie w [sekcji â€ZakoÅ„czenie po poprawnym\nodgadniÄ™ciuâ€][quitting-after-a-correct-guess]<!-- ignore --> w Rozdziale 2,\naby zakoÅ„czyÄ‡ program, gdy uÅ¼ytkownik wygraÅ‚ grÄ™, zgadujÄ…c poprawnÄ… liczbÄ™.\n\nUÅ¼ywaliÅ›my rÃ³wnieÅ¼ `continue` w grze w zgadywanie, co w pÄ™tli mÃ³wi programowi,\naby pominÄ…Å‚ pozostaÅ‚y kod w tej iteracji pÄ™tli i przeszedÅ‚ do nastÄ™pnej\niteracji.\n\n#### Zwracanie wartoÅ›ci z pÄ™tli\n\nJednym z zastosowaÅ„ pÄ™tli `loop` jest ponowne wykonanie operacji, o ktÃ³rej wiesz,\nÅ¼e moÅ¼e siÄ™ nie powieÅ›Ä‡, na przykÅ‚ad sprawdzenie, czy wÄ…tek zakoÅ„czyÅ‚ swoje\nzadanie. MoÅ¼e byÄ‡ rÃ³wnieÅ¼ konieczne przekazanie wyniku tej operacji poza pÄ™tlÄ™\ndo reszty kodu. Aby to zrobiÄ‡, moÅ¼esz dodaÄ‡ wartoÅ›Ä‡, ktÃ³rÄ… chcesz zwrÃ³ciÄ‡, po\nwyraÅ¼eniu `break`, ktÃ³rego uÅ¼ywasz do zatrzymania pÄ™tli; ta wartoÅ›Ä‡ zostanie\nzwrÃ³cona z pÄ™tli, abyÅ› mÃ³gÅ‚ jej uÅ¼yÄ‡, jak pokazano tutaj:\n\n```rust\nfn main() {\n    let mut counter = 0;\n\n    let result = loop {\n        counter += 1;\n\n        if counter == 10 {\n            break counter * 2;\n        }\n    };\n\n    println!(\"Wynik to {result}\");\n}\n```\n\nPrzed pÄ™tlÄ… deklarujemy zmiennÄ… `counter` i inicjalizujemy jÄ… na `0`.\nNastÄ™pnie deklarujemy zmiennÄ… `result`, aby przechowywaÅ‚a wartoÅ›Ä‡ zwrÃ³conÄ… z\npÄ™tli. W kaÅ¼dej iteracji pÄ™tli dodajemy `1` do zmiennej `counter`, a nastÄ™pnie\nsprawdzamy, czy `counter` jest rÃ³wne `10`. Gdy tak jest, uÅ¼ywamy sÅ‚owa\nkluczowego `break` z wartoÅ›ciÄ… `counter * 2`. Po pÄ™tli uÅ¼ywamy Å›rednika,\naby zakoÅ„czyÄ‡ instrukcjÄ™, ktÃ³ra przypisuje wartoÅ›Ä‡ do `result`. Na koniec\nwypisujemy wartoÅ›Ä‡ w `result`, ktÃ³ra w tym przypadku wynosi `20`.\n\nMoÅ¼esz rÃ³wnieÅ¼ `return` z wnÄ™trza pÄ™tli. Podczas gdy `break` tylko wychodzi z\nbieÅ¼Ä…cej pÄ™tli, `return` zawsze wychodzi z bieÅ¼Ä…cej funkcji.\n\n<!-- Old headings. Do not remove or links may break. -->\n<a id=\"loop-labels-to-disambiguate-between-multiple-loops\"></a>\n\n#### RozrÃ³Å¼nianie wielu pÄ™tli za pomocÄ… etykiet pÄ™tli\n\nJeÅ›li masz pÄ™tle zagnieÅ¼dÅ¼one w innych pÄ™tlach, `break` i `continue` dotyczÄ…\naktualnie najbardziej wewnÄ™trznej pÄ™tli. MoÅ¼esz opcjonalnie okreÅ›liÄ‡ _etykietÄ™\npÄ™tli_ dla pÄ™tli, ktÃ³rÄ… nastÄ™pnie moÅ¼esz uÅ¼yÄ‡ z `break` lub `continue`, aby\nokreÅ›liÄ‡, Å¼e te sÅ‚owa kluczowe dotyczÄ… oznaczonej pÄ™tli, a nie najbardziej\nwewnÄ™trznej. Etykiety pÄ™tli muszÄ… zaczynaÄ‡ siÄ™ od pojedynczego cudzysÅ‚owu.\nOto przykÅ‚ad z dwoma zagnieÅ¼dÅ¼onymi pÄ™tlami:\n\n```rust\nfn main() {\n    let mut count = 0;\n    'counting_up: loop {\n        println!(\"licznik = {count}\");\n        let mut remaining = 10;\n\n        loop {\n            println!(\"pozostaÅ‚o = {remaining}\");\n            if remaining == 9 {\n                break;\n            }\n            if count == 2 {\n                break 'counting_up;\n            }\n            remaining -= 1;\n        }\n\n        count += 1;\n    }\n    println!(\"KoÅ„cowy licznik = {count}\");\n}\n```\n\nZewnÄ™trzna pÄ™tla ma etykietÄ™ `'counting_up` i bÄ™dzie liczyÄ‡ od 0 do 2.\nWewnÄ™trzna pÄ™tla bez etykiety liczy od 10 do 9. Pierwszy `break`, ktÃ³ry nie\nokreÅ›la etykiety, zakoÅ„czy tylko wewnÄ™trznÄ… pÄ™tlÄ™. Instrukcja `break\n'counting_up;` zakoÅ„czy zewnÄ™trznÄ… pÄ™tlÄ™. Ten kod wypisuje:\n\n```console\n$ cargo run\n   Compiling loops v0.1.0 (file:///projects/loops)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.58s\n     Running `target/debug/loops`\nlicznik = 0\npozostaÅ‚o = 10\npozostaÅ‚o = 9\nlicznik = 1\npozostaÅ‚o = 10\npozostaÅ‚o = 9\nlicznik = 2\npozostaÅ‚o = 10\nKoÅ„cowy licznik = 2\n```\n\n<!-- Old headings. Do not remove or links may break. -->\n<a id=\"conditional-loops-with-while\"></a>\n\n#### Upraszczanie pÄ™tli warunkowych za pomocÄ… `while`\n\nProgram czÄ™sto musi oceniaÄ‡ warunek wewnÄ…trz pÄ™tli. DopÃ³ki warunek jest `true`,\npÄ™tla dziaÅ‚a. Gdy warunek przestaje byÄ‡ `true`, program wywoÅ‚uje `break`,\nzatrzymujÄ…c pÄ™tlÄ™. MoÅ¼liwe jest zaimplementowanie takiego zachowania za pomocÄ…\npoÅ‚Ä…czenia `loop`, `if`, `else` i `break`; moÅ¼esz sprÃ³bowaÄ‡ tego teraz w\nprogramie, jeÅ›li chcesz. Jednak ten wzorzec jest tak powszechny, Å¼e Rust ma\nwbudowanÄ… konstrukcjÄ™ jÄ™zykowÄ… dla niego, zwanÄ… pÄ™tlÄ… `while`. W Listingu 3-3\nuÅ¼ywamy `while`, aby zapÄ™tliÄ‡ program trzy razy, odliczajÄ…c za kaÅ¼dym razem,\na nastÄ™pnie, po pÄ™tli, wypisaÄ‡ wiadomoÅ›Ä‡ i zakoÅ„czyÄ‡ dziaÅ‚anie.\n\n<Listing number=\"3-3\" file-name=\"src/main.rs\" caption=\"UÅ¼ywanie pÄ™tli `while` do uruchamiania kodu, dopÃ³ki warunek ocenia siÄ™ na `true`\">\n\n```rust\nfn main() {\n    let mut number = 3;\n\n    while number != 0 {\n        println!(\"{number}!\");\n\n        number -= 1;\n    }\n\n    println!(\"START!!!\");\n}\n```\n\n</Listing>\n\nTa konstrukcja eliminuje wiele zagnieÅ¼dÅ¼eÅ„, ktÃ³re byÅ‚yby konieczne, gdybyÅ›\nuÅ¼ywaÅ‚ `loop`, `if`, `else` i `break`, i jest bardziej przejrzysta.\nDopÃ³ki warunek ocenia siÄ™ na `true`, kod dziaÅ‚a; w przeciwnym razie wychodzi\nz pÄ™tli.\n\n#### PrzeglÄ…danie kolekcji za pomocÄ… `for`\n\nMoÅ¼esz uÅ¼yÄ‡ konstrukcji `while` do iteracji po elementach kolekcji, takiej jak\ntablica. Na przykÅ‚ad, pÄ™tla w Listingu 3-4 wypisuje kaÅ¼dy element w tablicy `a`.\n\n<Listing number=\"3-4\" file-name=\"src/main.rs\" caption=\"Iterowanie po kaÅ¼dym elemencie kolekcji za pomocÄ… pÄ™tli `while`\">\n\n```rust\nfn main() {\n    let a = [10, 20, 30, 40, 50];\n    let mut index = 0;\n\n    while index < 5 {\n        println!(\"wartoÅ›Ä‡ to: {}\", a[index]);\n\n        index += 1;\n    }\n}\n```\n\n</Listing>\n\nTutaj kod liczy elementy w tablicy. Zaczyna od indeksu `0`, a nastÄ™pnie zapÄ™tla\nsiÄ™, aÅ¼ osiÄ…gnie ostatni indeks w tablicy (czyli, gdy `index < 5` przestaje byÄ‡\n`true`). Uruchomienie tego kodu wypisze kaÅ¼dy element w tablicy:\n\n```console\n$ cargo run\n   Compiling loops v0.1.0 (file:///projects/loops)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.32s\n     Running `target/debug/loops`\nwartoÅ›Ä‡ to: 10\nwartoÅ›Ä‡ to: 20\nwartoÅ›Ä‡ to: 30\nwartoÅ›Ä‡ to: 40\nwartoÅ›Ä‡ to: 50\n```\n\nWszystkie piÄ™Ä‡ wartoÅ›ci tablicy pojawia siÄ™ w terminalu, zgodnie z oczekiwaniami.\nMimo Å¼e `index` osiÄ…gnie wartoÅ›Ä‡ `5` w pewnym momencie, pÄ™tla przestaje siÄ™\nwykonywaÄ‡ przed prÃ³bÄ… pobrania szÃ³stej wartoÅ›ci z tablicy.\n\nJednak to podejÅ›cie jest podatne na bÅ‚Ä™dy; moglibyÅ›my spowodowaÄ‡ panikÄ™\nprogramu, jeÅ›li wartoÅ›Ä‡ indeksu lub warunek testowy sÄ… niepoprawne. Na\nprzykÅ‚ad, jeÅ›li zmieniÅ‚eÅ› definicjÄ™ tablicy `a` na cztery elementy, ale\nzapomniaÅ‚eÅ› zaktualizowaÄ‡ warunek na `while index < 4`, kod ulegÅ‚by panice.\nJest to rÃ³wnieÅ¼ wolne, poniewaÅ¼ kompilator dodaje kod wykonawczy do\nwykonywania kontroli warunkowej, czy indeks znajduje siÄ™ w granicach tablicy w\nkaÅ¼dej iteracji pÄ™tli.\n\nJako bardziej zwiÄ™zÅ‚Ä… alternatywÄ™, moÅ¼esz uÅ¼yÄ‡ pÄ™tli `for` i wykonaÄ‡ kod dla\nkaÅ¼dego elementu w kolekcji. PÄ™tla `for` wyglÄ…da jak kod w Listingu 3-5.\n\n<Listing number=\"3-5\" file-name=\"src/main.rs\" caption=\"Iterowanie po kaÅ¼dym elemencie kolekcji za pomocÄ… pÄ™tli `for`\">\n\n```rust\nfn main() {\n    let a = [10, 20, 30, 40, 50];\n\n    for element in a {\n        println!(\"wartoÅ›Ä‡ to: {element}\");\n    }\n}\n```\n\n</Listing>\n\nKiedy uruchomimy ten kod, zobaczymy ten sam wynik co w Listingu 3-4. Co\nwaÅ¼niejsze, zwiÄ™kszyliÅ›my teraz bezpieczeÅ„stwo kodu i wyeliminowaliÅ›my\nmoÅ¼liwoÅ›Ä‡ bÅ‚Ä™dÃ³w, ktÃ³re mogÅ‚yby wyniknÄ…Ä‡ z wyjÅ›cia poza koniec tablicy lub\nniewystarczajÄ…cego przeszukania i pominiÄ™cia niektÃ³rych elementÃ³w. Kod\nmaszynowy generowany z pÄ™tli `for` moÅ¼e byÄ‡ rÃ³wnieÅ¼ bardziej wydajny,\nponiewaÅ¼ indeks nie musi byÄ‡ porÃ³wnywany z dÅ‚ugoÅ›ciÄ… tablicy w kaÅ¼dej\niteracji.\n\nUÅ¼ywajÄ…c pÄ™tli `for`, nie musiaÅ‚byÅ› pamiÄ™taÄ‡ o zmienianiu Å¼adnego innego kodu,\ngdybyÅ› zmieniÅ‚ liczbÄ™ wartoÅ›ci w tablicy, tak jak to miaÅ‚o miejsce w metodzie\nuÅ¼ytej w Listingu 3-4.\n\nBezpieczeÅ„stwo i zwiÄ™zÅ‚oÅ›Ä‡ pÄ™tli `for` sprawiajÄ…, Å¼e sÄ… one najczÄ™Å›ciej\nuÅ¼ywanÄ… konstrukcjÄ… pÄ™tli w RuÅ›cie. Nawet w sytuacjach, gdy chcesz uruchomiÄ‡\njakiÅ› kod okreÅ›lonÄ… liczbÄ™ razy, jak w przykÅ‚adzie odliczania, ktÃ³ry uÅ¼ywaÅ‚\npÄ™tli `while` w Listingu 3-3, wiÄ™kszoÅ›Ä‡ RustaceanÃ³w uÅ¼yÅ‚aby pÄ™tli `for`. SposÃ³b\nna to polegaÅ‚by na uÅ¼yciu `Range`, dostarczanego przez bibliotekÄ™ standardowÄ…,\nktÃ³ry generuje wszystkie liczby w sekwencji, zaczynajÄ…c od jednej liczby i\nkoÅ„czÄ…c przed innÄ… liczbÄ….\n\nOto jak wyglÄ…daÅ‚oby odliczanie za pomocÄ… pÄ™tli `for` i innej metody, o ktÃ³rej\njeszcze nie mÃ³wiliÅ›my, `rev`, do odwracania zakresu:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust\nfn main() {\n    for number in (1..4).rev() {\n        println!(\"{number}!\");\n    }\n    println!(\"START!!!\");\n}\n```\n\nTen kod jest trochÄ™ Å‚adniejszy, prawda?\n\n## Podsumowanie\n\nUdaÅ‚o siÄ™! DotarÅ‚eÅ› do koÅ„ca obszernego rozdziaÅ‚u: nauczyÅ‚eÅ› siÄ™ o zmiennych,\nskalarnych i zÅ‚oÅ¼onych typach danych, funkcjach, komentarzach, wyraÅ¼eniach\n`if` i pÄ™tlach! Aby poÄ‡wiczyÄ‡ koncepcje omÃ³wione w tym rozdziale, sprÃ³buj\nzbudowaÄ‡ programy, aby wykonaÄ‡ nastÄ™pujÄ…ce zadania:\n\n- Konwertowanie temperatur miÄ™dzy stopniami Fahrenheita i Celsjusza.\n- Generowanie _n_-tej liczby Fibonacciego.\n- Wypisywanie tekstu kolÄ™dy â€The Twelve Days of Christmasâ€, wykorzystujÄ…c\n  powtÃ³rzenia w piosence.\n\nKiedy bÄ™dziesz gotowy, przejdziemy do koncepcji w RuÅ›cie, ktÃ³ra _nie_ wystÄ™puje\npowszechnie w innych jÄ™zykach programowania: wÅ‚asnoÅ›ci.\n\n[comparing-the-guess-to-the-secret-number]: ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number\n[quitting-after-a-correct-guess]: ch02-00-guessing-game-tutorial.html#quitting-after-a-correct-guess\n",
        "chapter_title": "PrzepÅ‚yw sterowania"
    },
    {
        "file_path": "ch04-00-understanding-ownership.md",
        "content": "# Zrozumienie wÅ‚asnoÅ›ci\n\nWÅ‚asnoÅ›Ä‡ to najbardziej unikalna cecha Rusta i ma gÅ‚Ä™bokie implikacje dla\npozostaÅ‚ej czÄ™Å›ci jÄ™zyka. UmoÅ¼liwia Rustowi gwarantowanie bezpieczeÅ„stwa\npamiÄ™ci bez potrzeby zbierania Å›mieci, dlatego waÅ¼ne jest zrozumienie, jak\ndziaÅ‚a wÅ‚asnoÅ›Ä‡. W tym rozdziale omÃ³wimy wÅ‚asnoÅ›Ä‡, a takÅ¼e kilka\npowiÄ…zanych funkcji: poÅ¼yczanie, wycinki i sposÃ³b, w jaki Rust rozmieszcza dane\nw pamiÄ™ci.\n",
        "chapter_title": "Zrozumienie wÅ‚asnoÅ›ci"
    },
    {
        "file_path": "ch04-01-what-is-ownership.md",
        "content": "## Czym jest WÅ‚asnoÅ›Ä‡?\n\n_WÅ‚asnoÅ›Ä‡_ to zbiÃ³r zasad, ktÃ³re okreÅ›lajÄ…, w jaki sposÃ³b program w Rust zarzÄ…dza pamiÄ™ciÄ….Wszystkie programy muszÄ… zarzÄ…dzaÄ‡ sposobem, w jaki wykorzystujÄ… pamiÄ™Ä‡ komputera podczas dziaÅ‚ania.NiektÃ³re jÄ™zyki majÄ… zbieranie Å›mieci, ktÃ³re regularnie szuka nieuÅ¼ywanej juÅ¼ pamiÄ™cipamiÄ™ci podczas dziaÅ‚ania programu; w innych jÄ™zykach programista musi jawnieprzydzieliÄ‡ i zwolniÄ‡ pamiÄ™Ä‡. Rust uÅ¼ywa trzeciego podejÅ›cia: PamiÄ™Ä‡ jest zarzÄ…dzanaprzez system wÅ‚asnoÅ›ci z zestawem zasad, ktÃ³re kompilator sprawdza. JeÅ›liktÃ³rakolwiek z zasad zostanie naruszona, program siÄ™ nie skompiluje. Å»adna z funkcjiwÅ‚asnoÅ›ci nie spowolni programu podczas jego dziaÅ‚ania.\n\nPoniewaÅ¼ wÅ‚asnoÅ›Ä‡ jest nowÄ… koncepcjÄ… dla wielu programistÃ³w, przyzwyczajenie siÄ™ do niej zajmuje trochÄ™ czasu.DobrÄ… wiadomoÅ›ciÄ… jest to, Å¼e im bardziej doÅ›wiadczony bÄ™dziesz w Rusti zasadach systemu wÅ‚asnoÅ›ci, tym Å‚atwiej bÄ™dzie ci naturalnierozwinÄ…Ä‡ kod, ktÃ³ry jest bezpieczny i wydajny. Trzymaj tak dalej!\n\nKiedy zrozumiesz wÅ‚asnoÅ›Ä‡, bÄ™dziesz mieÄ‡ solidne podstawy do zrozumieniafunkcji, ktÃ³re sprawiajÄ…, Å¼e Rust jest unikalny. W tym rozdziale poznasz wÅ‚asnoÅ›Ä‡,pracujÄ…c nad przykÅ‚adami, ktÃ³re koncentrujÄ… siÄ™ na bardzo popularnej strukturze danych:ciÄ…gach znakÃ³w.\n\n> ### Stos i sterta\n>\n> Wiele jÄ™zykÃ³w programowania nie wymaga od ciebie zbyt czÄ™stego myÅ›lenia o stosie i stercie.Ale w jÄ™zyku programowania systemowego, takim jak Rust, to, czy wartoÅ›Ä‡ znajduje siÄ™ na stosie, czy na stercie,wpÅ‚ywa na zachowanie jÄ™zyka i na to, dlaczego musisz podejmowaÄ‡ pewne decyzje.CzÄ™Å›ci wÅ‚asnoÅ›ci zostanÄ… opisane w odniesieniu do stosu i stertyw dalszej czÄ™Å›ci tego rozdziaÅ‚u, wiÄ™c oto krÃ³tkie wyjaÅ›nienie w przygotowaniu.\n>\n> ZarÃ³wno stos, jak i sterta sÄ… czÄ™Å›ciami pamiÄ™ci dostÄ™pnymi dla twojego kodu do uÅ¼yciaw czasie wykonywania, ale sÄ… one strukturalizowane w rÃ³Å¼ny sposÃ³b. Stos przechowuje wartoÅ›ciw kolejnoÅ›ci, w jakiej je otrzymuje, i usuwa wartoÅ›ci w odwrotnej kolejnoÅ›ci.Jest to okreÅ›lane jako _ostatnie weszÅ‚o, pierwsze wyszÅ‚o (LIFO)_. PomyÅ›l o stosietalerzy: Kiedy dodajesz wiÄ™cej talerzy, kÅ‚adziesz je na wierzchu stosu, a kiedypotrzebujesz talerza, bierzesz jeden z gÃ³ry. Dodawanie lub usuwanie talerzy ze Å›rodka lub z doÅ‚u nie dziaÅ‚aÅ‚oby tak dobrze!Dodawanie danych nazywa siÄ™ _wkÅ‚adaniem na stos_, a usuwanie danych nazywa siÄ™ _zdejmowaniem ze stosu_.Wszystkie dane przechowywane na stosie muszÄ… mieÄ‡ znanÄ…, staÅ‚Ä… wielkoÅ›Ä‡.Dane o nieznanym rozmiarze w czasie kompilacji lub rozmiarze, ktÃ³ry moÅ¼e siÄ™ zmieniÄ‡, muszÄ… byÄ‡ przechowywanena stercie.\n>\n> Sterta jest mniej zorganizowana: Kiedy umieszczasz dane na stercie, Å¼Ä…daszwielkoÅ›ci miejsca. Alokator pamiÄ™ci znajduje wolne miejsce na stercie,ktÃ³re jest wystarczajÄ…co duÅ¼e, oznacza je jako zajÄ™te i zwraca _wskaÅºnik_,ktÃ³ry jest adresem tej lokalizacji. Ten proces nazywa siÄ™ _alokacjÄ… na stercie_i jest czasami skracany do samego _alokowania_ (wkÅ‚adanie wartoÅ›ci na stos nie jest uwaÅ¼ane za alokacjÄ™).PoniewaÅ¼ wskaÅºnik do sterty ma znanÄ…, staÅ‚Ä… wielkoÅ›Ä‡, moÅ¼esz przechowywaÄ‡ wskaÅºnik na stosie,ale kiedy chcesz uzyskaÄ‡ rzeczywiste dane, musisz podÄ…Å¼aÄ‡ za wskaÅºnikiem.PomyÅ›l o tym, jakbyÅ› siedziaÅ‚ w restauracji. Kiedy wchodzisz, podajesz liczbÄ™osÃ³b w twojej grupie, a host znajduje pusty stÃ³Å‚, ktÃ³ry pasuje do wszystkich,i prowadzi ciÄ™ tam. JeÅ›li ktoÅ› z twojej grupy spÃ³Åºni siÄ™, moÅ¼e zapytaÄ‡,gdzie zostaÅ‚eÅ› usadzony, aby ciÄ™ znaleÅºÄ‡.\n>\n> WkÅ‚adanie na stos jest szybsze niÅ¼ alokowanie na stercie, poniewaÅ¼ alokator nigdy nie musi szukaÄ‡miejsca do przechowywania nowych danych; ta lokalizacja zawsze znajduje siÄ™ na szczycie stosu.W porÃ³wnaniu, alokacja miejsca na stercie wymaga wiÄ™cej pracy, poniewaÅ¼ alokator musinajpierw znaleÅºÄ‡ wystarczajÄ…co duÅ¼o miejsca, aby pomieÅ›ciÄ‡ dane, a nastÄ™pnie wykonaÄ‡ ksiÄ™gowoÅ›Ä‡,aby przygotowaÄ‡ siÄ™ do nastÄ™pnej alokacji.\n>\n> DostÄ™p do danych na stercie jest zazwyczaj wolniejszy niÅ¼ dostÄ™p do danych na stosie,poniewaÅ¼ musisz podÄ…Å¼aÄ‡ za wskaÅºnikiem, aby tam dotrzeÄ‡. WspÃ³Å‚czesne procesorysÄ… szybsze, jeÅ›li mniej skaczÄ… po pamiÄ™ci. KontynuujÄ…c analogiÄ™,rozwaÅ¼ kelnera w restauracji przyjmujÄ…cego zamÃ³wienia od wielu stolikÃ³w.Najbardziej efektywne jest zebranie wszystkich zamÃ³wieÅ„ przy jednym stole, zanim przejdzie siÄ™ do nastÄ™pnego.Przyjmowanie zamÃ³wienia ze stoÅ‚u A, nastÄ™pnie zamÃ³wienia ze stoÅ‚u B,nastÄ™pnie ponownie z A, a nastÄ™pnie ponownie z B, byÅ‚oby znacznie wolniejszym procesem.W ten sam sposÃ³b procesor zazwyczaj lepiej wykonuje swojÄ… pracÄ™, jeÅ›lidziaÅ‚a na danych, ktÃ³re sÄ… blisko innych danych (jak na stosie),a nie dalej (jak moÅ¼e byÄ‡ na stercie).\n>\n> Kiedy twÃ³j kod wywoÅ‚uje funkcjÄ™, wartoÅ›ci przekazane do funkcji(w tym, potencjalnie, wskaÅºniki do danych na stercie) i zmienne lokalne funkcji sÄ…wkÅ‚adane na stos. Kiedy funkcja siÄ™ koÅ„czy, te wartoÅ›ci sÄ… usuwane ze stosu.\n>\n> Åšledzenie, ktÃ³re czÄ™Å›ci kodu uÅ¼ywajÄ… jakich danych na stercie,minimalizowanie iloÅ›ci zduplikowanych danych na stercie i czyszczenie nieuÅ¼ywanychdanych na stercie, aby nie zabrakÅ‚o miejsca, to problemyczne kwestie,ktÃ³re adresuje system wÅ‚asnoÅ›ci. Kiedy zrozumiesz wÅ‚asnoÅ›Ä‡,nie bÄ™dziesz musiaÅ‚ czÄ™sto myÅ›leÄ‡ o stosie i stercie.Ale wiedzÄ…c, Å¼e gÅ‚Ã³wnym celem wÅ‚asnoÅ›ci jest zarzÄ…dzanie danymi na stercie,moÅ¼e to pomÃ³c wyjaÅ›niÄ‡, dlaczego dziaÅ‚a to tak, jak dziaÅ‚a.\n\n### Zasady WÅ‚asnoÅ›ci\n\nNajpierw przyjrzyjmy siÄ™ zasadom wÅ‚asnoÅ›ci. PamiÄ™taj o nich,gdy bÄ™dziemy przechodziÄ‡ przez przykÅ‚ady, ktÃ³re je ilustrujÄ…:\n\n- KaÅ¼da wartoÅ›Ä‡ w Rust ma _wÅ‚aÅ›ciciela_.\n- W danym momencie moÅ¼e byÄ‡ tylko jeden wÅ‚aÅ›ciciel.\n- Gdy wÅ‚aÅ›ciciel wyjdzie poza zasiÄ™g, wartoÅ›Ä‡ zostanie usuniÄ™ta (_dropped_).\n\n### ZasiÄ™g zmiennych\n\nTeraz, gdy podstawowa skÅ‚adnia Rust jest juÅ¼ za nami, nie bÄ™dziemy zawieraÄ‡ caÅ‚ego kodu `fn main() {` w przykÅ‚adach, wiÄ™c jeÅ›li Å›ledzisz, upewnij siÄ™, Å¼e umieÅ›ciÅ‚eÅ› poniÅ¼sze przykÅ‚ady rÄ™cznie w funkcji `main`. W rezultacie nasze przykÅ‚ady bÄ™dÄ… nieco bardziej zwiÄ™zÅ‚e, pozwalajÄ…c nam skupiÄ‡ siÄ™ na rzeczywistych szczegÃ³Å‚ach, a nie na kodzie szablonowym.\n\nJako pierwszy przykÅ‚ad wÅ‚asnoÅ›ci, przyjrzymy siÄ™ zasiÄ™gowi niektÃ³rych zmiennych. _ZasiÄ™g_ to zakres w programie, w ktÃ³rym element jest waÅ¼ny. WeÅºmy nastÄ™pujÄ…cÄ… zmiennÄ…:\n\n```rust\nlet s = \"hello\";\n```\n\nZmienna `s` odnosi siÄ™ do literaÅ‚u ciÄ…gu znakÃ³w, gdzie wartoÅ›Ä‡ ciÄ…gu jest zakodowana bezpoÅ›rednio w tekÅ›cie naszego programu. Zmienna jest waÅ¼na od momentu jej zadeklarowania do koÅ„ca bieÅ¼Ä…cego zasiÄ™gu. Listing 4-1 przedstawia program z komentarzami oznaczajÄ…cymi, gdzie zmienna `s` byÅ‚aby waÅ¼na.\n\n<Listing number=\"4-1\" caption=\"Zmienna i zasiÄ™g, w ktÃ³rym jest waÅ¼na\">\n\n```rust\n# fn main() {\n    {                      // s jest tutaj niewaÅ¼ne, poniewaÅ¼ nie zostaÅ‚o jeszcze zadeklarowane\n        let s = \"hello\";   // s jest waÅ¼ne od tego momentu\n\n        // rÃ³b coÅ› z s\n    }                      // ten zasiÄ™g siÄ™ skoÅ„czyÅ‚, a s jest juÅ¼ niewaÅ¼ne\n# }\n```\n\n</Listing>\n\nInnymi sÅ‚owy, sÄ… tutaj dwa waÅ¼ne momenty w czasie:\n\n- Kiedy `s` wchodzi _w_ zasiÄ™g, jest waÅ¼ne.\n- Pozostaje waÅ¼ne, dopÃ³ki nie wyjdzie _z_ zasiÄ™gu.\n\nNa tym etapie, zwiÄ…zek miÄ™dzy zasiÄ™gami a waÅ¼noÅ›ciÄ… zmiennych jest podobny jak w innych jÄ™zykach programowania. Teraz bÄ™dziemy budowaÄ‡ na tym zrozumieniu, wprowadzajÄ…c typ `String`.\n\n### Typ `String`\n\nAby zilustrowaÄ‡ zasady wÅ‚asnoÅ›ci, potrzebujemy typu danych, ktÃ³ry jest bardziej zÅ‚oÅ¼ony niÅ¼ te, ktÃ³re omÃ³wiliÅ›my w sekcji [â€Typy danychâ€][data-types]<!-- ignore --> w Rozdziale 3. WczeÅ›niej omÃ³wione typy majÄ… znany rozmiar, mogÄ… byÄ‡ przechowywane na stosie i zdejmowane ze stosu po zakoÅ„czeniu ich zasiÄ™gu, oraz mogÄ… byÄ‡ szybko i trywialnie kopiowane, aby utworzyÄ‡ nowÄ…, niezaleÅ¼nÄ… instancjÄ™, jeÅ›li inna czÄ™Å›Ä‡ kodu musi uÅ¼yÄ‡ tej samej wartoÅ›ci w innym zasiÄ™gu. Chcemy jednak przyjrzeÄ‡ siÄ™ danym przechowywanym na stercie i zbadaÄ‡, w jaki sposÃ³b Rust wie, kiedy te dane posprzÄ…taÄ‡, a typ `String` jest doskonaÅ‚ym przykÅ‚adem.\n\nSkoncentrujemy siÄ™ na czÄ™Å›ciach `String`, ktÃ³re odnoszÄ… siÄ™ do wÅ‚asnoÅ›ci. Te aspekty dotyczÄ… rÃ³wnieÅ¼ innych zÅ‚oÅ¼onych typÃ³w danych, niezaleÅ¼nie od tego, czy sÄ… dostarczane przez bibliotekÄ™ standardowÄ…, czy stworzone przez ciebie. Aspekty `String` niezwiÄ…zane z wÅ‚asnoÅ›ciÄ… omÃ³wimy w [Rozdziale 8][ch8]<!-- ignore -->.\n\nWidzieliÅ›my juÅ¼ literaÅ‚y ciÄ…gÃ³w znakÃ³w, gdzie wartoÅ›Ä‡ ciÄ…gu jest zakodowana na staÅ‚e w naszym programie. LiteraÅ‚y ciÄ…gÃ³w znakÃ³w sÄ… wygodne, ale nie nadajÄ… siÄ™ do kaÅ¼dej sytuacji, w ktÃ³rej moÅ¼emy chcieÄ‡ uÅ¼yÄ‡ tekstu. Jednym z powodÃ³w jest to, Å¼e sÄ… one niezmienne. InnÄ… przyczynÄ… jest to, Å¼e nie kaÅ¼da wartoÅ›Ä‡ ciÄ…gu moÅ¼e byÄ‡ znana, gdy piszemy nasz kod: na przykÅ‚ad, co jeÅ›li chcemy pobraÄ‡ dane od uÅ¼ytkownika i je zapisaÄ‡? WÅ‚aÅ›nie dla takich sytuacji Rust ma typ `String`. Ten typ zarzÄ…dza danymi alokowanymi na stercie i jako taki jest w stanie przechowywaÄ‡ iloÅ›Ä‡ tekstu, ktÃ³ra jest nam nieznana w czasie kompilacji. MoÅ¼esz utworzyÄ‡ `String` z literaÅ‚u ciÄ…gu znakÃ³w za pomocÄ… funkcji `from`, w ten sposÃ³b:\n\n```rust\nlet s = String::from(\"hello\");\n```\n\nOperator podwÃ³jnego dwukropka `::` pozwala nam na umieszczenie funkcji `from` w przestrzeni nazw typu `String`, zamiast uÅ¼ywaÄ‡ nazwy takiej jak `string_from`. WiÄ™cej o tej skÅ‚adni omÃ³wimy w sekcji [â€Metodyâ€][methods]<!-- ignore --> w Rozdziale 5, oraz gdy bÄ™dziemy mÃ³wiÄ‡ o przestrzeniach nazw z moduÅ‚ami w sekcji [â€ÅšcieÅ¼ki do odwoÅ‚ywania siÄ™ do elementu w drzewie moduÅ‚Ã³wâ€][paths-module-tree]<!-- ignore --> w Rozdziale 7.\n\nTego rodzaju ciÄ…g _moÅ¼e_ byÄ‡ mutowalny:\n\n```rust\n# fn main() {\n    let mut s = String::from(\"hello\");\n\n    s.push_str(\", world!\"); // push_str() dodaje literaÅ‚ do String\n\n    println!(\"{s}\"); // to wyÅ›wietli `hello, world!`\n# }\n```\n\nWiÄ™c, jaka jest tutaj rÃ³Å¼nica? Dlaczego `String` moÅ¼e byÄ‡ mutowalny, a literaÅ‚y nie? RÃ³Å¼nica tkwi w sposobie, w jaki te dwa typy obsÅ‚ugujÄ… pamiÄ™Ä‡.\n\n### PamiÄ™Ä‡ i Alokacja\n\nW przypadku literaÅ‚u ciÄ…gu znakÃ³w, znamy jego zawartoÅ›Ä‡ w czasie kompilacji, wiÄ™c tekst jest zakodowany bezpoÅ›rednio w finalnym pliku wykonywalnym. Dlatego literaÅ‚y ciÄ…gÃ³w znakÃ³w sÄ… szybkie i wydajne. Ale te wÅ‚aÅ›ciwoÅ›ci wynikajÄ… tylko z niezmiennoÅ›ci literaÅ‚u ciÄ…gu znakÃ³w. Niestety, nie moÅ¼emy umieÅ›ciÄ‡ bloku pamiÄ™ci w pliku binarnym dla kaÅ¼dego fragmentu tekstu, ktÃ³rego rozmiar jest nieznany w czasie kompilacji i ktÃ³rego rozmiar moÅ¼e zmieniaÄ‡ siÄ™ podczas dziaÅ‚ania programu.\n\nZ typem `String`, aby obsÅ‚ugiwaÄ‡ zmienny, rozszerzalny fragment tekstu, musimy zaalokowaÄ‡ na stercie iloÅ›Ä‡ pamiÄ™ci, nieznanÄ… w czasie kompilacji, aby pomieÅ›ciÄ‡ zawartoÅ›Ä‡. Oznacza to:\n\n- PamiÄ™Ä‡ musi byÄ‡ Å¼Ä…dana od alokatora pamiÄ™ci w czasie wykonywania.\n- Potrzebujemy sposobu na zwrÃ³cenie tej pamiÄ™ci alokatorowi, gdy skoÅ„czymy z naszym `String`.\n\nTa pierwsza czÄ™Å›Ä‡ jest wykonywana przez nas: Kiedy wywoÅ‚ujemy `String::from`, jego implementacja Å¼Ä…da potrzebnej pamiÄ™ci. Jest to doÅ›Ä‡ powszechne w jÄ™zykach programowania.\n\nJednak druga czÄ™Å›Ä‡ jest inna. W jÄ™zykach z _garbage collector (GC)_, GC Å›ledzi i usuwa pamiÄ™Ä‡, ktÃ³ra nie jest juÅ¼ uÅ¼ywana, i nie musimy o tym myÅ›leÄ‡. W wiÄ™kszoÅ›ci jÄ™zykÃ³w bez GC, to nasza odpowiedzialnoÅ›Ä‡, aby zidentyfikowaÄ‡, kiedy pamiÄ™Ä‡ nie jest juÅ¼ uÅ¼ywana i wywoÅ‚aÄ‡ kod, aby jawnie jÄ… zwolniÄ‡, tak jak robiliÅ›my to, aby jÄ… zaÅ¼Ä…daÄ‡. Robienie tego poprawnie byÅ‚o historycznie trudnym problemem programistycznym. JeÅ›li zapomnimy, zmarnujemy pamiÄ™Ä‡. JeÅ›li zrobimy to zbyt wczeÅ›nie, bÄ™dziemy mieÄ‡ nieprawidÅ‚owÄ… zmiennÄ…. JeÅ›li zrobimy to dwukrotnie, to teÅ¼ jest bÅ‚Ä…d. Musimy sparowaÄ‡ dokÅ‚adnie jednÄ… `allocate` z dokÅ‚adnie jednÄ… `free`.\n\nRust obiera innÄ… Å›cieÅ¼kÄ™: PamiÄ™Ä‡ jest automatycznie zwracana, gdy zmienna, ktÃ³ra jÄ… posiada, wyjdzie poza zasiÄ™g. Oto wersja naszego przykÅ‚adu zasiÄ™gu z Listingu 4-1, uÅ¼ywajÄ…ca `String` zamiast literaÅ‚u ciÄ…gu znakÃ³w:\n\n```rust\n# fn main() {\n    {\n        let s = String::from(\"hello\"); // s jest waÅ¼ne od tego momentu\n\n        // rÃ³b coÅ› z s\n    }                                  // ten zasiÄ™g siÄ™ skoÅ„czyÅ‚, a s jest juÅ¼\n                                       // niewaÅ¼ne\n# }\n```\n\nIstnieje naturalny moment, w ktÃ³rym moÅ¼emy zwrÃ³ciÄ‡ pamiÄ™Ä‡ potrzebnÄ… naszej `String` alokatorowi: kiedy `s` wyjdzie poza zasiÄ™g. Kiedy zmienna wychodzi poza zasiÄ™g, Rust wywoÅ‚uje dla nas specjalnÄ… funkcjÄ™. Funkcja ta nazywa siÄ™ [`drop`][drop]<!-- ignore --> i to w niej autor `String` moÅ¼e umieÅ›ciÄ‡ kod do zwracania pamiÄ™ci. Rust automatycznie wywoÅ‚uje `drop` przy zamykajÄ…cym nawiasie klamrowym.\n\n> Uwaga: W C++ ten wzorzec dealokowania zasobÃ³w na koÅ„cu Å¼ycia elementu jest czasami nazywany _Resource Acquisition Is Initialization (RAII)_. Funkcja `drop` w Rust bÄ™dzie ci znana, jeÅ›li uÅ¼ywaÅ‚eÅ› wzorcÃ³w RAII.\n\nTen wzorzec ma gÅ‚Ä™boki wpÅ‚yw na sposÃ³b pisania kodu w Rust. MoÅ¼e wydawaÄ‡ siÄ™ prosty teraz, ale zachowanie kodu moÅ¼e byÄ‡ nieoczekiwane w bardziej skomplikowanych sytuacjach, gdy chcemy, aby wiele zmiennych uÅ¼ywaÅ‚o danych, ktÃ³re zaalokowaliÅ›my na stercie. Przyjrzyjmy siÄ™ teraz kilku z tych sytuacji.\n\n<a id=\"ways-variables-and-data-interact-move\"></a>\n\n#### Zmienne i Dane w Interakcji przez Przeniesienie (Move)\n\nW Rust wiele zmiennych moÅ¼e wchodziÄ‡ w interakcjÄ™ z tymi samymi danymi na rÃ³Å¼ne sposoby. Listing 4-2 przedstawia przykÅ‚ad uÅ¼ycia liczby caÅ‚kowitej.\n\n<Listing number=\"4-2\" caption=\"Przypisanie wartoÅ›ci caÅ‚kowitej zmiennej `x` do `y`\">\n\n```rust\n# fn main() {\n    let x = 5;\n    let y = x;\n# }\n```\n\n</Listing>\n\nPrawdopodobnie moÅ¼emy zgadnÄ…Ä‡, co to robi: â€Przypisz wartoÅ›Ä‡ `5` do `x`; nastÄ™pnie, utwÃ³rz kopiÄ™ wartoÅ›ci z `x` i przypisz jÄ… do `y`.â€ Mamy teraz dwie zmienne, `x` i `y`, i obie sÄ… rÃ³wne `5`. Tak wÅ‚aÅ›nie siÄ™ dzieje, poniewaÅ¼ liczby caÅ‚kowite sÄ… prostymi wartoÅ›ciami o znanym, staÅ‚ym rozmiarze, a te dwie wartoÅ›ci `5` sÄ… umieszczane na stosie.\n\nTeraz przyjrzyjmy siÄ™ wersji `String`:\n\n```rust\n# fn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1;\n# }\n```\n\nWyglÄ…da to bardzo podobnie, wiÄ™c moglibyÅ›my zaÅ‚oÅ¼yÄ‡, Å¼e dziaÅ‚aÅ‚oby tak samo: to znaczy, Å¼e druga linia utworzyÅ‚aby kopiÄ™ wartoÅ›ci z `s1` i przypisaÅ‚a jÄ… do `s2`. Ale tak siÄ™ nie dzieje.\n\nPrzyjrzyj siÄ™ Rysunkowi 4-1, aby zobaczyÄ‡, co dzieje siÄ™ z `String` pod maskÄ…. `String` skÅ‚ada siÄ™ z trzech czÄ™Å›ci, pokazanych po lewej stronie: wskaÅºnika do pamiÄ™ci, ktÃ³ra przechowuje zawartoÅ›Ä‡ ciÄ…gu, dÅ‚ugoÅ›ci i pojemnoÅ›ci. Ta grupa danych jest przechowywana na stosie. Po prawej stronie znajduje siÄ™ pamiÄ™Ä‡ na stercie, ktÃ³ra przechowuje zawartoÅ›Ä‡.\n\n<img alt=\"Dwie tabele: pierwsza tabela zawiera reprezentacjÄ™ s1 na stosie, skÅ‚adajÄ…cÄ… siÄ™ z jej dÅ‚ugoÅ›ci (5), pojemnoÅ›ci (5) i wskaÅºnika do pierwszej wartoÅ›ci w drugiej tabeli. Druga tabela zawiera reprezentacjÄ™ danych ciÄ…gu znakÃ³w na stercie, bajt po bajcie.\" src=\"img/trpl04-01.svg\" class=\"center\" style=\"width: 50%;\" />\n\n<span class=\"caption\">Rysunek 4-1: Reprezentacja w pamiÄ™ci `String` zawierajÄ…cego wartoÅ›Ä‡ `\"hello\"` przypisanÄ… do `s1`</span>\n\nDÅ‚ugoÅ›Ä‡ to iloÅ›Ä‡ pamiÄ™ci, w bajtach, ktÃ³rÄ… aktualnie wykorzystuje zawartoÅ›Ä‡ `String`. PojemnoÅ›Ä‡ to caÅ‚kowita iloÅ›Ä‡ pamiÄ™ci, w bajtach, ktÃ³rÄ… `String` otrzymaÅ‚ od alokatora. RÃ³Å¼nica miÄ™dzy dÅ‚ugoÅ›ciÄ… a pojemnoÅ›ciÄ… ma znaczenie, ale nie w tym kontekÅ›cie, wiÄ™c na razie moÅ¼na jÄ… zignorowaÄ‡.\n\nKiedy przypisujemy `s1` do `s2`, dane `String` sÄ… kopiowane, co oznacza, Å¼e kopiujemy wskaÅºnik, dÅ‚ugoÅ›Ä‡ i pojemnoÅ›Ä‡, ktÃ³re znajdujÄ… siÄ™ na stosie. Nie kopiujemy danych na stercie, do ktÃ³rych odwoÅ‚uje siÄ™ wskaÅºnik. Innymi sÅ‚owy, reprezentacja danych w pamiÄ™ci wyglÄ…da jak na Rysunku 4-2.\n\n<img alt=\"Trzy tabele: tabele s1 i s2 reprezentujÄ…ce te ciÄ…gi na stosie, odpowiednio, i obie wskazujÄ…ce na te same dane ciÄ…gu na stercie.\" src=\"img/trpl04-02.svg\" class=\"center\" style=\"width: 50%;\" />\n\n<span class=\"caption\">Rysunek 4-2: Reprezentacja w pamiÄ™ci zmiennej `s2`, ktÃ³ra zawiera kopiÄ™ wskaÅºnika, dÅ‚ugoÅ›ci i pojemnoÅ›ci `s1`</span>\n\nReprezentacja _nie_ wyglÄ…da jak na Rysunku 4-3, ktÃ³ry przedstawiaÅ‚by pamiÄ™Ä‡, gdyby Rust zamiast tego skopiowaÅ‚ rÃ³wnieÅ¼ dane na stercie. Gdyby Rust tak zrobiÅ‚, operacja `s2 = s1` mogÅ‚aby byÄ‡ bardzo kosztowna pod wzglÄ™dem wydajnoÅ›ci, gdyby dane na stercie byÅ‚y duÅ¼e.\n\n<img alt=\"Cztery tabele: dwie tabele reprezentujÄ…ce dane stosu dla s1 i s2, a kaÅ¼da wskazuje na wÅ‚asnÄ… kopiÄ™ danych ciÄ…gu na stercie.\" src=\"img/trpl04-03.svg\" class=\"center\" style=\"width: 50%;\" />\n\n<span class=\"caption\">Rysunek 4-3: Inna moÅ¼liwoÅ›Ä‡ tego, co `s2 = s1` mÃ³gÅ‚by zrobiÄ‡, gdyby Rust skopiowaÅ‚ rÃ³wnieÅ¼ dane ze sterty</span>\n\nWczeÅ›niej powiedzieliÅ›my, Å¼e gdy zmienna wychodzi poza zasiÄ™g, Rust automatycznie wywoÅ‚uje funkcjÄ™ `drop` i zwalnia pamiÄ™Ä‡ sterty dla tej zmiennej. Ale Rysunek 4-2 pokazuje, Å¼e oba wskaÅºniki danych wskazujÄ… na tÄ™ samÄ… lokalizacjÄ™. To jest problem: kiedy `s2` i `s1` wyjdÄ… poza zasiÄ™g, oba bÄ™dÄ… prÃ³bowaÅ‚y zwolniÄ‡ tÄ™ samÄ… pamiÄ™Ä‡. Jest to znane jako bÅ‚Ä…d _podwÃ³jnego zwolnienia_ (_double free_) i jest jednym z bÅ‚Ä™dÃ³w bezpieczeÅ„stwa pamiÄ™ci, o ktÃ³rych wspomnieliÅ›my wczeÅ›niej. Dwukrotne zwolnienie pamiÄ™ci moÅ¼e prowadziÄ‡ do uszkodzenia pamiÄ™ci, co potencjalnie moÅ¼e prowadziÄ‡ do luk w zabezpieczeniach.\n\nAby zapewniÄ‡ bezpieczeÅ„stwo pamiÄ™ci, po linii `let s2 = s1;`, Rust uwaÅ¼a `s1` za juÅ¼ nieprawidÅ‚owe. Dlatego Rust nie musi zwalniaÄ‡ niczego, gdy `s1` wychodzi poza zasiÄ™g. SprawdÅº, co siÄ™ stanie, gdy sprÃ³bujesz uÅ¼yÄ‡ `s1` po utworzeniu `s2`; to nie zadziaÅ‚a:\n\n```rust,ignore,does_not_compile\n# fn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1;\n\n    println!(\"{s1}, world!\");\n# }\n```\n\nOtrzymasz bÅ‚Ä…d podobny do tego, poniewaÅ¼ Rust uniemoÅ¼liwia uÅ¼ycie uniewaÅ¼nionej referencji:\n\n```console\n$ cargo run\n   Compiling ownership v0.1.0 (file:///projects/ownership)\nerror[E0382]: borrow of moved value: `s1`\n --> src/main.rs:5:16\n  |\n2 |     let s1 = String::from(\"hello\");\n  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait\n3 |     let s2 = s1;\n  |              -- value moved here\n4 |\n5 |     println!(\"{s1}, world!\");\n  |                ^^ value borrowed here after move\n  |\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider cloning the value if the performance cost is acceptable\n  |\n3 |     let s2 = s1.clone();\n  |                ++++++++\n\nFor more information about this error, try `rustc --explain E0382`.\nerror: could not compile `ownership` (bin \"ownership\") due to 1 previous error\n```\n\nJeÅ›li sÅ‚yszaÅ‚eÅ› o pojÄ™ciach _pÅ‚ytka kopia_ i _gÅ‚Ä™boka kopia_ pracujÄ…c z innymi jÄ™zykami, koncepcja kopiowania wskaÅºnika, dÅ‚ugoÅ›ci i pojemnoÅ›ci bez kopiowania danych prawdopodobnie brzmi jak tworzenie pÅ‚ytkiej kopii. Ale poniewaÅ¼ Rust rÃ³wnieÅ¼ uniewaÅ¼nia pierwszÄ… zmiennÄ…, zamiast nazywaÄ‡ to pÅ‚ytkÄ… kopiÄ…, nazywa siÄ™ to _przeniesieniem_. W tym przykÅ‚adzie powiedzielibyÅ›my, Å¼e `s1` zostaÅ‚o _przeniesione_ do `s2`. Zatem to, co faktycznie siÄ™ dzieje, pokazano na Rysunku 4-4.\n\n<img alt=\"Trzy tabele: tabele s1 i s2 reprezentujÄ…ce te ciÄ…gi na stosie, odpowiednio, i obie wskazujÄ…ce na te same dane ciÄ…gu na stercie. Tabela s1 jest wyszarzona, poniewaÅ¼ s1 nie jest juÅ¼ waÅ¼ne; tylko s2 moÅ¼e byÄ‡ uÅ¼ywane do dostÄ™pu do danych na stercie.\" src=\"img/trpl04-04.svg\" class=\"center\" style=\"width: 50%;\" />\n\n<span class=\"caption\">Rysunek 4-4: Reprezentacja w pamiÄ™ci po uniewaÅ¼nieniu `s1`</span>\n\nTo rozwiÄ…zuje nasz problem! Gdy tylko `s2` jest waÅ¼ne, gdy wyjdzie ono poza zasiÄ™g, samo zwolni pamiÄ™Ä‡, i gotowe.\n\nDodatkowo, istnieje wynikajÄ…ca z tego decyzja projektowa: Rust nigdy nie stworzy automatycznie â€gÅ‚Ä™bokichâ€ kopii twoich danych. Dlatego wszelkie _automatyczne_ kopiowanie moÅ¼na uznaÄ‡ za tanie pod wzglÄ™dem wydajnoÅ›ci czasu wykonania.\n\n#### ZasiÄ™g i przypisanie\n\nOdwrotnoÅ›Ä‡ tego jest rÃ³wnieÅ¼ prawdziwa dla zwiÄ…zku miÄ™dzy zasiÄ™giem, wÅ‚asnoÅ›ciÄ… i zwalnianiem pamiÄ™ci za pomocÄ… funkcji `drop`. Kiedy przypisujesz caÅ‚kowicie nowÄ… wartoÅ›Ä‡ do istniejÄ…cej zmiennej, Rust natychmiast wywoÅ‚a `drop` i zwolni pamiÄ™Ä‡ oryginalnej wartoÅ›ci. RozwaÅ¼my na przykÅ‚ad ten kod:\n\n```rust\n# fn main() {\n    let mut s = String::from(\"hello\");\n    s = String::from(\"ahoy\");\n\n    println!(\"{s}, world!\");\n# }\n```\n\nPoczÄ…tkowo deklarujemy zmiennÄ… `s` i wiÄ…Å¼emy jÄ… z `String` o wartoÅ›ci `\"hello\"`. NastÄ™pnie, natychmiast tworzymy nowy `String` o wartoÅ›ci `\"ahoy\"` i przypisujemy go do `s`. W tym momencie nic nie odnosi siÄ™ do oryginalnej wartoÅ›ci na stercie. Rysunek 4-5 ilustruje teraz dane stosu i sterty:\n\n<img alt=\"Jedna tabela reprezentujÄ…ca wartoÅ›Ä‡ ciÄ…gu na stosie, wskazujÄ…ca na drugÄ… czÄ™Å›Ä‡ danych ciÄ…gu (ahoy) na stercie, z oryginalnymi danymi ciÄ…gu (hello) wyszarzonymi, poniewaÅ¼ nie moÅ¼na juÅ¼ do nich uzyskaÄ‡ dostÄ™pu.\" src=\"img/trpl04-05.svg\" class=\"center\" style=\"width: 50%;\" />\n\n<span class=\"caption\">Rysunek 4-5: Reprezentacja w pamiÄ™ci po caÅ‚kowitym zastÄ…pieniu wartoÅ›ci poczÄ…tkowej</span>\n\nOryginalny ciÄ…g znakÃ³w natychmiast wychodzi wiÄ™c poza zasiÄ™g. Rust uruchomi na nim funkcjÄ™ `drop` i jego pamiÄ™Ä‡ zostanie natychmiast zwolniona. Kiedy na koÅ„cu wydrukujemy wartoÅ›Ä‡, bÄ™dzie ona wynosiÄ‡ `â€ahoy, world!â€`.\n\n<a id=\"ways-variables-and-data-interact-clone\"></a>\n\n#### Zmienne i Dane w Interakcji przez Klonowanie (Clone)\n\nJeÅ›li _chcemy_ gÅ‚Ä™boko skopiowaÄ‡ dane `String` ze sterty, a nie tylko dane ze stosu, moÅ¼emy uÅ¼yÄ‡ wspÃ³lnej metody `clone`. SkÅ‚adniÄ™ metod omÃ³wimy w Rozdziale 5, ale poniewaÅ¼ metody sÄ… wspÃ³lnÄ… cechÄ… wielu jÄ™zykÃ³w programowania, prawdopodobnie widziaÅ‚eÅ› je juÅ¼ wczeÅ›niej.\n\nOto przykÅ‚ad metody `clone` w dziaÅ‚aniu:\n\n```rust\n# fn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1.clone();\n\n    println!(\"s1 = {s1}, s2 = {s2}\");\n# }\n```\n\nTo dziaÅ‚a bez problemÃ³w i wyraÅºnie tworzy zachowanie pokazane na Rysunku 4-3, gdzie dane na stercie _sÄ…_ kopiowane.\n\nKiedy widzisz wywoÅ‚anie `clone`, wiesz, Å¼e wykonywany jest jakiÅ› dowolny kod i Å¼e ten kod moÅ¼e byÄ‡ kosztowny. To wizualny wskaÅºnik, Å¼e dzieje siÄ™ coÅ› innego.\n\n#### Dane tylko na stosie: Kopia\n\nJest jeszcze jedna kwestia, o ktÃ³rej jeszcze nie mÃ³wiliÅ›my. Ten kod uÅ¼ywajÄ…cy liczb caÅ‚kowitych â€” czÄ™Å›Ä‡ z nich pokazana w Listingu 4-2 â€” dziaÅ‚a i jest prawidÅ‚owy:\n\n```rust\n# fn main() {\n    let x = 5;\n    let y = x;\n\n    println!(\"x = {x}, y = {y}\");\n# }\n```\n\nAle ten kod wydaje siÄ™ zaprzeczaÄ‡ temu, czego siÄ™ wÅ‚aÅ›nie nauczyliÅ›my: Nie mamy wywoÅ‚ania `clone`, ale `x` jest nadal waÅ¼ne i nie zostaÅ‚o przeniesione do `y`.\n\nPowodem jest to, Å¼e typy takie jak liczby caÅ‚kowite, ktÃ³re majÄ… znany rozmiar w czasie kompilacji, sÄ… przechowywane w caÅ‚oÅ›ci na stosie, wiÄ™c kopie rzeczywistych wartoÅ›ci sÄ… szybkie do wykonania. Oznacza to, Å¼e nie ma powodu, dla ktÃ³rego chcielibyÅ›my uniemoÅ¼liwiÄ‡ `x` bycie waÅ¼nym po utworzeniu zmiennej `y`. Innymi sÅ‚owy, nie ma tutaj rÃ³Å¼nicy miÄ™dzy kopiowaniem gÅ‚Ä™bokim a pÅ‚ytkim, wiÄ™c wywoÅ‚anie `clone` nie zrobiÅ‚oby nic innego niÅ¼ zwykÅ‚e kopiowanie pÅ‚ytkie, i moÅ¼emy to pominÄ…Ä‡.\n\nRust posiada specjalnÄ… adnotacjÄ™ zwanÄ… cechÄ… `Copy`, ktÃ³rÄ… moÅ¼emy umieszczaÄ‡ na typach przechowywanych na stosie, tak jak to jest w przypadku liczb caÅ‚kowitych (wiÄ™cej o cechach omÃ³wimy w [Rozdziale 10][traits]<!-- ignore -->). JeÅ›li typ implementuje cechÄ™ `Copy`, zmienne, ktÃ³re jej uÅ¼ywajÄ…, nie sÄ… przenoszone, lecz sÄ… trywialnie kopiowane, co sprawia, Å¼e pozostajÄ… waÅ¼ne po przypisaniu do innej zmiennej.\n\nRust nie pozwoli nam zaadnotowaÄ‡ typu jako `Copy`, jeÅ›li typ, lub ktÃ³rakolwiek z jego czÄ™Å›ci, zaimplementowaÅ‚ cechÄ™ `Drop`. JeÅ›li typ potrzebuje, aby coÅ› specjalnego siÄ™ staÅ‚o, gdy wartoÅ›Ä‡ wyjdzie poza zasiÄ™g, a my dodamy adnotacjÄ™ `Copy` do tego typu, otrzymamy bÅ‚Ä…d kompilacji. Aby dowiedzieÄ‡ siÄ™, jak dodaÄ‡ adnotacjÄ™ `Copy` do swojego typu w celu zaimplementowania cechy, zobacz [â€Cechy pochodneâ€][derivable-traits]<!-- ignore --> w Dodatku C.\n\nWiÄ™c, jakie typy implementujÄ… cechÄ™ `Copy`? Aby byÄ‡ pewnym, moÅ¼esz sprawdziÄ‡ dokumentacjÄ™ dla danego typu, ale ogÃ³lnie rzecz biorÄ…c, kaÅ¼da grupa prostych wartoÅ›ci skalarnych moÅ¼e implementowaÄ‡ `Copy`, a nic, co wymaga alokacji lub jest jakÄ…Å› formÄ… zasobu, nie moÅ¼e implementowaÄ‡ `Copy`. Oto niektÃ³re typy, ktÃ³re implementujÄ… `Copy`:\n\n- Wszystkie typy caÅ‚kowite, takie jak `u32`.\n- Typ boolowski, `bool`, z wartoÅ›ciami `true` i `false`.\n- Wszystkie typy zmiennoprzecinkowe, takie jak `f64`.\n- Typ znakowy, `char`.\n- Krotki, jeÅ›li zawierajÄ… tylko typy, ktÃ³re rÃ³wnieÅ¼ implementujÄ… `Copy`. Na przykÅ‚ad `(i32, i32)` implementuje `Copy`, ale `(i32, String)` nie.\n\n### WÅ‚asnoÅ›Ä‡ i Funkcje\n\nMechanizmy przekazywania wartoÅ›ci do funkcji sÄ… podobne do tych, ktÃ³re wystÄ™pujÄ… przy przypisywaniu wartoÅ›ci do zmiennej. Przekazanie zmiennej do funkcji spowoduje przeniesienie lub skopiowanie, tak jak przypisanie. Listing 4-3 zawiera przykÅ‚ad z adnotacjami pokazujÄ…cymi, gdzie zmienne wchodzÄ… w zasiÄ™g i wychodzÄ… z niego.\n\n<Listing number=\"4-3\" file-name=\"src/main.rs\" caption=\"Funkcje z adnotacjami wÅ‚asnoÅ›ci i zasiÄ™gu\">\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");  // s wchodzi w zasiÄ™g\n\n    takes_ownership(s);             // wartoÅ›Ä‡ s przenosi siÄ™ do funkcji...\n                                    // ... i dlatego jest tutaj niewaÅ¼na\n\n    let x = 5;                      // x wchodzi w zasiÄ™g\n\n    makes_copy(x);                  // PoniewaÅ¼ i32 implementuje cechÄ™ Copy,\n                                    // x NIE przenosi siÄ™ do funkcji,\n                                    // wiÄ™c moÅ¼na uÅ¼ywaÄ‡ x pÃ³Åºniej.\n\n} // Tutaj x wychodzi z zasiÄ™gu, potem s. JednakÅ¼e, poniewaÅ¼ wartoÅ›Ä‡ s zostaÅ‚a przeniesiona,\n  // nic specjalnego siÄ™ nie dzieje.\n\nfn takes_ownership(some_string: String) { // some_string wchodzi w zasiÄ™g\n    println!(\"{some_string}\");\n} // Tutaj some_string wychodzi z zasiÄ™gu i wywoÅ‚ywane jest `drop`. PamiÄ™Ä‡ bazowa\n  // jest zwalniana.\n\nfn makes_copy(some_integer: i32) { // some_integer wchodzi w zasiÄ™g\n    println!(\"{some_integer}\");\n} // Tutaj some_integer wychodzi z zasiÄ™gu. Nic specjalnego siÄ™ nie dzieje.\n```\n\n</Listing>\n\nJeÅ›li sprÃ³bowalibyÅ›my uÅ¼yÄ‡ `s` po wywoÅ‚aniu `takes_ownership`, Rust wyrzuciÅ‚by bÅ‚Ä…d kompilacji. Te statyczne sprawdzenia chroniÄ… nas przed bÅ‚Ä™dami. SprÃ³buj dodaÄ‡ kod do `main`, ktÃ³ry uÅ¼ywa `s` i `x`, aby zobaczyÄ‡, gdzie moÅ¼na ich uÅ¼ywaÄ‡, a gdzie zasady wÅ‚asnoÅ›ci uniemoÅ¼liwiajÄ… to.\n\n### WartoÅ›ci zwracane i zasiÄ™g\n\nZwracanie wartoÅ›ci moÅ¼e rÃ³wnieÅ¼ przenosiÄ‡ wÅ‚asnoÅ›Ä‡. Listing 4-4 przedstawia przykÅ‚ad funkcji, ktÃ³ra zwraca pewnÄ… wartoÅ›Ä‡, z podobnymi adnotacjami jak te z Listingu 4-3.\n\n<Listing number=\"4-4\" file-name=\"src/main.rs\" caption=\"Przenoszenie wÅ‚asnoÅ›ci wartoÅ›ci zwracanych\">\n\n```rust\nfn main() {\n    let s1 = gives_ownership();        // gives_ownership przenosi swojÄ… wartoÅ›Ä‡\n                                       // zwracanÄ… do s1\n\n    let s2 = String::from(\"hello\");    // s2 wchodzi w zasiÄ™g\n\n    let s3 = takes_and_gives_back(s2); // s2 jest przenoszone do\n                                       // takes_and_gives_back, ktÃ³re rÃ³wnieÅ¼\n                                       // przenosi swojÄ… wartoÅ›Ä‡ zwracanÄ… do s3\n} // Tutaj s3 wychodzi z zasiÄ™gu i jest usuwane. s2 zostaÅ‚o przeniesione, wiÄ™c nic\n  // siÄ™ nie dzieje. s1 wychodzi z zasiÄ™gu i jest usuwane.\n\nfn gives_ownership() -> String {       // gives_ownership przeniesie swojÄ…\n                                       // wartoÅ›Ä‡ zwracanÄ… do funkcji,\n                                       // ktÃ³ra jÄ… wywoÅ‚a\n\n    let some_string = String::from(\"yours\"); // some_string wchodzi w zasiÄ™g\n\n    some_string                        // some_string jest zwracane i\n                                       // przenosi siÄ™ do funkcji\n                                       // wywoÅ‚ujÄ…cej\n}\n\n// Ta funkcja przyjmuje String i zwraca String.\nfn takes_and_gives_back(a_string: String) -> String {\n    // a_string wchodzi w\n    // zasiÄ™g\n\n    a_string  // a_string jest zwracane i przenosi siÄ™ do funkcji wywoÅ‚ujÄ…cej\n}\n```\n\n</Listing>\n\nWÅ‚asnoÅ›Ä‡ zmiennej zawsze podlega temu samemu wzorcowi: przypisanie wartoÅ›ci do innej zmiennej powoduje jej przeniesienie. Gdy zmienna zawierajÄ…ca dane na stercie wyjdzie poza zasiÄ™g, wartoÅ›Ä‡ zostanie posprzÄ…tana przez `drop`, chyba Å¼e wÅ‚asnoÅ›Ä‡ danych zostaÅ‚a przeniesiona do innej zmiennej.\n\nChociaÅ¼ to dziaÅ‚a, przejmowanie wÅ‚asnoÅ›ci, a nastÄ™pnie zwracanie wÅ‚asnoÅ›ci przy kaÅ¼dej funkcji jest trochÄ™ mÄ™czÄ…ce. Co, jeÅ›li chcemy pozwoliÄ‡ funkcji uÅ¼yÄ‡ wartoÅ›ci, ale nie przejmowaÄ‡ wÅ‚asnoÅ›ci? Jest to doÅ›Ä‡ denerwujÄ…ce, Å¼e wszystko, co przekazujemy, musi byÄ‡ rÃ³wnieÅ¼ zwrÃ³cone, jeÅ›li chcemy uÅ¼yÄ‡ tego ponownie, oprÃ³cz wszelkich danych wynikajÄ…cych z treÅ›ci funkcji, ktÃ³re rÃ³wnieÅ¼ moÅ¼emy chcieÄ‡ zwrÃ³ciÄ‡.\n\nRust pozwala nam zwracaÄ‡ wiele wartoÅ›ci za pomocÄ… krotki, jak pokazano w Listingu 4-5.\n\n<Listing number=\"4-5\" file-name=\"src/main.rs\" caption=\"Zwracanie wÅ‚asnoÅ›ci parametrÃ³w\">\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let (s2, len) = calculate_length(s1);\n\n    println!(\"DÅ‚ugoÅ›Ä‡ '{s2}' wynosi {len}.\");\n}\n\nfn calculate_length(s: String) -> (String, usize) {\n    let length = s.len(); // len() zwraca dÅ‚ugoÅ›Ä‡ String\n\n    (s, length)\n}\n```\n\n</Listing>\n\nAle to zbyt wiele ceremonii i duÅ¼o pracy dla koncepcji, ktÃ³ra powinna byÄ‡ powszechna. Na szczÄ™Å›cie Rust ma funkcjÄ™ do uÅ¼ywania wartoÅ›ci bez przenoszenia wÅ‚asnoÅ›ci: referencje.\n\n[data-types]: ch03-02-data-types.html#data-types\n[ch8]: ch08-02-strings.html\n[traits]: ch10-02-traits.html\n[derivable-traits]: appendix-03-derivable-traits.html\n[methods]: ch05-03-method-syntax.html#methods\n[paths-module-tree]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\n[drop]: ../std/ops/trait.Drop.html#tymethod.drop",
        "chapter_title": "Czym jest WÅ‚asnoÅ›Ä‡?"
    },
    {
        "file_path": "ch04-02-references-and-borrowing.md",
        "content": "## Referencje i PoÅ¼yczanie\n\nProblem z kodem krotki w Listingu 4-5 polega na tym, Å¼e musimy zwrÃ³ciÄ‡ `String` do funkcji wywoÅ‚ujÄ…cej, abyÅ›my mogli nadal uÅ¼ywaÄ‡ `String` po wywoÅ‚aniu `calculate_length`, poniewaÅ¼ `String` zostaÅ‚o przeniesione do `calculate_length`. Zamiast tego moÅ¼emy dostarczyÄ‡ referencjÄ™ do wartoÅ›ci `String`. Referencja jest jak wskaÅºnik w tym sensie, Å¼e jest to adres, za ktÃ³rym moÅ¼emy podÄ…Å¼aÄ‡, aby uzyskaÄ‡ dostÄ™p do danych przechowywanych pod tym adresem; te dane sÄ… wÅ‚asnoÅ›ciÄ… innej zmiennej. W przeciwieÅ„stwie do wskaÅºnika, referencja gwarantuje, Å¼e wskazuje na waÅ¼nÄ… wartoÅ›Ä‡ okreÅ›lonego typu przez caÅ‚y okres Å¼ycia tej referencji.\n\nOto jak zdefiniowaÄ‡ i uÅ¼yÄ‡ funkcji `calculate_length`, ktÃ³ra jako parametr przyjmuje referencjÄ™ do obiektu zamiast przejmowaÄ‡ wÅ‚asnoÅ›Ä‡ wartoÅ›ci:\n\n<Listing file-name=\"src/main.rs\">\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"DÅ‚ugoÅ›Ä‡ '{s1}' wynosi {len}.\");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\n</Listing>\n\nPo pierwsze, zauwaÅ¼, Å¼e caÅ‚y kod krotki w deklaracji zmiennej i wartoÅ›ci zwracanej funkcji zniknÄ…Å‚. Po drugie, zauwaÅ¼, Å¼e przekazujemy `&s1` do `calculate_length` i, w jej definicji, przyjmujemy `&String` zamiast `String`. Te ampersandy reprezentujÄ… referencje i pozwalajÄ… odwoÅ‚ywaÄ‡ siÄ™ do pewnej wartoÅ›ci bez przejmowania jej wÅ‚asnoÅ›ci. Rysunek 4-6 przedstawia tÄ™ koncepcjÄ™.\n\n<img alt=\"Trzy tabele: tabela dla s zawiera tylko wskaÅºnik do tabeli dla s1. Tabela dla s1 zawiera dane stosu dla s1 i wskazuje na dane ciÄ…gu na stercie.\" src=\"img/trpl04-06.svg\" class=\"center\" />\n\n<span class=\"caption\">Rysunek 4-6: Diagram `&String` `s` wskazujÄ…cego na `String` `s1`</span>\n\n> Uwaga: PrzeciwieÅ„stwem referencji za pomocÄ… `&` jest _dereferencjowanie_, ktÃ³re jest realizowane za pomocÄ… operatora dereferencji, `*`. Zobaczymy kilka zastosowaÅ„ operatora dereferencji w Rozdziale 8 i omÃ³wimy szczegÃ³Å‚y dereferencji w Rozdziale 15.\n\nPrzyjrzyjmy siÄ™ bliÅ¼ej wywoÅ‚aniu funkcji:\n\n```rust\n# fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n# \n#     println!(\"DÅ‚ugoÅ›Ä‡ '{s1}' wynosi {len}.\");\n# }\n# \n# fn calculate_length(s: &String) -> usize {\n#     s.len()\n# }\n```\n\nSkÅ‚adnia `&s1` pozwala nam utworzyÄ‡ referencjÄ™, ktÃ³ra _odnosi siÄ™_ do wartoÅ›ci `s1`, ale jej nie posiada. PoniewaÅ¼ referencja nie jest jej wÅ‚aÅ›cicielem, wartoÅ›Ä‡, na ktÃ³rÄ… wskazuje, nie zostanie usuniÄ™ta, gdy referencja przestanie byÄ‡ uÅ¼ywana.\n\nPodobnie, sygnatura funkcji uÅ¼ywa `&` do wskazania, Å¼e typ parametru `s` jest referencjÄ…. Dodajmy kilka wyjaÅ›niajÄ…cych adnotacji:\n\n```rust\n# fn main() {\n#     let s1 = String::from(\"hello\");\n# \n#     let len = calculate_length(&s1);\n# \n#     println!(\"DÅ‚ugoÅ›Ä‡ '{s1}' wynosi {len}.\");\n# }\n# \nfn calculate_length(s: &String) -> usize { // s jest referencjÄ… do String\n    s.len()\n} // Tutaj s wychodzi z zasiÄ™gu. Ale poniewaÅ¼ s nie posiada wÅ‚asnoÅ›ci tego,\n  // do czego siÄ™ odnosi, String nie jest usuwane.\n```\n\nZasiÄ™g, w ktÃ³rym zmienna `s` jest waÅ¼na, jest taki sam jak zasiÄ™g kaÅ¼dego parametru funkcji, ale wartoÅ›Ä‡ wskazywana przez referencjÄ™ nie jest usuwana, gdy `s` przestaje byÄ‡ uÅ¼ywane, poniewaÅ¼ `s` nie posiada wÅ‚asnoÅ›ci. Gdy funkcje majÄ… referencje jako parametry zamiast rzeczywistych wartoÅ›ci, nie bÄ™dziemy musieli zwracaÄ‡ wartoÅ›ci, aby oddaÄ‡ wÅ‚asnoÅ›Ä‡, poniewaÅ¼ nigdy jej nie posiadaliÅ›my.\n\nNazywamy czynnoÅ›Ä‡ tworzenia referencji _poÅ¼yczaniem_. Jak w prawdziwym Å¼yciu, jeÅ›li ktoÅ› posiada coÅ›, moÅ¼esz to od niego poÅ¼yczyÄ‡. Kiedy skoÅ„czysz, musisz to zwrÃ³ciÄ‡. Nie jesteÅ› jego wÅ‚aÅ›cicielem.\n\nWiÄ™c co siÄ™ stanie, jeÅ›li sprÃ³bujemy zmodyfikowaÄ‡ coÅ›, co poÅ¼yczamy? WyprÃ³buj kod z Listingu 4-6. Uwaga, spoiler: To nie dziaÅ‚a!\n\n<Listing number=\"4-6\" file-name=\"src/main.rs\" caption=\"PrÃ³ba modyfikacji poÅ¼yczonej wartoÅ›ci\">\n\n```rust,ignore,does_not_compile\nfn main() {\n    let s = String::from(\"hello\");\n\n    change(&s);\n}\n\nfn change(some_string: &String) {\n    some_string.push_str(\", world\");\n}\n```\n\n</Listing>\n\nOto bÅ‚Ä…d:\n\n```console\n$ cargo run\n   Compiling ownership v0.1.0 (file:///projects/ownership)\nerror[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&` reference\n --> src/main.rs:8:5\n  |\n8 |     some_string.push_str(\", world\");\n  |     ^^^^^^^^^^^ `some_string` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n  |\nhelp: consider changing this to be a mutable reference\n  |\n7 | fn change(some_string: &mut String) {\n  |                         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `ownership` (bin \"ownership\") due to 1 previous error\n```\n\nTak jak zmienne sÄ… domyÅ›lnie niezmienne, tak samo referencje. Nie wolno nam modyfikowaÄ‡ czegoÅ›, do czego mamy referencjÄ™.\n\n### Mutowalne referencje\n\nMoÅ¼emy naprawiÄ‡ kod z Listingu 4-6, aby umoÅ¼liwiÄ‡ modyfikacjÄ™ poÅ¼yczonej wartoÅ›ci za pomocÄ… kilku drobnych zmian, ktÃ³re zamiast tego uÅ¼ywajÄ… _mutowalnej referencji_:\n\n<Listing file-name=\"src/main.rs\">\n\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    change(&mut s);\n}\n\nfn change(some_string: &mut String) {\n    some_string.push_str(\", world\");\n}\n```\n\n</Listing>\n\nNajpierw zmieniamy `s` na `mut`. NastÄ™pnie tworzymy mutowalnÄ… referencjÄ™ za pomocÄ… `&mut s` w miejscu wywoÅ‚ania funkcji `change` i aktualizujemy sygnaturÄ™ funkcji, aby akceptowaÅ‚a mutowalnÄ… referencjÄ™ za pomocÄ… `some_string: &mut String`. DziÄ™ki temu bardzo jasno wynika, Å¼e funkcja `change` bÄ™dzie mutowaÄ‡ poÅ¼yczonÄ… wartoÅ›Ä‡.\n\nMutowalne referencje majÄ… jedno duÅ¼e ograniczenie: jeÅ›li masz mutowalnÄ… referencjÄ™ do wartoÅ›ci, nie moÅ¼esz mieÄ‡ Å¼adnych innych referencji do tej wartoÅ›ci. Ten kod, ktÃ³ry prÃ³buje utworzyÄ‡ dwie mutowalne referencje do `s`, zakoÅ„czy siÄ™ niepowodzeniem:\n\n<Listing file-name=\"src/main.rs\">\n\n```rust,ignore,does_not_compile\n# fn main() {\n    let mut s = String::from(\"hello\");\n\n    let r1 = &mut s;\n    let r2 = &mut s;\n\n    println!(\"{r1}, {r2}\");\n# }\n```\n\n</Listing>\n\nOto bÅ‚Ä…d:\n\n```console\n$ cargo run\n   Compiling ownership v0.1.0 (file:///projects/ownership)\nerror[E0499]: cannot borrow `s` as mutable more than once at a time\n --> src/main.rs:5:14\n  |\n4 |     let r1 = &mut s;\n  |              ------ first mutable borrow occurs here\n5 |     let r2 = &mut s;\n  |              ^^^^^^ second mutable borrow occurs here\n6 |\n7 |     println!(\"{r1}, {r2}\");\n  |                -- first borrow later used here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `ownership` (bin \"ownership\") due to 1 previous error\n```\n\nTen bÅ‚Ä…d mÃ³wi, Å¼e ten kod jest nieprawidÅ‚owy, poniewaÅ¼ nie moÅ¼emy poÅ¼yczyÄ‡ `s` jako mutowalne wiÄ™cej niÅ¼ raz w tym samym czasie. Pierwsze mutowalne poÅ¼yczenie nastÄ™puje w `r1` i musi trwaÄ‡, dopÃ³ki nie zostanie uÅ¼yte w `println!`, ale miÄ™dzy utworzeniem tej mutowalnej referencji a jej uÅ¼yciem prÃ³bowaliÅ›my utworzyÄ‡ kolejnÄ… mutowalnÄ… referencjÄ™ w `r2`, ktÃ³ra poÅ¼ycza te same dane co `r1`.\n\nOgraniczenie zapobiegajÄ…ce rÃ³wnoczesnemu posiadaniu wielu mutowalnych referencji do tych samych danych pozwala na mutacjÄ™, ale w bardzo kontrolowany sposÃ³b. Jest to coÅ›, z czym borykajÄ… siÄ™ nowi Rustaceanowie, poniewaÅ¼ wiÄ™kszoÅ›Ä‡ jÄ™zykÃ³w pozwala mutowaÄ‡, kiedy tylko chcesz. KorzyÅ›ciÄ… z tego ograniczenia jest to, Å¼e Rust moÅ¼e zapobiegaÄ‡ wyÅ›cigom danych w czasie kompilacji. _WyÅ›cig danych_ jest podobny do warunku wyÅ›cigu i wystÄ™puje, gdy zachodzÄ… te trzy zachowania:\n\n- Dwa lub wiÄ™cej wskaÅºnikÃ³w uzyskuje dostÄ™p do tych samych danych w tym samym czasie.\n- Co najmniej jeden ze wskaÅºnikÃ³w jest uÅ¼ywany do zapisu danych.\n- Nie ma mechanizmu synchronizujÄ…cego dostÄ™p do danych.\n\nWyÅ›cigi danych powodujÄ… niezdefiniowane zachowanie i mogÄ… byÄ‡ trudne do zdiagnozowania i naprawienia, gdy prÃ³bujesz je Å›ledziÄ‡ w czasie wykonania; Rust zapobiega temu problemowi, odmawiajÄ…c kompilacji kodu z wyÅ›cigami danych!\n\nJak zawsze, moÅ¼emy uÅ¼yÄ‡ nawiasÃ³w klamrowych do stworzenia nowego zasiÄ™gu, co pozwala na wiele mutowalnych referencji, ale nie _jednoczesnych_:\n\n```rust\n# fn main() {\n    let mut s = String::from(\"hello\");\n\n    {\n        let r1 = &mut s;\n    } // r1 wychodzi z zasiÄ™gu tutaj, wiÄ™c moÅ¼emy stworzyÄ‡ nowÄ… referencjÄ™ bez problemÃ³w.\n\n    let r2 = &mut s;\n# }\n```\n\nRust narzuca podobnÄ… zasadÄ™ dla Å‚Ä…czenia mutowalnych i niemutowalnych referencji. Ten kod powoduje bÅ‚Ä…d:\n\n```rust,ignore,does_not_compile\n# fn main() {\n    let mut s = String::from(\"hello\");\n\n    let r1 = &s; // bez problemu\n    let r2 = &s; // bez problemu\n    let r3 = &mut s; // DUÅ»Y PROBLEM\n\n    println!(\"{r1}, {r2}, and {r3}\");\n# }\n```\n\nOto bÅ‚Ä…d:\n\n```console\n$ cargo run\n   Compiling ownership v0.1.0 (file:///projects/ownership)\nerror[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable\n --> src/main.rs:6:14\n  |\n4 |     let r1 = &s; // no problem\n  |              -- immutable borrow occurs here\n5 |     let r2 = &s; // no problem\n6 |     let r3 = &mut s; // BIG PROBLEM\n  |              ^^^^^^ mutable borrow occurs here\n7 |\n8 |     println!(\"{r1}, {r2}, and {r3}\");\n  |                -- immutable borrow later used here\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `ownership` (bin \"ownership\") due to 1 previous error\n```\n\nUff! _Nie_ moÅ¼emy rÃ³wnieÅ¼ mieÄ‡ mutowalnej referencji, gdy mamy niezmiennÄ… referencjÄ™ do tej samej wartoÅ›ci.\n\nUÅ¼ytkownicy referencji niezmiennej nie spodziewajÄ… siÄ™, Å¼e wartoÅ›Ä‡ nagle siÄ™ zmieni! JednakÅ¼e, wiele referencji niezmiennych jest dozwolonych, poniewaÅ¼ nikt, kto tylko odczytuje dane, nie ma moÅ¼liwoÅ›ci wpÅ‚ywania na odczytywanie danych przez nikogo innego.\n\nZauwaÅ¼, Å¼e zasiÄ™g referencji rozpoczyna siÄ™ w miejscu jej wprowadzenia i trwa do ostatniego uÅ¼ycia tej referencji. Na przykÅ‚ad, ten kod skompiluje siÄ™, poniewaÅ¼ ostatnie uÅ¼ycie referencji niezmiennych jest w `println!`, zanim zostanie wprowadzona referencja mutowalna:\n\n```rust\n# fn main() {\n    let mut s = String::from(\"hello\");\n\n    let r1 = &s; // bez problemu\n    let r2 = &s; // bez problemu\n    println!(\"{r1} i {r2}\");\n    // Zmienne r1 i r2 nie bÄ™dÄ… uÅ¼ywane po tym punkcie.\n\n    let r3 = &mut s; // bez problemu\n    println!(\"{r3}\");\n# }\n```\n\nZasiÄ™gi niezmiennych referencji `r1` i `r2` koÅ„czÄ… siÄ™ po `println!`, gdzie sÄ… ostatnio uÅ¼ywane, co nastÄ™puje przed utworzeniem mutowalnej referencji `r3`. Te zasiÄ™gi nie nakÅ‚adajÄ… siÄ™, wiÄ™c ten kod jest dozwolony: kompilator moÅ¼e stwierdziÄ‡, Å¼e referencja nie jest juÅ¼ uÅ¼ywana w punkcie przed koÅ„cem zasiÄ™gu.\n\nChociaÅ¼ bÅ‚Ä™dy poÅ¼yczania mogÄ… czasem frustrowaÄ‡, pamiÄ™taj, Å¼e to kompilator Rust wskazuje potencjalny bÅ‚Ä…d wczeÅ›nie (w czasie kompilacji, a nie w czasie wykonania) i pokazuje dokÅ‚adnie, gdzie leÅ¼y problem. Wtedy nie musisz szukaÄ‡ przyczyny, dla ktÃ³rej twoje dane nie sÄ… tym, czego siÄ™ spodziewaÅ‚eÅ›.\n\n### ZwisajÄ…ce referencje\n\nW jÄ™zykach ze wskaÅºnikami Å‚atwo jest bÅ‚Ä™dnie utworzyÄ‡ _zwisajÄ…cy wskaÅºnik_ â€” wskaÅºnik, ktÃ³ry odwoÅ‚uje siÄ™ do miejsca w pamiÄ™ci, ktÃ³re mogÅ‚o zostaÄ‡ przekazane komuÅ› innemu â€” zwalniajÄ…c czÄ™Å›Ä‡ pamiÄ™ci, jednoczeÅ›nie zachowujÄ…c wskaÅºnik do tej pamiÄ™ci. W Rust, natomiast, kompilator gwarantuje, Å¼e referencje nigdy nie bÄ™dÄ… zwisajÄ…cymi referencjami: jeÅ›li masz referencjÄ™ do jakichÅ› danych, kompilator zapewni, Å¼e dane te nie wyjdÄ… poza zasiÄ™g przed referencjÄ… do nich.\n\nSprÃ³bujmy utworzyÄ‡ zwisajÄ…cÄ… referencjÄ™, aby zobaczyÄ‡, jak Rust im zapobiega, sygnalizujÄ…c bÅ‚Ä…d kompilacji:\n\n<Listing file-name=\"src/main.rs\">\n\n```rust,ignore,does_not_compile\nfn main() {\n    let reference_to_nothing = dangle();\n}\n\nfn dangle() -> &String {\n    let s = String::from(\"hello\");\n\n    &s\n}\n```\n\n</Listing>\n\nOto bÅ‚Ä…d:\n\n```console\n$ cargo run\n   Compiling ownership v0.1.0 (file:///projects/ownership)\nerror[E0106]: missing lifetime specifier\n --> src/main.rs:5:16\n  |\n5 | fn dangle() -> &String {\n  |                ^ expected named lifetime parameter\n  |\n  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\nhelp: consider using the `'static` lifetime, but this is uncommon unless you're returning a borrowed value from a `const` or a `static`\n  |\n5 | fn dangle() -> &'static String {\n  |                 +++++++\nhelp: instead, you are more likely to want to return an owned value\n  |\n5 - fn dangle() -> &String {\n5 + fn dangle() -> String {\n  |\n\nFor more information about this error, try `rustc --explain E0106`.\nerror: could not compile `ownership` (bin \"ownership\") due to 1 previous error\n```\n\nTen komunikat o bÅ‚Ä™dzie odnosi siÄ™ do funkcji, ktÃ³rej jeszcze nie omÃ³wiliÅ›my: czasÃ³w Å¼ycia. SzczegÃ³Å‚owo omÃ³wimy czasy Å¼ycia w Rozdziale 10. Ale jeÅ›li zignorujesz czÄ™Å›ci dotyczÄ…ce czasÃ³w Å¼ycia, komunikat zawiera klucz do tego, dlaczego ten kod jest problemem:\n\n```text\ntyp zwracany przez tÄ™ funkcjÄ™ zawiera wartoÅ›Ä‡ poÅ¼yczonÄ…, ale nie ma wartoÅ›ci,\nz ktÃ³rej moÅ¼na jÄ… poÅ¼yczyÄ‡\n```\n\nPrzyjrzyjmy siÄ™ bliÅ¼ej, co dokÅ‚adnie dzieje siÄ™ na kaÅ¼dym etapie naszego kodu `dangle`:\n\n<Listing file-name=\"src/main.rs\">\n\n```rust,ignore,does_not_compile\n# fn main() {\n#     let reference_to_nothing = dangle();\n# }\n# \nfn dangle() -> &String { // dangle zwraca referencjÄ™ do String\n\n    let s = String::from(\"hello\"); // s to nowy String\n\n    &s // zwracamy referencjÄ™ do String, s\n} // Tutaj s wychodzi z zasiÄ™gu i jest usuwane, wiÄ™c jego pamiÄ™Ä‡ znika.\n  // NiebezpieczeÅ„stwo!\n```\n\n</Listing>\n\nPoniewaÅ¼ `s` jest tworzone wewnÄ…trz `dangle`, kiedy kod `dangle` siÄ™ zakoÅ„czy, `s` zostanie dealokowane. Ale prÃ³bowaliÅ›my zwrÃ³ciÄ‡ do niego referencjÄ™. Oznacza to, Å¼e ta referencja wskazywaÅ‚aby na nieprawidÅ‚owy `String`. To niedobrze! Rust nam na to nie pozwoli.\n\nRozwiÄ…zaniem jest bezpoÅ›rednie zwrÃ³cenie `String`:\n\n```rust\n# fn main() {\n#     let string = no_dangle();\n# }\n# \nfn no_dangle() -> String {\n    let s = String::from(\"hello\");\n\n    s\n}\n```\n\nTo dziaÅ‚a bez problemÃ³w. WÅ‚asnoÅ›Ä‡ zostaje przeniesiona, a nic nie jest dealokowane.\n\n### Zasady referencji\n\nPodsumujmy, co omÃ³wiliÅ›my na temat referencji:\n\n- W dowolnym momencie moÅ¼esz mieÄ‡ _albo_ jednÄ… mutowalnÄ… referencjÄ™ _albo_ dowolnÄ… liczbÄ™ niemutowalnych referencji.\n- Referencje muszÄ… byÄ‡ zawsze waÅ¼ne.\n\nNastÄ™pnie przyjrzymy siÄ™ innemu rodzajowi referencji: wycinkom (slices).",
        "chapter_title": "Referencje i PoÅ¼yczanie"
    },
    {
        "file_path": "ch04-03-slices.md",
        "content": "## Typ Wycinak (Slice)\n\n_Wycinki (Slices)_ pozwalajÄ… odwoÅ‚ywaÄ‡ siÄ™ do ciÄ…gÅ‚ej sekwencji elementÃ³w w [kolekcji](ch08-00-common-collections.md)<!-- ignore -->. Wycinek jest rodzajem referencji, wiÄ™c nie posiada wÅ‚asnoÅ›ci.\n\nOto maÅ‚y problem programistyczny: Napisz funkcjÄ™, ktÃ³ra przyjmuje ciÄ…g sÅ‚Ã³w oddzielonych spacjami i zwraca pierwsze sÅ‚owo, ktÃ³re znajdzie w tym ciÄ…gu. JeÅ›li funkcja nie znajdzie spacji w ciÄ…gu, caÅ‚y ciÄ…g musi byÄ‡ jednym sÅ‚owem, wiÄ™c powinien zostaÄ‡ zwrÃ³cony caÅ‚y ciÄ…g.\n\n> Uwaga: Dla celÃ³w wprowadzenia wycinkÃ³w, w tej sekcji zakÅ‚adamy tylko ASCII; bardziej szczegÃ³Å‚owe omÃ³wienie obsÅ‚ugi UTF-8 znajduje siÄ™ w sekcji [â€Przechowywanie tekstu kodowanego w UTF-8 za pomocÄ… ciÄ…gÃ³w znakÃ³wâ€][strings]<!-- ignore --> w Rozdziale 8.\n\nPrzyjrzyjmy siÄ™, jak napisalibyÅ›my sygnaturÄ™ tej funkcji bez uÅ¼ycia wycinkÃ³w, aby zrozumieÄ‡ problem, ktÃ³ry wycinki rozwiÄ…Å¼Ä…:\n\n```rust,ignore\nfn first_word(s: &String) -> ?\n```\n\nFunkcja `first_word` ma parametr typu `&String`. Nie potrzebujemy wÅ‚asnoÅ›ci, wiÄ™c to jest w porzÄ…dku. (W idiomatycznym Rust, funkcje nie przejmujÄ… wÅ‚asnoÅ›ci swoich argumentÃ³w, chyba Å¼e jest to konieczne, a powody tego stanÄ… siÄ™ jasne, gdy bÄ™dziemy kontynuowaÄ‡.) Ale co powinniÅ›my zwrÃ³ciÄ‡? Nie mamy tak naprawdÄ™ sposobu, aby mÃ³wiÄ‡ o _czÄ™Å›ci_ ciÄ…gu. Jednak moglibyÅ›my zwrÃ³ciÄ‡ indeks koÅ„ca sÅ‚owa, wskazany przez spacjÄ™. SprÃ³bujmy tego, jak pokazano w Listingu 4-7.\n\n<Listing number=\"4-7\" file-name=\"src/main.rs\" caption=\"Funkcja `first_word`, ktÃ³ra zwraca wartoÅ›Ä‡ indeksu bajtowego do parametru `String`\">\n\n```rust\nfn first_word(s: &String) -> usize {\n    let bytes = s.as_bytes();\n\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return i;\n        }\n    }\n\n    s.len()\n}\n# \n# fn main() {}\n```\n\n</Listing>\n\nPoniewaÅ¼ musimy przejÅ›Ä‡ przez `String` element po elemencie i sprawdziÄ‡, czy wartoÅ›Ä‡ jest spacjÄ…, przeksztaÅ‚cimy nasz `String` w tablicÄ™ bajtÃ³w za pomocÄ… metody `as_bytes`.\n\n```rust,ignore\n# fn first_word(s: &String) -> usize {\n    let bytes = s.as_bytes();\n# \n#     for (i, &item) in bytes.iter().enumerate() {\n#         if item == b' ' {\n#             return i;\n#         }\n#     }\n# \n#     s.len()\n# }\n# \n# fn main() {}\n```\n\nNastÄ™pnie, tworzymy iterator po tablicy bajtÃ³w uÅ¼ywajÄ…c metody `iter`:\n\n```rust,ignore\n# fn first_word(s: &String) -> usize {\n#     let bytes = s.as_bytes();\n# \n    for (i, &item) in bytes.iter().enumerate() {\n#         if item == b' ' {\n#             return i;\n#         }\n#     }\n# \n#     s.len()\n# }\n# \n# fn main() {}\n```\n\nIteratory omÃ³wimy bardziej szczegÃ³Å‚owo w [Rozdziale 13][ch13]<!-- ignore -->. Na razie wystarczy wiedzieÄ‡, Å¼e `iter` to metoda, ktÃ³ra zwraca kaÅ¼dy element w kolekcji, a `enumerate` opakowuje wynik `iter` i zwraca kaÅ¼dy element jako czÄ™Å›Ä‡ krotki. Pierwszy element krotki zwrÃ³conej z `enumerate` to indeks, a drugi element to referencja do elementu. Jest to nieco wygodniejsze niÅ¼ samodzielne obliczanie indeksu.\n\nPoniewaÅ¼ metoda `enumerate` zwraca krotkÄ™, moÅ¼emy uÅ¼yÄ‡ wzorcÃ³w do dekonstrukcji tej krotki. WiÄ™cej o wzorcach omÃ³wimy w [Rozdziale 6][ch6]<!-- ignore -->. W pÄ™tli `for` okreÅ›lamy wzorzec, ktÃ³ry ma `i` dla indeksu w krotce i `&item` dla pojedynczego bajtu w krotce. PoniewaÅ¼ otrzymujemy referencjÄ™ do elementu z `.iter().enumerate()`, uÅ¼ywamy `&` we wzorcu.\n\nWewnÄ…trz pÄ™tli `for` szukamy bajtu reprezentujÄ…cego spacjÄ™, uÅ¼ywajÄ…c skÅ‚adni literaÅ‚u bajtowego. JeÅ›li znajdziemy spacjÄ™, zwracamy pozycjÄ™. W przeciwnym razie zwracamy dÅ‚ugoÅ›Ä‡ ciÄ…gu, uÅ¼ywajÄ…c `s.len()`.\n\n```rust,ignore\n# fn first_word(s: &String) -> usize {\n#     let bytes = s.as_bytes();\n# \n#     for (i, &item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return i;\n        }\n    }\n\n    s.len()\n# }\n# \n# fn main() {}\n```\n\nMamy teraz sposÃ³b na znalezienie indeksu koÅ„ca pierwszego sÅ‚owa w ciÄ…gu, ale jest problem. Zwracamy samo `usize`, ale jest to znaczÄ…ca liczba tylko w kontekÅ›cie `&String`. Innymi sÅ‚owy, poniewaÅ¼ jest to oddzielna wartoÅ›Ä‡ od `String`, nie ma gwarancji, Å¼e bÄ™dzie ona nadal waÅ¼na w przyszÅ‚oÅ›ci. RozwaÅ¼ program z Listingu 4-8, ktÃ³ry uÅ¼ywa funkcji `first_word` z Listingu 4-7.\n\n<Listing number=\"4-8\" file-name=\"src/main.rs\" caption=\"Przechowywanie wyniku wywoÅ‚ania funkcji `first_word`, a nastÄ™pnie zmiana zawartoÅ›ci `String`\">\n\n```rust\n# fn first_word(s: &String) -> usize {\n#     let bytes = s.as_bytes();\n# \n#     for (i, &item) in bytes.iter().enumerate() {\n#         if item == b' ' {\n#             return i;\n#         }\n#     }\n# \n#     s.len()\n# }\n# \nfn main() {\n    let mut s = String::from(\"hello world\");\n\n    let word = first_word(&s); // word otrzyma wartoÅ›Ä‡ 5\n\n    s.clear(); // to oprÃ³Å¼nia String, sprawiajÄ…c, Å¼e staje siÄ™ rÃ³wny \"\"\n\n    // word nadal ma wartoÅ›Ä‡ 5 tutaj, ale s nie ma juÅ¼ Å¼adnej zawartoÅ›ci, ktÃ³rej moglibyÅ›my\n    // sensownie uÅ¼yÄ‡ z wartoÅ›ciÄ… 5, wiÄ™c word jest teraz caÅ‚kowicie niewaÅ¼ne!\n}\n```\n\n</Listing>\n\nTen program kompiluje siÄ™ bez Å¼adnych bÅ‚Ä™dÃ³w i skompilowaÅ‚by siÄ™ rÃ³wnieÅ¼, gdybyÅ›my uÅ¼yli `word` po wywoÅ‚aniu `s.clear()`. PoniewaÅ¼ `word` w Å¼aden sposÃ³b nie jest powiÄ…zane ze stanem `s`, `word` nadal zawiera wartoÅ›Ä‡ `5`. MoglibyÅ›my uÅ¼yÄ‡ tej wartoÅ›ci `5` ze zmiennÄ… `s`, aby sprÃ³bowaÄ‡ wyodrÄ™bniÄ‡ pierwsze sÅ‚owo, ale byÅ‚by to bÅ‚Ä…d, poniewaÅ¼ zawartoÅ›Ä‡ `s` zmieniÅ‚a siÄ™, odkÄ…d zapisaliÅ›my `5` w `word`.\n\nMartwienie siÄ™ o to, Å¼e indeks w `word` przestaje byÄ‡ zsynchronizowany z danymi w `s`, jest uciÄ…Å¼liwe i podatne na bÅ‚Ä™dy! ZarzÄ…dzanie tymi indeksami jest jeszcze bardziej kruche, jeÅ›li napiszemy funkcjÄ™ `second_word`. Jej sygnatura musiaÅ‚aby wyglÄ…daÄ‡ tak:\n\n```rust,ignore\nfn second_word(s: &String) -> (usize, usize) {\n```\n\nTeraz Å›ledzimy indeks poczÄ…tkowy _i_ koÅ„cowy, i mamy jeszcze wiÄ™cej wartoÅ›ci, ktÃ³re zostaÅ‚y obliczone na podstawie danych w okreÅ›lonym stanie, ale w ogÃ³le nie sÄ… z tym stanem powiÄ…zane. Mamy trzy niepowiÄ…zane zmienne, ktÃ³re muszÄ… byÄ‡ zsynchronizowane.\n\nNa szczÄ™Å›cie Rust ma rozwiÄ…zanie tego problemu: wycinki ciÄ…gÃ³w znakÃ³w (string slices).\n\n### Wycinki ciÄ…gÃ³w znakÃ³w (String Slices)\n\n_Wycinek ciÄ…gu znakÃ³w_ to referencja do ciÄ…gÅ‚ej sekwencji elementÃ³w `String` i wyglÄ…da tak:\n\n```rust\n# fn main() {\n    let s = String::from(\"hello world\");\n\n    let hello = &s[0..5];\n    let world = &s[6..11];\n# }\n```\n\nZamiast referencji do caÅ‚ego `String`, `hello` jest referencjÄ… do fragmentu `String`, okreÅ›lonego dodatkowym fragmentem `[0..5]`. Wycinki tworzymy za pomocÄ… zakresu w nawiasach kwadratowych, okreÅ›lajÄ…c `[indeks_poczÄ…tkowy..indeks_koÅ„cowy]`, gdzie _`indeks_poczÄ…tkowy`_ to pierwsza pozycja w wycinku, a _`indeks_koÅ„cowy`_ to jeden wiÄ™cej niÅ¼ ostatnia pozycja w wycinku. WewnÄ™trznie struktura danych wycinka przechowuje pozycjÄ™ poczÄ…tkowÄ… i dÅ‚ugoÅ›Ä‡ wycinka, co odpowiada _`indeks_koÅ„cowy`_ minus _`indeks_poczÄ…tkowy`_. Zatem w przypadku `let world = &s[6..11];`, `world` byÅ‚by wycinkiem, ktÃ³ry zawiera wskaÅºnik do bajtu o indeksie 6 w `s` z wartoÅ›ciÄ… dÅ‚ugoÅ›ci `5`.\n\nRysunek 4-7 przedstawia to na diagramie.\n\n<img alt=\"Trzy tabele: tabela reprezentujÄ…ca dane stosu s, ktÃ³ra wskazuje na bajt o indeksie 0 w tabeli danych ciÄ…gu &quot;hello world&quot; na stercie. Trzecia tabela reprezentuje dane stosu wycinka world, ktÃ³ra ma wartoÅ›Ä‡ dÅ‚ugoÅ›ci 5 i wskazuje na bajt 6 tabeli danych sterty.\" src=\"img/trpl04-07.svg\" class=\"center\" style=\"width: 50%;\" />\n\n<span class=\"caption\">Rysunek 4-7: Wycinek ciÄ…gu znakÃ³w odnoszÄ…cy siÄ™ do czÄ™Å›ci `String`</span>\n\nDziÄ™ki skÅ‚adni zakresu `..` w Rust, jeÅ›li chcesz zaczÄ…Ä‡ od indeksu 0, moÅ¼esz pominÄ…Ä‡ wartoÅ›Ä‡ przed dwoma kropkami. Innymi sÅ‚owy, te sÄ… rÃ³wnowaÅ¼ne:\n\n```rust\nlet s = String::from(\"hello\");\n\nlet slice = &s[0..2];\nlet slice = &s[..2];\n```\n\nAnalogicznie, jeÅ›li twÃ³j wycinek zawiera ostatni bajt `String`, moÅ¼esz pominÄ…Ä‡ koÅ„cowÄ… liczbÄ™. Oznacza to, Å¼e te sÄ… rÃ³wnowaÅ¼ne:\n\n```rust\nlet s = String::from(\"hello\");\n\nlet len = s.len();\n\nlet slice = &s[3..len];\nlet slice = &s[3..];\n```\n\nMoÅ¼esz rÃ³wnieÅ¼ pominÄ…Ä‡ obie wartoÅ›ci, aby utworzyÄ‡ wycinek caÅ‚ego ciÄ…gu. W ten sposÃ³b te sÄ… rÃ³wnowaÅ¼ne:\n\n```rust\nlet s = String::from(\"hello\");\n\nlet len = s.len();\n\nlet slice = &s[0..len];\nlet slice = &s[..];\n```\n\n> Uwaga: Indeksy zakresu wycinka ciÄ…gu muszÄ… wystÄ™powaÄ‡ na prawidÅ‚owych granicach znakÃ³w UTF-8. JeÅ›li sprÃ³bujesz utworzyÄ‡ wycinek ciÄ…gu w Å›rodku znaku wielobajtowego, program zakoÅ„czy siÄ™ bÅ‚Ä™dem.\n\nMajÄ…c na uwadze wszystkie te informacje, przepiszmy `first_word`, aby zwracaÅ‚o wycinek. Typ, ktÃ³ry oznacza â€wycinek ciÄ…gu znakÃ³wâ€, jest zapisywany jako `&str`:\n\n<Listing file-name=\"src/main.rs\">\n\n```rust\nfn first_word(s: &String) -> &str {\n    let bytes = s.as_bytes();\n\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &s[0..i];\n        }\n    }\n\n    &s[..]\n}\n# \n# fn main() {}\n```\n\n</Listing>\n\nIndeks koÅ„ca sÅ‚owa uzyskujemy w ten sam sposÃ³b, jak w Listingu 4-7, szukajÄ…c pierwszego wystÄ…pienia spacji. Gdy znajdziemy spacjÄ™, zwracamy wycinek ciÄ…gu, uÅ¼ywajÄ…c poczÄ…tku ciÄ…gu i indeksu spacji jako indeksÃ³w poczÄ…tkowego i koÅ„cowego.\n\nTeraz, gdy wywoÅ‚ujemy `first_word`, otrzymujemy jednÄ… wartoÅ›Ä‡, ktÃ³ra jest powiÄ…zana z danymi podstawowymi. WartoÅ›Ä‡ ta skÅ‚ada siÄ™ z referencji do punktu poczÄ…tkowego wycinka i liczby elementÃ³w w wycinku.\n\nZwracanie wycinka dziaÅ‚aÅ‚oby rÃ³wnieÅ¼ dla funkcji `second_word`:\n\n```rust,ignore\nfn second_word(s: &String) -> &str {\n```\n\nMamy teraz prosty interfejs API, ktÃ³ry jest znacznie trudniejszy do popsucia, poniewaÅ¼ kompilator zapewni, Å¼e referencje do `String` pozostanÄ… waÅ¼ne. PamiÄ™tasz bÅ‚Ä…d w programie z Listingu 4-8, kiedy uzyskaliÅ›my indeks koÅ„ca pierwszego sÅ‚owa, ale potem wyczyÅ›ciliÅ›my ciÄ…g, wiÄ™c nasz indeks byÅ‚ nieprawidÅ‚owy? Ten kod byÅ‚ logicznie niepoprawny, ale nie wykazywaÅ‚ Å¼adnych natychmiastowych bÅ‚Ä™dÃ³w. Problemy pojawiÅ‚yby siÄ™ pÃ³Åºniej, gdybyÅ›my nadal prÃ³bowali uÅ¼ywaÄ‡ indeksu pierwszego sÅ‚owa z oprÃ³Å¼nionym ciÄ…giem. Wycinki uniemoÅ¼liwiajÄ… ten bÅ‚Ä…d i pozwalajÄ… nam znacznie wczeÅ›niej dowiedzieÄ‡ siÄ™, Å¼e mamy problem z naszym kodem. UÅ¼ycie wersji `first_word` z wycinkiem spowoduje bÅ‚Ä…d kompilacji:\n\n<Listing file-name=\"src/main.rs\">\n\n```rust,ignore,does_not_compile\n# fn first_word(s: &String) -> &str {\n#     let bytes = s.as_bytes();\n# \n#     for (i, &item) in bytes.iter().enumerate() {\n#         if item == b' ' {\n#             return &s[0..i];\n#         }\n#     }\n# \n#     &s[..]\n# }\n# \nfn main() {\n    let mut s = String::from(\"hello world\");\n\n    let word = first_word(&s);\n\n    s.clear(); // bÅ‚Ä…d!\n\n    println!(\"pierwsze sÅ‚owo to: {word}\");\n}\n```\n\n</Listing>\n\nOto bÅ‚Ä…d kompilatora:\n\n```console\n$ cargo run\n   Compiling ownership v0.1.0 (file:///projects/ownership)\nerror[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable\n  --> src/main.rs:18:5\n   |\n16 |     let word = first_word(&s);\n   |                           -- immutable borrow occurs here\n17 |\n18 |     s.clear(); // error!\n   |     ^^^^^^^^^ mutable borrow occurs here\n19 |\n20 |     println!(\"the first word is: {word}\");\n   |                                   ---- immutable borrow later used here\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `ownership` (bin \"ownership\") due to 1 previous error\n```\n\nPrzypomnij sobie z zasad poÅ¼yczania, Å¼e jeÅ›li mamy niezmiennÄ… referencjÄ™ do czegoÅ›, nie moÅ¼emy rÃ³wnieÅ¼ wziÄ…Ä‡ mutowalnej referencji. PoniewaÅ¼ `clear` musi skrÃ³ciÄ‡ `String`, potrzebuje mutowalnej referencji. `println!` po wywoÅ‚aniu `clear` uÅ¼ywa referencji w `word`, wiÄ™c referencja niezmienna musi byÄ‡ nadal aktywna w tym punkcie. Rust zabrania istnienia mutowalnej referencji w `clear` i niezmiennej referencji w `word` w tym samym czasie, a kompilacja koÅ„czy siÄ™ niepowodzeniem. Rust nie tylko uÅ‚atwiÅ‚ nam korzystanie z API, ale takÅ¼e wyeliminowaÅ‚ caÅ‚Ä… klasÄ™ bÅ‚Ä™dÃ³w w czasie kompilacji!\n\n<a id=\"string-literals-are-slices\"></a>\n\n#### LiteraÅ‚y ciÄ…gÃ³w znakÃ³w jako wycinki\n\nPrzypomnijmy, Å¼e mÃ³wiliÅ›my o literaÅ‚ach ciÄ…gÃ³w znakÃ³w przechowywanych wewnÄ…trz pliku binarnego. Teraz, gdy wiemy o wycinkach, moÅ¼emy wÅ‚aÅ›ciwie zrozumieÄ‡ literaÅ‚y ciÄ…gÃ³w znakÃ³w:\n\n```rust\nlet s = \"Hello, world!\";\n```\n\nTyp `s` to `&str`: jest to wycinek wskazujÄ…cy na ten konkretny punkt w pliku binarnym. Jest to rÃ³wnieÅ¼ powÃ³d, dla ktÃ³rego literaÅ‚y ciÄ…gÃ³w znakÃ³w sÄ… niezmienne; `&str` to niezmienna referencja.\n\n#### Wycinki ciÄ…gÃ³w znakÃ³w jako parametry\n\nWiedza o tym, Å¼e moÅ¼na tworzyÄ‡ wycinki z literaÅ‚Ã³w i wartoÅ›ci `String`, prowadzi nas do jeszcze jednego ulepszenia funkcji `first_word`, a mianowicie jej sygnatury:\n\n```rust,ignore\nfn first_word(s: &String) -> &str {\n```\n\nBardziej doÅ›wiadczony Rustacean napisaÅ‚by sygnaturÄ™ pokazanÄ… w Listingu 4-9 zamiast niej, poniewaÅ¼ pozwala to nam uÅ¼ywaÄ‡ tej samej funkcji zarÃ³wno dla wartoÅ›ci `&String`, jak i dla wartoÅ›ci `&str`.\n\n<Listing number=\"4-9\" caption=\"Ulepszanie funkcji `first_word` poprzez uÅ¼ycie wycinka ciÄ…gu znakÃ³w dla typu parametru `s`\">\n\n```rust,ignore\nfn first_word(s: &str) -> &str {\n#     let bytes = s.as_bytes();\n# \n#     for (i, &item) in bytes.iter().enumerate() {\n#         if item == b' ' {\n#             return &s[0..i];\n#         }\n#     }\n# \n#     &s[..]\n# }\n# \n# fn main() {\n#     let my_string = String::from(\"hello world\");\n# \n#     // `first_word` dziaÅ‚a na wycinkach `String`Ã³w, czÄ™Å›ciowych lub caÅ‚ych.\n#     let word = first_word(&my_string[0..6]);\n#     let word = first_word(&my_string[..]);\n#     // `first_word` dziaÅ‚a rÃ³wnieÅ¼ na referencjach do `String`Ã³w, ktÃ³re sÄ… rÃ³wnowaÅ¼ne\n#     // z caÅ‚ymi wycinkami `String`Ã³w.\n#     let word = first_word(&my_string);\n# \n#     let my_string_literal = \"hello world\";\n# \n#     // `first_word` dziaÅ‚a na wycinkach literaÅ‚Ã³w ciÄ…gu znakÃ³w, czÄ™Å›ciowych lub\n#     // caÅ‚ych.\n#     let word = first_word(&my_string_literal[0..6]);\n#     let word = first_word(&my_string_literal[..]);\n# \n#     // PoniewaÅ¼ literaÅ‚y ciÄ…gu znakÃ³w *sÄ…* juÅ¼ wycinkami ciÄ…gu znakÃ³w,\n#     // to rÃ³wnieÅ¼ dziaÅ‚a, bez skÅ‚adni wycinkÃ³w!\n#     let word = first_word(my_string_literal);\n# }\n```\n\n</Listing>\n\nJeÅ›li mamy wycinek ciÄ…gu znakÃ³w, moÅ¼emy go przekazaÄ‡ bezpoÅ›rednio. JeÅ›li mamy `String`, moÅ¼emy przekazaÄ‡ wycinek `String` lub referencjÄ™ do `String`. Ta elastycznoÅ›Ä‡ wykorzystuje konwersje dereferencji, cechÄ™, ktÃ³rÄ… omÃ³wimy w sekcji [â€UÅ¼ywanie konwersji dereferencji w funkcjach i metodachâ€][deref-coercions]<!-- ignore --> w Rozdziale 15.\n\nDefiniowanie funkcji, ktÃ³ra przyjmuje wycinek ciÄ…gu znakÃ³w zamiast referencji do `String`, sprawia, Å¼e nasze API jest bardziej ogÃ³lne i uÅ¼yteczne bez utraty Å¼adnej funkcjonalnoÅ›ci:\n\n<Listing file-name=\"src/main.rs\">\n\n```rust\n# fn first_word(s: &str) -> &str {\n#     let bytes = s.as_bytes();\n# \n#     for (i, &item) in bytes.iter().enumerate() {\n#         if item == b' ' {\n#             return &s[0..i];\n#         }\n#     }\n# \n#     &s[..]\n# }\n# \nfn main() {\n    let my_string = String::from(\"hello world\");\n\n    // `first_word` dziaÅ‚a na wycinkach `String`Ã³w, czÄ™Å›ciowych lub caÅ‚ych.\n    let word = first_word(&my_string[0..6]);\n    let word = first_word(&my_string[..]);\n    // `first_word` dziaÅ‚a rÃ³wnieÅ¼ na referencjach do `String`Ã³w, ktÃ³re sÄ… rÃ³wnowaÅ¼ne\n    // z caÅ‚ymi wycinkami `String`Ã³w.\n    let word = first_word(&my_string);\n\n    let my_string_literal = \"hello world\";\n\n    // `first_word` dziaÅ‚a na wycinkach literaÅ‚Ã³w ciÄ…gu znakÃ³w, czÄ™Å›ciowych lub\n    // caÅ‚ych.\n    let word = first_word(&my_string_literal[0..6]);\n    let word = first_word(&my_string_literal[..]);\n\n    // PoniewaÅ¼ literaÅ‚y ciÄ…gu znakÃ³w *sÄ…* juÅ¼ wycinkami ciÄ…gu znakÃ³w,\n    // to rÃ³wnieÅ¼ dziaÅ‚a, bez skÅ‚adni wycinkÃ³w!\n    let word = first_word(my_string_literal);\n}\n```\n\n</Listing>\n\n### Inne wycinki\n\nWycinki ciÄ…gÃ³w znakÃ³w, jak moÅ¼na sobie wyobraziÄ‡, sÄ… specyficzne dla ciÄ…gÃ³w. Ale istnieje rÃ³wnieÅ¼ bardziej ogÃ³lny typ wycinka. RozwaÅ¼my tÄ™ tablicÄ™:\n\n```rust\nlet a = [1, 2, 3, 4, 5];\n```\n\nTak samo jak moÅ¼emy chcieÄ‡ odwoÅ‚aÄ‡ siÄ™ do czÄ™Å›ci ciÄ…gu, moÅ¼emy chcieÄ‡ odwoÅ‚aÄ‡ siÄ™ do czÄ™Å›ci tablicy. ZrobilibyÅ›my to w ten sposÃ³b:\n\n```rust\nlet a = [1, 2, 3, 4, 5];\n\nlet slice = &a[1..3];\n\nassert_eq!(slice, &[2, 3]);\n```\n\nTen wycinek ma typ `&[i32]`. DziaÅ‚a tak samo jak wycinki ciÄ…gÃ³w, przechowujÄ…c referencjÄ™ do pierwszego elementu i dÅ‚ugoÅ›Ä‡. BÄ™dziesz uÅ¼ywaÄ‡ tego rodzaju wycinkÃ³w dla wszelkiego rodzaju innych kolekcji. Te kolekcje omÃ³wimy szczegÃ³Å‚owo, gdy bÄ™dziemy mÃ³wiÄ‡ o wektorach w Rozdziale 8.\n\n## Podsumowanie\n\nKoncepcje wÅ‚asnoÅ›ci, poÅ¼yczania i wycinkÃ³w zapewniajÄ… bezpieczeÅ„stwo pamiÄ™ci w programach Rust w czasie kompilacji. JÄ™zyk Rust daje kontrolÄ™ nad wykorzystaniem pamiÄ™ci w taki sam sposÃ³b, jak inne jÄ™zyki programowania systemowego. Ale to, Å¼e wÅ‚aÅ›ciciel danych automatycznie czyÅ›ci te dane, gdy wÅ‚aÅ›ciciel wychodzi poza zasiÄ™g, oznacza, Å¼e nie musisz pisaÄ‡ i debugowaÄ‡ dodatkowego kodu, aby uzyskaÄ‡ tÄ™ kontrolÄ™.\n\nWÅ‚asnoÅ›Ä‡ wpÅ‚ywa na dziaÅ‚anie wielu innych czÄ™Å›ci Rust, wiÄ™c bÄ™dziemy rozmawiaÄ‡ o tych koncepcjach w dalszej czÄ™Å›ci ksiÄ…Å¼ki. PrzejdÅºmy do RozdziaÅ‚u 5 i przyjrzyjmy siÄ™ grupowaniu fragmentÃ³w danych w `struct`.\n\n[ch13]: ch13-02-iterators.html\n[ch6]: ch06-02-match.html#patterns-that-bind-to-values\n[strings]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings\n[deref-coercions]: ch15-02-deref.html#using-deref-coercions-in-functions-and-methods",
        "chapter_title": "Typ Wycinak (Slice)"
    },
    {
        "file_path": "ch05-00-structs.md",
        "content": "# UÅ¼ycie struktur do organizacji powiÄ…zanych danych\n\n_Struktura_ to niestandardowy typ danych, ktÃ³ry pozwala na grupowanie i nazywanie wielu powiÄ…zanych wartoÅ›ci, tworzÄ…cych spÃ³jnÄ… grupÄ™. JeÅ›li znasz jÄ™zyki obiektowe, struktura jest jak atrybuty danych obiektu. W tym rozdziale porÃ³wnamy krotki ze strukturami, aby rozbudowaÄ‡ twojÄ… wiedzÄ™ i pokazaÄ‡, kiedy struktury sÄ… lepszym sposobem na grupowanie danych.\n\nOmÃ³wimy, jak definiowaÄ‡ i tworzyÄ‡ instancje struktur. Dowiemy siÄ™, jak definiowaÄ‡ funkcje skojarzone, zwÅ‚aszcza _metody_, aby okreÅ›laÄ‡ zachowanie zwiÄ…zane z typem struktury. Struktury i typy wyliczeniowe (enum, omÃ³wione w Rozdziale 6) to elementy skÅ‚adowe do tworzenia nowych typÃ³w w domenie twojego programu, aby w peÅ‚ni wykorzystaÄ‡ sprawdzanie typÃ³w w czasie kompilacji w Rust.\n",
        "chapter_title": "UÅ¼ycie struktur do organizacji powiÄ…zanych danych"
    },
    {
        "file_path": "ch05-01-defining-structs.md",
        "content": "## Definiowanie i tworzenie instancji struktur\n\nStruktury sÄ… podobne do krotek, omÃ³wionych w sekcji [â€Typ krotkiâ€][tuples]<!-- ignore -->, w tym, Å¼e obie przechowujÄ… wiele powiÄ…zanych wartoÅ›ci. Podobnie jak krotki, elementy struktury mogÄ… byÄ‡ rÃ³Å¼nych typÃ³w. W przeciwieÅ„stwie do krotek, w strukturze nazwiesz kaÅ¼dy element danych, tak aby byÅ‚o jasne, co oznaczajÄ… wartoÅ›ci. Dodanie tych nazw sprawia, Å¼e struktury sÄ… bardziej elastyczne niÅ¼ krotki: nie musisz polegaÄ‡ na kolejnoÅ›ci danych, aby okreÅ›liÄ‡ lub uzyskaÄ‡ dostÄ™p do wartoÅ›ci instancji.\n\nAby zdefiniowaÄ‡ strukturÄ™, wpisujemy sÅ‚owo kluczowe `struct` i nadajemy nazwÄ™ caÅ‚ej strukturze. Nazwa struktury powinna opisywaÄ‡ znaczenie grupowanych danych. NastÄ™pnie, w nawiasach klamrowych, definiujemy nazwy i typy elementÃ³w danych, ktÃ³re nazywamy _polami_. Na przykÅ‚ad, Listing 5-1 przedstawia strukturÄ™, ktÃ³ra przechowuje informacje o koncie uÅ¼ytkownika.\n\n<Listing number=\"5-1\" file-name=\"src/main.rs\" caption=\"Definicja struktury `User`\">\n\n```rust\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n# \n# fn main() {}\n```\n\n</Listing>\n\nAby uÅ¼yÄ‡ struktury po jej zdefiniowaniu, tworzymy _instancjÄ™_ tej struktury, okreÅ›lajÄ…c konkretne wartoÅ›ci dla kaÅ¼dego z pÃ³l. Tworzymy instancjÄ™, podajÄ…c nazwÄ™ struktury, a nastÄ™pnie dodajemy nawiasy klamrowe zawierajÄ…ce pary _`klucz: wartoÅ›Ä‡`_, gdzie klucze to nazwy pÃ³l, a wartoÅ›ci to dane, ktÃ³re chcemy przechowywaÄ‡ w tych polach. Nie musimy okreÅ›laÄ‡ pÃ³l w tej samej kolejnoÅ›ci, w jakiej zadeklarowaliÅ›my je w strukturze. Innymi sÅ‚owy, definicja struktury jest jak ogÃ³lny szablon dla typu, a instancje wypeÅ‚niajÄ… ten szablon konkretnymi danymi, aby utworzyÄ‡ wartoÅ›ci tego typu. Na przykÅ‚ad, moÅ¼emy zadeklarowaÄ‡ konkretnego uÅ¼ytkownika, jak pokazano w Listingu 5-2.\n\n<Listing number=\"5-2\" file-name=\"src/main.rs\" caption=\"Tworzenie instancji struktury `User`\">\n\n```rust\n# struct User {\n#     active: bool,\n#     username: String,\n#     email: String,\n#     sign_in_count: u64,\n# }\n# \nfn main() {\n    let user1 = User {\n        active: true,\n        username: String::from(\"someusername123\"),\n        email: String::from(\"someone@example.com\"),\n        sign_in_count: 1,\n    };\n}\n```\n\n</Listing>\n\nAby uzyskaÄ‡ konkretnÄ… wartoÅ›Ä‡ ze struktury, uÅ¼ywamy notacji kropkowej. Na przykÅ‚ad, aby uzyskaÄ‡ dostÄ™p do adresu e-mail tego uÅ¼ytkownika, uÅ¼ywamy `user1.email`. JeÅ›li instancja jest mutowalna, moÅ¼emy zmieniÄ‡ wartoÅ›Ä‡, uÅ¼ywajÄ…c notacji kropkowej i przypisujÄ…c jÄ… do konkretnego pola. Listing 5-3 pokazuje, jak zmieniÄ‡ wartoÅ›Ä‡ w polu `email` mutowalnej instancji `User`.\n\n<Listing number=\"5-3\" file-name=\"src/main.rs\" caption=\"Zmiana wartoÅ›ci w polu `email` instancji `User`\">\n\n```rust\n# struct User {\n#     active: bool,\n#     username: String,\n#     email: String,\n#     sign_in_count: u64,\n# }\n# \nfn main() {\n    let mut user1 = User {\n        active: true,\n        username: String::from(\"someusername123\"),\n        email: String::from(\"someone@example.com\"),\n        sign_in_count: 1,\n    };\n\n    user1.email = String::from(\"anotheremail@example.com\");\n}\n```\n\n</Listing>\n\nZauwaÅ¼, Å¼e caÅ‚a instancja musi byÄ‡ mutowalna; Rust nie pozwala nam oznaczaÄ‡ tylko niektÃ³rych pÃ³l jako mutowalne. Podobnie jak w przypadku kaÅ¼dego wyraÅ¼enia, moÅ¼emy skonstruowaÄ‡ nowÄ… instancjÄ™ struktury jako ostatnie wyraÅ¼enie w treÅ›ci funkcji, aby niejawnie zwrÃ³ciÄ‡ tÄ™ nowÄ… instancjÄ™.\n\nListing 5-4 przedstawia funkcjÄ™ `build_user`, ktÃ³ra zwraca instancjÄ™ `User` z podanym adresem e-mail i nazwÄ… uÅ¼ytkownika. Pole `active` otrzymuje wartoÅ›Ä‡ `true`, a `sign_in_count` wartoÅ›Ä‡ `1`.\n\n<Listing number=\"5-4\" file-name=\"src/main.rs\" caption=\"Funkcja `build_user`, ktÃ³ra przyjmuje adres e-mail i nazwÄ™ uÅ¼ytkownika oraz zwraca instancjÄ™ `User`\">\n\n```rust\n# struct User {\n#     active: bool,\n#     username: String,\n#     email: String,\n#     sign_in_count: u64,\n# }\n# \nfn build_user(email: String, username: String) -> User {\n    User {\n        active: true,\n        username: username,\n        email: email,\n        sign_in_count: 1,\n    }\n}\n# \n# fn main() {\n#     let user1 = build_user(\n#         String::from(\"someone@example.com\"),\n#         String::from(\"someusername123\"),\n#     );\n# }\n```\n\n</Listing>\n\nLogiczne jest nazwanie parametrÃ³w funkcji tak samo jak pÃ³l struktury, ale powtarzanie nazw pÃ³l `email` i `username` oraz zmiennych jest trochÄ™ uciÄ…Å¼liwe. Gdyby struktura miaÅ‚a wiÄ™cej pÃ³l, powtarzanie kaÅ¼dej nazwy staÅ‚oby siÄ™ jeszcze bardziej irytujÄ…ce. Na szczÄ™Å›cie istnieje wygodna skrÃ³cona forma!\n\n<a id=\"using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name\"></a>\n\n### UÅ¼ywanie skrÃ³conej skÅ‚adni inicjalizacji pola\n\nPoniewaÅ¼ nazwy parametrÃ³w i nazwy pÃ³l struktury sÄ… dokÅ‚adnie takie same w Listingu 5-4, moÅ¼emy uÅ¼yÄ‡ skÅ‚adni _skrÃ³conej inicjalizacji pola_ do przepisania `build_user` tak, aby zachowywaÅ‚a siÄ™ dokÅ‚adnie tak samo, ale nie powtarzaÅ‚a `username` i `email`, jak pokazano w Listingu 5-5.\n\n<Listing number=\"5-5\" file-name=\"src/main.rs\" caption=\"Funkcja `build_user`, ktÃ³ra uÅ¼ywa skrÃ³conej inicjalizacji pola, poniewaÅ¼ parametry `username` i `email` majÄ… takie same nazwy jak pola struktury\">\n\n```rust\n# struct User {\n#     active: bool,\n#     username: String,\n#     email: String,\n#     sign_in_count: u64,\n# }\n# \nfn build_user(email: String, username: String) -> User {\n    User {\n        active: true,\n        username,\n        email,\n        sign_in_count: 1,\n    }\n}\n# \n# fn main() {\n#     let user1 = build_user(\n#         String::from(\"someone@example.com\"),\n#         String::from(\"someusername123\"),\n#     );\n# }\n```\n\n</Listing>\n\nTutaj tworzymy nowÄ… instancjÄ™ struktury `User`, ktÃ³ra ma pole o nazwie `email`. Chcemy ustawiÄ‡ wartoÅ›Ä‡ pola `email` na wartoÅ›Ä‡ z parametru `email` funkcji `build_user`. PoniewaÅ¼ pole `email` i parametr `email` majÄ… tÄ™ samÄ… nazwÄ™, wystarczy napisaÄ‡ `email` zamiast `email: email`.\n\n<a id=\"creating-instances-from-other-instances-with-struct-update-syntax\"></a>\n\n### Tworzenie instancji za pomocÄ… skÅ‚adni aktualizacji struktury\n\nCzÄ™sto przydaje siÄ™ tworzenie nowej instancji struktury, ktÃ³ra zawiera wiÄ™kszoÅ›Ä‡ wartoÅ›ci z innej instancji tego samego typu, ale zmienia niektÃ³re z nich. MoÅ¼esz to zrobiÄ‡ za pomocÄ… skÅ‚adni aktualizacji struktury.\n\nNajpierw, w Listingu 5-6, pokazujemy, jak utworzyÄ‡ nowÄ… instancjÄ™ `User` w `user2` w zwykÅ‚y sposÃ³b, bez skÅ‚adni aktualizacji. Ustawiamy nowÄ… wartoÅ›Ä‡ dla `email`, ale poza tym uÅ¼ywamy tych samych wartoÅ›ci z `user1`, ktÃ³re utworzyliÅ›my w Listingu 5-2.\n\n<Listing number=\"5-6\" file-name=\"src/main.rs\" caption=\"Tworzenie nowej instancji `User` z uÅ¼yciem wszystkich wartoÅ›ci z `user1` oprÃ³cz jednej\">\n\n```rust\n# struct User {\n#     active: bool,\n#     username: String,\n#     email: String,\n#     sign_in_count: u64,\n# }\n# \nfn main() {\n    // --snip--\n# \n#     let user1 = User {\n#         email: String::from(\"someone@example.com\"),\n#         username: String::from(\"someusername123\"),\n#         active: true,\n#         sign_in_count: 1,\n#     };\n\n    let user2 = User {\n        active: user1.active,\n        username: user1.username,\n        email: String::from(\"another@example.com\"),\n        sign_in_count: user1.sign_in_count,\n    };\n}\n```\n\n</Listing>\n\nUÅ¼ywajÄ…c skÅ‚adni aktualizacji struktury, moÅ¼emy osiÄ…gnÄ…Ä‡ ten sam efekt za pomocÄ… mniejszej iloÅ›ci kodu, jak pokazano w Listingu 5-7. SkÅ‚adnia `..` okreÅ›la, Å¼e pozostaÅ‚e pola, ktÃ³re nie zostaÅ‚y jawnie ustawione, powinny mieÄ‡ takÄ… samÄ… wartoÅ›Ä‡ jak pola w danej instancji.\n\n<Listing number=\"5-7\" file-name=\"src/main.rs\" caption=\"UÅ¼ywanie skÅ‚adni aktualizacji struktury do ustawienia nowej wartoÅ›ci `email` dla instancji `User`, ale uÅ¼ycie reszty wartoÅ›ci z `user1`\">\n\n```rust\n# struct User {\n#     active: bool,\n#     username: String,\n#     email: String,\n#     sign_in_count: u64,\n# }\n# \nfn main() {\n    // --snip--\n# \n#     let user1 = User {\n#         email: String::from(\"someone@example.com\"),\n#         username: String::from(\"someusername123\"),\n#         active: true,\n#         sign_in_count: 1,\n#     };\n\n    let user2 = User {\n        email: String::from(\"another@example.com\"),\n        ..user1\n    };\n}\n```\n\n</Listing>\n\nKod w Listingu 5-7 rÃ³wnieÅ¼ tworzy instancjÄ™ `user2`, ktÃ³ra ma innÄ… wartoÅ›Ä‡ dla `email`, ale ma te same wartoÅ›ci dla pÃ³l `username`, `active` i `sign_in_count` co `user1`. Instrukcja `..user1` musi znajdowaÄ‡ siÄ™ na koÅ„cu, aby okreÅ›liÄ‡, Å¼e wszelkie pozostaÅ‚e pola powinny otrzymaÄ‡ swoje wartoÅ›ci z odpowiednich pÃ³l w `user1`, ale moÅ¼emy wybraÄ‡, aby okreÅ›liÄ‡ wartoÅ›ci dla dowolnej liczby pÃ³l w dowolnej kolejnoÅ›ci, niezaleÅ¼nie od kolejnoÅ›ci pÃ³l w definicji struktury.\n\nZauwaÅ¼, Å¼e skÅ‚adnia aktualizacji struktury uÅ¼ywa `=` jak przypisania; dzieje siÄ™ tak dlatego, Å¼e przenosi ona dane, tak jak widzieliÅ›my to w sekcji [â€Zmienne i dane w interakcji przez przeniesienieâ€][move]<!-- ignore -->. W tym przykÅ‚adzie nie moÅ¼emy juÅ¼ uÅ¼ywaÄ‡ `user1` po utworzeniu `user2`, poniewaÅ¼ `String` z pola `username` w `user1` zostaÅ‚o przeniesione do `user2`. GdybyÅ›my podali `user2` nowe wartoÅ›ci `String` dla `email` i `username`, a wiÄ™c uÅ¼yli tylko wartoÅ›ci `active` i `sign_in_count` z `user1`, wÃ³wczas `user1` byÅ‚oby nadal waÅ¼ne po utworzeniu `user2`. ZarÃ³wno `active`, jak i `sign_in_count` to typy implementujÄ…ce cechÄ™ `Copy`, wiÄ™c zastosowaÅ‚oby siÄ™ zachowanie, o ktÃ³rym mÃ³wiliÅ›my w sekcji [â€Dane tylko na stosie: Kopiaâ€][copy]<!-- ignore -->. W tym przykÅ‚adzie nadal moÅ¼emy uÅ¼ywaÄ‡ `user1.email`, poniewaÅ¼ jego wartoÅ›Ä‡ nie zostaÅ‚a przeniesiona z `user1`.\n\n<a id=\"using-tuple-structs-without-named-fields-to-create-different-types\"></a>\n\n### Tworzenie rÃ³Å¼nych typÃ³w za pomocÄ… struktur krotkowych\n\nRust obsÅ‚uguje rÃ³wnieÅ¼ struktury, ktÃ³re wyglÄ…dajÄ… podobnie do krotek, nazywane _strukturami krotkowymi_. Struktury krotkowe posiadajÄ… dodatkowe znaczenie, ktÃ³re nadaje im nazwa struktury, ale nie majÄ… nazw powiÄ…zanych z ich polami; zamiast tego majÄ… tylko typy pÃ³l. Struktury krotkowe sÄ… uÅ¼yteczne, gdy chcesz nadaÄ‡ caÅ‚ej krotce nazwÄ™ i uczyniÄ‡ jÄ… innym typem niÅ¼ inne krotki, oraz gdy nazwanie kaÅ¼dego pola, jak w zwykÅ‚ej strukturze, byÅ‚oby zbyt rozwlekÅ‚e lub redundantne.\n\nAby zdefiniowaÄ‡ strukturÄ™ krotkowÄ…, zacznij od sÅ‚owa kluczowego `struct` i nazwy struktury, a nastÄ™pnie podaj typy w krotce. Na przykÅ‚ad, tutaj definiujemy i uÅ¼ywamy dwÃ³ch struktur krotkowych o nazwach `Color` i `Point`:\n\n<Listing file-name=\"src/main.rs\">\n\n```rust\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nfn main() {\n    let black = Color(0, 0, 0);\n    let origin = Point(0, 0, 0);\n}\n```\n\n</Listing>\n\nZauwaÅ¼, Å¼e wartoÅ›ci `black` i `origin` sÄ… rÃ³Å¼nych typÃ³w, poniewaÅ¼ sÄ… instancjami rÃ³Å¼nych struktur krotek. KaÅ¼da zdefiniowana przez ciebie struktura jest swoim wÅ‚asnym typem, mimo Å¼e pola w strukturze mogÄ… mieÄ‡ te same typy. Na przykÅ‚ad, funkcja, ktÃ³ra przyjmuje parametr typu `Color`, nie moÅ¼e przyjÄ…Ä‡ `Point` jako argumentu, mimo Å¼e oba typy skÅ‚adajÄ… siÄ™ z trzech wartoÅ›ci `i32`. W przeciwnym razie, instancje struktur krotek sÄ… podobne do krotek w tym sensie, Å¼e moÅ¼na je dekomponowaÄ‡ na pojedyncze elementy i moÅ¼na uÅ¼yÄ‡ `.` po ktÃ³rym nastÄ™puje indeks, aby uzyskaÄ‡ dostÄ™p do pojedynczej wartoÅ›ci. W przeciwieÅ„stwie do krotek, struktury krotki wymagajÄ… podania nazwy typu struktury podczas dekompozycji. Na przykÅ‚ad, napisalibyÅ›my `let Point(x, y, z) = origin;`, aby dekomponowaÄ‡ wartoÅ›ci punktu `origin` na zmienne o nazwach `x`, `y` i `z`.\n\n<a id=\"unit-like-structs-without-any-fields\"></a>\n\n### Definiowanie struktur podobnych do jednostek\n\nMoÅ¼na rÃ³wnieÅ¼ definiowaÄ‡ struktury, ktÃ³re nie majÄ… Å¼adnych pÃ³l! Nazywa siÄ™ je _strukturami podobnymi do jednostek_, poniewaÅ¼ zachowujÄ… siÄ™ podobnie do `()`, typu jednostkowego, o ktÃ³rym wspominaliÅ›my w sekcji [â€Typ krotkiâ€][tuples]<!-- ignore -->. Struktury podobne do jednostek mogÄ… byÄ‡ uÅ¼yteczne, gdy trzeba zaimplementowaÄ‡ cechÄ™ dla jakiegoÅ› typu, ale nie ma siÄ™ Å¼adnych danych do przechowywania w samym typie. O cechach omÃ³wimy w Rozdziale 10. Oto przykÅ‚ad deklaracji i tworzenia instancji struktury jednostkowej o nazwie `AlwaysEqual`:\n\n<Listing file-name=\"src/main.rs\">\n\n```rust\nstruct AlwaysEqual;\n\nfn main() {\n    let subject = AlwaysEqual;\n}\n```\n\n</Listing>\n\nAby zdefiniowaÄ‡ `AlwaysEqual`, uÅ¼ywamy sÅ‚owa kluczowego `struct`, wybranej nazwy, a nastÄ™pnie Å›rednika. Nie ma potrzeby uÅ¼ywania nawiasÃ³w klamrowych ani okrÄ…gÅ‚ych! NastÄ™pnie moÅ¼emy uzyskaÄ‡ instancjÄ™ `AlwaysEqual` w zmiennej `subject` w podobny sposÃ³b: uÅ¼ywajÄ…c zdefiniowanej nazwy, bez nawiasÃ³w klamrowych ani okrÄ…gÅ‚ych. WyobraÅº sobie, Å¼e pÃ³Åºniej zaimplementujemy zachowanie dla tego typu, tak aby kaÅ¼da instancja `AlwaysEqual` zawsze byÅ‚a rÃ³wna kaÅ¼dej instancji dowolnego innego typu, byÄ‡ moÅ¼e w celach testowych. Nie potrzebowalibyÅ›my Å¼adnych danych, aby zaimplementowaÄ‡ to zachowanie! W Rozdziale 10 dowiesz siÄ™, jak definiowaÄ‡ cechy i implementowaÄ‡ je na dowolnym typie, w tym na strukturach podobnych do jednostek.\n\n> ### WÅ‚asnoÅ›Ä‡ Danych Struktury\n>\n> W definicji struktury `User` z Listingu 5-1 uÅ¼yliÅ›my wÅ‚asnego typu `String` zamiast typu wycinka ciÄ…gu `&str`. Jest to celowy wybÃ³r, poniewaÅ¼ chcemy, aby kaÅ¼da instancja tej struktury posiadaÅ‚a wszystkie swoje dane, a dane te byÅ‚y waÅ¼ne tak dÅ‚ugo, jak waÅ¼na jest caÅ‚a struktura.\n>\n> MoÅ¼liwe jest rÃ³wnieÅ¼, aby struktury przechowywaÅ‚y referencje do danych naleÅ¼Ä…cych do czegoÅ› innego, ale do tego wymagane jest uÅ¼ycie _czasÃ³w Å¼ycia_ â€“ funkcji Rust, ktÃ³rÄ… omÃ³wimy w Rozdziale 10. Czasy Å¼ycia zapewniajÄ…, Å¼e dane, do ktÃ³rych odnosi siÄ™ struktura, sÄ… waÅ¼ne tak dÅ‚ugo, jak waÅ¼na jest struktura. Powiedzmy, Å¼e sprÃ³bujesz przechowywaÄ‡ referencjÄ™ w strukturze bez okreÅ›lania czasÃ³w Å¼ycia, tak jak poniÅ¼ej w *src/main.rs*; to nie zadziaÅ‚a:\n>\n> <Listing file-name=\"src/main.rs\">\n>\n> <!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->\n>\n> ```rust,ignore,does_not_compile\n> struct User {\n>     active: bool,\n>     username: &str,\n>     email: &str,\n>     sign_in_count: u64,\n> }\n>\n> fn main() {\n>     let user1 = User {\n>         active: true,\n>         username: \"someusername123\",\n>         email: \"someone@example.2com\",\n>         sign_in_count: 1,\n>     };\n> }\n> ```\n>\n> </Listing>\n>\n> Kompilator bÄ™dzie narzekaÅ‚, Å¼e potrzebuje specyfikatorÃ³w czasu Å¼ycia:\n>\n> ```console\n> $ cargo run\n>    Compiling structs v0.1.0 (file:///projects/structs)\n> error[E0106]: missing lifetime specifier\n>  --> src/main.rs:3:15\n>   |\n> 3 |     username: &str,\n>   |               ^ expected named lifetime parameter\n>   |\n> help: consider introducing a named lifetime parameter\n>   |\n> 1 ~ struct User<'a> {\n> 2 |     active: bool,\n> 3 ~     username: &'a str,\n>   |\n>\n> error[E0106]: missing lifetime specifier\n>  --> src/main.rs:4:12\n>   |\n> 4 |     email: &str,\n>   |            ^ expected named lifetime parameter\n>   |\n> help: consider introducing a named lifetime parameter\n>   |\n> 1 ~ struct User<'a> {\n> 2 |     active: bool,\n> 3 |     username: &str,\n> 4 ~     email: &'a str,\n>   |\n>\n> For more information about this error, try `rustc --explain E0106`.\n> error: could not compile `structs` (bin \"structs\") due to 2 previous errors\n> ```\n>\n> W Rozdziale 10 omÃ³wimy, jak naprawiÄ‡ te bÅ‚Ä™dy, aby moÅ¼na byÅ‚o przechowywaÄ‡ referencje w strukturach, ale na razie bÄ™dziemy naprawiaÄ‡ takie bÅ‚Ä™dy, uÅ¼ywajÄ…c typÃ³w posiadanych, takich jak `String`, zamiast referencji, takich jak `&str`.\n\n[tuples]: ch03-02-data-types.html#the-tuple-type\n[move]: ch04-01-what-is-ownership.html#variables-and-data-interact-with-move\n[copy]: ch04-01-what-is-ownership.html#stack-only-data-copy",
        "chapter_title": "Definiowanie i tworzenie instancji struktur"
    },
    {
        "file_path": "ch05-02-example-structs.md",
        "content": "## PrzykÅ‚adowy program uÅ¼ywajÄ…cy struktur\n\nAby zrozumieÄ‡, kiedy warto uÅ¼ywaÄ‡ struktur, napiszmy program, ktÃ³ry oblicza pole prostokÄ…ta. Zaczniemy od uÅ¼ycia pojedynczych zmiennych, a nastÄ™pnie zrefaktoryzujemy program, aÅ¼ bÄ™dziemy uÅ¼ywaÄ‡ struktur.\n\nStwÃ³rzmy nowy projekt binarny za pomocÄ… Cargo o nazwie _rectangles_, ktÃ³ry bÄ™dzie przyjmowaÅ‚ szerokoÅ›Ä‡ i wysokoÅ›Ä‡ prostokÄ…ta podane w pikselach i obliczaÅ‚ pole prostokÄ…ta. Listing 5-8 przedstawia krÃ³tki program z jednym sposobem na zrobienie tego w pliku _src/main.rs_ naszego projektu.\n\n<Listing number=\"5-8\" file-name=\"src/main.rs\" caption=\"Obliczanie pola prostokÄ…ta okreÅ›lonego przez oddzielne zmienne szerokoÅ›ci i wysokoÅ›ci\">\n\n```rust\nfn main() {\n    let width1 = 30;\n    let height1 = 50;\n\n    println!(\n        \"Pole prostokÄ…ta wynosi {} pikseli kwadratowych.\",\n        area(width1, height1)\n    );\n}\n\nfn area(width: u32, height: u32) -> u32 {\n    width * height\n}\n```\n\n</Listing>\n\nTeraz uruchom ten program za pomocÄ… `cargo run`:\n\n```console\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.42s\n     Running `target/debug/rectangles`\nThe area of the rectangle is 1500 square pixels.\n```\n\nTen kod z powodzeniem oblicza pole prostokÄ…ta, wywoÅ‚ujÄ…c funkcjÄ™ `area` z kaÅ¼dym wymiarem, ale moÅ¼emy zrobiÄ‡ wiÄ™cej, aby uczyniÄ‡ ten kod bardziej przejrzystym i czytelnym.\n\nProblem z tym kodem jest widoczny w sygnaturze `area`:\n\n```rust,ignore\n# fn main() {\n#     let width1 = 30;\n#     let height1 = 50;\n# \n#     println!(\n#         \"Pole prostokÄ…ta wynosi {} pikseli kwadratowych.\",\n#         area(width1, height1)\n#     );\n# }\n# \nfn area(width: u32, height: u32) -> u32 {\n#     width * height\n# }\n```\n\nFunkcja `area` ma za zadanie obliczyÄ‡ pole jednego prostokÄ…ta, ale napisana przez nas funkcja ma dwa parametry i nigdzie w naszym programie nie jest jasne, Å¼e te parametry sÄ… ze sobÄ… powiÄ…zane. ByÅ‚oby bardziej czytelne i Å‚atwiejsze w zarzÄ…dzaniu, gdybyÅ›my zgrupowali szerokoÅ›Ä‡ i wysokoÅ›Ä‡. OmÃ³wiliÅ›my juÅ¼ jeden sposÃ³b, w jaki moglibyÅ›my to zrobiÄ‡ w sekcji [â€Typ krotkiâ€][the-tuple-type]<!-- ignore --> w Rozdziale 3: uÅ¼ywajÄ…c krotek.\n\n### Refaktoryzacja za pomocÄ… krotek\n\nListing 5-9 przedstawia innÄ… wersjÄ™ naszego programu, ktÃ³ra uÅ¼ywa krotek.\n\n<Listing number=\"5-9\" file-name=\"src/main.rs\" caption=\"OkreÅ›lanie szerokoÅ›ci i wysokoÅ›ci prostokÄ…ta za pomocÄ… krotki\">\n\n```rust\nfn main() {\n    let rect1 = (30, 50);\n\n    println!(\n        \"Pole prostokÄ…ta wynosi {} pikseli kwadratowych.\",\n        area(rect1)\n    );\n}\n\nfn area(dimensions: (u32, u32)) -> u32 {\n    dimensions.0 * dimensions.1\n}\n```\n\n</Listing>\n\nPod pewnym wzglÄ™dem ten program jest lepszy. Krotki pozwalajÄ… nam dodaÄ‡ trochÄ™ struktury, a teraz przekazujemy tylko jeden argument. Ale pod innym wzglÄ™dem ta wersja jest mniej przejrzysta: krotki nie nazywajÄ… swoich elementÃ³w, wiÄ™c musimy indeksowaÄ‡ czÄ™Å›ci krotki, co sprawia, Å¼e nasze obliczenia sÄ… mniej oczywiste.\n\nPomylenie szerokoÅ›ci i wysokoÅ›ci nie miaÅ‚oby znaczenia dla obliczania powierzchni, ale gdybyÅ›my chcieli narysowaÄ‡ prostokÄ…t na ekranie, miaÅ‚oby to znaczenie! MusielibyÅ›my pamiÄ™taÄ‡, Å¼e `width` to indeks krotki `0`, a `height` to indeks krotki `1`. ByÅ‚oby to jeszcze trudniejsze do zrozumienia i zapamiÄ™tania dla kogoÅ› innego, kto uÅ¼ywaÅ‚by naszego kodu. PoniewaÅ¼ nie przekazaliÅ›my znaczenia naszych danych w naszym kodzie, Å‚atwiej jest teraz wprowadziÄ‡ bÅ‚Ä™dy.\n\n<a id=\"refactoring-with-structs-adding-more-meaning\"></a>\n\n### Refaktoryzacja za pomocÄ… struktur\n\nUÅ¼ywamy struktur, aby dodaÄ‡ znaczenie poprzez etykietowanie danych. MoÅ¼emy przeksztaÅ‚ciÄ‡ krotkÄ™, ktÃ³rej uÅ¼ywamy, w strukturÄ™ z nazwÄ… dla caÅ‚oÅ›ci, a takÅ¼e nazwami dla czÄ™Å›ci, jak pokazano w Listingu 5-10.\n\n<Listing number=\"5-10\" file-name=\"src/main.rs\" caption=\"Definiowanie struktury `Rectangle`\">\n\n```rust\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\n        \"Pole prostokÄ…ta wynosi {} pikseli kwadratowych.\",\n        area(&rect1)\n    );\n}\n\nfn area(rectangle: &Rectangle) -> u32 {\n    rectangle.width * rectangle.height\n}\n```\n\n</Listing>\n\nTutaj zdefiniowaliÅ›my strukturÄ™ i nazwaliÅ›my jÄ… `Rectangle`. W nawiasach klamrowych zdefiniowaliÅ›my pola jako `width` i `height`, z ktÃ³rych oba majÄ… typ `u32`. NastÄ™pnie, w `main`, utworzyliÅ›my konkretnÄ… instancjÄ™ `Rectangle` o szerokoÅ›ci `30` i wysokoÅ›ci `50`.\n\nNasza funkcja `area` jest teraz zdefiniowana z jednym parametrem, ktÃ³ry nazwaliÅ›my `rectangle`, ktÃ³rego typem jest niezmienne poÅ¼yczenie instancji struktury `Rectangle`. Jak wspomniano w Rozdziale 4, chcemy poÅ¼yczyÄ‡ strukturÄ™, a nie przejmowaÄ‡ jej wÅ‚asnoÅ›ci. W ten sposÃ³b `main` zachowuje wÅ‚asnoÅ›Ä‡ i moÅ¼e nadal uÅ¼ywaÄ‡ `rect1`, co jest powodem, dla ktÃ³rego uÅ¼ywamy `&` w sygnaturze funkcji i tam, gdzie wywoÅ‚ujemy funkcjÄ™.\n\nFunkcja `area` uzyskuje dostÄ™p do pÃ³l `width` i `height` instancji `Rectangle` (zauwaÅ¼, Å¼e dostÄ™p do pÃ³l poÅ¼yczonej instancji struktury nie przenosi wartoÅ›ci pÃ³l, dlatego czÄ™sto spotyka siÄ™ poÅ¼yczanie struktur). Nasza sygnatura funkcji `area` mÃ³wi teraz dokÅ‚adnie, co mamy na myÅ›li: Oblicz pole `Rectangle`, uÅ¼ywajÄ…c jego pÃ³l `width` i `height`. Przekazuje to, Å¼e szerokoÅ›Ä‡ i wysokoÅ›Ä‡ sÄ… ze sobÄ… powiÄ…zane, i nadaje wartoÅ›ciom opisowe nazwy, zamiast uÅ¼ywaÄ‡ wartoÅ›ci indeksu krotki `0` i `1`. Jest to korzyÅ›Ä‡ dla przejrzystoÅ›ci.\n\n<a id=\"adding-useful-functionality-with-derived-traits\"></a>\n\n### Dodawanie funkcjonalnoÅ›ci za pomocÄ… wyprowadzonych cech (derived traits)\n\nPrzydaÅ‚oby siÄ™ mÃ³c wyÅ›wietliÄ‡ instancjÄ™ `Rectangle` podczas debugowania programu i zobaczyÄ‡ wartoÅ›ci wszystkich jej pÃ³l. Listing 5-11 prÃ³buje uÅ¼yÄ‡ makra [`println!`][println]<!-- ignore -->, tak jak uÅ¼ywaliÅ›my w poprzednich rozdziaÅ‚ach. Jednak to nie zadziaÅ‚a.\n\n<Listing number=\"5-11\" file-name=\"src/main.rs\" caption=\"PrÃ³ba wydrukowania instancji `Rectangle`\">\n\n```rust,ignore,does_not_compile\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\"rect1 to {rect1}\");\n}\n```\n\n</Listing>\n\nKiedy skompilujemy ten kod, otrzymamy bÅ‚Ä…d z nastÄ™pujÄ…cym gÅ‚Ã³wnym komunikatem:\n\n```text\nerror[E0277]: `Rectangle` doesn't implement `std::fmt::Display`\n```\n\nMakro `println!` potrafi wiele rodzajÃ³w formatowania, a domyÅ›lnie nawiasy klamrowe mÃ³wiÄ… `println!`, aby uÅ¼yÄ‡ formatowania znanego jako `Display`: wyjÅ›cie przeznaczone do bezpoÅ›redniego uÅ¼ytku przez uÅ¼ytkownika koÅ„cowego. Prymitywne typy, ktÃ³re widzieliÅ›my do tej pory, domyÅ›lnie implementujÄ… `Display`, poniewaÅ¼ istnieje tylko jeden sposÃ³b, w jaki chciaÅ‚byÅ› pokazaÄ‡ `1` lub inny typ prymitywny uÅ¼ytkownikowi. Ale w przypadku struktur sposÃ³b, w jaki `println!` powinien sformatowaÄ‡ wyjÅ›cie, jest mniej jasny, poniewaÅ¼ istnieje wiÄ™cej moÅ¼liwoÅ›ci wyÅ›wietlania: Czy chcesz przecinkÃ³w, czy nie? Czy chcesz drukowaÄ‡ nawiasy klamrowe? Czy wszystkie pola powinny byÄ‡ wyÅ›wietlane? Z powodu tej niejednoznacznoÅ›ci Rust nie prÃ³buje zgadywaÄ‡, czego chcemy, a struktury nie majÄ… dostarczonej implementacji `Display` do uÅ¼ycia z `println!` i symbolem zastÄ™pczym `{}`.\n\nJeÅ›li bÄ™dziemy dalej czytaÄ‡ bÅ‚Ä™dy, znajdziemy tÄ™ pomocnÄ… notatkÄ™:\n\n```text\n   |                        |`Rectangle` nie moÅ¼e byÄ‡ sformatowany za pomocÄ… domyÅ›lnego formatatora\n   |                        wymaganego przez ten parametr formatowania\n```\n\nSprÃ³bujmy! WywoÅ‚anie makra `println!` bÄ™dzie teraz wyglÄ…daÄ‡ tak: `println!(\"rect1 to {rect1:?}\");`. Umieszczenie specyfikatora `:?` w nawiasach klamrowych mÃ³wi `println!`, Å¼e chcemy uÅ¼yÄ‡ formatu wyjÅ›ciowego o nazwie `Debug`. Cecha `Debug` umoÅ¼liwia nam wyÅ›wietlanie naszej struktury w sposÃ³b uÅ¼yteczny dla programistÃ³w, dziÄ™ki czemu moÅ¼emy zobaczyÄ‡ jej wartoÅ›Ä‡ podczas debugowania kodu.\n\nSkompiluj kod z tÄ… zmianÄ…. Cholera! Nadal otrzymujemy bÅ‚Ä…d:\n\n```text\nerror[E0277]: `Rectangle` nie implementuje `Debug`\n```\n\nAle znowu, kompilator daje nam pomocnÄ… notatkÄ™:\n\n```text\n   |                        wymagany przez ten parametr formatowania\n   |\n```\n\nRust _zawiera_ funkcjonalnoÅ›Ä‡ do wyÅ›wietlania informacji debugujÄ…cych, ale musimy jawnie jÄ… wÅ‚Ä…czyÄ‡, aby ta funkcjonalnoÅ›Ä‡ byÅ‚a dostÄ™pna dla naszej struktury. Aby to zrobiÄ‡, dodajemy zewnÄ™trzny atrybut `#[derive(Debug)]` tuÅ¼ przed definicjÄ… struktury, jak pokazano w Listingu 5-12.\n\n<Listing number=\"5-12\" file-name=\"src/main.rs\" caption=\"Dodawanie atrybutu do wyprowadzania cechy `Debug` i drukowanie instancji `Rectangle` za pomocÄ… formatowania debugowania\">\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\"rect1 to {rect1:?}\");\n}\n```\n\n</Listing>\n\nTeraz, gdy uruchomimy program, nie otrzymamy Å¼adnych bÅ‚Ä™dÃ³w i zobaczymy nastÄ™pujÄ…ce wyjÅ›cie:\n\n```console\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s\n     Running `target/debug/rectangles`\nrect1 is Rectangle { width: 30, height: 50 }\n```\n\nPiÄ™knie! To nie jest najÅ‚adniejsze wyjÅ›cie, ale pokazuje wartoÅ›ci wszystkich pÃ³l dla tej instancji, co z pewnoÅ›ciÄ… pomogÅ‚oby podczas debugowania. Kiedy mamy wiÄ™ksze struktury, przydatne jest, aby wyjÅ›cie byÅ‚o nieco Å‚atwiejsze do odczytania; w takich przypadkach moÅ¼emy uÅ¼yÄ‡ `{:#?}` zamiast `{:?}` w ciÄ…gu `println!`. W tym przykÅ‚adzie uÅ¼ycie stylu `{:#?}` spowoduje wyÅ›wietlenie nastÄ™pujÄ…cego komunikatu:\n\n```console\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s\n     Running `target/debug/rectangles`\nrect1 is Rectangle {\n    width: 30,\n    height: 50,\n}\n```\n\nInnym sposobem wydrukowania wartoÅ›ci za pomocÄ… formatu `Debug` jest uÅ¼ycie makra [`dbg!`][dbg]<!-- ignore -->, ktÃ³re przejmuje wÅ‚asnoÅ›Ä‡ wyraÅ¼enia (w przeciwieÅ„stwie do `println!`, ktÃ³re przyjmuje referencjÄ™), drukuje plik i numer linii, w ktÃ³rej wystÄ™puje wywoÅ‚anie makra `dbg!` wraz z wynikowÄ… wartoÅ›ciÄ… tego wyraÅ¼enia i zwraca wÅ‚asnoÅ›Ä‡ wartoÅ›ci.\n\n> Uwaga: WywoÅ‚anie makra `dbg!` drukuje do standardowego strumienia bÅ‚Ä™dÃ³w konsoli (`stderr`), w przeciwieÅ„stwie do `println!`, ktÃ³re drukuje do standardowego strumienia wyjÅ›ciowego konsoli (`stdout`). WiÄ™cej o `stderr` i `stdout` omÃ³wimy w sekcji [â€Przekierowywanie bÅ‚Ä™dÃ³w do standardowego strumienia bÅ‚Ä™dÃ³wâ€ w Rozdziale 12][err]<!-- ignore -->.\n\nOto przykÅ‚ad, w ktÃ³rym interesuje nas wartoÅ›Ä‡ przypisana do pola `width`, a takÅ¼e wartoÅ›Ä‡ caÅ‚ej struktury w `rect1`:\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let scale = 2;\n    let rect1 = Rectangle {\n        width: dbg!(30 * scale),\n        height: 50,\n    };\n\n    dbg!(&rect1);\n}\n```\n\nMoÅ¼emy umieÅ›ciÄ‡ `dbg!` wokÃ³Å‚ wyraÅ¼enia `30 * scale` i, poniewaÅ¼ `dbg!` zwraca wÅ‚asnoÅ›Ä‡ wartoÅ›ci wyraÅ¼enia, pole `width` otrzyma tÄ™ samÄ… wartoÅ›Ä‡, jakbyÅ›my nie mieli tam wywoÅ‚ania `dbg!`. Nie chcemy, aby `dbg!` przejmowaÅ‚o wÅ‚asnoÅ›Ä‡ `rect1`, wiÄ™c w nastÄ™pnym wywoÅ‚aniu uÅ¼ywamy referencji do `rect1`. Oto jak wyglÄ…da wyjÅ›cie z tego przykÅ‚adu:\n\n```console\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s\n     Running `target/debug/rectangles`\n[src/main.rs:10:16] 30 * scale = 60\n[src/main.rs:14:5] &rect1 = Rectangle {\n    width: 60,\n    height: 50,\n}\n```\n\nWidzimy, Å¼e pierwsza czÄ™Å›Ä‡ wyjÅ›cia pochodzi z pliku _src/main.rs_ w linii 10, gdzie debugujemy wyraÅ¼enie `30 * scale`, a jego wynikowa wartoÅ›Ä‡ to `60` (formatowanie `Debug` zaimplementowane dla liczb caÅ‚kowitych polega na wydrukowaniu tylko ich wartoÅ›ci). WywoÅ‚anie `dbg!` w linii 14 pliku _src/main.rs_ wyprowadza wartoÅ›Ä‡ `&rect1`, czyli struktury `Rectangle`. To wyjÅ›cie wykorzystuje Å‚adne formatowanie `Debug` typu `Rectangle`. Makro `dbg!` moÅ¼e byÄ‡ naprawdÄ™ pomocne, gdy prÃ³bujesz dowiedzieÄ‡ siÄ™, co robi twÃ³j kod!\n\nOprÃ³cz cechy `Debug`, Rust dostarczyÅ‚ szereg cech, ktÃ³rych moÅ¼emy uÅ¼ywaÄ‡ z atrybutem `derive`, ktÃ³re mogÄ… dodawaÄ‡ uÅ¼yteczne zachowanie do naszych niestandardowych typÃ³w. Te cechy i ich zachowania sÄ… wymienione w [Dodatku C][app-c]<!-- ignore -->. OmÃ³wimy, jak zaimplementowaÄ‡ te cechy z niestandardowym zachowaniem, a takÅ¼e jak tworzyÄ‡ wÅ‚asne cechy w Rozdziale 10. Istnieje rÃ³wnieÅ¼ wiele innych atrybutÃ³w niÅ¼ `derive`; wiÄ™cej informacji moÅ¼na znaleÅºÄ‡ w sekcji [â€Atrybutyâ€ w dokumentacji Rust Reference][attributes].\n\nNasza funkcja `area` jest bardzo specyficzna: oblicza tylko pole prostokÄ…tÃ³w. Pomocne byÅ‚oby powiÄ…zanie tego zachowania bliÅ¼ej z naszÄ… strukturÄ… `Rectangle`, poniewaÅ¼ nie bÄ™dzie ono dziaÅ‚aÄ‡ z Å¼adnym innym typem. Przyjrzyjmy siÄ™, jak moÅ¼emy kontynuowaÄ‡ refaktoryzacjÄ™ tego kodu, zamieniajÄ…c funkcjÄ™ `area` w metodÄ™ `area` zdefiniowanÄ… dla naszego typu `Rectangle`.\n\n[the-tuple-type]: ch03-02-data-types.html#the-tuple-type\n[app-c]: appendix-03-derivable-traits.md\n[println]: ../std/macro.println.html\n[dbg]: ../std/macro.dbg.html\n[err]: ch12-06-writing-to-stderr-instead-of-stdout.html\n[attributes]: ../reference/attributes.html",
        "chapter_title": "PrzykÅ‚adowy program uÅ¼ywajÄ…cy struktur"
    },
    {
        "file_path": "ch05-03-method-syntax.md",
        "content": "## Metody\n\nMetody sÄ… podobne do funkcji: deklarujemy je sÅ‚owem kluczowym `fn` i nazwÄ…, mogÄ… mieÄ‡ parametry i zwracaÄ‡ wartoÅ›Ä‡, oraz zawierajÄ… kod, ktÃ³ry jest uruchamiany po wywoÅ‚aniu metody z innego miejsca. W przeciwieÅ„stwie do funkcji, metody sÄ… definiowane w kontekÅ›cie struktury (lub typu wyliczeniowego albo obiektu cechy, ktÃ³re omÃ³wimy odpowiednio w [Rozdziale 6][enums]<!-- ignore --> i [Rozdziale 18][trait-objects]<!-- ignore -->), a ich pierwszym parametrem jest zawsze `self`, ktÃ³re reprezentuje instancjÄ™ struktury, na ktÃ³rej wywoÅ‚ywana jest metoda.\n\n<a id=\"defining-methods\"></a>\n\n### SkÅ‚adnia metody\n\nZmieÅ„my funkcjÄ™ `area`, ktÃ³ra ma instancjÄ™ `Rectangle` jako parametr, i zamiast tego stwÃ³rzmy metodÄ™ `area` zdefiniowanÄ… w strukturze `Rectangle`, jak pokazano w Listingu 5-13.\n\n<Listing number=\"5-13\" file-name=\"src/main.rs\" caption=\"Definiowanie metody `area` w strukturze `Rectangle`\">\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\n        \"Pole prostokÄ…ta wynosi {} pikseli kwadratowych.\",\n        rect1.area()\n    );\n}\n```\n\n</Listing>\n\nAby zdefiniowaÄ‡ funkcjÄ™ w kontekÅ›cie `Rectangle`, rozpoczynamy blok `impl` (implementacji) dla `Rectangle`. Wszystko w tym bloku `impl` bÄ™dzie powiÄ…zane z typem `Rectangle`. NastÄ™pnie przenosimy funkcjÄ™ `area` do nawiasÃ³w klamrowych `impl` i zmieniamy pierwszy (a w tym przypadku jedyny) parametr na `self` w sygnaturze i wszÄ™dzie w treÅ›ci. W `main`, gdzie wywoÅ‚aliÅ›my funkcjÄ™ `area` i przekazaliÅ›my `rect1` jako argument, moÅ¼emy zamiast tego uÅ¼yÄ‡ _skÅ‚adni metody_ do wywoÅ‚ania metody `area` na naszej instancji `Rectangle`. SkÅ‚adnia metody wystÄ™puje po instancji: dodajemy kropkÄ™, po ktÃ³rej nastÄ™puje nazwa metody, nawiasy i wszelkie argumenty.\n\nW sygnaturze `area` uÅ¼ywamy `&self` zamiast `rectangle: &Rectangle`. `&self` to w rzeczywistoÅ›ci skrÃ³t od `self: &Self`. W bloku `impl` typ `Self` jest aliasem dla typu, dla ktÃ³rego jest blok `impl`. Metody muszÄ… mieÄ‡ parametr o nazwie `self` typu `Self` jako swÃ³j pierwszy parametr, wiÄ™c Rust pozwala na skrÃ³cenie tego do samej nazwy `self` w miejscu pierwszego parametru. ZauwaÅ¼, Å¼e nadal musimy uÅ¼ywaÄ‡ `&` przed skrÃ³tem `self`, aby wskazaÄ‡, Å¼e ta metoda poÅ¼ycza instancjÄ™ `Self`, tak jak zrobiliÅ›my to w `rectangle: &Rectangle`. Metody mogÄ… przejmowaÄ‡ wÅ‚asnoÅ›Ä‡ `self`, poÅ¼yczaÄ‡ `self` niezmiennie, jak to zrobiliÅ›my tutaj, lub poÅ¼yczaÄ‡ `self` mutowalnie, tak jak kaÅ¼dy inny parametr.\n\nWybraliÅ›my `&self` z tego samego powodu, dla ktÃ³rego uÅ¼yliÅ›my `&Rectangle` w wersji funkcyjnej: nie chcemy przejmowaÄ‡ wÅ‚asnoÅ›ci i chcemy tylko odczytywaÄ‡ dane ze struktury, a nie do niej zapisywaÄ‡. GdybyÅ›my chcieli zmieniÄ‡ instancjÄ™, na ktÃ³rej wywoÅ‚aliÅ›my metodÄ™, w ramach dziaÅ‚ania metody, uÅ¼ylibyÅ›my `&mut self` jako pierwszego parametru. Posiadanie metody, ktÃ³ra przejmuje wÅ‚asnoÅ›Ä‡ instancji, uÅ¼ywajÄ…c tylko `self` jako pierwszego parametru, jest rzadkie; ta technika jest zazwyczaj uÅ¼ywana, gdy metoda przeksztaÅ‚ca `self` w coÅ› innego i chcemy uniemoÅ¼liwiÄ‡ wywoÅ‚ujÄ…cemu uÅ¼ywanie oryginalnej instancji po transformacji.\n\nGÅ‚Ã³wnym powodem uÅ¼ywania metod zamiast funkcji, oprÃ³cz zapewnienia skÅ‚adni metody i braku koniecznoÅ›ci powtarzania typu `self` w sygnaturze kaÅ¼dej metody, jest organizacja. UmieÅ›ciliÅ›my wszystkie rzeczy, ktÃ³re moÅ¼emy zrobiÄ‡ z instancjÄ… typu, w jednym bloku `impl`, zamiast zmuszaÄ‡ przyszÅ‚ych uÅ¼ytkownikÃ³w naszego kodu do szukania moÅ¼liwoÅ›ci `Rectangle` w rÃ³Å¼nych miejscach dostarczanej przez nas biblioteki.\n\nZauwaÅ¼, Å¼e moÅ¼emy nadaÄ‡ metodzie takÄ… samÄ… nazwÄ™ jak jednemu z pÃ³l struktury. Na przykÅ‚ad, moÅ¼emy zdefiniowaÄ‡ metodÄ™ w `Rectangle`, ktÃ³ra rÃ³wnieÅ¼ nazywa siÄ™ `width`:\n\n<Listing file-name=\"src/main.rs\">\n\n```rust\n# #[derive(Debug)]\n# struct Rectangle {\n#     width: u32,\n#     height: u32,\n# }\n# \nimpl Rectangle {\n    fn width(&self) -> bool {\n        self.width > 0\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    if rect1.width() {\n        println!(\"ProstokÄ…t ma szerokoÅ›Ä‡ rÃ³Å¼nÄ… od zera; wynosi {}\", rect1.width);\n    }\n}\n```\n\n</Listing>\n\nTutaj, decydujemy, aby metoda `width` zwracaÅ‚a `true`, jeÅ›li wartoÅ›Ä‡ w polu `width` instancji jest wiÄ™ksza niÅ¼ `0`, a `false`, jeÅ›li wartoÅ›Ä‡ jest `0`: moÅ¼emy uÅ¼yÄ‡ pola o tej samej nazwie w metodzie do dowolnego celu. W `main`, gdy po `rect1.width` umieÅ›cimy nawiasy, Rust wie, Å¼e chodzi nam o metodÄ™ `width`. Gdy nie uÅ¼ywamy nawiasÃ³w, Rust wie, Å¼e chodzi nam o pole `width`.\n\nCzÄ™sto, choÄ‡ nie zawsze, gdy nadajemy metodzie takÄ… samÄ… nazwÄ™ jak polu, chcemy, aby zwracaÅ‚a tylko wartoÅ›Ä‡ z pola i nic wiÄ™cej. Takie metody nazywane sÄ… _getterami_, a Rust nie implementuje ich automatycznie dla pÃ³l struktur, tak jak robiÄ… to niektÃ³re inne jÄ™zyki. Gettery sÄ… uÅ¼yteczne, poniewaÅ¼ moÅ¼na uczyniÄ‡ pole prywatnym, ale metodÄ™ publicznÄ…, a tym samym umoÅ¼liwiÄ‡ dostÄ™p tylko do odczytu do tego pola jako czÄ™Å›ci publicznego API typu. OmÃ³wimy, czym sÄ… publiczne i prywatne, oraz jak oznaczyÄ‡ pole lub metodÄ™ jako publicznÄ… lub prywatnÄ… w [Rozdziale 7][public]<!-- ignore -->.\n\n> ### Gdzie jest operator `->`?\n>\n> W C i C++ do wywoÅ‚ywania metod uÅ¼ywa siÄ™ dwÃ³ch rÃ³Å¼nych operatorÃ³w: `.` jeÅ›li wywoÅ‚uje siÄ™ metodÄ™ bezpoÅ›rednio na obiekcie, oraz `->` jeÅ›li wywoÅ‚uje siÄ™ metodÄ™ na wskaÅºniku do obiektu i trzeba najpierw dereferencjowaÄ‡ wskaÅºnik. Innymi sÅ‚owy, jeÅ›li `object` jest wskaÅºnikiem, `object->something()` jest podobne do `(*object).something()`.\n>\n> Rust nie ma odpowiednika operatora `->`; zamiast tego, Rust ma funkcjÄ™ zwanÄ… _automatycznym referencjowaniem i dereferencjowaniem_. WywoÅ‚ywanie metod jest jednym z niewielu miejsc w Rust z takim zachowaniem.\n>\n> DziaÅ‚a to w nastÄ™pujÄ…cy sposÃ³b: Kiedy wywoÅ‚ujesz metodÄ™ `object.something()`, Rust automatycznie dodaje `&`, `&mut` lub `*`, tak aby `object` pasowaÅ‚ do sygnatury metody. Innymi sÅ‚owy, poniÅ¼sze sÄ… takie same:\n>\n> <!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->\n>\n> ```rust\n> # #[derive(Debug,Copy,Clone)]\n> # struct Point {\n> #     x: f64,\n> #     y: f64,\n> # }\n> #\n> # impl Point {\n> #    fn distance(&self, other: &Point) -> f64 {\n> #        let x_squared = f64::powi(other.x - self.x, 2);\n> #        let y_squared = f64::powi(other.y - self.y, 2);\n> #\n> #        f64::sqrt(x_squared + y_squared)\n> #    }\n> # }\n> # let p1 = Point { x: 0.0, y: 0.0 };\n> # let p2 = Point { x: 5.0, y: 6.5 };\n> p1.distance(&p2);\n> (&p1).distance(&p2);\n> ```\n>\n> Pierwsza z nich wyglÄ…da znacznie czyÅ›ciej. To automatyczne zachowanie referencjonowania dziaÅ‚a, poniewaÅ¼ metody majÄ… wyraÅºny odbiornik â€” typ `self`. BiorÄ…c pod uwagÄ™ odbiornik i nazwÄ™ metody, Rust moÅ¼e jednoznacznie okreÅ›liÄ‡, czy metoda odczytuje (`&self`), mutuje (`&mut self`), czy zuÅ¼ywa (`self`). Fakt, Å¼e Rust sprawia, Å¼e poÅ¼yczanie jest niejawne dla odbiornikÃ³w metod, jest duÅ¼Ä… czÄ™Å›ciÄ… sprawiania, Å¼e wÅ‚asnoÅ›Ä‡ jest ergonomiczna w praktyce.\n\n### Metody z wiÄ™kszÄ… liczbÄ… parametrÃ³w\n\nPoÄ‡wiczmy uÅ¼ywanie metod, implementujÄ…c drugÄ… metodÄ™ w strukturze `Rectangle`. Tym razem chcemy, aby instancja `Rectangle` przyjmowaÅ‚a innÄ… instancjÄ™ `Rectangle` i zwracaÅ‚a `true`, jeÅ›li drugi `Rectangle` moÅ¼e caÅ‚kowicie zmieÅ›ciÄ‡ siÄ™ w `self` (pierwszym `Rectangle`); w przeciwnym razie powinna zwrÃ³ciÄ‡ `false`. Oznacza to, Å¼e po zdefiniowaniu metody `can_hold`, chcemy mÃ³c napisaÄ‡ program pokazany w Listingu 5-14.\n\n<Listing number=\"5-14\" file-name=\"src/main.rs\" caption=\"UÅ¼ycie jeszcze nie napisanej metody `can_hold`\">\n\n```rust,ignore\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n    let rect2 = Rectangle {\n        width: 10,\n        height: 40,\n    };\n    let rect3 = Rectangle {\n        width: 60,\n        height: 45,\n    };\n\n    println!(\"Czy rect1 moÅ¼e pomieÅ›ciÄ‡ rect2? {}\", rect1.can_hold(&rect2));\n    println!(\"Czy rect1 moÅ¼e pomieÅ›ciÄ‡ rect3? {}\", rect1.can_hold(&rect3));\n}\n```\n\n</Listing>\n\nOczekiwane wyjÅ›cie wyglÄ…daÅ‚oby nastÄ™pujÄ…co, poniewaÅ¼ oba wymiary `rect2` sÄ… mniejsze niÅ¼ wymiary `rect1`, ale `rect3` jest szerszy niÅ¼ `rect1`:\n\n```text\nCan rect1 hold rect2? true\nCan rect1 hold rect3? false\n```\n\nWiemy, Å¼e chcemy zdefiniowaÄ‡ metodÄ™, wiÄ™c bÄ™dzie ona w bloku `impl Rectangle`. Nazwa metody bÄ™dzie `can_hold`, i przyjmie niezmienne poÅ¼yczenie innego `Rectangle` jako parametr. MoÅ¼emy stwierdziÄ‡, jaki bÄ™dzie typ parametru, patrzÄ…c na kod, ktÃ³ry wywoÅ‚uje metodÄ™: `rect1.can_hold(&rect2)` przekazuje `&rect2`, co jest niezmiennym poÅ¼yczeniem `rect2`, instancji `Rectangle`. Ma to sens, poniewaÅ¼ musimy tylko odczytywaÄ‡ `rect2` (zamiast zapisywaÄ‡, co oznaczaÅ‚oby, Å¼e potrzebowalibyÅ›my mutowalnego poÅ¼yczenia), i chcemy, aby `main` zachowaÅ‚o wÅ‚asnoÅ›Ä‡ `rect2`, abyÅ›my mogli go ponownie uÅ¼yÄ‡ po wywoÅ‚aniu metody `can_hold`. WartoÅ›ciÄ… zwracanÄ… `can_hold` bÄ™dzie Boolean, a implementacja sprawdzi, czy szerokoÅ›Ä‡ i wysokoÅ›Ä‡ `self` sÄ… wiÄ™ksze niÅ¼ szerokoÅ›Ä‡ i wysokoÅ›Ä‡ drugiego `Rectangle`, odpowiednio. Dodajmy nowÄ… metodÄ™ `can_hold` do bloku `impl` z Listingu 5-13, pokazanej w Listingu 5-15.\n\n<Listing number=\"5-15\" file-name=\"src/main.rs\" caption=\"Implementacja metody `can_hold` w `Rectangle`, ktÃ³ra przyjmuje innÄ… instancjÄ™ `Rectangle` jako parametr\">\n\n```rust\n# #[derive(Debug)]\n# struct Rectangle {\n#     width: u32,\n#     height: u32,\n# }\n# \nimpl Rectangle {\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n\n    fn can_hold(&self, other: &Rectangle) -> bool {\n        self.width > other.width && self.height > other.height\n    }\n}\n# \n# fn main() {\n#     let rect1 = Rectangle {\n#         width: 30,\n#         height: 50,\n#     };\n#     let rect2 = Rectangle {\n#         width: 10,\n#         height: 40,\n#     };\n#     let rect3 = Rectangle {\n#         width: 60,\n#         height: 45,\n#     };\n# \n#     println!(\"Czy rect1 moÅ¼e pomieÅ›ciÄ‡ rect2? {}\", rect1.can_hold(&rect2));\n#     println!(\"Czy rect1 moÅ¼e pomieÅ›ciÄ‡ rect3? {}\", rect1.can_hold(&rect3));\n# }\n```\n\n</Listing>\n\nPo uruchomieniu tego kodu z funkcjÄ… `main` z Listingu 5-14, otrzymamy poÅ¼Ä…dane wyjÅ›cie. Metody mogÄ… przyjmowaÄ‡ wiele parametrÃ³w, ktÃ³re dodajemy do sygnatury po parametrze `self`, a te parametry dziaÅ‚ajÄ… tak samo jak parametry w funkcjach.\n\n### Funkcje skojarzone\n\nWszystkie funkcje zdefiniowane w bloku `impl` nazywane sÄ… _funkcjami skojarzonymi_, poniewaÅ¼ sÄ… powiÄ…zane z typem nazwanym po `impl`. MoÅ¼emy definiowaÄ‡ funkcje skojarzone, ktÃ³re nie majÄ… `self` jako swojego pierwszego parametru (i dlatego nie sÄ… metodami), poniewaÅ¼ nie potrzebujÄ… instancji typu do dziaÅ‚ania. UÅ¼yliÅ›my juÅ¼ jednej takiej funkcji: funkcji `String::from` zdefiniowanej dla typu `String`.\n\nFunkcje skojarzone, ktÃ³re nie sÄ… metodami, sÄ… czÄ™sto uÅ¼ywane jako konstruktory, ktÃ³re zwracajÄ… nowÄ… instancjÄ™ struktury. SÄ… one czÄ™sto nazywane `new`, ale `new` nie jest specjalnÄ… nazwÄ… i nie jest wbudowane w jÄ™zyk. Na przykÅ‚ad, moglibyÅ›my zapewniÄ‡ funkcjÄ™ skojarzonÄ… o nazwie `square`, ktÃ³ra miaÅ‚aby jeden parametr wymiaru i uÅ¼ywaÅ‚aby go zarÃ³wno jako szerokoÅ›ci, jak i wysokoÅ›ci, uÅ‚atwiajÄ…c w ten sposÃ³b tworzenie kwadratowego `Rectangle` zamiast koniecznoÅ›ci dwukrotnego okreÅ›lania tej samej wartoÅ›ci:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust\n# #[derive(Debug)]\n# struct Rectangle {\n#     width: u32,\n#     height: u32,\n# }\n# \nimpl Rectangle {\n    fn square(size: u32) -> Self {\n        Self {\n            width: size,\n            height: size,\n        }\n    }\n}\n# \n# fn main() {\n#     let sq = Rectangle::square(3);\n# }\n```\n\nSÅ‚owa kluczowe `Self` w typie zwracanym i w treÅ›ci funkcji sÄ… aliasami dla typu, ktÃ³ry pojawia siÄ™ po sÅ‚owie kluczowym `impl`, czyli w tym przypadku `Rectangle`.\n\nAby wywoÅ‚aÄ‡ tÄ™ funkcjÄ™ skojarzonÄ…, uÅ¼ywamy skÅ‚adni `::` z nazwÄ… struktury; `let sq = Rectangle::square(3);` jest przykÅ‚adem. Ta funkcja jest umieszczona w przestrzeni nazw struktury: skÅ‚adnia `::` jest uÅ¼ywana zarÃ³wno dla funkcji skojarzonych, jak i przestrzeni nazw utworzonych przez moduÅ‚y. OmÃ³wimy moduÅ‚y w [Rozdziale 7][modules]<!-- ignore -->.\n\n### Wiele blokÃ³w `impl`\n\nKaÅ¼da struktura moÅ¼e mieÄ‡ wiele blokÃ³w `impl`. Na przykÅ‚ad, Listing 5-15 jest rÃ³wnowaÅ¼ny z kodem pokazanym w Listingu 5-16, ktÃ³ry ma kaÅ¼dÄ… metodÄ™ w swoim wÅ‚asnym bloku `impl`.\n\n<Listing number=\"5-16\" caption=\"Przepisanie Listingu 5-15 z uÅ¼yciem wielu blokÃ³w `impl`\">\n\n```rust\n# #[derive(Debug)]\n# struct Rectangle {\n#     width: u32,\n#     height: u32,\n# }\n# \nimpl Rectangle {\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n}\n\nimpl Rectangle {\n    fn can_hold(&self, other: &Rectangle) -> bool {\n        self.width > other.width && self.height > other.height\n    }\n}\n# \n# fn main() {\n#     let rect1 = Rectangle {\n#         width: 30,\n#         height: 50,\n#     };\n#     let rect2 = Rectangle {\n#         width: 10,\n#         height: 40,\n#     };\n#     let rect3 = Rectangle {\n#         width: 60,\n#         height: 45,\n#     };\n# \n#     println!(\"Czy rect1 moÅ¼e pomieÅ›ciÄ‡ rect2? {}\", rect1.can_hold(&rect2));\n#     println!(\"Czy rect1 moÅ¼e pomieÅ›ciÄ‡ rect3? {}\", rect1.can_hold(&rect3));\n# }\n```\n\n</Listing>\n\nNie ma powodu, aby rozdzielaÄ‡ te metody na wiele blokÃ³w `impl` w tym przypadku, ale jest to poprawna skÅ‚adnia. Zobaczymy przypadek, w ktÃ³rym wiele blokÃ³w `impl` jest uÅ¼ytecznych w Rozdziale 10, gdzie omÃ³wimy typy generyczne i cechy.\n\n## Podsumowanie\n\nStruktury pozwalajÄ… tworzyÄ‡ niestandardowe typy, ktÃ³re majÄ… znaczenie dla twojej domeny. UÅ¼ywajÄ…c struktur, moÅ¼esz zachowaÄ‡ powiÄ…zane ze sobÄ… fragmenty danych i nazywaÄ‡ kaÅ¼dy z nich, aby TwÃ³j kod byÅ‚ przejrzysty. W blokach `impl` moÅ¼esz definiowaÄ‡ funkcje powiÄ…zane z Twoim typem, a metody sÄ… rodzajem funkcji powiÄ…zanych, ktÃ³re pozwalajÄ… okreÅ›laÄ‡ zachowanie instancji Twoich struktur.\n\nAle struktury to nie jedyny sposÃ³b, w jaki moÅ¼esz tworzyÄ‡ niestandardowe typy: przejdÅºmy do funkcji `enum` w Rust, aby dodaÄ‡ kolejne narzÄ™dzie do Twojego zestawu.\n\n[enums]: ch06-00-enums.html\n[trait-objects]: ch18-02-trait-objects.md\n[public]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword\n[modules]: ch07-02-defining-modules-to-control-scope-and-privacy.html",
        "chapter_title": "Metody"
    },
    {
        "file_path": "ch06-00-enums.md",
        "content": "# Typy wyliczeniowe (enum) i dopasowywanie wzorcÃ³w\n\nW tym rozdziale przyjrzymy siÄ™ wyliczeniom, zwanym rÃ³wnieÅ¼ _enumami_.Enumy pozwalajÄ… zdefiniowaÄ‡ typ poprzez wyliczenie jego moÅ¼liwych wariantÃ³w.Najpierw zdefiniujemy i uÅ¼yjemy enum, aby pokazaÄ‡, jak enum moÅ¼e kodowaÄ‡znaczenie wraz z danymi. NastÄ™pnie zbadamy szczegÃ³lnie uÅ¼yteczny enum,nazwany `Option`, ktÃ³ry wyraÅ¼a, Å¼e wartoÅ›Ä‡ moÅ¼e byÄ‡ albo czymÅ›, albo niczym.NastÄ™pnie przyjrzymy siÄ™, jak dopasowywanie wzorcÃ³w w wyraÅ¼eniu `match`uÅ‚atwia uruchamianie rÃ³Å¼nego kodu dla rÃ³Å¼nych wartoÅ›ci enum. Na koniecomÃ³wimy, jak konstrukcja `if let` jest kolejnym wygodnym i zwiÄ™zÅ‚ym idiomemdostÄ™pnym do obsÅ‚ugi enumÃ³w w twoim kodzie.\n",
        "chapter_title": "Typy wyliczeniowe (enum) i dopasowywanie wzorcÃ³w"
    },
    {
        "file_path": "ch06-01-defining-an-enum.md",
        "content": "## Definiowanie typu wyliczeniowego\n\nPodczas gdy struktury dajÄ… ci sposÃ³b grupowania powiÄ…zanych pÃ³l i danych, jak `Rectangle` z jego `width` i `height`, enums dajÄ… ci sposÃ³b powiedzenia, Å¼e wartoÅ›Ä‡ jest jednÄ… z moÅ¼liwych zestawÃ³w wartoÅ›ci. Na przykÅ‚ad, moÅ¼emy chcieÄ‡ powiedzieÄ‡, Å¼e `Rectangle` jest jednym z moÅ¼liwych ksztaÅ‚tÃ³w, ktÃ³re obejmujÄ… rÃ³wnieÅ¼ `Circle` i `Triangle`. Aby to zrobiÄ‡, Rust pozwala nam zakodowaÄ‡ te moÅ¼liwoÅ›ci jako enum.\n\nPrzyjrzyjmy siÄ™ sytuacji, ktÃ³rÄ… moÅ¼emy chcieÄ‡ wyraziÄ‡ w kodzie i zobaczmy, dlaczego enums sÄ… uÅ¼yteczne i bardziej odpowiednie niÅ¼ struktury w tym przypadku. Powiedzmy, Å¼e musimy pracowaÄ‡ z adresami IP. Obecnie uÅ¼ywane sÄ… dwa gÅ‚Ã³wne standardy dla adresÃ³w IP: wersja czwarta i wersja szÃ³sta. PoniewaÅ¼ sÄ… to jedyne moÅ¼liwoÅ›ci dla adresu IP, z ktÃ³rymi nasz program siÄ™ spotka, moÅ¼emy _wyliczyÄ‡_ wszystkie moÅ¼liwe warianty, skÄ…d pochodzi nazwa â€enumerationâ€.\n\nKaÅ¼dy adres IP moÅ¼e byÄ‡ adresem wersji czwartej lub wersji szÃ³stej, ale nie oboma jednoczeÅ›nie. Ta wÅ‚aÅ›ciwoÅ›Ä‡ adresÃ³w IP sprawia, Å¼e struktura danych enum jest odpowiednia, poniewaÅ¼ wartoÅ›Ä‡ enum moÅ¼e byÄ‡ tylko jednym ze swoich wariantÃ³w. ZarÃ³wno adresy wersji czwartej, jak i wersji szÃ³stej sÄ… nadal zasadniczo adresami IP, wiÄ™c powinny byÄ‡ traktowane jako ten sam typ, gdy kod obsÅ‚uguje sytuacje, ktÃ³re majÄ… zastosowanie do kaÅ¼dego rodzaju adresu IP.\n\nMoÅ¼emy wyraziÄ‡ tÄ™ koncepcjÄ™ w kodzie, definiujÄ…c wyliczenie `IpAddrKind` i wymieniajÄ…c moÅ¼liwe rodzaje adresÃ³w IP, ktÃ³rymi mogÄ… byÄ‡ `V4` i `V6`. SÄ… to warianty enum:\n\n```rust\nenum IpAddrKind {\n    V4,\n    V6,\n}\n# \n# fn main() {\n#     let four = IpAddrKind::V4;\n#     let six = IpAddrKind::V6;\n# \n#     route(IpAddrKind::V4);\n#     route(IpAddrKind::V6);\n# }\n# \n# fn route(ip_kind: IpAddrKind) {}\n```\n\n`IpAddrKind` to teraz niestandardowy typ danych, ktÃ³rego moÅ¼emy uÅ¼ywaÄ‡ w innych miejscach naszego kodu.\n\n### WartoÅ›ci wyliczeniowe\n\nMoÅ¼emy tworzyÄ‡ instancje kaÅ¼dego z dwÃ³ch wariantÃ³w `IpAddrKind` w nastÄ™pujÄ…cy sposÃ³b:\n\n```rust\n# enum IpAddrKind {\n#     V4,\n#     V6,\n# }\n# \n# fn main() {\n    let four = IpAddrKind::V4;\n    let six = IpAddrKind::V6;\n# \n#     route(IpAddrKind::V4);\n#     route(IpAddrKind::V6);\n# }\n# \n# fn route(ip_kind: IpAddrKind) {}\n```\n\nZauwaÅ¼, Å¼e warianty enum sÄ… umieszczone w przestrzeni nazw pod jego identyfikatorem, a my uÅ¼ywamy podwÃ³jnego dwukropka do rozdzielenia tych dwÃ³ch. Jest to przydatne, poniewaÅ¼ teraz obie wartoÅ›ci `IpAddrKind::V4` i `IpAddrKind::V6` sÄ… tego samego typu: `IpAddrKind`. MoÅ¼emy wtedy, na przykÅ‚ad, zdefiniowaÄ‡ funkcjÄ™, ktÃ³ra przyjmuje dowolny `IpAddrKind`:\n\n```rust\n# enum IpAddrKind {\n#     V4,\n#     V6,\n# }\n# \n# fn main() {\n#     let four = IpAddrKind::V4;\n#     let six = IpAddrKind::V6;\n# \n#     route(IpAddrKind::V4);\n#     route(IpAddrKind::V6);\n# }\n# \nfn route(ip_kind: IpAddrKind) {}\n```\n\nI moÅ¼emy wywoÅ‚aÄ‡ tÄ™ funkcjÄ™ z dowolnym wariantem:\n\n```rust\n# enum IpAddrKind {\n#     V4,\n#     V6,\n# }\n# \n# fn main() {\n#     let four = IpAddrKind::V4;\n#     let six = IpAddrKind::V6;\n# \n    route(IpAddrKind::V4);\n    route(IpAddrKind::V6);\n# }\n# \n# fn route(ip_kind: IpAddrKind) {}\n```\n\nUÅ¼ywanie typÃ³w wyliczeniowych (enums) ma jeszcze wiÄ™cej zalet. MyÅ›lÄ…c wiÄ™cej o naszym typie adresu IP, w tej chwili nie mamy sposobu na przechowywanie rzeczywistych _danych_ adresu IP; wiemy tylko, jakiego jest _rodzaju_. BiorÄ…c pod uwagÄ™, Å¼e wÅ‚aÅ›nie dowiedziaÅ‚eÅ› siÄ™ o strukturach w Rozdziale 5, moÅ¼esz byÄ‡ skÅ‚onny do rozwiÄ…zania tego problemu za pomocÄ… struktur, jak pokazano w Listingu 6-1.\n\n<Listing number=\"6-1\" caption=\"Przechowywanie danych i wariantu `IpAddrKind` adresu IP za pomocÄ… `struct`\">\n\n```rust\n# fn main() {\n    enum IpAddrKind {\n        V4,\n        V6,\n    }\n\n    struct IpAddr {\n        kind: IpAddrKind,\n        address: String,\n    }\n\n    let home = IpAddr {\n        kind: IpAddrKind::V4,\n        address: String::from(\"127.0.0.1\"),\n    };\n\n    let loopback = IpAddr {\n        kind: IpAddrKind::V6,\n        address: String::from(\"::1\"),\n    };\n# }\n```\n\n</Listing>\n\nTutaj zdefiniowaliÅ›my strukturÄ™ `IpAddr`, ktÃ³ra ma dwa pola: pole `kind` typu `IpAddrKind` (enum, ktÃ³re zdefiniowaliÅ›my wczeÅ›niej) i pole `address` typu `String`. Mamy dwie instancje tej struktury. Pierwsza to `home` i ma wartoÅ›Ä‡ `IpAddrKind::V4` jako swoje `kind` z powiÄ…zanymi danymi adresu `127.0.0.1`. Druga instancja to `loopback`. Ma ona inny wariant `IpAddrKind` jako swojÄ… wartoÅ›Ä‡ `kind`, `V6`, i ma powiÄ…zany z nim adres `::1`. UÅ¼yliÅ›my struktury do poÅ‚Ä…czenia wartoÅ›ci `kind` i `address`, wiÄ™c teraz wariant jest powiÄ…zany z wartoÅ›ciÄ….\n\nJednakÅ¼e, reprezentowanie tej samej koncepcji uÅ¼ywajÄ…c tylko typu wyliczeniowego jest bardziej zwiÄ™zÅ‚e: zamiast typu wyliczeniowego wewnÄ…trz struktury, moÅ¼emy umieÅ›ciÄ‡ dane bezpoÅ›rednio w kaÅ¼dym wariancie typu wyliczeniowego. Ta nowa definicja typu wyliczeniowego `IpAddr` mÃ³wi, Å¼e zarÃ³wno warianty `V4`, jak i `V6` bÄ™dÄ… miaÅ‚y powiÄ…zane wartoÅ›ci `String`:\n\n```rust\n# fn main() {\n    enum IpAddr {\n        V4(String),\n        V6(String),\n    }\n\n    let home = IpAddr::V4(String::from(\"127.0.0.1\"));\n\n    let loopback = IpAddr::V6(String::from(\"::1\"));\n# }\n```\n\nDane do kaÅ¼dego wariantu enum doÅ‚Ä…czamy bezpoÅ›rednio, wiÄ™c nie ma potrzeby uÅ¼ywania dodatkowej struktury. W tym przypadku Å‚atwiej jest rÃ³wnieÅ¼ zauwaÅ¼yÄ‡ innÄ… cechÄ™ dziaÅ‚ania enumÃ³w: nazwa kaÅ¼dego zdefiniowanego przez nas wariantu enum staje siÄ™ rÃ³wnieÅ¼ funkcjÄ…, ktÃ³ra konstruuje instancjÄ™ enum. Oznacza to, Å¼e `IpAddr::V4()` jest wywoÅ‚aniem funkcji, ktÃ³ra przyjmuje argument `String` i zwraca instancjÄ™ typu `IpAddr`. TÄ™ funkcjÄ™ konstruujÄ…cÄ… otrzymujemy automatycznie w wyniku zdefiniowania enum.\n\nIstnieje jeszcze jedna zaleta uÅ¼ywania typu wyliczeniowego zamiast struktury: kaÅ¼dy wariant moÅ¼e mieÄ‡ rÃ³Å¼ne typy i iloÅ›ci powiÄ…zanych danych. Adresy IP wersji czwartej zawsze bÄ™dÄ… miaÅ‚y cztery komponenty numeryczne o wartoÅ›ciach od 0 do 255. GdybyÅ›my chcieli przechowywaÄ‡ adresy `V4` jako cztery wartoÅ›ci `u8`, ale nadal wyraÅ¼aÄ‡ adresy `V6` jako pojedynczÄ… wartoÅ›Ä‡ `String`, nie bylibyÅ›my w stanie tego zrobiÄ‡ za pomocÄ… struktury. Typy wyliczeniowe z Å‚atwoÅ›ciÄ… radzÄ… sobie z tym przypadkiem:\n\n```rust\n# fn main() {\n    enum IpAddr {\n        V4(u8, u8, u8, u8),\n        V6(String),\n    }\n\n    let home = IpAddr::V4(127, 0, 0, 1);\n\n    let loopback = IpAddr::V6(String::from(\"::1\"));\n# }\n```\n\nPokazaliÅ›my kilka rÃ³Å¼nych sposobÃ³w definiowania struktur danych do przechowywania adresÃ³w IP wersji czwartej i szÃ³stej. Jednak, jak siÄ™ okazuje, chÄ™Ä‡ przechowywania adresÃ³w IP i kodowania ich rodzaju jest tak powszechna, Å¼e [biblioteka standardowa ma definicjÄ™, ktÃ³rej moÅ¼emy uÅ¼yÄ‡!][IpAddr]<!-- ignore --> Przyjrzyjmy siÄ™, jak biblioteka standardowa definiuje `IpAddr`. Ma ona dokÅ‚adnie ten sam typ wyliczeniowy i warianty, ktÃ³re zdefiniowaliÅ›my i uÅ¼yliÅ›my, ale osadza dane adresowe w wariantach w postaci dwÃ³ch rÃ³Å¼nych struktur, ktÃ³re sÄ… definiowane inaczej dla kaÅ¼dego wariantu:\n\n```rust\nstruct Ipv4Addr {\n    // --snip--\n}\n\nstruct Ipv6Addr {\n    // --snip--\n}\n\nenum IpAddr {\n    V4(Ipv4Addr),\n    V6(Ipv6Addr),\n}\n```\n\nTen kod ilustruje, Å¼e wariant enum moÅ¼e zawieraÄ‡ dowolny rodzaj danych: ciÄ…gi znakÃ³w, typy numeryczne lub struktury, na przykÅ‚ad. MoÅ¼e nawet zawieraÄ‡ inny enum! Ponadto, typy biblioteki standardowej czÄ™sto nie sÄ… o wiele bardziej skomplikowane niÅ¼ to, co sam byÅ› wymyÅ›liÅ‚.\n\nZauwaÅ¼, Å¼e choÄ‡ biblioteka standardowa zawiera definicjÄ™ dla `IpAddr`, nadal moÅ¼emy tworzyÄ‡ i uÅ¼ywaÄ‡ wÅ‚asnej definicji bez konfliktu, poniewaÅ¼ nie wprowadziliÅ›my definicji z biblioteki standardowej do naszego zasiÄ™gu. WiÄ™cej o wprowadzaniu typÃ³w do zasiÄ™gu omÃ³wimy w Rozdziale 7.\n\nPrzyjrzyjmy siÄ™ innemu przykÅ‚adowi typu wyliczeniowego w Listingu 6-2: ten ma szerokÄ… gamÄ™ typÃ³w osadzonych w swoich wariantach.\n\n<Listing number=\"6-2\" caption=\"Typ wyliczeniowy `Message`, ktÃ³rego warianty przechowujÄ… rÃ³Å¼ne iloÅ›ci i typy wartoÅ›ci\">\n\n```rust\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n# \n# fn main() {}\n```\n\n</Listing>\n\nTen typ wyliczeniowy ma cztery warianty o rÃ³Å¼nych typach:\n\n- `Quit`: Nie ma z nim zwiÄ…zanych Å¼adnych danych\n- `Move`: Ma nazwane pola, podobnie jak struktura\n- `Write`: Zawiera pojedynczy `String`\n- `ChangeColor`: Zawiera trzy wartoÅ›ci `i32`\n\nDefiniowanie enum z wariantami takimi jak te w Listingu 6-2 jest podobne do definiowania rÃ³Å¼nych rodzajÃ³w definicji struktur, z tÄ… rÃ³Å¼nicÄ…, Å¼e enum nie uÅ¼ywa sÅ‚owa kluczowego `struct`, a wszystkie warianty sÄ… zgrupowane pod typem `Message`. NastÄ™pujÄ…ce struktury mogÅ‚yby przechowywaÄ‡ te same dane, co poprzednie warianty enum:\n\n```rust\nstruct QuitMessage; // struktura jednostkowa\nstruct MoveMessage {\n    x: i32,\n    y: i32,\n}\nstruct WriteMessage(String); // struktura krotki\nstruct ChangeColorMessage(i32, i32, i32); // struktura krotki\n# \n# fn main() {}\n```\n\nAle gdybyÅ›my uÅ¼yli rÃ³Å¼nych struktur, z ktÃ³rych kaÅ¼da ma swÃ³j wÅ‚asny typ, nie moglibyÅ›my tak Å‚atwo zdefiniowaÄ‡ funkcji, ktÃ³ra przyjmowaÅ‚aby dowolny z tych rodzajÃ³w wiadomoÅ›ci, jak w przypadku typu wyliczeniowego `Message` zdefiniowanego w Listingu 6-2, ktÃ³ry jest pojedynczym typem.\n\nIstnieje jeszcze jedno podobieÅ„stwo miÄ™dzy typami wyliczeniowymi a strukturami: tak jak jesteÅ›my w stanie definiowaÄ‡ metody w strukturach za pomocÄ… `impl`, tak samo jesteÅ›my w stanie definiowaÄ‡ metody w typach wyliczeniowych. Oto metoda o nazwie `call`, ktÃ³rÄ… moglibyÅ›my zdefiniowaÄ‡ w naszym typie wyliczeniowym `Message`:\n\n```rust\n# fn main() {\n#     enum Message {\n#         Quit,\n#         Move { x: i32, y: i32 },\n#         Write(String),\n#         ChangeColor(i32, i32, i32),\n#     }\n# \n    impl Message {\n        fn call(&self) {\n            // treÅ›Ä‡ metody zostaÅ‚aby zdefiniowana tutaj\n        }\n    }\n\n    let m = Message::Write(String::from(\"hello\"));\n    m.call();\n# }\n```\n\nTreÅ›Ä‡ metody uÅ¼yÅ‚aby `self`, aby uzyskaÄ‡ wartoÅ›Ä‡, na ktÃ³rej wywoÅ‚aliÅ›my metodÄ™. W tym przykÅ‚adzie utworzyliÅ›my zmiennÄ… `m`, ktÃ³ra ma wartoÅ›Ä‡ `Message::Write(String::from(\"hello\"))`, i to wÅ‚aÅ›nie bÄ™dzie `self` w treÅ›ci metody `call`, gdy zostanie uruchomione `m.call()`.\n\nPrzyjrzyjmy siÄ™ innemu enumowi w bibliotece standardowej, ktÃ³ry jest bardzo powszechny i uÅ¼yteczny: `Option`.\n\n<a id=\"the-option-enum-and-its-advantages-over-null-values\"></a>\n\n### Typ wyliczeniowy `Option`\n\nTa sekcja bada studium przypadku `Option`, ktÃ³re jest innym typem wyliczeniowym zdefiniowanym przez bibliotekÄ™ standardowÄ…. Typ `Option` koduje bardzo powszechny scenariusz, w ktÃ³rym wartoÅ›Ä‡ moÅ¼e byÄ‡ czymÅ›, albo moÅ¼e byÄ‡ niczym.\n\nNa przykÅ‚ad, jeÅ›li zaÅ¼Ä…dasz pierwszego elementu z niepustej listy, otrzymasz wartoÅ›Ä‡. JeÅ›li zaÅ¼Ä…dasz pierwszego elementu z pustej listy, otrzymasz nic. WyraÅ¼enie tej koncepcji w kategoriach systemu typÃ³w oznacza, Å¼e kompilator moÅ¼e sprawdziÄ‡, czy obsÅ‚uÅ¼yÅ‚eÅ› wszystkie przypadki, ktÃ³re powinieneÅ› obsÅ‚uÅ¼yÄ‡; ta funkcjonalnoÅ›Ä‡ moÅ¼e zapobiegaÄ‡ bÅ‚Ä™dom, ktÃ³re sÄ… niezwykle powszechne w innych jÄ™zykach programowania.\n\nProjektowanie jÄ™zykÃ³w programowania czÄ™sto rozpatruje siÄ™ w kategoriach tego, jakie funkcje siÄ™ uwzglÄ™dnia, ale funkcje, ktÃ³re siÄ™ wyklucza, rÃ³wnieÅ¼ sÄ… waÅ¼ne. Rust nie posiada funkcji null, ktÃ³rÄ… ma wiele innych jÄ™zykÃ³w. _Null_ to wartoÅ›Ä‡, ktÃ³ra oznacza, Å¼e nie ma tam Å¼adnej wartoÅ›ci. W jÄ™zykach z null, zmienne mogÄ… zawsze byÄ‡ w jednym z dwÃ³ch stanÃ³w: null lub nie-null.\n\nW swojej prezentacji z 2009 roku â€Null References: The Billion Dollar Mistakeâ€ Tony Hoare, wynalazca wartoÅ›ci null, powiedziaÅ‚:\n\n> Nazywam to moim miliardowym bÅ‚Ä™dem. W tamtym czasie projektowaÅ‚em pierwszy kompleksowy system typÃ³w dla referencji w jÄ™zyku obiektowym. Moim celem byÅ‚o zapewnienie, Å¼e wszelkie uÅ¼ycie referencji powinno byÄ‡ absolutnie bezpieczne, z automatycznym sprawdzaniem wykonywanym przez kompilator. Ale nie mogÅ‚em oprzeÄ‡ siÄ™ pokusie wprowadzenia referencji null, po prostu dlatego, Å¼e byÅ‚a tak Å‚atwa do zaimplementowania. DoprowadziÅ‚o to do niezliczonych bÅ‚Ä™dÃ³w, luk w zabezpieczeniach i awarii systemÃ³w, ktÃ³re prawdopodobnie spowodowaÅ‚y miliard dolarÃ³w bÃ³lu i szkÃ³d w ciÄ…gu ostatnich czterdziestu lat.\n\nProblem z wartoÅ›ciami null polega na tym, Å¼e jeÅ›li sprÃ³bujesz uÅ¼yÄ‡ wartoÅ›ci null jako wartoÅ›ci nie-null, otrzymasz jakiÅ› bÅ‚Ä…d. PoniewaÅ¼ ta wÅ‚aÅ›ciwoÅ›Ä‡ null lub nie-null jest wszechobecna, niezwykle Å‚atwo jest popeÅ‚niÄ‡ tego rodzaju bÅ‚Ä…d.\n\nJednak koncepcja, ktÃ³rÄ… null prÃ³buje wyraziÄ‡, jest nadal uÅ¼yteczna: null to wartoÅ›Ä‡, ktÃ³ra jest obecnie nieprawidÅ‚owa lub nieobecna z jakiegoÅ› powodu.\n\nProblem nie leÅ¼y w samej koncepcji, lecz w konkretnej implementacji. W zwiÄ…zku z tym Rust nie posiada wartoÅ›ci null, ale ma enum, ktÃ³ry moÅ¼e kodowaÄ‡ koncepcjÄ™ obecnoÅ›ci lub braku wartoÅ›ci. Tym enumem jest `Option<T>`, i jest on [zdefiniowany przez bibliotekÄ™ standardowÄ…][option]<!-- ignore --> w nastÄ™pujÄ…cy sposÃ³b:\n\n```rust\nenum Option<T> {\n    None,\n    Some(T),\n}\n```\n\nTyp wyliczeniowy `Option<T>` jest tak uÅ¼yteczny, Å¼e jest nawet wÅ‚Ä…czony do preambuly; nie musisz jawnie wprowadzaÄ‡ go do zasiÄ™gu. Jego warianty sÄ… rÃ³wnieÅ¼ wÅ‚Ä…czone do preambuly: moÅ¼esz uÅ¼ywaÄ‡ `Some` i `None` bezpoÅ›rednio bez prefiksu `Option::`. Typ wyliczeniowy `Option<T>` jest nadal zwykÅ‚ym typem wyliczeniowym, a `Some(T)` i `None` sÄ… nadal wariantami typu `Option<T>`.\n\nSkÅ‚adnia `<T>` to cecha Rust, o ktÃ³rej jeszcze nie mÃ³wiliÅ›my. Jest to ogÃ³lny parametr typu, a o ogÃ³lnych typach szerzej omÃ³wimy w Rozdziale 10. Na razie musisz wiedzieÄ‡, Å¼e `<T>` oznacza, Å¼e wariant `Some` typu wyliczeniowego `Option` moÅ¼e przechowywaÄ‡ pojedynczy element danych dowolnego typu, a kaÅ¼dy konkretny typ, ktÃ³ry zostanie uÅ¼yty zamiast `T`, sprawia, Å¼e caÅ‚y typ `Option<T>` staje siÄ™ innym typem. Oto kilka przykÅ‚adÃ³w uÅ¼ycia wartoÅ›ci `Option` do przechowywania typÃ³w liczbowych i znakowych:\n\n```rust\n# fn main() {\n    let some_number = Some(5);\n    let some_char = Some('e');\n\n    let absent_number: Option<i32> = None;\n# }\n```\n\nTyp `some_number` to `Option<i32>`. Typ `some_char` to `Option<char>`, co jest innym typem. Rust moÅ¼e wywnioskowaÄ‡ te typy, poniewaÅ¼ okreÅ›liliÅ›my wartoÅ›Ä‡ w wariancie `Some`. Dla `absent_number`, Rust wymaga od nas adnotacji caÅ‚ego typu `Option`: kompilator nie moÅ¼e wywnioskowaÄ‡ typu, ktÃ³ry bÄ™dzie przechowywaÅ‚ odpowiadajÄ…cy mu wariant `Some`, patrzÄ…c tylko na wartoÅ›Ä‡ `None`. Tutaj mÃ³wimy Rustowi, Å¼e chcemy, aby `absent_number` byÅ‚ typu `Option<i32>`.\n\nKiedy mamy wartoÅ›Ä‡ `Some`, wiemy, Å¼e wartoÅ›Ä‡ jest obecna, a wartoÅ›Ä‡ jest przechowywana w `Some`. Kiedy mamy wartoÅ›Ä‡ `None`, w pewnym sensie oznacza to to samo co null: nie mamy waÅ¼nej wartoÅ›ci. Dlaczego wiÄ™c `Option<T>` jest lepsze niÅ¼ null?\n\nKrÃ³tko mÃ³wiÄ…c, poniewaÅ¼ `Option<T>` i `T` (gdzie `T` moÅ¼e byÄ‡ dowolnym typem) sÄ… rÃ³Å¼nymi typami, kompilator nie pozwoli nam uÅ¼yÄ‡ wartoÅ›ci `Option<T>` tak, jakby byÅ‚a ona na pewno prawidÅ‚owÄ… wartoÅ›ciÄ…. Na przykÅ‚ad ten kod nie skompiluje siÄ™, poniewaÅ¼ prÃ³buje dodaÄ‡ `i8` do `Option<i8>`:\n\n```rust,ignore,does_not_compile\n# fn main() {\n    let x: i8 = 5;\n    let y: Option<i8> = Some(5);\n\n    let sum = x + y;\n# }\n```\n\nJeÅ›li uruchomimy ten kod, otrzymamy komunikat o bÅ‚Ä™dzie podobny do tego:\n\n```console\n$ cargo run\n   Compiling enums v0.1.0 (file:///projects/enums)\nerror[E0277]: cannot add `Option<i8>` do `i8`\n --> src/main.rs:5:17\n  |\n5 |     let sum = x + y;\n  |                 ^ brak implementacji dla `i8 + Option<i8>`\n  |\n  = help: cecha `Add<Option<i8>>` nie jest zaimplementowana dla `i8`\n  = help: nastÄ™pujÄ…ce inne typy implementujÄ… cechÄ™ `Add<Rhs>`:\n            `&i8` implementuje `Add<i8>`\n            `&i8` implementuje `Add`\n            `i8` implementuje `Add<&i8>`\n            `i8` implementuje `Add`\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `enums` (bin \"enums\") due to 1 previous error\n```\n\nIntensywnie! W efekcie ten komunikat o bÅ‚Ä™dzie oznacza, Å¼e Rust nie rozumie, jak dodaÄ‡ `i8` i `Option<i8>`, poniewaÅ¼ sÄ… to rÃ³Å¼ne typy. Kiedy mamy wartoÅ›Ä‡ typu takiego jak `i8` w Rust, kompilator zapewni, Å¼e zawsze mamy prawidÅ‚owÄ… wartoÅ›Ä‡. MoÅ¼emy postÄ™powaÄ‡ pewnie, nie muszÄ…c sprawdzaÄ‡ wartoÅ›ci null przed uÅ¼yciem tej wartoÅ›ci. Tylko wtedy, gdy mamy `Option<i8>` (lub dowolny typ wartoÅ›ci, z ktÃ³rym pracujemy), musimy martwiÄ‡ siÄ™ o ewentualny brak wartoÅ›ci, a kompilator upewni siÄ™, Å¼e obsÅ‚uÅ¼ymy ten przypadek przed uÅ¼yciem wartoÅ›ci.\n\nInnymi sÅ‚owy, musisz przekonwertowaÄ‡ `Option<T>` na `T`, zanim bÄ™dziesz mÃ³gÅ‚ wykonywaÄ‡ operacje `T`. OgÃ³lnie rzecz biorÄ…c, pomaga to wychwyciÄ‡ jeden z najczÄ™stszych problemÃ³w z null: zaÅ‚oÅ¼enie, Å¼e coÅ› nie jest null, gdy w rzeczywistoÅ›ci jest. \n\nEliminowanie ryzyka bÅ‚Ä™dnego zaÅ‚oÅ¼enia wartoÅ›ci nie-null pomaga ci byÄ‡ pewniejszym swojego kodu. Aby mieÄ‡ wartoÅ›Ä‡, ktÃ³ra potencjalnie moÅ¼e byÄ‡ null, musisz jawnie siÄ™ na to zgodziÄ‡, czyniÄ…c typ tej wartoÅ›ci `Option<T>`. NastÄ™pnie, gdy uÅ¼ywasz tej wartoÅ›ci, musisz jawnie obsÅ‚uÅ¼yÄ‡ przypadek, gdy wartoÅ›Ä‡ jest null. WszÄ™dzie tam, gdzie wartoÅ›Ä‡ ma typ, ktÃ³ry nie jest `Option<T>`, _moÅ¼esz_ bezpiecznie zaÅ‚oÅ¼yÄ‡, Å¼e wartoÅ›Ä‡ nie jest null. ByÅ‚a to celowa decyzja projektowa dla Rust, aby ograniczyÄ‡ wszechobecnoÅ›Ä‡ wartoÅ›ci null i zwiÄ™kszyÄ‡ bezpieczeÅ„stwo kodu w Rust.\n\nWiÄ™c jak wyciÄ…gnÄ…Ä‡ wartoÅ›Ä‡ `T` z wariantu `Some`, gdy masz wartoÅ›Ä‡ typu `Option<T>`, aby mÃ³c jej uÅ¼yÄ‡? Enum `Option<T>` ma wiele metod, ktÃ³re sÄ… przydatne w rÃ³Å¼nych sytuacjach; moÅ¼esz je sprawdziÄ‡ w [jej dokumentacji][docs]<!-- ignore -->. Zapoznanie siÄ™ z metodami w `Option<T>` bÄ™dzie niezwykle pomocne w Twojej podrÃ³Å¼y z Rust.\n\nOgÃ³lnie rzecz biorÄ…c, aby uÅ¼yÄ‡ wartoÅ›ci `Option<T>`, chcesz mieÄ‡ kod, ktÃ³ry obsÅ‚uÅ¼y kaÅ¼dy wariant. Chcesz, aby pewien kod uruchamiaÅ‚ siÄ™ tylko wtedy, gdy masz wartoÅ›Ä‡ `Some(T)`, i ten kod moÅ¼e uÅ¼ywaÄ‡ wewnÄ™trznego `T`. Chcesz, aby inny kod uruchamiaÅ‚ siÄ™ tylko wtedy, gdy masz wartoÅ›Ä‡ `None`, a ten kod nie ma dostÄ™pnej wartoÅ›ci `T`. WyraÅ¼enie `match` jest konstrukcjÄ… przepÅ‚ywu sterowania, ktÃ³ra robi to wÅ‚aÅ›nie w przypadku enumÃ³w: uruchamia inny kod w zaleÅ¼noÅ›ci od wariantu enum, ktÃ³ry posiada, a ten kod moÅ¼e uÅ¼ywaÄ‡ danych zawartych w pasujÄ…cej wartoÅ›ci.\n\n[IpAddr]: ../std/net/enum.IpAddr.html\n[option]: ../std/option/enum.Option.html\n[docs]: ../std/option/enum.Option.html",
        "chapter_title": "Definiowanie typu wyliczeniowego"
    },
    {
        "file_path": "ch06-02-match.md",
        "content": "<a id=\"the-match-control-flow-operator\"></a>\n\n## Konstrukcja kontroli przepÅ‚ywu `match`\n\nRust ma niezwykle potÄ™Å¼nÄ… konstrukcjÄ™ kontroli przepÅ‚ywu o nazwie `match`, ktÃ³ra pozwala porÃ³wnywaÄ‡ wartoÅ›Ä‡ z seriÄ… wzorcÃ³w, a nastÄ™pnie wykonywaÄ‡ kod na podstawie pasujÄ…cego wzorca. Wzorce mogÄ… skÅ‚adaÄ‡ siÄ™ z literaÅ‚Ã³w, nazw zmiennych, symboli wieloznacznych i wielu innych rzeczy; [RozdziaÅ‚ 19][ch19-00-patterns]<!-- ignore --> obejmuje wszystkie rÃ³Å¼ne rodzaje wzorcÃ³w i to, co robiÄ…. SiÅ‚a `match` pochodzi z ekspresywnoÅ›ci wzorcÃ³w i faktu, Å¼e kompilator potwierdza, Å¼e wszystkie moÅ¼liwe przypadki sÄ… obsÅ‚ugiwane.\n\nPomyÅ›l o wyraÅ¼eniu `match` jak o maszynie do sortowania monet: monety zjeÅ¼dÅ¼ajÄ… po torze z otworami o rÃ³Å¼nej wielkoÅ›ci, a kaÅ¼da moneta wpada przez pierwszy otwÃ³r, do ktÃ³rego pasuje. W ten sam sposÃ³b wartoÅ›ci przechodzÄ… przez kaÅ¼dy wzorzec w `match`, a przy pierwszym wzorcu, do ktÃ³rego wartoÅ›Ä‡ â€pasujeâ€, wartoÅ›Ä‡ wpada do skojarzonego bloku kodu, aby zostaÄ‡ uÅ¼yta podczas wykonania.\n\nSkoro mowa o monetach, uÅ¼yjmy ich jako przykÅ‚adu z `match`! MoÅ¼emy napisaÄ‡ funkcjÄ™, ktÃ³ra przyjmuje nieznanÄ… monetÄ™ amerykaÅ„skÄ… i, podobnie jak maszyna liczÄ…ca, okreÅ›la, jaka to moneta i zwraca jej wartoÅ›Ä‡ w centach, jak pokazano w Listingu 6-3.\n\n<Listing number=\"6-3\" caption=\"Typ wyliczeniowy i wyraÅ¼enie `match`, ktÃ³re ma warianty typu wyliczeniowego jako wzorce\">\n\n```rust\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny => 1,\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter => 25,\n    }\n}\n# \n# fn main() {}\n```\n\n</Listing>\n\nRozÅ‚Ã³Å¼my `match` w funkcji `value_in_cents`. Najpierw wymieniamy sÅ‚owo kluczowe `match`, po ktÃ³rym nastÄ™puje wyraÅ¼enie, ktÃ³re w tym przypadku jest wartoÅ›ciÄ… `coin`. To wydaje siÄ™ bardzo podobne do wyraÅ¼enia warunkowego uÅ¼ywanego z `if`, ale jest duÅ¼a rÃ³Å¼nica: z `if` warunek musi ewaluowaÄ‡ do wartoÅ›ci boolowskiej, ale tutaj moÅ¼e to byÄ‡ dowolny typ. Typ `coin` w tym przykÅ‚adzie to enum `Coin`, ktÃ³ry zdefiniowaliÅ›my w pierwszej linii.\n\nNastÄ™pne sÄ… ramiona `match`. Ramka skÅ‚ada siÄ™ z dwÃ³ch czÄ™Å›ci: wzorca i pewnego kodu. Pierwsza ramka ma wzorzec, ktÃ³rym jest wartoÅ›Ä‡ `Coin::Penny`, a nastÄ™pnie operator `=>`, ktÃ³ry oddziela wzorzec od kodu do uruchomienia. Kod w tym przypadku to po prostu wartoÅ›Ä‡ `1`. KaÅ¼da ramka jest oddzielona od nastÄ™pnej przecinkiem.\n\nKiedy wyraÅ¼enie `match` jest wykonywane, porÃ³wnuje ono wynikowÄ… wartoÅ›Ä‡ z wzorcem kaÅ¼dej gaÅ‚Ä™zi, po kolei. JeÅ›li wzorzec pasuje do wartoÅ›ci, kod skojarzony z tym wzorcem jest wykonywany. JeÅ›li ten wzorzec nie pasuje do wartoÅ›ci, wykonanie przechodzi do nastÄ™pnej gaÅ‚Ä™zi, podobnie jak w maszynie do sortowania monet. MoÅ¼emy mieÄ‡ tyle gaÅ‚Ä™zi, ile potrzebujemy: w Listingu 6-3, nasz `match` ma cztery gaÅ‚Ä™zie.\n\nKod skojarzony z kaÅ¼dym ramieniem jest wyraÅ¼eniem, a wynikowa wartoÅ›Ä‡ wyraÅ¼enia w pasujÄ…cym ramieniu jest wartoÅ›ciÄ…, ktÃ³ra jest zwracana dla caÅ‚ego wyraÅ¼enia `match`.\n\nZazwyczaj nie uÅ¼ywamy nawiasÃ³w klamrowych, jeÅ›li kod gaÅ‚Ä™zi `match` jest krÃ³tki, jak w Listingu 6-3, gdzie kaÅ¼da gaÅ‚Ä…Åº po prostu zwraca wartoÅ›Ä‡. JeÅ›li chcesz uruchomiÄ‡ wiele linii kodu w gaÅ‚Ä™zi `match`, musisz uÅ¼yÄ‡ nawiasÃ³w klamrowych, a przecinek po gaÅ‚Ä™zi jest wtedy opcjonalny. Na przykÅ‚ad, poniÅ¼szy kod drukuje â€Lucky penny!â€ za kaÅ¼dym razem, gdy metoda jest wywoÅ‚ywana z `Coin::Penny`, ale nadal zwraca ostatniÄ… wartoÅ›Ä‡ bloku, `1`:\n\n```rust\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny => {\n            println!(\"SzczÄ™Å›liwy grosz!\");\n            1\n        }\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter => 25,\n    }\n}\n# \n# fn main() {}\n```\n\n### Wzorce, ktÃ³re wiÄ…Å¼Ä… siÄ™ z wartoÅ›ciami\n\nInnÄ… przydatnÄ… cechÄ… ramion `match` jest to, Å¼e mogÄ… one wiÄ…zaÄ‡ siÄ™ z czÄ™Å›ciami wartoÅ›ci, ktÃ³re pasujÄ… do wzorca. W ten sposÃ³b moÅ¼emy wyodrÄ™bniaÄ‡ wartoÅ›ci z wariantÃ³w enum.\n\nNa przykÅ‚ad, zmieÅ„my jeden z naszych wariantÃ³w enum, aby przechowywaÅ‚ w sobie dane. Od 1999 do 2008 roku Stany Zjednoczone biÅ‚y Ä‡wierÄ‡dolarÃ³wki z rÃ³Å¼nymi wzorami dla kaÅ¼dego z 50 stanÃ³w po jednej stronie. Å»adne inne monety nie otrzymaÅ‚y wzorÃ³w stanÃ³w, wiÄ™c tylko Ä‡wierÄ‡dolarÃ³wki majÄ… tÄ™ dodatkowÄ… wartoÅ›Ä‡. MoÅ¼emy dodaÄ‡ tÄ™ informacjÄ™ do naszego `enum`, zmieniajÄ…c wariant `Quarter` tak, aby zawieraÅ‚ wartoÅ›Ä‡ `UsState` przechowywanÄ… w Å›rodku, co zrobiliÅ›my w Listingu 6-4.\n\n<Listing number=\"6-4\" caption=\"Enum `Coin`, w ktÃ³rym wariant `Quarter` zawiera rÃ³wnieÅ¼ wartoÅ›Ä‡ `UsState`\">\n\n```rust\n#[derive(Debug)] // abyÅ›my mogli za chwilÄ™ sprawdziÄ‡ stan\nenum UsState {\n    Alabama,\n    Alaska,\n    // --snip--\n}\n\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(UsState),\n}\n# \n# fn main() {}\n```\n\n</Listing>\n\nWyobraÅºmy sobie, Å¼e przyjaciel prÃ³buje zebraÄ‡ wszystkie 50 monet stanowych. Podczas gdy my sortujemy naszÄ… drobnÄ… monetÄ™ wedÅ‚ug typu monety, bÄ™dziemy rÃ³wnieÅ¼ wywoÅ‚ywaÄ‡ nazwÄ™ stanu zwiÄ…zanego z kaÅ¼dÄ… monetÄ…, tak aby jeÅ›li jest to moneta, ktÃ³rej nasz przyjaciel nie ma, mÃ³gÅ‚ jÄ… dodaÄ‡ do swojej kolekcji.\n\nW wyraÅ¼eniu `match` dla tego kodu dodajemy zmiennÄ… o nazwie `state` do wzorca, ktÃ³ry pasuje do wartoÅ›ci wariantu `Coin::Quarter`. Gdy pasuje `Coin::Quarter`, zmienna `state` zostanie powiÄ…zana z wartoÅ›ciÄ… stanu tej Ä‡wiartki. NastÄ™pnie moÅ¼emy uÅ¼yÄ‡ `state` w kodzie dla tego ramienia, w ten sposÃ³b:\n\n```rust\n# #[derive(Debug)]\n# enum UsState {\n#     Alabama,\n#     Alaska,\n#     // --snip--\n# }\n# \n# enum Coin {\n#     Penny,\n#     Nickel,\n#     Dime,\n#     Quarter(UsState),\n# }\n# \nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny => 1,\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter(state) => {\n            println!(\"Moneta stanowa z {state:?}!\");\n            25\n        }\n    }\n}\n# \n# fn main() {\n#     value_in_cents(Coin::Quarter(UsState::Alaska));\n# }\n```\n\nGdybyÅ›my wywoÅ‚ali `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin` byÅ‚by `Coin::Quarter(UsState::Alaska)`. Kiedy porÃ³wnamy tÄ™ wartoÅ›Ä‡ z kaÅ¼dym z ramion `match`, Å¼adne z nich nie pasuje, dopÃ³ki nie dotrzemy do `Coin::Quarter(state)`. W tym momencie wiÄ…zanie dla `state` bÄ™dzie wartoÅ›ciÄ… `UsState::Alaska`. MoÅ¼emy nastÄ™pnie uÅ¼yÄ‡ tego wiÄ…zania w wyraÅ¼eniu `println!`, uzyskujÄ…c w ten sposÃ³b wewnÄ™trznÄ… wartoÅ›Ä‡ stanu z wariantu enum `Coin` dla `Quarter`.\n\n<a id=\"matching-with-optiont\"></a>\n\n### Wzorzec `Option<T>` `match`\n\n\nW poprzedniej sekcji chcieliÅ›my wydobyÄ‡ wewnÄ™trznÄ… wartoÅ›Ä‡ `T` z przypadku `Some` podczas uÅ¼ywania `Option<T>`; moÅ¼emy rÃ³wnieÅ¼ obsÅ‚ugiwaÄ‡ `Option<T>` za pomocÄ… `match`, tak jak zrobiliÅ›my to z enumem `Coin`! Zamiast porÃ³wnywaÄ‡ monety, bÄ™dziemy porÃ³wnywaÄ‡ warianty `Option<T>`, ale sposÃ³b dziaÅ‚ania wyraÅ¼enia `match` pozostaje taki sam.\n\nPowiedzmy, Å¼e chcemy napisaÄ‡ funkcjÄ™, ktÃ³ra przyjmuje `Option<i32>` i, jeÅ›li w Å›rodku jest wartoÅ›Ä‡, dodaje do niej 1. JeÅ›li w Å›rodku nie ma wartoÅ›ci, funkcja powinna zwrÃ³ciÄ‡ wartoÅ›Ä‡ `None` i nie prÃ³bowaÄ‡ wykonywaÄ‡ Å¼adnych operacji.\n\nTÄ™ funkcjÄ™ bardzo Å‚atwo napisaÄ‡, dziÄ™ki `match`, i bÄ™dzie ona wyglÄ…daÄ‡ jak Listing 6-5.\n\n<Listing number=\"6-5\" caption=\"Funkcja, ktÃ³ra uÅ¼ywa wyraÅ¼enia `match` w `Option<i32>`\">\n\n```rust\n# fn main() {\n    fn plus_one(x: Option<i32>) -> Option<i32> {\n        match x {\n            None => None,\n            Some(i) => Some(i + 1),\n        }\n    }\n\n    let five = Some(5);\n    let six = plus_one(five);\n    let none = plus_one(None);\n# }\n```\n\n</Listing>\n\nPrzyjrzyjmy siÄ™ dokÅ‚adniej pierwszemu wykonaniu `plus_one`. Kiedy wywoÅ‚ujemy `plus_one(five)`, zmienna `x` w ciele `plus_one` bÄ™dzie miaÅ‚a wartoÅ›Ä‡ `Some(5)`. NastÄ™pnie porÃ³wnujemy jÄ… z kaÅ¼dym ramieniem `match`:\n\n```rust,ignore\n# fn main() {\n#     fn plus_one(x: Option<i32>) -> Option<i32> {\n#         match x {\n            None => None,\n#             Some(i) => Some(i + 1),\n#         }\n#     }\n# \n#     let five = Some(5);\n#     let six = plus_one(five);\n#     let none = plus_one(None);\n# }\n```\n\nWartoÅ›Ä‡ `Some(5)` nie pasuje do wzorca `None`, wiÄ™c przechodzimy do nastÄ™pnego ramienia:\n\n```rust,ignore\n# fn main() {\n#     fn plus_one(x: Option<i32>) -> Option<i32> {\n#         match x {\n#             None => None,\n            Some(i) => Some(i + 1),\n#         }\n#     }\n# \n#     let five = Some(5);\n#     let six = plus_one(five);\n#     let none = plus_one(None);\n# }\n```\n\nCzy `Some(5)` pasuje do `Some(i)`? Tak! Mamy ten sam wariant. `i` wiÄ…Å¼e siÄ™ z wartoÅ›ciÄ… zawartÄ… w `Some`, wiÄ™c `i` przyjmuje wartoÅ›Ä‡ `5`. NastÄ™pnie kod w ramieniu `match` jest wykonywany, wiÄ™c dodajemy 1 do wartoÅ›ci `i` i tworzymy nowÄ… wartoÅ›Ä‡ `Some` z naszym Å‚Ä…cznym `6` w Å›rodku.\n\nRozwaÅ¼my teraz drugie wywoÅ‚anie `plus_one` w Listingu 6-5, gdzie `x` jest `None`. Wchodzimy do `match` i porÃ³wnujemy z pierwszym ramieniem:\n\n```rust,ignore\n# fn main() {\n#     fn plus_one(x: Option<i32>) -> Option<i32> {\n#         match x {\n            None => None,\n#             Some(i) => Some(i + 1),\n#         }\n#     }\n# \n#     let five = Some(5);\n#     let six = plus_one(five);\n#     let none = plus_one(None);\n# }\n```\n\nPasuje! Nie ma wartoÅ›ci do dodania, wiÄ™c program zatrzymuje siÄ™ i zwraca wartoÅ›Ä‡ `None` po prawej stronie `=>`. PoniewaÅ¼ pierwsze ramiÄ™ pasowaÅ‚o, Å¼adne inne ramiona nie sÄ… porÃ³wnywane.\n\nÅÄ…czenie `match` i enumÃ³w jest przydatne w wielu sytuacjach. BÄ™dziesz czÄ™sto widziaÅ‚ ten wzorzec w kodzie Rust: `match` z enumem, powiÄ…zanie zmiennej z danymi wewnÄ…trz, a nastÄ™pnie wykonanie kodu na tej podstawie. Na poczÄ…tku jest to trochÄ™ trudne, ale gdy siÄ™ do tego przyzwyczaisz, bÄ™dziesz Å¼aÅ‚owaÅ‚, Å¼e nie miaÅ‚eÅ› tego we wszystkich jÄ™zykach. Jest to konsekwentnie ulubiona funkcja uÅ¼ytkownikÃ³w.\n\n### Dopasowania sÄ… wyczerpujÄ…ce\n\nJest jeszcze jeden aspekt `match`, ktÃ³ry musimy omÃ³wiÄ‡: wzorce ramion muszÄ… obejmowaÄ‡ wszystkie moÅ¼liwoÅ›ci. RozwaÅ¼my tÄ™ wersjÄ™ naszej funkcji `plus_one`, ktÃ³ra zawiera bÅ‚Ä…d i nie skompiluje siÄ™:\n\n```rust,ignore,does_not_compile\n# fn main() {\n    fn plus_one(x: Option<i32>) -> Option<i32> {\n        match x {\n            Some(i) => Some(i + 1),\n        }\n    }\n# \n#     let five = Some(5);\n#     let six = plus_one(five);\n#     let none = plus_one(None);\n# }\n```\n\nNie obsÅ‚uÅ¼yliÅ›my przypadku `None`, wiÄ™c ten kod spowoduje bÅ‚Ä…d. Na szczÄ™Å›cie jest to bÅ‚Ä…d, ktÃ³ry Rust potrafi wyÅ‚apaÄ‡. JeÅ›li sprÃ³bujemy skompilowaÄ‡ ten kod, otrzymamy taki bÅ‚Ä…d:\n\n```console\n$ cargo run\n   Compiling enums v0.1.0 (file:///projects/enums)\nerror[E0004]: non-exhaustive patterns: `None` nie pokryto\n --> src/main.rs:3:15\n  |\n3 |         match x {\n  |               ^ wzorzec `None` nie pokryto\n  |\nnote: `Option<i32>` zdefiniowano tutaj\n --> /rustc/1159e78c4747b02ef996e55082b704c09b970588/library/core/src/option.rs:593:1\n ::: /rustc/1159e78c4747b02ef996e55082b704c09b970588/library/core/src/option.rs:597:5\n  |\n  = note: nie pokryto\n  = note: dopasowana wartoÅ›Ä‡ jest typu `Option<i32>`\nhelp: upewnij siÄ™, Å¼e wszystkie moÅ¼liwe przypadki sÄ… obsÅ‚ugiwane, dodajÄ…c ramiÄ™ dopasowania z wzorcem wieloznacznym lub jawnym wzorcem, jak pokazano\n  |\n4 ~             Some(i) => Some(i + 1),\n5 ~             None => todo!(),\n  |\n\nFor more information about this error, try `rustc --explain E0004`.\nerror: could not compile `enums` (bin \"enums\") due to 1 previous error\n```\n\nRust wie, Å¼e nie objÄ™liÅ›my kaÅ¼dego moÅ¼liwego przypadku i nawet wie, ktÃ³ry wzorzec pominÄ™liÅ›my! Dopasowania w Rust sÄ… _wyczerpujÄ…ce_: Musimy wyczerpaÄ‡ kaÅ¼dÄ… ostatniÄ… moÅ¼liwoÅ›Ä‡, aby kod byÅ‚ poprawny. ZwÅ‚aszcza w przypadku `Option<T>`, gdy Rust uniemoÅ¼liwia nam zapomnienie o jawnej obsÅ‚udze przypadku `None`, chroni nas przed zakÅ‚adaniem, Å¼e mamy wartoÅ›Ä‡, gdy moÅ¼emy mieÄ‡ null, co uniemoÅ¼liwia popeÅ‚nienie bÅ‚Ä™du miliarda dolarÃ³w, o ktÃ³rym mÃ³wiliÅ›my wczeÅ›niej.\n\n### Wzorce ogÃ³lne (Catch-All) i symbol zastÄ™pczy `_`\n\nUÅ¼ywajÄ…c typÃ³w wyliczeniowych, moÅ¼emy rÃ³wnieÅ¼ podejmowaÄ‡ specjalne dziaÅ‚ania dla kilku konkretnych wartoÅ›ci, ale dla wszystkich innych wartoÅ›ci podjÄ…Ä‡ jedno domyÅ›lne dziaÅ‚anie. WyobraÅºmy sobie, Å¼e implementujemy grÄ™, w ktÃ³rej, jeÅ›li na rzucie kostkÄ… wypadnie 3, gracz nie rusza siÄ™, ale zamiast tego dostaje fantazyjny nowy kapelusz. JeÅ›li wypadnie 7, gracz traci fantazyjny kapelusz. Dla wszystkich innych wartoÅ›ci, gracz przesuwa siÄ™ o tÄ™ liczbÄ™ pÃ³l na planszy. Oto `match`, ktÃ³ry implementuje tÄ™ logikÄ™, z wynikiem rzutu kostkÄ… zakodowanym na staÅ‚e, a nie wartoÅ›ciÄ… losowÄ…, a caÅ‚a inna logika jest reprezentowana przez funkcje bez ciaÅ‚, poniewaÅ¼ ich faktyczne zaimplementowanie wykracza poza zakres tego przykÅ‚adu:\n\n```rust\n# fn main() {\n    let dice_roll = 9;\n    match dice_roll {\n        3 => add_fancy_hat(),\n        7 => remove_fancy_hat(),\n        other => move_player(other),\n    }\n\n    fn add_fancy_hat() {}\n    fn fn remove_fancy_hat() {}\n    fn move_player(num_spaces: u8) {}\n# }\n```\n\nDla pierwszych dwÃ³ch gaÅ‚Ä™zi wzorcami sÄ… literaÅ‚y `3` i `7`. Dla ostatniej gaÅ‚Ä™zi, ktÃ³ra obejmuje wszystkie inne moÅ¼liwe wartoÅ›ci, wzorcem jest zmienna, ktÃ³rÄ… nazwaliÅ›my `other`. Kod uruchamiany dla gaÅ‚Ä™zi `other` uÅ¼ywa zmiennej, przekazujÄ…c jÄ… do funkcji `move_player`.\n\nTen kod kompiluje siÄ™, chociaÅ¼ nie wymieniliÅ›my wszystkich moÅ¼liwych wartoÅ›ci, jakie moÅ¼e mieÄ‡ `u8`, poniewaÅ¼ ostatni wzorzec bÄ™dzie pasowaÅ‚ do wszystkich wartoÅ›ci, ktÃ³re nie zostaÅ‚y specjalnie wymienione. Ten wzorzec typu catch-all speÅ‚nia wymÃ³g, Å¼e `match` musi byÄ‡ wyczerpujÄ…ce. ZauwaÅ¼, Å¼e musimy umieÅ›ciÄ‡ ramiÄ™ typu catch-all na koÅ„cu, poniewaÅ¼ wzorce sÄ… oceniane po kolei. GdybyÅ›my umieÅ›cili ramiÄ™ typu catch-all wczeÅ›niej, inne ramiona nigdy by siÄ™ nie uruchomiÅ‚y, wiÄ™c Rust ostrzeÅ¼e nas, jeÅ›li dodamy ramiona po catch-all!\n\nRust posiada rÃ³wnieÅ¼ wzorzec, ktÃ³rego moÅ¼emy uÅ¼yÄ‡, gdy chcemy zastosowaÄ‡ wzorzec ogÃ³lny, ale nie chcemy _uÅ¼ywaÄ‡_ wartoÅ›ci w tym wzorcu: `_` to specjalny wzorzec, ktÃ³ry pasuje do dowolnej wartoÅ›ci i nie wiÄ…Å¼e siÄ™ z tÄ… wartoÅ›ciÄ…. To mÃ³wi Rustowi, Å¼e nie bÄ™dziemy uÅ¼ywaÄ‡ tej wartoÅ›ci, wiÄ™c Rust nie ostrzeÅ¼e nas o nieuÅ¼ywanej zmiennej.\n\nZmieÅ„my zasady gry: teraz, jeÅ›li wyrzucisz coÅ› innego niÅ¼ 3 lub 7, musisz rzuciÄ‡ ponownie. Nie potrzebujemy juÅ¼ uÅ¼ywaÄ‡ wartoÅ›ci typu catch-all, wiÄ™c moÅ¼emy zmieniÄ‡ nasz kod, aby uÅ¼ywaÅ‚ `_` zamiast zmiennej o nazwie `other`:\n\n```rust\n# fn main() {\n    let dice_roll = 9;\n    match dice_roll {\n        3 => add_fancy_hat(),\n        7 => remove_fancy_hat(),\n        _ => reroll(),\n    }\n\n    fn add_fancy_hat() {}\n    fn remove_fancy_hat() {}\n    fn reroll() {}\n# }\n```\n\nTen przykÅ‚ad rÃ³wnieÅ¼ speÅ‚nia wymÃ³g wyczerpujÄ…cego dopasowania, poniewaÅ¼ jawnie ignorujemy wszystkie inne wartoÅ›ci w ostatnim ramieniu; niczego nie pominÄ™liÅ›my.\n\nNa koniec zmienimy zasady gry jeszcze raz, tak aby nic innego nie dziaÅ‚o siÄ™ w Twojej turze, jeÅ›li wyrzucisz coÅ› innego niÅ¼ 3 lub 7. MoÅ¼emy to wyraziÄ‡, uÅ¼ywajÄ…c wartoÅ›ci jednostkowej (typu pustej krotki, o ktÃ³rej wspominaliÅ›my w sekcji [â€Typ krotkiâ€][tuples]<!-- ignore -->) jako kodu, ktÃ³ry towarzyszy ramieniu `_`:\n\n```rust\n# fn main() {\n    let dice_roll = 9;\n    match dice_roll {\n        3 => add_fancy_hat(),\n        7 => remove_fancy_hat(),\n        _ => (),\n    }\n\n    fn add_fancy_hat() {}\n    fn remove_fancy_hat() {}\n# }\n```\n\nTutaj jawnie mÃ³wimy Rustowi, Å¼e nie zamierzamy uÅ¼ywaÄ‡ Å¼adnej innej wartoÅ›ci, ktÃ³ra nie pasuje do wzorca w poprzednim ramieniu, i nie chcemy uruchamiaÄ‡ Å¼adnego kodu w tym przypadku.\n\nWiÄ™cej o wzorcach i dopasowywaniu omÃ³wimy w [Rozdziale 19][ch19-00-patterns]<!-- ignore -->. Na razie przejdziemy do skÅ‚adni `if let`, ktÃ³ra moÅ¼e byÄ‡ uÅ¼yteczna w sytuacjach, gdy wyraÅ¼enie `match` jest nieco rozwlekÅ‚e.\n\n[tuples]: ch03-02-data-types.html#the-tuple-type\n[ch19-00-patterns]: ch19-00-patterns.html",
        "chapter_title": "Konstrukcja kontroli przepÅ‚ywu `match`"
    },
    {
        "file_path": "ch06-03-if-let.md",
        "content": "## ZwiÄ™zÅ‚a kontrola przepÅ‚ywu z `if let` i `let...else`\n\nSkÅ‚adnia `if let` pozwala poÅ‚Ä…czyÄ‡ `if` i `let` w mniej rozwlekÅ‚y sposÃ³b obsÅ‚ugi wartoÅ›ci pasujÄ…cych do jednego wzorca, ignorujÄ…c pozostaÅ‚e. RozwaÅ¼ program z Listingu 6-6, ktÃ³ry dopasowuje wartoÅ›Ä‡ `Option<u8>` w zmiennej `config_max`, ale chce wykonaÄ‡ kod tylko wtedy, gdy wartoÅ›Ä‡ jest wariantem `Some`.\n\n<Listing number=\"6-6\" caption=\"`match`, ktÃ³ry dba tylko o wykonanie kodu, gdy wartoÅ›Ä‡ jest `Some`\">\n\n```rust\n# fn main() {\n    let config_max = Some(3u8);\n    match config_max {\n        Some(max) => println!(\"Maksymalna wartoÅ›Ä‡ skonfigurowana to {max}\"),\n        _ => (),\n    }\n# }\n```\n\n</Listing>\n\nJeÅ›li wartoÅ›Ä‡ jest `Some`, drukujemy wartoÅ›Ä‡ z wariantu `Some`, wiÄ…Å¼Ä…c jÄ… ze zmiennÄ… `max` we wzorcu. Nie chcemy nic robiÄ‡ z wartoÅ›ciÄ… `None`. Aby speÅ‚niÄ‡ wyraÅ¼enie `match`, musimy dodaÄ‡ `_ => ()` po przetworzeniu tylko jednego wariantu, co jest irytujÄ…cym, powtarzalnym kodem do dodania.\n\nZamiast tego, moglibyÅ›my to napisaÄ‡ w krÃ³tszy sposÃ³b za pomocÄ… `if let`. PoniÅ¼szy kod zachowuje siÄ™ tak samo jak `match` w Listingu 6-6:\n\n```rust\n# fn main() {\n    let config_max = Some(3u8);\n    if let Some(max) = config_max {\n        println!(\"Maksymalna wartoÅ›Ä‡ skonfigurowana to {max}\");\n    }\n# }\n```\n\nSkÅ‚adnia `if let` przyjmuje wzorzec i wyraÅ¼enie oddzielone znakiem rÃ³wnoÅ›ci. DziaÅ‚a tak samo jak `match`, gdzie wyraÅ¼enie jest przekazywane do `match`, a wzorzec jest jego pierwszym ramieniem. W tym przypadku wzorzec to `Some(max)`, a `max` wiÄ…Å¼e siÄ™ z wartoÅ›ciÄ… wewnÄ…trz `Some`. MoÅ¼emy nastÄ™pnie uÅ¼yÄ‡ `max` w ciele bloku `if let` w ten sam sposÃ³b, w jaki uÅ¼yliÅ›my `max` w odpowiadajÄ…cym ramieniu `match`. Kod w bloku `if let` jest wykonywany tylko wtedy, gdy wartoÅ›Ä‡ pasuje do wzorca.\n\nUÅ¼ywanie `if let` oznacza mniej pisania, mniej wciÄ™Ä‡ i mniej kodu szablonowego. Tracisz jednak wyczerpujÄ…ce sprawdzanie, ktÃ³re wymusza `match`, a ktÃ³re gwarantuje, Å¼e nie zapomnisz obsÅ‚uÅ¼yÄ‡ Å¼adnych przypadkÃ³w. WybÃ³r miÄ™dzy `match` a `if let` zaleÅ¼y od tego, co robisz w konkretnej sytuacji i czy zyskanie zwiÄ™zÅ‚oÅ›ci jest odpowiednim kompromisem za utratÄ™ wyczerpujÄ…cego sprawdzania.\n\nInnymi sÅ‚owy, `if let` moÅ¼na traktowaÄ‡ jako skÅ‚adniÄ™ cukrowÄ… dla `match`, ktÃ³ra uruchamia kod, gdy wartoÅ›Ä‡ pasuje do jednego wzorca, a nastÄ™pnie ignoruje wszystkie inne wartoÅ›ci.\n\nMoÅ¼emy doÅ‚Ä…czyÄ‡ `else` do `if let`. Blok kodu, ktÃ³ry towarzyszy `else`, jest taki sam jak blok kodu, ktÃ³ry towarzyszyÅ‚by przypadkowi `_` w wyraÅ¼eniu `match` rÃ³wnowaÅ¼nym `if let` i `else`. Przypomnij sobie definicjÄ™ enum `Coin` w Listingu 6-4, gdzie wariant `Quarter` zawieraÅ‚ rÃ³wnieÅ¼ wartoÅ›Ä‡ `UsState`. GdybyÅ›my chcieli zliczaÄ‡ wszystkie monety inne niÅ¼ Ä‡wierÄ‡dolarÃ³wki, jednoczeÅ›nie ogÅ‚aszajÄ…c stan Ä‡wierÄ‡dolarÃ³wek, moglibyÅ›my to zrobiÄ‡ za pomocÄ… wyraÅ¼enia `match`, tak jak to:\n\n```rust\n# #[derive(Debug)]\n# enum UsState {\n#     Alabama,\n#     Alaska,\n#     // --snip--\n# }\n# \n# enum Coin {\n#     Penny,\n#     Nickel,\n#     Dime,\n#     Quarter(UsState),\n# }\n# \n# fn main() {\n#     let coin = Coin::Penny;\n    let mut count = 0;\n    match coin {\n        Coin::Quarter(state) => println!(\"Moneta stanowa z {state:?}!\"),\n        _ => count += 1,\n    }\n# }\n```\n\nAlbo moglibyÅ›my uÅ¼yÄ‡ wyraÅ¼enia `if let` i `else`, w ten sposÃ³b:\n\n```rust\n# #[derive(Debug)]\n# enum UsState {\n#     Alabama,\n#     Alaska,\n#     // --snip--\n# }\n# \n# enum Coin {\n#     Penny,\n#     Nickel,\n#     Dime,\n#     Quarter(UsState),\n# }\n# \n# fn main() {\n#     let coin = Coin::Penny;\n    let mut count = 0;\n    if let Coin::Quarter(state) = coin {\n        println!(\"Moneta stanowa z {state:?}!\");\n    } else {\n        count += 1;\n    }\n# }\n```\n\n## Pozostawanie na â€szczÄ™Å›liwej Å›cieÅ¼ceâ€ z `let...else`\n\nCzÄ™stym wzorcem jest wykonanie pewnego obliczenia, gdy wartoÅ›Ä‡ jest obecna, a w przeciwnym razie zwrÃ³cenie wartoÅ›ci domyÅ›lnej. KontynuujÄ…c nasz przykÅ‚ad monet z wartoÅ›ciÄ… `UsState`, gdybyÅ›my chcieli powiedzieÄ‡ coÅ› zabawnego w zaleÅ¼noÅ›ci od wieku stanu na monecie, moglibyÅ›my wprowadziÄ‡ metodÄ™ w `UsState` do sprawdzania wieku stanu, w ten sposÃ³b:\n\n```rust\n# #[derive(Debug)] // abyÅ›my mogli za chwilÄ™ sprawdziÄ‡ stan\n# enum UsState {\n#     Alabama,\n#     Alaska,\n#     // --snip--\n# }\n# \nimpl UsState {\n    fn existed_in(&self, year: u16) -> bool {\n        match self {\n            UsState::Alabama => year >= 1819,\n            UsState::Alaska => year >= 1959,\n            // -- snip --\n        }\n    }\n}\n# \n# enum Coin {\n#     Penny,\n#     Nickel,\n#     Dime,\n#     Quarter(UsState),\n# }\n# \n# fn describe_state_quarter(coin: Coin) -> Option<String> {\n#     if let Coin::Quarter(state) = coin {\n#         if state.existed_in(1900) {\n#             Some(format!(\"{state:?} jest doÅ›Ä‡ stare, jak na AmerykÄ™!\"))\n#         } else {\n#             Some(format!(\"{state:?} jest stosunkowo nowe.\"))\n#         }\n#     } else {\n#         None\n#     }\n# }\n# \n# fn main() {\n#     if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {\n#         println!(\"{desc}\");\n#     }\n# }\n```\n\nNastÄ™pnie, moglibyÅ›my uÅ¼yÄ‡ `if let`, aby dopasowaÄ‡ typ monety, wprowadzajÄ…c zmiennÄ… `state` w treÅ›ci warunku, jak w Listingu 6-7.\n\n<Listing number=\"6-7\" caption=\"Sprawdzanie, czy stan istniaÅ‚ w 1900 roku za pomocÄ… warunkÃ³w zagnieÅ¼dÅ¼onych w `if let`\">\n\n```rust\n# #[derive(Debug)] // abyÅ›my mogli za chwilÄ™ sprawdziÄ‡ stan\n# enum UsState {\n#     Alabama,\n#     Alaska,\n#     // --snip--\n# }\n# \n# impl UsState {\n#     fn existed_in(&self, year: u16) -> bool {\n#         match self {\n#             UsState::Alabama => year >= 1819,\n#             UsState::Alaska => year >= 1959,\n#             // -- snip --\n#         }\n#     }\n# }\n# \n# enum Coin {\n#     Penny,\n#     Nickel,\n#     Dime,\n#     Quarter(UsState),\n# }\n# \nfn describe_state_quarter(coin: Coin) -> Option<String> {\n    if let Coin::Quarter(state) = coin {\n        if state.existed_in(1900) {\n            Some(format!(\"{state:?} jest doÅ›Ä‡ stare, jak na AmerykÄ™!\"))\n        } else {\n            Some(format!(\"{state:?} jest stosunkowo nowe.\"))\n        }\n    } else {\n        None\n    }\n}\n# \n# fn main() {\n#     if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {\n#         println!(\"{desc}\");\n#     }\n# }\n```\n\n</Listing>\n\nTo zaÅ‚atwia sprawÄ™, ale przenosi pracÄ™ do ciaÅ‚a instrukcji `if let`, a jeÅ›li praca do wykonania jest bardziej skomplikowana, trudno moÅ¼e byÄ‡ dokÅ‚adnie Å›ledziÄ‡, jak gaÅ‚Ä™zie najwyÅ¼szego poziomu siÄ™ ze sobÄ… Å‚Ä…czÄ…. MoglibyÅ›my rÃ³wnieÅ¼ wykorzystaÄ‡ fakt, Å¼e wyraÅ¼enia produkujÄ… wartoÅ›Ä‡, aby albo wyprodukowaÄ‡ `state` z `if let`, albo zwrÃ³ciÄ‡ wczeÅ›nie, jak w Listingu 6-8. (PodobnÄ… rzecz moÅ¼na by zrobiÄ‡ z `match`.)\n\n<Listing number=\"6-8\" caption=\"UÅ¼ywanie `if let` do produkcji wartoÅ›ci lub wczesnego powrotu\">\n\n```rust\n# #[derive(Debug)] // abyÅ›my mogli za chwilÄ™ sprawdziÄ‡ stan\n# enum UsState {\n#     Alabama,\n#     Alaska,\n#     // --snip--\n# }\n# \n# impl UsState {\n#     fn existed_in(&self, year: u16) -> bool {\n#         match self {\n#             UsState::Alabama => year >= 1819,\n#             UsState::Alaska => year >= 1959,\n#             // -- snip --\n#         }\n#     }\n# }\n# \n# enum Coin {\n#     Penny,\n#     Nickel,\n#     Dime,\n#     Quarter(UsState),\n# }\n# \nfn describe_state_quarter(coin: Coin) -> Option<String> {\n    let state = if let Coin::Quarter(state) = coin {\n        state\n    } else {\n        return None;\n    };\n\n    if state.existed_in(1900) {\n        Some(format!(\"{state:?} jest doÅ›Ä‡ stare, jak na AmerykÄ™!\"))\n    } else {\n        Some(format!(\"{state:?} jest stosunkowo nowe.\"))\n    }\n}\n# \n# fn main() {\n#     if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {\n#         println!(\"{desc}\");\n#     }\n# }\n```\n\n</Listing>\n\nTo jest w pewnym sensie trochÄ™ irytujÄ…ce! Jedna gaÅ‚Ä…Åº `if let` produkuje wartoÅ›Ä‡, a druga caÅ‚kowicie zwraca z funkcji.\n\nAby ten powszechny wzorzec byÅ‚ Å‚atwiejszy do wyraÅ¼enia, Rust posiada `let...else`. SkÅ‚adnia `let...else` przyjmuje wzorzec po lewej stronie i wyraÅ¼enie po prawej, bardzo podobnie do `if let`, ale nie ma gaÅ‚Ä™zi `if`, tylko gaÅ‚Ä…Åº `else`. JeÅ›li wzorzec pasuje, to wiÄ…Å¼e wartoÅ›Ä‡ ze wzorca w zewnÄ™trznym zasiÄ™gu. JeÅ›li wzorzec _nie_ pasuje, program przechodzi do gaÅ‚Ä™zi `else`, ktÃ³ra musi zwrÃ³ciÄ‡ wartoÅ›Ä‡ z funkcji.\n\nW Listingu 6-9 moÅ¼esz zobaczyÄ‡, jak wyglÄ…da Listing 6-8, gdy uÅ¼ywamy `let...else` zamiast `if let`.\n\n<Listing number=\"6-9\" caption=\"UÅ¼ywanie `let...else` do wyjaÅ›nienia przepÅ‚ywu przez funkcjÄ™\">\n\n```rust\n# #[derive(Debug)] // abyÅ›my mogli za chwilÄ™ sprawdziÄ‡ stan\n# enum UsState {\n#     Alabama,\n#     Alaska,\n#     // --snip--\n# }\n# \n# impl UsState {\n#     fn existed_in(&self, year: u16) -> bool {\n#         match self {\n#             UsState::Alabama => year >= 1819,\n#             UsState::Alaska => year >= 1959,\n#             // -- snip --\n#         }\n#     }\n# }\n# \n# enum Coin {\n#     Penny,\n#     Nickel,\n#     Dime,\n#     Quarter(UsState),\n# }\n# \nfn describe_state_quarter(coin: Coin) -> Option<String> {\n    let Coin::Quarter(state) = coin else {\n        return None;\n    };\n\n    if state.existed_in(1900) {\n        Some(format!(\"{state:?} jest doÅ›Ä‡ stare, jak na AmerykÄ™!\"))\n    } else {\n        Some(format!(\"{state:?} jest stosunkowo nowe.\"))\n    }\n}\n# \n# fn main() {\n#     if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {\n#         println!(\"{desc}\");\n#     }\n# }\n```\n\n</Listing>\n\nZauwaÅ¼, Å¼e w ten sposÃ³b pozostaje ona na â€szczÄ™Å›liwej Å›cieÅ¼ceâ€ w gÅ‚Ã³wnym ciele funkcji, bez znaczÄ…co rÃ³Å¼niÄ…cego siÄ™ przepÅ‚ywu sterowania dla dwÃ³ch gaÅ‚Ä™zi, tak jak to byÅ‚o w przypadku `if let`.\n\nJeÅ›li znajdziesz siÄ™ w sytuacji, w ktÃ³rej logika Twojego programu jest zbyt rozwlekÅ‚a, aby wyraziÄ‡ jÄ… za pomocÄ… `match`, pamiÄ™taj, Å¼e `if let` i `let...else` rÃ³wnieÅ¼ sÄ… w Twojej skrzynce narzÄ™dziowej Rust.\n\n## Podsumowanie\n\nOmÃ³wiliÅ›my, jak uÅ¼ywaÄ‡ typÃ³w wyliczeniowych do tworzenia niestandardowych typÃ³w, ktÃ³re mogÄ… byÄ‡ jednym z zestawu wyliczonych wartoÅ›ci. PokazaliÅ›my, jak typ `Option<T>` z biblioteki standardowej pomaga uÅ¼ywaÄ‡ systemu typÃ³w do zapobiegania bÅ‚Ä™dom. Gdy wartoÅ›ci wyliczeniowe zawierajÄ… dane, moÅ¼esz uÅ¼yÄ‡ `match` lub `if let` do wyodrÄ™bnienia i uÅ¼ycia tych wartoÅ›ci, w zaleÅ¼noÅ›ci od liczby przypadkÃ³w, ktÃ³re musisz obsÅ‚uÅ¼yÄ‡.\n\nTwoje programy w Rust mogÄ… teraz wyraÅ¼aÄ‡ koncepcje w Twojej dziedzinie za pomocÄ… struktur i typÃ³w wyliczeniowych. Tworzenie niestandardowych typÃ³w do uÅ¼ycia w Twoim API zapewnia bezpieczeÅ„stwo typÃ³w: kompilator upewni siÄ™, Å¼e Twoje funkcje otrzymujÄ… tylko wartoÅ›ci typu, ktÃ³rego oczekuje kaÅ¼da funkcja.\n\nAby zapewniÄ‡ uÅ¼ytkownikom dobrze zorganizowane API, ktÃ³re jest proste w uÅ¼yciu i eksponuje dokÅ‚adnie to, czego bÄ™dÄ… potrzebowaÄ‡, przejdÅºmy teraz do moduÅ‚Ã³w Rust.\n",
        "chapter_title": "ZwiÄ™zÅ‚a kontrola przepÅ‚ywu z `if let` i `let...else`"
    },
    {
        "file_path": "ch07-00-managing-growing-projects-with-packages-crates-and-modules.md",
        "content": "<a id=\"managing-growing-projects-with-packages-crates-and-modules\"></a>\n\n# Pakiety, KapsuÅ‚y (Crate) i ModuÅ‚y\n\nW miarÄ™ pisania duÅ¼ych programÃ³w organizacja kodu staje siÄ™ coraz waÅ¼niejsza.GrupujÄ…c powiÄ…zane funkcjonalnoÅ›ci i oddzielajÄ…c kod o rÃ³Å¼nych cechach,wyjaÅ›nisz, gdzie znaleÅºÄ‡ kod implementujÄ…cy okreÅ›lonÄ… funkcjÄ™ i gdzieudaÄ‡ siÄ™, aby zmieniÄ‡ sposÃ³b dziaÅ‚ania funkcji.\n\nNapisane do tej pory programy znajdowaÅ‚y siÄ™ w jednym module w jednym pliku. W miarÄ™ rozrastania siÄ™ projektu, kod powinien byÄ‡ dzielony na wiele moduÅ‚Ã³w, a nastÄ™pnie na wiele plikÃ³w. Pakiet moÅ¼e zawieraÄ‡ wiele kapsuÅ‚ binarnych i opcjonalnie jednÄ… kapsuÅ‚Ä™ bibliotecznÄ…. W miarÄ™ rozrastania siÄ™ pakietu, moÅ¼na wyodrÄ™bniÄ‡ jego czÄ™Å›ci do osobnych kapsuÅ‚, ktÃ³re stajÄ… siÄ™ zewnÄ™trznymi zaleÅ¼noÅ›ciami. Ten rozdziaÅ‚ obejmuje wszystkie te techniki. Dla bardzo duÅ¼ych projektÃ³w skÅ‚adajÄ…cych siÄ™ z zestawu powiÄ…zanych ze sobÄ… pakietÃ³w, ktÃ³re ewoluujÄ… razem, Cargo oferuje obszary robocze, ktÃ³re omÃ³wimy w sekcji [â€Obszary robocze Cargoâ€][workspaces]<!-- ignore --> w Rozdziale 14.\n\nOmÃ³wimy rÃ³wnieÅ¼ hermetyzacjÄ™ szczegÃ³Å‚Ã³w implementacji, co pozwala na ponowne wykorzystanie kodu na wyÅ¼szym poziomie: po zaimplementowaniu operacji, inny kod moÅ¼e wywoÅ‚aÄ‡ twÃ³j kod za poÅ›rednictwem jego publicznego interfejsu, bez koniecznoÅ›ci znajomoÅ›ci dziaÅ‚ania implementacji. SposÃ³b, w jaki piszesz kod, okreÅ›la, ktÃ³re czÄ™Å›ci sÄ… publiczne do uÅ¼ytku przez inny kod, a ktÃ³re sÄ… prywatnymi szczegÃ³Å‚ami implementacji, ktÃ³re zastrzegasz sobie prawo do zmiany. Jest to kolejny sposÃ³b na ograniczenie iloÅ›ci szczegÃ³Å‚Ã³w, ktÃ³re musisz mieÄ‡ w gÅ‚owie.\n\nPowiÄ…zanÄ… koncepcjÄ… jest zasiÄ™g: zagnieÅ¼dÅ¼ony kontekst, w ktÃ³rym pisany jest kod, ma zestaw nazw, ktÃ³re sÄ… zdefiniowane jako â€w zasiÄ™guâ€. Podczas czytania, pisania i kompilowania kodu, programiÅ›ci i kompilatory muszÄ… wiedzieÄ‡, czy dana nazwa w danym miejscu odnosi siÄ™ do zmiennej, funkcji, struktury, typu wyliczeniowego, moduÅ‚u, staÅ‚ej lub innego elementu i co ten element oznacza. MoÅ¼esz tworzyÄ‡ zasiÄ™gi i zmieniaÄ‡, ktÃ³re nazwy sÄ… w zasiÄ™gu lub poza nim. Nie moÅ¼esz mieÄ‡ dwÃ³ch elementÃ³w o tej samej nazwie w tym samym zasiÄ™gu; dostÄ™pne sÄ… narzÄ™dzia do rozwiÄ…zywania konfliktÃ³w nazw.\n\nRust ma szereg funkcji, ktÃ³re pozwalajÄ… zarzÄ…dzaÄ‡ organizacjÄ… kodu, w tym to, ktÃ³re szczegÃ³Å‚y sÄ… ujawniane, ktÃ³re sÄ… prywatne i jakie nazwy znajdujÄ… siÄ™ w kaÅ¼dym zasiÄ™gu w twoich programach. Te funkcje, czasami zbiorczo nazywane _systemem moduÅ‚Ã³w_, obejmujÄ…:\n\n* **Pakiety**: Funkcja Cargo, ktÃ³ra umoÅ¼liwia budowanie, testowanie i udostÄ™pnianie kapsuÅ‚ (crates)\n* **KapsuÅ‚y (Crates)**: Drzewo moduÅ‚Ã³w, ktÃ³re produkuje bibliotekÄ™ lub plik wykonywalny\n* **ModuÅ‚y i `use`**: PozwalajÄ… kontrolowaÄ‡ organizacjÄ™, zasiÄ™g i prywatnoÅ›Ä‡ Å›cieÅ¼ek\n* **ÅšcieÅ¼ki**: SposÃ³b nazywania elementu, takiego jak struktura, funkcja lub moduÅ‚\n\nW tym rozdziale omÃ³wimy wszystkie te funkcje, dowiemy siÄ™, jak ze sobÄ… wspÃ³Å‚dziaÅ‚ajÄ… i wyjaÅ›nimy, jak uÅ¼ywaÄ‡ ich do zarzÄ…dzania zasiÄ™giem. Na koniec powinieneÅ› mieÄ‡ solidne zrozumienie systemu moduÅ‚Ã³w i byÄ‡ w stanie pracowaÄ‡ z zasiÄ™gami jak profesjonalista!\n\n[workspaces]: ch14-03-cargo-workspaces.html\n",
        "chapter_title": "Pakiety, KapsuÅ‚y (Crate) i ModuÅ‚y"
    },
    {
        "file_path": "ch07-01-packages-and-crates.md",
        "content": "## Pakiety i KapsuÅ‚y (Crate)\n\nPierwsze czÄ™Å›ci systemu moduÅ‚Ã³w, ktÃ³re omÃ³wimy, to pakiety i kapsuÅ‚y.\n\n_KapsuÅ‚a (crate)_ to najmniejsza iloÅ›Ä‡ kodu, jakÄ… kompilator Rust rozwaÅ¼a w danym momencie. Nawet jeÅ›li uruchomisz `rustc` zamiast `cargo` i przekaÅ¼esz pojedynczy plik ÅºrÃ³dÅ‚owy (tak jak zrobiliÅ›my to w sekcji [â€Podstawy programu w Rustâ€][basics]<!-- ignore --> w Rozdziale 1), kompilator traktuje ten plik jako kapsuÅ‚Ä™. KapsuÅ‚y mogÄ… zawieraÄ‡ moduÅ‚y, a moduÅ‚y mogÄ… byÄ‡ zdefiniowane w innych plikach, ktÃ³re sÄ… kompilowane razem z kapsuÅ‚Ä…, jak zobaczymy w kolejnych sekcjach.\n\nKapsuÅ‚a moÅ¼e wystÄ™powaÄ‡ w jednej z dwÃ³ch form: kapsuÅ‚a binarna lub kapsuÅ‚a biblioteczna. _KapsuÅ‚y binarne_ to programy, ktÃ³re moÅ¼na skompilowaÄ‡ do pliku wykonywalnego, ktÃ³ry moÅ¼na uruchomiÄ‡, na przykÅ‚ad program wiersza poleceÅ„ lub serwer. KaÅ¼da z nich musi mieÄ‡ funkcjÄ™ o nazwie `main`, ktÃ³ra definiuje, co dzieje siÄ™, gdy plik wykonywalny jest uruchamiany. Wszystkie kapsuÅ‚y, ktÃ³re do tej pory utworzyliÅ›my, byÅ‚y kapsuÅ‚ami binarnymi.\n\n_KapsuÅ‚y biblioteczne_ nie majÄ… funkcji `main` i nie kompilujÄ… siÄ™ do pliku wykonywalnego. Zamiast tego definiujÄ… funkcjonalnoÅ›Ä‡ przeznaczonÄ… do wspÃ³Å‚dzielenia z wieloma projektami. Na przykÅ‚ad, kapsuÅ‚a `rand`, ktÃ³rej uÅ¼yliÅ›my w [Rozdziale 2][rand]<!-- ignore -->, zapewnia funkcjonalnoÅ›Ä‡ generowania liczb losowych. Przez wiÄ™kszoÅ›Ä‡ czasu, gdy Rustaceans mÃ³wiÄ… â€kapsuÅ‚aâ€, majÄ… na myÅ›li kapsuÅ‚Ä™ bibliotecznÄ…, i uÅ¼ywajÄ… â€kapsuÅ‚yâ€ zamiennie z ogÃ³lnÄ… koncepcjÄ… programistycznÄ… â€bibliotekaâ€.\n\n_Katalog gÅ‚Ã³wny kapsuÅ‚y (crate root)_ to plik ÅºrÃ³dÅ‚owy, od ktÃ³rego kompilator Rust zaczyna i ktÃ³ry stanowi moduÅ‚ gÅ‚Ã³wny twojej kapsuÅ‚y (szczegÃ³Å‚owo wyjaÅ›nimy moduÅ‚y w sekcji [â€Kontrola zasiÄ™gu i prywatnoÅ›ci za pomocÄ… moduÅ‚Ã³wâ€][modules]<!-- ignore -->).\n\n_Pakiet_ to zbiÃ³r jednej lub wiÄ™cej kapsuÅ‚ (crates), ktÃ³re zapewniajÄ… zestaw funkcjonalnoÅ›ci. Pakiet zawiera plik _Cargo.toml_, ktÃ³ry opisuje, jak zbudowaÄ‡ te kapsuÅ‚y. Cargo jest faktycznie pakietem, ktÃ³ry zawiera kapsuÅ‚Ä™ binarnÄ… dla narzÄ™dzia wiersza poleceÅ„, ktÃ³rego uÅ¼ywaÅ‚eÅ› do budowania swojego kodu. Pakiet Cargo zawiera rÃ³wnieÅ¼ kapsuÅ‚Ä™ bibliotecznÄ…, od ktÃ³rej zaleÅ¼y kapsuÅ‚a binarna. Inne projekty mogÄ… zaleÅ¼eÄ‡ od kapsuÅ‚y bibliotecznej Cargo, aby uÅ¼ywaÄ‡ tej samej logiki, ktÃ³rej uÅ¼ywa narzÄ™dzie wiersza poleceÅ„ Cargo.\n\nPakiet moÅ¼e zawieraÄ‡ dowolnÄ… liczbÄ™ kapsuÅ‚ binarnych, ale co najwyÅ¼ej jednÄ… kapsuÅ‚Ä™ bibliotecznÄ…. Pakiet musi zawieraÄ‡ co najmniej jednÄ… kapsuÅ‚Ä™, niezaleÅ¼nie od tego, czy jest to kapsuÅ‚a biblioteczna, czy binarna.\n\nPrzeanalizujmy, co dzieje siÄ™, gdy tworzymy pakiet. Najpierw wpisujemy polecenie `cargo new my-project`:\n\n```console\n$ cargo new my-project\n     Created binary (application) `my-project` package\n$ ls my-project\nCargo.toml\nsrc\n$ ls my-project/src\nmain.rs\n```\n\nPo uruchomieniu `cargo new my-project` uÅ¼ywamy `ls`, aby zobaczyÄ‡, co Cargo tworzy. W katalogu _my-project_ znajduje siÄ™ plik _Cargo.toml_, dajÄ…c nam pakiet. Jest teÅ¼ katalog _src_, ktÃ³ry zawiera _main.rs_. OtwÃ³rz _Cargo.toml_ w swoim edytorze tekstu i zauwaÅ¼, Å¼e nie ma tam wzmianki o _src/main.rs_. Cargo przestrzega konwencji, Å¼e _src/main.rs_ jest katalogiem gÅ‚Ã³wnym kapsuÅ‚y binarnej o tej samej nazwie co pakiet. Podobnie, Cargo wie, Å¼e jeÅ›li katalog pakietu zawiera _src/lib.rs_, pakiet zawiera kapsuÅ‚Ä™ bibliotecznÄ… o tej samej nazwie co pakiet, a _src/lib.rs_ jest jej katalogiem gÅ‚Ã³wnym. Cargo przekazuje pliki katalogu gÅ‚Ã³wnego kapsuÅ‚y do `rustc` w celu zbudowania biblioteki lub pliku binarnego.\n\nTutaj mamy pakiet, ktÃ³ry zawiera tylko _src/main.rs_, co oznacza, Å¼e zawiera tylko kapsuÅ‚Ä™ binarnÄ… o nazwie `my-project`. JeÅ›li pakiet zawiera _src/main.rs_ i _src/lib.rs_, ma dwie kapsuÅ‚y: binarnÄ… i bibliotecznÄ…, obie o tej samej nazwie co pakiet. Pakiet moÅ¼e mieÄ‡ wiele kapsuÅ‚ binarnych, umieszczajÄ…c pliki w katalogu _src/bin_: kaÅ¼dy plik bÄ™dzie osobnÄ… kapsuÅ‚Ä… binarnÄ….\n\n[basics]: ch01-02-hello-world.html#rust-program-basics\n[modules]: ch07-02-defining-modules-to-control-scope-and-privacy.html\n[rand]: ch02-00-guessing-game-tutorial.html#generating-a-random-number",
        "chapter_title": "Pakiety i KapsuÅ‚y (Crate)"
    },
    {
        "file_path": "ch07-02-defining-modules-to-control-scope-and-privacy.md",
        "content": "<a id=\"defining-modules-to-control-scope-and-privacy\"></a>\n\n## Kontrola zasiÄ™gu i prywatnoÅ›ci za pomocÄ… moduÅ‚Ã³w\n\nW tej sekcji omÃ³wimy moduÅ‚y i inne czÄ™Å›ci systemu moduÅ‚Ã³w, a mianowicie _Å›cieÅ¼ki_, ktÃ³re pozwalajÄ… nadawaÄ‡ nazwy elementom; sÅ‚owo kluczowe `use`, ktÃ³re wprowadza Å›cieÅ¼kÄ™ do zasiÄ™gu; oraz sÅ‚owo kluczowe `pub`, aby uczyniÄ‡ elementy publicznymi. OmÃ³wimy rÃ³wnieÅ¼ sÅ‚owo kluczowe `as`, pakiety zewnÄ™trzne i operator glob.\n\n### ÅšciÄ…gawka z moduÅ‚Ã³w\n\nZanim przejdziemy do szczegÃ³Å‚Ã³w moduÅ‚Ã³w i Å›cieÅ¼ek, przedstawiamy tutaj szybkie odniesienie do tego, jak dziaÅ‚ajÄ… moduÅ‚y, Å›cieÅ¼ki, sÅ‚owo kluczowe `use` i sÅ‚owo kluczowe `pub` w kompilatorze, oraz jak wiÄ™kszoÅ›Ä‡ programistÃ³w organizuje swÃ³j kod. Przejdziemy przez przykÅ‚ady kaÅ¼dej z tych reguÅ‚ w tym rozdziale, ale jest to Å›wietne miejsce, aby odwoÅ‚aÄ‡ siÄ™ do nich jako przypomnienie o tym, jak dziaÅ‚ajÄ… moduÅ‚y.\n\n- **Zacznij od korzenia kapsuÅ‚y (crate root)**: Podczas kompilowania kapsuÅ‚y, kompilator najpierw szuka kodu do skompilowania w pliku korzenia kapsuÅ‚y (zazwyczaj _src/lib.rs_ dla kapsuÅ‚y bibliotecznej i _src/main.rs_ dla kapsuÅ‚y binarnej).\n- **Deklarowanie moduÅ‚Ã³w**: W pliku korzenia kapsuÅ‚y moÅ¼esz zadeklarowaÄ‡ nowe moduÅ‚y; powiedzmy, Å¼e deklarujesz moduÅ‚ â€gardenâ€ za pomocÄ… `mod garden;`. Kompilator bÄ™dzie szukaÅ‚ kodu moduÅ‚u w tych miejscach:\n  - Wbudowane, w nawiasach klamrowych, ktÃ³re zastÄ™pujÄ… Å›rednik po `mod garden`\n  - W pliku _src/garden.rs_\n  - W pliku _src/garden/mod.rs_\n- **Deklarowanie podmoduÅ‚Ã³w**: W dowolnym pliku innym niÅ¼ korzeÅ„ kapsuÅ‚y moÅ¼esz deklarowaÄ‡ podmoduÅ‚y. Na przykÅ‚ad, moÅ¼esz zadeklarowaÄ‡ `mod vegetables;` w _src/garden.rs_. Kompilator bÄ™dzie szukaÅ‚ kodu podmoduÅ‚u w katalogu nazwanym dla moduÅ‚u rodzicielskiego w tych miejscach:\n  - Wbudowane, bezpoÅ›rednio po `mod vegetables`, w nawiasach klamrowych zamiast Å›rednika\n  - W pliku _src/garden/vegetables.rs_\n  - W pliku _src/garden/vegetables/mod.rs_\n- **ÅšcieÅ¼ki do kodu w moduÅ‚ach**: Gdy moduÅ‚ jest czÄ™Å›ciÄ… twojej kapsuÅ‚y, moÅ¼esz odwoÅ‚ywaÄ‡ siÄ™ do kodu w tym module z dowolnego innego miejsca w tej samej kapsule, o ile zasady prywatnoÅ›ci na to pozwalajÄ…, uÅ¼ywajÄ…c Å›cieÅ¼ki do kodu. Na przykÅ‚ad, typ `Asparagus` w module warzyw ogrodowych znajdowaÅ‚by siÄ™ pod `crate::garden::vegetables::Asparagus`.\n- **Prywatne vs publiczne**: Kod w module jest domyÅ›lnie prywatny dla jego moduÅ‚Ã³w nadrzÄ™dnych. Aby moduÅ‚ byÅ‚ publiczny, zadeklaruj go za pomocÄ… `pub mod` zamiast `mod`. Aby elementy w publicznym module byÅ‚y rÃ³wnieÅ¼ publiczne, uÅ¼yj `pub` przed ich deklaracjami.\n- **SÅ‚owo kluczowe `use`**: W zasiÄ™gu, sÅ‚owo kluczowe `use` tworzy skrÃ³ty do elementÃ³w, aby zmniejszyÄ‡ powtarzanie dÅ‚ugich Å›cieÅ¼ek. W kaÅ¼dym zasiÄ™gu, ktÃ³ry moÅ¼e odwoÅ‚ywaÄ‡ siÄ™ do `crate::garden::vegetables::Asparagus`, moÅ¼esz utworzyÄ‡ skrÃ³t za pomocÄ… `use crate::garden::vegetables::Asparagus;`, a odtÄ…d musisz tylko napisaÄ‡ `Asparagus`, aby uÅ¼yÄ‡ tego typu w zasiÄ™gu.\n\nTutaj tworzymy binarnÄ… kapsuÅ‚Ä™ o nazwie `backyard`, ktÃ³ra ilustruje te zasady. Katalog kapsuÅ‚y, rÃ³wnieÅ¼ nazwany _backyard_, zawiera nastÄ™pujÄ…ce pliki i katalogi:\n\n```text\nbackyard\nâ”œâ”€â”€ Cargo.lock\nâ”œâ”€â”€ Cargo.toml\nâ””â”€â”€ src\n    â”œâ”€â”€ garden\n    â”‚Â Â  â””â”€â”€ vegetables.rs\n    â”œâ”€â”€ garden.rs\n    â””â”€â”€ main.rs\n```\n\nPlik gÅ‚Ã³wny kapsuÅ‚y w tym przypadku to _src/main.rs_, i zawiera:\n\n<Listing file-name=\"src/main.rs\">\n\n```rust,noplayground,ignore\nuse crate::garden::vegetables::Asparagus;\n\npub mod garden;\n\nfn main() {\n    let plant = Asparagus {};\n    println!(\"RosnÄ™ {plant:?}!\");\n}\n```\n\n</Listing>\n\nLinia `pub mod garden;` informuje kompilator, aby uwzglÄ™dniÅ‚ kod znajdujÄ…cy siÄ™ w pliku _src/garden.rs_, ktÃ³ry to plik zawiera:\n\n<Listing file-name=\"src/garden.rs\">\n\n```rust,noplayground,ignore\npub mod vegetables;\n```\n\n</Listing>\n\nTutaj, `pub mod vegetables;` oznacza, Å¼e kod z _src/garden/vegetables.rs_ rÃ³wnieÅ¼ jest wÅ‚Ä…czony. Ten kod to:\n\n```rust,noplayground,ignore\n#[derive(Debug)]\npub struct Asparagus {}\n```\n\nTeraz przejdÅºmy do szczegÃ³Å‚Ã³w tych zasad i pokaÅ¼my je w dziaÅ‚aniu!\n\n### Grupowanie powiÄ…zanego kodu w moduÅ‚ach\n\n_ModuÅ‚y_ pozwalajÄ… nam organizowaÄ‡ kod w ramach kapsuÅ‚y w celu zwiÄ™kszenia czytelnoÅ›ci i Å‚atwego ponownego uÅ¼ycia. ModuÅ‚y pozwalajÄ… nam rÃ³wnieÅ¼ kontrolowaÄ‡ _prywatnoÅ›Ä‡_ elementÃ³w, poniewaÅ¼ kod w module jest domyÅ›lnie prywatny. Prywatne elementy to wewnÄ™trzne szczegÃ³Å‚y implementacji niedostÄ™pne do uÅ¼ytku zewnÄ™trznego. MoÅ¼emy zdecydowaÄ‡ siÄ™ na uczynienie moduÅ‚Ã³w i elementÃ³w w nich publicznymi, co udostÄ™pnia je, aby umoÅ¼liwiÄ‡ zewnÄ™trznemu kodowi ich uÅ¼ywanie i zaleÅ¼noÅ›Ä‡ od nich.\n\nNa przykÅ‚ad, napiszmy bibliotekÄ™, ktÃ³ra zapewnia funkcjonalnoÅ›Ä‡ restauracji. Zdefiniujemy sygnatury funkcji, ale pozostawimy ich ciaÅ‚a puste, aby skoncentrowaÄ‡ siÄ™ na organizacji kodu, a nie na implementacji restauracji.\n\nW branÅ¼y restauracyjnej niektÃ³re czÄ™Å›ci restauracji sÄ… nazywane â€front of houseâ€, a inne â€back of houseâ€. _Front of house_ to miejsce, gdzie sÄ… klienci; obejmuje to miejsca, gdzie gospodarze sadzajÄ… klientÃ³w, kelnerzy przyjmujÄ… zamÃ³wienia i pÅ‚atnoÅ›ci, a barmani przygotowujÄ… napoje. _Back of house_ to miejsce, gdzie szefowie kuchni i kucharze pracujÄ… w kuchni, zmywacze naczyÅ„ sprzÄ…tajÄ…, a menedÅ¼erowie wykonujÄ… prace administracyjne.\n\nAby ustrukturyzowaÄ‡ naszÄ… kapsuÅ‚Ä™ w ten sposÃ³b, moÅ¼emy zorganizowaÄ‡ jej funkcje w zagnieÅ¼dÅ¼one moduÅ‚y. UtwÃ³rz nowÄ… bibliotekÄ™ o nazwie `restaurant`, uruchamiajÄ…c `cargo new restaurant --lib`. NastÄ™pnie wprowadÅº kod z Listingu 7-1 do pliku _src/lib.rs_, aby zdefiniowaÄ‡ niektÃ³re moduÅ‚y i sygnatury funkcji; ten kod to sekcja â€front of houseâ€.\n\n<Listing number=\"7-1\" file-name=\"src/lib.rs\" caption=\"ModuÅ‚ `front_of_house` zawierajÄ…cy inne moduÅ‚y, ktÃ³re nastÄ™pnie zawierajÄ… funkcje\">\n\n```rust,noplayground\nmod front_of_house {\n    mod hosting {\n        fn add_to_waitlist() {}\n\n        fn seat_at_table() {}\n    }\n\n    mod serving {\n        fn take_order() {}\n\n        fn serve_order() {}\n\n        fn take_payment() {}\n    }\n}\n```\n\n</Listing>\n\nDefiniujemy moduÅ‚ za pomocÄ… sÅ‚owa kluczowego `mod`, a nastÄ™pnie nazwÄ™ moduÅ‚u (w tym przypadku `front_of_house`). CiaÅ‚o moduÅ‚u znajduje siÄ™ nastÄ™pnie w nawiasach klamrowych. WewnÄ…trz moduÅ‚Ã³w moÅ¼emy umieszczaÄ‡ inne moduÅ‚y, jak w tym przypadku moduÅ‚y `hosting` i `serving`. ModuÅ‚y mogÄ… rÃ³wnieÅ¼ zawieraÄ‡ definicje innych elementÃ³w, takich jak struktury, typy wyliczeniowe, staÅ‚e, cechy, oraz, jak w Listingu 7-1, funkcje.\n\nUÅ¼ywajÄ…c moduÅ‚Ã³w, moÅ¼emy grupowaÄ‡ powiÄ…zane definicje i nazywaÄ‡ ich relacje. ProgramiÅ›ci korzystajÄ…cy z tego kodu mogÄ… nawigowaÄ‡ po kodzie na podstawie grup, zamiast czytaÄ‡ wszystkie definicje, co uÅ‚atwia im znalezienie odpowiednich definicji. ProgramiÅ›ci dodajÄ…cy nowÄ… funkcjonalnoÅ›Ä‡ do tego kodu wiedzieliby, gdzie umieÅ›ciÄ‡ kod, aby program pozostaÅ‚ uporzÄ…dkowany.\n\nWczeÅ›niej wspomnieliÅ›my, Å¼e pliki _src/main.rs_ i _src/lib.rs_ nazywane sÄ… _katalogami gÅ‚Ã³wnymi kapsuÅ‚ (crate roots)_. Powodem ich nazwy jest to, Å¼e zawartoÅ›Ä‡ ktÃ³regokolwiek z tych dwÃ³ch plikÃ³w tworzy moduÅ‚ o nazwie `crate` w katalogu gÅ‚Ã³wnym struktury moduÅ‚Ã³w kapsuÅ‚y, znanego jako _drzewo moduÅ‚Ã³w_.\n\nListing 7-2 przedstawia drzewo moduÅ‚Ã³w dla struktury z Listingu 7-1.\n\n<Listing number=\"7-2\" caption=\"Drzewo moduÅ‚Ã³w dla kodu z Listingu 7-1\">\n\n```text\nkapsuÅ‚a (crate)\n â””â”€â”€ front_of_house\n     â”œâ”€â”€ hosting\n     â”‚   â”œâ”€â”€ add_to_waitlist\n     â”‚   â””â”€â”€ seat_at_table\n     â””â”€â”€ serving\n         â”œâ”€â”€ take_order\n         â”œâ”€â”€ serve_order\n         â””â”€â”€ take_payment\n```\n\n</Listing>\n\nTo drzewo pokazuje, jak niektÃ³re moduÅ‚y zagnieÅ¼dÅ¼ajÄ… siÄ™ w innych moduÅ‚ach; na przykÅ‚ad, `hosting` zagnieÅ¼dÅ¼a siÄ™ w `front_of_house`. Drzewo pokazuje rÃ³wnieÅ¼, Å¼e niektÃ³re moduÅ‚y sÄ… _sÄ…siadami_, co oznacza, Å¼e sÄ… zdefiniowane w tym samym module; `hosting` i `serving` sÄ… sÄ…siadami zdefiniowanymi w `front_of_house`. JeÅ›li moduÅ‚ A jest zawarty w module B, mÃ³wimy, Å¼e moduÅ‚ A jest _dzieckiem_ moduÅ‚u B, a moduÅ‚ B jest _rodzicem_ moduÅ‚u A. ZauwaÅ¼, Å¼e caÅ‚e drzewo moduÅ‚Ã³w jest zakorzenione pod niejawnym moduÅ‚em o nazwie `crate`.\n\nDrzewo moduÅ‚Ã³w moÅ¼e przypominaÄ‡ drzewo katalogÃ³w systemu plikÃ³w na Twoim komputerze; to bardzo trafne porÃ³wnanie! Podobnie jak katalogi w systemie plikÃ³w, uÅ¼ywasz moduÅ‚Ã³w do organizacji kodu. I podobnie jak pliki w katalogu, potrzebujemy sposobu na znalezienie naszych moduÅ‚Ã³w.\n",
        "chapter_title": "Kontrola zasiÄ™gu i prywatnoÅ›ci za pomocÄ… moduÅ‚Ã³w"
    },
    {
        "file_path": "ch07-04-bringing-paths-into-scope-with-the-use-keyword.md",
        "content": "## Wprowadzanie Å›cieÅ¼ek do zasiÄ™gu za pomocÄ… sÅ‚owa kluczowego `use`\n\nKoniecznoÅ›Ä‡ wypisywania peÅ‚nych Å›cieÅ¼ek do wywoÅ‚ywania funkcji moÅ¼e byÄ‡ uciÄ…Å¼liwa i powtarzalna. W Listing 7-7, niezaleÅ¼nie od tego, czy wybraliÅ›my Å›cieÅ¼kÄ™ absolutnÄ…, czy wzglÄ™dnÄ… do funkcji `add_to_waitlist`, za kaÅ¼dym razem, gdy chcieliÅ›my wywoÅ‚aÄ‡ `add_to_waitlist`, musieliÅ›my rÃ³wnieÅ¼ okreÅ›laÄ‡ `front_of_house` i `hosting`. Na szczÄ™Å›cie istnieje sposÃ³b na uproszczenie tego procesu: MoÅ¼emy utworzyÄ‡ skrÃ³t do Å›cieÅ¼ki za pomocÄ… sÅ‚owa kluczowego `use` raz, a nastÄ™pnie uÅ¼ywaÄ‡ krÃ³tszej nazwy wszÄ™dzie indziej w danym zasiÄ™gu.\n\nW Listing 7-11 wprowadzamy moduÅ‚ `crate::front_of_house::hosting` do zasiÄ™gu funkcji `eat_at_restaurant`, tak abyÅ›my musieli okreÅ›laÄ‡ jedynie `hosting::add_to_waitlist`, aby wywoÅ‚aÄ‡ funkcjÄ™ `add_to_waitlist` w `eat_at_restaurant`.\n\n<Listing number=\"7-11\" file-name=\"src/lib.rs\" caption=\"Wprowadzanie moduÅ‚u do zasiÄ™gu za pomocÄ… `use`\">\n\n```rust,noplayground,test_harness\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\nuse crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\n```\n\n</Listing>\n\nDodanie `use` i Å›cieÅ¼ki w zasiÄ™gu jest podobne do tworzenia dowiÄ…zania symbolicznego w systemie plikÃ³w. DodajÄ…c `use crate::front_of_house::hosting` w katalogu gÅ‚Ã³wnym skrzynki, `hosting` jest teraz prawidÅ‚owÄ… nazwÄ… w tym zasiÄ™gu, tak jakby moduÅ‚ `hosting` zostaÅ‚ zdefiniowany w katalogu gÅ‚Ã³wnym skrzynki. ÅšcieÅ¼ki wprowadzone do zasiÄ™gu za pomocÄ… `use` rÃ³wnieÅ¼ sprawdzajÄ… prywatnoÅ›Ä‡, tak jak kaÅ¼da inna Å›cieÅ¼ka.\n\nZwrÃ³Ä‡ uwagÄ™, Å¼e `use` tworzy skrÃ³t tylko dla konkretnego zasiÄ™gu, w ktÃ³rym wystÄ™puje `use`. Listing 7-12 przenosi funkcjÄ™ `eat_at_restaurant` do nowego moduÅ‚u potomnego o nazwie `customer`, ktÃ³ry jest wÃ³wczas innym zasiÄ™giem niÅ¼ instrukcja `use`, wiÄ™c ciaÅ‚o funkcji nie skompiluje siÄ™.\n\n<Listing number=\"7-12\" file-name=\"src/lib.rs\" caption=\"Instrukcja `use` ma zastosowanie tylko w zasiÄ™gu, w ktÃ³rym siÄ™ znajduje.\">\n\n```rust,noplayground,test_harness,does_not_compile,ignore\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\nuse crate::front_of_house::hosting;\n\nmod customer {\n    pub fn eat_at_restaurant() {\n        hosting::add_to_waitlist();\n    }\n}\n```\n\n</Listing>\n\nBÅ‚Ä…d kompilatora pokazuje, Å¼e skrÃ³t nie ma juÅ¼ zastosowania w module `customer`:\n\n```console\n$ cargo build\n   Compiling restaurant v0.1.0 (file:///projects/restaurant)\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `hosting`\n  --> src/lib.rs:11:9\n   |\n11 |         hosting::add_to_waitlist();\n   |         ^^^^^^^ use of unresolved module or unlinked crate `hosting`\n   |\n   = help: if you wanted to use a crate named `hosting`, use `cargo add hosting` to add it to your `Cargo.toml`\nhelp: consider importing this module through its public re-export\n   |\n10 +     use crate::hosting;\n   |\n\nwarning: unused import: `crate::front_of_house::hosting`\n --> src/lib.rs:7:5\n  |\n7 | use crate::front_of_house::hosting;\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `restaurant` (lib) generated 1 warning\nerror: could not compile `restaurant` (lib) due to 1 previous error; 1 warning emitted\n```\n\nZauwaÅ¼, Å¼e pojawiÅ‚o siÄ™ rÃ³wnieÅ¼ ostrzeÅ¼enie, Å¼e `use` nie jest juÅ¼ uÅ¼ywane w swoim zasiÄ™gu! Aby rozwiÄ…zaÄ‡ ten problem, przenieÅ› `use` rÃ³wnieÅ¼ do moduÅ‚u `customer` lub odwoÅ‚aj siÄ™ do skrÃ³tu w module nadrzÄ™dnym za pomocÄ… `super::hosting` w module potomnym `customer`.\n\n### Tworzenie idiomatycznych Å›cieÅ¼ek `use`\n\nW Listing 7-11 mogÅ‚eÅ› siÄ™ zastanawiaÄ‡, dlaczego okreÅ›liliÅ›my `use crate::front_of_house::hosting`, a nastÄ™pnie wywoÅ‚aliÅ›my `hosting::add_to_waitlist` w `eat_at_restaurant`, zamiast okreÅ›laÄ‡ Å›cieÅ¼kÄ™ `use` aÅ¼ do funkcji `add_to_waitlist`, aby osiÄ…gnÄ…Ä‡ ten sam rezultat, jak w Listing 7-13.\n\n<Listing number=\"7-13\" file-name=\"src/lib.rs\" caption=\"Wprowadzanie funkcji `add_to_waitlist` do zasiÄ™gu za pomocÄ… `use`, co jest nieidiomatyczne\">\n\n```rust,noplayground,test_harness\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\nuse crate::front_of_house::hosting::add_to_waitlist;\n\npub fn eat_at_restaurant() {\n    add_to_waitlist();\n}\n```\n\n</Listing>\n\nChociaÅ¼ zarÃ³wno Listing 7-11, jak i Listing 7-13 wykonujÄ… to samo zadanie, Listing 7-11 jest idiomatycznym sposobem wprowadzania funkcji do zasiÄ™gu za pomocÄ… `use`. Wprowadzenie moduÅ‚u nadrzÄ™dnego funkcji do zasiÄ™gu za pomocÄ… `use` oznacza, Å¼e musimy okreÅ›liÄ‡ moduÅ‚ nadrzÄ™dny podczas wywoÅ‚ywania funkcji. OkreÅ›lanie moduÅ‚u nadrzÄ™dnego podczas wywoÅ‚ywania funkcji jasno informuje, Å¼e funkcja nie jest zdefiniowana lokalnie, jednoczeÅ›nie minimalizujÄ…c powtarzanie peÅ‚nej Å›cieÅ¼ki. Kod w Listing 7-13 niejasno okreÅ›la, gdzie zdefiniowano `add_to_waitlist`.\n\nZ drugiej strony, podczas wprowadzania struktur, wyliczeÅ„ i innych elementÃ³w za pomocÄ… `use`, idiomatyczne jest okreÅ›lanie peÅ‚nej Å›cieÅ¼ki. Listing 7-14 pokazuje idiomatyczny sposÃ³b wprowadzania struktury `HashMap` ze standardowej biblioteki do zasiÄ™gu skrzynki binarnej.\n\n<Listing number=\"7-14\" file-name=\"src/main.rs\" caption=\"Idiomatyczne wprowadzanie `HashMap` do zasiÄ™gu\">\n\n```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut map = HashMap::new();\n    map.insert(1, 2);\n}\n```\n\n</Listing>\n\nNie ma mocnego powodu, dla ktÃ³rego ten idiom: to po prostu konwencja, ktÃ³ra siÄ™ wyksztaÅ‚ciÅ‚a, a ludzie przyzwyczaili siÄ™ do czytania i pisania kodu w Rust w ten sposÃ³b.\n\nWyjÄ…tkiem od tego idiomu jest sytuacja, gdy wprowadzamy dwa elementy o tej samej nazwie do zasiÄ™gu za pomocÄ… instrukcji `use`, poniewaÅ¼ Rust na to nie pozwala. Listing 7-15 pokazuje, jak wprowadziÄ‡ dwa typy `Result` do zasiÄ™gu, ktÃ³re majÄ… tÄ™ samÄ… nazwÄ™, ale rÃ³Å¼ne moduÅ‚y nadrzÄ™dne, oraz jak siÄ™ do nich odwoÅ‚ywaÄ‡.\n\n<Listing number=\"7-15\" file-name=\"src/lib.rs\" caption=\"Wprowadzanie dwÃ³ch typÃ³w o tej samej nazwie do tego samego zasiÄ™gu wymaga uÅ¼ycia ich moduÅ‚Ã³w nadrzÄ™dnych.\">\n\n```rust,noplayground\nuse std::fmt;\nuse std::io;\n\nfn function1() -> fmt::Result {\n    // --snip--\n#     Ok(())\n}\n\nfn function2() -> io::Result<()> {\n    // --snip--\n#     Ok(())\n}\n```\n\n</Listing>\n\nJak widaÄ‡, uÅ¼ycie moduÅ‚Ã³w nadrzÄ™dnych odrÃ³Å¼nia dwa typy `Result`. GdybyÅ›my zamiast tego okreÅ›lili `use std::fmt::Result` i `use std::io::Result`, mielibyÅ›my dwa typy `Result` w tym samym zasiÄ™gu, a Rust nie wiedziaÅ‚by, o ktÃ³ry nam chodzi, gdybyÅ›my uÅ¼yli `Result`.\n\n### Nadawanie nowych nazw za pomocÄ… sÅ‚owa kluczowego `as`\n\nIstnieje inne rozwiÄ…zanie problemu wprowadzania dwÃ³ch typÃ³w o tej samej nazwie do tego samego zasiÄ™gu za pomocÄ… `use`: Po Å›cieÅ¼ce moÅ¼emy okreÅ›liÄ‡ `as` i nowÄ… lokalnÄ… nazwÄ™, czyli _alias_, dla typu. Listing 7-16 pokazuje inny sposÃ³b napisania kodu z Listing 7-15 poprzez zmianÄ™ nazwy jednego z dwÃ³ch typÃ³w `Result` za pomocÄ… `as`.\n\n<Listing number=\"7-16\" file-name=\"src/lib.rs\" caption=\"Zmiana nazwy typu po wprowadzeniu go do zasiÄ™gu za pomocÄ… sÅ‚owa kluczowego `as`\">\n\n```rust,noplayground\nuse std::fmt::Result;\nuse std::io::Result as IoResult;\n\nfn function1() -> Result {\n    // --snip--\n#     Ok(())\n}\n\nfn function2() -> IoResult<()> {\n    // --snip--\n#     Ok(())\n}\n```\n\n</Listing>\n\nW drugiej instrukcji `use` wybraliÅ›my nowÄ… nazwÄ™ `IoResult` dla typu `std::io::Result`, ktÃ³ra nie bÄ™dzie kolidowaÄ‡ z `Result` z `std::fmt`, ktÃ³ry rÃ³wnieÅ¼ wprowadziliÅ›my do zasiÄ™gu. Listing 7-15 i Listing 7-16 sÄ… uwaÅ¼ane za idiomatyczne, wiÄ™c wybÃ³r naleÅ¼y do Ciebie!\n\n### Ponowne eksportowanie nazw za pomocÄ… `pub use`\n\nKiedy wprowadzamy nazwÄ™ do zasiÄ™gu za pomocÄ… sÅ‚owa kluczowego `use`, nazwa jest prywatna dla zasiÄ™gu, do ktÃ³rego jÄ… zaimportowaliÅ›my. Aby umoÅ¼liwiÄ‡ kodowi spoza tego zasiÄ™gu odwoÅ‚ywanie siÄ™ do tej nazwy tak, jakby zostaÅ‚a zdefiniowana w tym zasiÄ™gu, moÅ¼emy poÅ‚Ä…czyÄ‡ `pub` i `use`. Ta technika nazywa siÄ™ _re-eksportowaniem_, poniewaÅ¼ wprowadzamy element do zasiÄ™gu, ale takÅ¼e udostÄ™pniamy ten element innym, aby mogli go wprowadziÄ‡ do swojego zasiÄ™gu.\n\nListing 7-17 pokazuje kod z Listing 7-11, w ktÃ³rym `use` w module gÅ‚Ã³wnym zostaÅ‚o zmienione na `pub use`.\n\n<Listing number=\"7-17\" file-name=\"src/lib.rs\" caption=\"UdostÄ™pnianie nazwy dowolnemu kodowi z nowego zasiÄ™gu za pomocÄ… `pub use`\">\n\n```rust,noplayground,test_harness\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub use crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\n```\n\n</Listing>\n\nPrzed tÄ… zmianÄ…, kod zewnÄ™trzny musiaÅ‚by wywoÅ‚ywaÄ‡ funkcjÄ™ `add_to_waitlist` uÅ¼ywajÄ…c Å›cieÅ¼ki `restaurant::front_of_house::hosting::add_to_waitlist()`, co wymagaÅ‚oby rÃ³wnieÅ¼, aby moduÅ‚ `front_of_house` byÅ‚ oznaczony jako `pub`. Teraz, gdy `pub use` ponownie wyeksportowaÅ‚o moduÅ‚ `hosting` z moduÅ‚u gÅ‚Ã³wnego, kod zewnÄ™trzny moÅ¼e zamiast tego uÅ¼ywaÄ‡ Å›cieÅ¼ki `restaurant::hosting::add_to_waitlist()`.\n\nPonowny eksport jest przydatny, gdy wewnÄ™trzna struktura kodu rÃ³Å¼ni siÄ™ od sposobu, w jaki programiÅ›ci wywoÅ‚ujÄ…cy kod myÅ›leliby o domenie. Na przykÅ‚ad, w tej metaforze restauracji, osoby prowadzÄ…ce restauracjÄ™ myÅ›lÄ… o â€front of houseâ€ i â€back of houseâ€. Ale klienci odwiedzajÄ…cy restauracjÄ™ prawdopodobnie nie bÄ™dÄ… myÅ›leÄ‡ o czÄ™Å›ciach restauracji w tych kategoriach. DziÄ™ki `pub use` moÅ¼emy pisaÄ‡ kod o jednej strukturze, ale udostÄ™pniaÄ‡ innÄ… strukturÄ™. DziÄ™ki temu nasza biblioteka jest dobrze zorganizowana dla programistÃ³w pracujÄ…cych nad bibliotekÄ… i programistÃ³w wywoÅ‚ujÄ…cych bibliotekÄ™. Inny przykÅ‚ad `pub use` i jego wpÅ‚ywu na dokumentacjÄ™ skrzynki omÃ³wimy w rozdziale 14 w sekcji [â€Eksportowanie wygodnego publicznego APIâ€][ch14-pub-use].<!-- ignore -->\n\n### UÅ¼ywanie pakietÃ³w zewnÄ™trznych\n\nW Rozdziale 2 programowaliÅ›my projekt gry zgadywanek, ktÃ³ry uÅ¼ywaÅ‚ zewnÄ™trznego pakietu `rand` do generowania liczb losowych. Aby uÅ¼yÄ‡ `rand` w naszym projekcie, dodaliÅ›my nastÄ™pujÄ…cÄ… liniÄ™ do _Cargo.toml_:\n\n<!-- When updating the version of `rand` used, also update the version of\n`rand` used in these files so they all match:\n* ch02-00-guessing-game-tutorial.md\n* ch14-03-cargo-workspaces.md\n-->\n\n<Listing file-name=\"Cargo.toml\">\n\n```toml\nrand = \"0.8.5\"\n```\n\n</Listing>\n\nDodanie `rand` jako zaleÅ¼noÅ›ci w _Cargo.toml_ informuje Cargo, aby pobraÅ‚ pakiet `rand` i wszystkie jego zaleÅ¼noÅ›ci z [crates.io](https://crates.io/) i udostÄ™pniÅ‚ `rand` naszemu projektowi.\n\nNastÄ™pnie, aby wprowadziÄ‡ definicje `rand` do zasiÄ™gu naszego pakietu, dodaliÅ›my liniÄ™ `use` zaczynajÄ…cÄ… siÄ™ od nazwy skrzynki, `rand`, i wymieniliÅ›my elementy, ktÃ³re chcieliÅ›my wprowadziÄ‡ do zasiÄ™gu. Przypomnij sobie, Å¼e w sekcji [â€Generowanie liczby losowejâ€][rand]<!-- ignore --> w Rozdziale 2 wprowadziliÅ›my cechÄ™ `Rng` do zasiÄ™gu i wywoÅ‚aliÅ›my funkcjÄ™ `rand::thread_rng`:\n\n```rust,ignore\n# use std::io;\n# \nuse rand::Rng;\n\nfn main() {\n#     println!(\"Guess the number!\");\n# \n    let secret_number = rand::thread_rng().gen_range(1..=100);\n# \n#     println!(\"The secret number is: {secret_number}\");\n# \n#     println!(\"Please input your guess.\");\n# \n#     let mut guess = String::new();\n# \n#     io::stdin()\n#         .read_line(&mut guess)\n#         .expect(\"Failed to read line\");\n# \n#     println!(\"You guessed: {guess}\");\n}\n```\n\nCzÅ‚onkowie spoÅ‚ecznoÅ›ci Rust udostÄ™pnili wiele pakietÃ³w na [crates.io](https://crates.io/), a wÅ‚Ä…czenie ktÃ³regokolwiek z nich do Twojego pakietu obejmuje te same kroki: wymienienie ich w pliku _Cargo.toml_ Twojego pakietu i uÅ¼ycie `use` do wprowadzenia elementÃ³w z ich skrzynek do zasiÄ™gu.\n\nZauwaÅ¼, Å¼e standardowa biblioteka `std` jest rÃ³wnieÅ¼ skrzynkÄ… zewnÄ™trznÄ… dla naszego pakietu. PoniewaÅ¼ standardowa biblioteka jest dostarczana z jÄ™zykiem Rust, nie musimy zmieniaÄ‡ _Cargo.toml_, aby uwzglÄ™dniÄ‡ `std`. Musimy jednak odwoÅ‚aÄ‡ siÄ™ do niej za pomocÄ… `use`, aby wprowadziÄ‡ z niej elementy do zasiÄ™gu naszego pakietu. Na przykÅ‚ad, w przypadku `HashMap` uÅ¼ylibyÅ›my tej linii:\n\n```rust\nuse std::collections::HashMap;\n```\n\nJest to Å›cieÅ¼ka absolutna zaczynajÄ…ca siÄ™ od `std`, nazwy skrzynki standardowej biblioteki.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"using-nested-paths-to-clean-up-large-use-lists\"></a>\n\n### UÅ¼ywanie zagnieÅ¼dÅ¼onych Å›cieÅ¼ek do porzÄ…dkowania list `use`\n\nJeÅ›li uÅ¼ywamy wielu elementÃ³w zdefiniowanych w tej samej skrzynce lub tym samym module, wymienianie kaÅ¼dego elementu w osobnej linii moÅ¼e zajmowaÄ‡ duÅ¼o miejsca w naszych plikach. Na przykÅ‚ad, te dwie instrukcje `use` z gry zgadywanek w Listing 2-4 wprowadzajÄ… elementy z `std` do zasiÄ™gu:\n\n<Listing file-name=\"src/main.rs\">\n\n```rust,ignore\n# use rand::Rng;\n// --snip--\nuse std::cmp::Ordering;\nuse std::io;\n// --snip--\n# \n# fn main() {\n#     println!(\"Guess the number!\");\n# \n#     let secret_number = rand::thread_rng().gen_range(1..=100);\n# \n#     println!(\"The secret number is: {secret_number}\");\n# \n#     println!(\"Please input your guess.\");\n# \n#     let mut guess = String::new();\n# \n#     io::stdin()\n#         .read_line(&mut guess)\n#         .expect(\"Failed to read line\");\n# \n#     println!(\"You guessed: {guess}\");\n# \n#     match guess.cmp(&secret_number) {\n#         Ordering::Less => println!(\"Too small!\"),\n#         Ordering::Greater => println!(\"Too big!\"),\n#         Ordering::Equal => println!(\"You win!\"),\n#     }\n# }\n```\n\n</Listing>\n\nZamiast tego moÅ¼emy uÅ¼yÄ‡ zagnieÅ¼dÅ¼onych Å›cieÅ¼ek, aby wprowadziÄ‡ te same elementy do zasiÄ™gu w jednej linii. Robimy to, okreÅ›lajÄ…c wspÃ³lnÄ… czÄ™Å›Ä‡ Å›cieÅ¼ki, po ktÃ³rej nastÄ™pujÄ… dwa dwukropki, a nastÄ™pnie nawiasy klamrowe wokÃ³Å‚ listy czÄ™Å›ci Å›cieÅ¼ek, ktÃ³re siÄ™ rÃ³Å¼niÄ…, jak pokazano w Listing 7-18.\n\n<Listing number=\"7-18\" file-name=\"src/main.rs\" caption=\"OkreÅ›lanie zagnieÅ¼dÅ¼onej Å›cieÅ¼ki w celu wprowadzenia wielu elementÃ³w z tym samym prefiksem do zasiÄ™gu\">\n\n```rust,ignore\n# use rand::Rng;\n// --snip--\nuse std::{cmp::Ordering, io};\n// --snip--\n# \n# fn main() {\n#     println!(\"Guess the number!\");\n# \n#     let secret_number = rand::thread_rng().gen_range(1..=100);\n# \n#     println!(\"The secret number is: {secret_number}\");\n# \n#     println!(\"Please input your guess.\");\n# \n#     let mut guess = String::new();\n# \n#     io::stdin()\n#         .read_line(&mut guess)\n#         .expect(\"Failed to read line\");\n# \n#     let guess: u32 = guess.trim().parse().expect(\"Please type a number!\");\n# \n#     println!(\"You guessed: {guess}\");\n# \n#     match guess.cmp(&secret_number) {\n#         Ordering::Less => println!(\"Too small!\"),\n#         Ordering::Greater => println!(\"Too big!\"),\n#         Ordering::Equal => println!(\"You win!\"),\n#     }\n# }\n```\n\n</Listing>\n\nW wiÄ™kszych programach wprowadzanie wielu elementÃ³w do zasiÄ™gu z tej samej skrzynki lub moduÅ‚u za pomocÄ… zagnieÅ¼dÅ¼onych Å›cieÅ¼ek moÅ¼e znacznie zmniejszyÄ‡ liczbÄ™ oddzielnych instrukcji `use`!\n\nMoÅ¼emy uÅ¼ywaÄ‡ zagnieÅ¼dÅ¼onych Å›cieÅ¼ek na dowolnym poziomie Å›cieÅ¼ki, co jest przydatne przy Å‚Ä…czeniu dwÃ³ch instrukcji `use`, ktÃ³re wspÃ³Å‚dzielÄ… podÅ›cieÅ¼kÄ™. Na przykÅ‚ad, Listing 7-19 pokazuje dwie instrukcje `use`: jedna, ktÃ³ra wprowadza `std::io` do zasiÄ™gu, i druga, ktÃ³ra wprowadza `std::io::Write` do zasiÄ™gu.\n\n<Listing number=\"7-19\" file-name=\"src/lib.rs\" caption=\"Dwie instrukcje `use`, gdzie jedna jest podÅ›cieÅ¼kÄ… drugiej\">\n\n```rust,noplayground\nuse std::io;\nuse std::io::Write;\n```\n\n</Listing>\n\nWspÃ³lnÄ… czÄ™Å›ciÄ… tych dwÃ³ch Å›cieÅ¼ek jest `std::io`, i to jest kompletna pierwsza Å›cieÅ¼ka. Aby poÅ‚Ä…czyÄ‡ te dwie Å›cieÅ¼ki w jednÄ… instrukcjÄ™ `use`, moÅ¼emy uÅ¼yÄ‡ `self` w zagnieÅ¼dÅ¼onej Å›cieÅ¼ce, jak pokazano w Listing 7-20.\n\n<Listing number=\"7-20\" file-name=\"src/lib.rs\" caption=\"ÅÄ…czenie Å›cieÅ¼ek z Listing 7-19 w jednÄ… instrukcjÄ™ `use`\">\n\n```rust,noplayground\nuse std::io::{self, Write};\n```\n\n</Listing>\n\nTa linia wprowadza `std::io` i `std::io::Write` do zasiÄ™gu.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"the-glob-operator\"></a>\n\n### Importowanie elementÃ³w za pomocÄ… operatora glob\n\nJeÅ›li chcemy wprowadziÄ‡ _wszystkie_ publiczne elementy zdefiniowane w Å›cieÅ¼ce do zasiÄ™gu, moÅ¼emy okreÅ›liÄ‡ tÄ™ Å›cieÅ¼kÄ™, po ktÃ³rej nastÄ™puje operator glob `*`:\n\n```rust\nuse std::collections::*;\n```\n\nTa instrukcja `use` wprowadza wszystkie publiczne elementy zdefiniowane w `std::collections` do bieÅ¼Ä…cego zasiÄ™gu. Zachowaj ostroÅ¼noÅ›Ä‡ podczas uÅ¼ywania operatora glob! Glob moÅ¼e utrudniÄ‡ okreÅ›lenie, jakie nazwy sÄ… w zasiÄ™gu i gdzie nazwa uÅ¼yta w programie zostaÅ‚a zdefiniowana. Dodatkowo, jeÅ›li zaleÅ¼noÅ›Ä‡ zmieni swoje definicje, to co zostaÅ‚o zaimportowane, rÃ³wnieÅ¼ siÄ™ zmieni, co moÅ¼e prowadziÄ‡ do bÅ‚Ä™dÃ³w kompilatora podczas aktualizacji zaleÅ¼noÅ›ci, jeÅ›li zaleÅ¼noÅ›Ä‡ doda definicjÄ™ o tej samej nazwie co Twoja definicja w tym samym zasiÄ™gu, na przykÅ‚ad.\n\nOperator glob jest czÄ™sto uÅ¼ywany podczas testowania, aby wprowadziÄ‡ wszystko, co jest testowane, do moduÅ‚u `tests`; omÃ³wimy to w sekcji [â€Jak pisaÄ‡ testyâ€][writing-tests]<!-- ignore --> w Rozdziale 11. Operator glob jest rÃ³wnieÅ¼ czasami uÅ¼ywany jako czÄ™Å›Ä‡ wzorca preludium: zobacz [dokumentacjÄ™ standardowej biblioteki](../std/prelude/index.html#other-preludes)<!-- ignore -->, aby uzyskaÄ‡ wiÄ™cej informacji na temat tego wzorca.\n\n[ch14-pub-use]: ch14-02-publishing-to-crates-io.html#exporting-a-convenient-public-api\n[rand]: ch02-00-guessing-game-tutorial.html#generating-a-random-number\n[writing-tests]: ch11-01-writing-tests.html#how-to-write-tests\n",
        "chapter_title": "Wprowadzanie Å›cieÅ¼ek do zasiÄ™gu za pomocÄ… sÅ‚owa kluczowego use"
    },
    {
        "file_path": "ch07-05-separating-modules-into-different-files.md",
        "content": "## Dzielenie moduÅ‚Ã³w na rÃ³Å¼ne pliki\n\nDo tej pory wszystkie przykÅ‚ady w tym rozdziale definiowaÅ‚y wiele moduÅ‚Ã³w w jednym pliku. Kiedy moduÅ‚y stajÄ… siÄ™ duÅ¼e, moÅ¼esz chcieÄ‡ przenieÅ›Ä‡ ich definicje do oddzielnego pliku, aby uÅ‚atwiÄ‡ nawigacjÄ™ po kodzie.\n\nNa przykÅ‚ad, zacznijmy od kodu z Listing 7-17, ktÃ³ry miaÅ‚ wiele moduÅ‚Ã³w restauracji. WyodrÄ™bnimy moduÅ‚y do plikÃ³w zamiast definiowaÄ‡ wszystkie moduÅ‚y w pliku gÅ‚Ã³wnym skrzynki. W tym przypadku plikiem gÅ‚Ã³wnym skrzynki jest _src/lib.rs_, ale ta procedura dziaÅ‚a rÃ³wnieÅ¼ w przypadku skrzynek binarnych, ktÃ³rych plikiem gÅ‚Ã³wnym skrzynki jest _src/main.rs_.\n\nNajpierw wyodrÄ™bnimy moduÅ‚ `front_of_house` do jego wÅ‚asnego pliku. UsuÅ„ kod w nawiasach klamrowych dla moduÅ‚u `front_of_house`, pozostawiajÄ…c tylko deklaracjÄ™ `mod front_of_house;`, tak aby _src/lib.rs_ zawieraÅ‚ kod pokazany w Listing 7-21. ZauwaÅ¼, Å¼e to nie skompiluje siÄ™, dopÃ³ki nie utworzymy pliku _src/front_of_house.rs_ w Listing 7-22.\n\n<Listing number=\"7-21\" file-name=\"src/lib.rs\" caption=\"Deklaracja moduÅ‚u `front_of_house`, ktÃ³rego ciaÅ‚o bÄ™dzie znajdowaÄ‡ siÄ™ w *src/front_of_house.rs*\">\n\n```rust,ignore,does_not_compile\nmod front_of_house;\n\npub use crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\n```\n\n</Listing>\n\nNastÄ™pnie umieÅ›Ä‡ kod, ktÃ³ry znajdowaÅ‚ siÄ™ w nawiasach klamrowych, w nowym pliku o nazwie _src/front_of_house.rs_, jak pokazano w Listing 7-22. Kompilator wie, aby szukaÄ‡ w tym pliku, poniewaÅ¼ napotkaÅ‚ deklaracjÄ™ moduÅ‚u w katalogu gÅ‚Ã³wnym skrzynki o nazwie `front_of_house`.\n\n<Listing number=\"7-22\" file-name=\"src/front_of_house.rs\" caption=\"Definicje w module `front_of_house` w *src/front_of_house.rs*\">\n\n```rust,ignore\npub mod hosting {\n    pub fn add_to_waitlist() {}\n}\n```\n\n</Listing>\n\nZauwaÅ¼, Å¼e plik naleÅ¼y zaÅ‚adowaÄ‡ za pomocÄ… deklaracji `mod` _tylko raz_ w drzewie moduÅ‚Ã³w. Kiedy kompilator dowie siÄ™, Å¼e plik jest czÄ™Å›ciÄ… projektu (i wie, gdzie w drzewie moduÅ‚Ã³w znajduje siÄ™ kod, ze wzglÄ™du na miejsce, w ktÃ³rym umieszczono instrukcjÄ™ `mod`), inne pliki w projekcie powinny odwoÅ‚ywaÄ‡ siÄ™ do kodu zaÅ‚adowanego pliku, uÅ¼ywajÄ…c Å›cieÅ¼ki do miejsca, w ktÃ³rym zostaÅ‚ zadeklarowany, jak opisano w sekcji [â€ÅšcieÅ¼ki do odwoÅ‚ywania siÄ™ do elementu w drzewie moduÅ‚Ã³wâ€][paths].<!-- ignore --> Innymi sÅ‚owy, `mod` _nie_ jest operacjÄ… â€includeâ€, ktÃ³rÄ… mogÅ‚eÅ› widzieÄ‡ w innych jÄ™zykach programowania.\n\nNastÄ™pnie wyodrÄ™bnimy moduÅ‚ `hosting` do jego wÅ‚asnego pliku. Proces jest nieco inny, poniewaÅ¼ `hosting` jest moduÅ‚em podrzÄ™dnym `front_of_house`, a nie moduÅ‚u gÅ‚Ã³wnego. Plik dla `hosting` umieÅ›cimy w nowym katalogu, ktÃ³ry bÄ™dzie nazwany od jego przodkÃ³w w drzewie moduÅ‚Ã³w, w tym przypadku _src/front_of_house_.\n\nAby rozpoczÄ…Ä‡ przenoszenie `hosting`, zmieniamy _src/front_of_house.rs_, tak aby zawieraÅ‚ tylko deklaracjÄ™ moduÅ‚u `hosting`:\n\n<Listing file-name=\"src/front_of_house.rs\">\n\n```rust,ignore\npub mod hosting;\n```\n\n</Listing>\n\nNastÄ™pnie tworzymy katalog _src/front_of_house_ i plik _hosting.rs_, aby zawieraÄ‡ definicje z moduÅ‚u `hosting`:\n\n<Listing file-name=\"src/front_of_house/hosting.rs\">\n\n```rust,ignore\npub fn add_to_waitlist() {}\n```\n\n</Listing>\n\nGdybyÅ›my zamiast tego umieÅ›cili _hosting.rs_ w katalogu _src_, kompilator oczekiwaÅ‚by, Å¼e kod _hosting.rs_ bÄ™dzie w module `hosting` zadeklarowanym w katalogu gÅ‚Ã³wnym skrzynki, a nie zadeklarowanym jako dziecko moduÅ‚u `front_of_house`. Zasady kompilatora dotyczÄ…ce tego, ktÃ³re pliki sprawdziÄ‡ pod kÄ…tem kodu poszczegÃ³lnych moduÅ‚Ã³w, oznaczajÄ…, Å¼e katalogi i pliki bardziej Å›ciÅ›le odpowiadajÄ… drzewu moduÅ‚Ã³w.\n\n> ### Alternatywne Å›cieÅ¼ki plikÃ³w\n>\n> Do tej pory omÃ³wiliÅ›my najbardziej idiomatyczne Å›cieÅ¼ki plikÃ³w uÅ¼ywane przez kompilator Rust, ale Rust obsÅ‚uguje rÃ³wnieÅ¼ starszy styl Å›cieÅ¼ek plikÃ³w. Dla moduÅ‚u o nazwie `front_of_house` zadeklarowanego w katalogu gÅ‚Ã³wnym skrzynki, kompilator bÄ™dzie szukaÅ‚ kodu moduÅ‚u w:\n>\n> - _src/front_of_house.rs_ (to, co omÃ³wiliÅ›my)\n> - _src/front_of_house/mod.rs_ (starszy styl, nadal obsÅ‚ugiwana Å›cieÅ¼ka)\n>\n> Dla moduÅ‚u o nazwie `hosting`, ktÃ³ry jest podmoduÅ‚em `front_of_house`, kompilator bÄ™dzie szukaÅ‚ kodu moduÅ‚u w:\n>\n> - _src/front_of_house/hosting.rs_ (to, co omÃ³wiliÅ›my)\n> - _src/front_of_house/hosting/mod.rs_ (starszy styl, nadal obsÅ‚ugiwana Å›cieÅ¼ka)\n>\n> JeÅ›li uÅ¼yjesz obu stylÃ³w dla tego samego moduÅ‚u, otrzymasz bÅ‚Ä…d kompilacji. Mieszanie obu stylÃ³w dla rÃ³Å¼nych moduÅ‚Ã³w w tym samym projekcie jest dozwolone, ale moÅ¼e byÄ‡ mylÄ…ce dla osÃ³b nawigujÄ…cych po Twoim projekcie.\n>\n> GÅ‚Ã³wnÄ… wadÄ… stylu, ktÃ³ry uÅ¼ywa plikÃ³w o nazwie _mod.rs_, jest to, Å¼e projekt moÅ¼e zawieraÄ‡ wiele plikÃ³w o nazwie _mod.rs_, co moÅ¼e prowadziÄ‡ do zamieszania, gdy masz je otwarte w edytorze w tym samym czasie.\n\nPrzenieÅ›liÅ›my kod kaÅ¼dego moduÅ‚u do osobnego pliku, a drzewo moduÅ‚Ã³w pozostaÅ‚o takie samo. WywoÅ‚ania funkcji w `eat_at_restaurant` bÄ™dÄ… dziaÅ‚aÄ‡ bez Å¼adnych modyfikacji, mimo Å¼e definicje znajdujÄ… siÄ™ w rÃ³Å¼nych plikach. Ta technika pozwala przenosiÄ‡ moduÅ‚y do nowych plikÃ³w, gdy rosnÄ….\n\nZauwaÅ¼, Å¼e instrukcja `pub use crate::front_of_house::hosting` w _src/lib.rs_ rÃ³wnieÅ¼ nie ulegÅ‚a zmianie, ani `use` nie ma wpÅ‚ywu na to, ktÃ³re pliki sÄ… kompilowane jako czÄ™Å›Ä‡ skrzynki. SÅ‚owo kluczowe `mod` deklaruje moduÅ‚y, a Rust szuka w pliku o tej samej nazwie co moduÅ‚ kodu, ktÃ³ry naleÅ¼y do tego moduÅ‚u.\n\n## Podsumowanie\n\nRust pozwala dzieliÄ‡ pakiet na wiele skrzynek, a skrzynkÄ™ na moduÅ‚y, tak aby moÅ¼na byÅ‚o odwoÅ‚ywaÄ‡ siÄ™ do elementÃ³w zdefiniowanych w jednym module z innego moduÅ‚u. MoÅ¼na to zrobiÄ‡, okreÅ›lajÄ…c Å›cieÅ¼ki absolutne lub wzglÄ™dne. Te Å›cieÅ¼ki moÅ¼na wprowadziÄ‡ do zasiÄ™gu za pomocÄ… instrukcji `use`, aby moÅ¼na byÅ‚o uÅ¼ywaÄ‡ krÃ³tszej Å›cieÅ¼ki dla wielokrotnego uÅ¼ycia elementu w tym zasiÄ™gu. Kod moduÅ‚u jest domyÅ›lnie prywatny, ale moÅ¼na uczyniÄ‡ definicje publicznymi, dodajÄ…c sÅ‚owo kluczowe `pub`.\n\nW nastÄ™pnym rozdziale przyjrzymy siÄ™ niektÃ³rym strukturom danych kolekcji w standardowej bibliotece, ktÃ³rych moÅ¼na uÅ¼yÄ‡ w swoim schludnie zorganizowanym kodzie.\n\n[paths]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\n",
        "chapter_title": "Dzielenie moduÅ‚Ã³w na rÃ³Å¼ne pliki"
    },
    {
        "file_path": "ch08-00-common-collections.md",
        "content": "# WspÃ³lne kolekcje\n\nStandardowa biblioteka Rusta zawiera szereg bardzo przydatnych struktur danych zwanych _kolekcjami_. WiÄ™kszoÅ›Ä‡ innych typÃ³w danych reprezentuje jednÄ… konkretnÄ… wartoÅ›Ä‡, ale kolekcje mogÄ… zawieraÄ‡ wiele wartoÅ›ci. W przeciwieÅ„stwie do wbudowanych typÃ³w tablicowych i krotkowych, dane, na ktÃ³re wskazujÄ… te kolekcje, sÄ… przechowywane na stercie, co oznacza, Å¼e iloÅ›Ä‡ danych nie musi byÄ‡ znana w czasie kompilacji i moÅ¼e rosnÄ…Ä‡ lub zmniejszaÄ‡ siÄ™ w trakcie dziaÅ‚ania programu. KaÅ¼dy rodzaj kolekcji ma inne moÅ¼liwoÅ›ci i koszty, a wybÃ³r odpowiedniej dla bieÅ¼Ä…cej sytuacji to umiejÄ™tnoÅ›Ä‡, ktÃ³rÄ… rozwiniesz z czasem. W tym rozdziale omÃ³wimy trzy kolekcje, ktÃ³re sÄ… bardzo czÄ™sto uÅ¼ywane w programach Rust:\n\n- _Wektor_ umoÅ¼liwia przechowywanie zmiennej liczby wartoÅ›ci obok siebie.\n- _CiÄ…g znakÃ³w_ to kolekcja znakÃ³w. WspomnieliÅ›my juÅ¼ o typie `String`, ale w tym rozdziale omÃ³wimy go szczegÃ³Å‚owo.\n- _Mapa haszujÄ…ca_ umoÅ¼liwia powiÄ…zanie wartoÅ›ci z konkretnym kluczem. Jest to szczegÃ³lna implementacja bardziej ogÃ³lnej struktury danych zwanej _mapÄ…_.\n\nAby dowiedzieÄ‡ siÄ™ o innych rodzajach kolekcji dostarczanych przez standardowÄ… bibliotekÄ™, zobacz [dokumentacjÄ™][collections].\n\nOmÃ³wimy, jak tworzyÄ‡ i aktualizowaÄ‡ wektory, ciÄ…gi znakÃ³w i mapy haszujÄ…ce, a takÅ¼e co sprawia, Å¼e kaÅ¼da z nich jest wyjÄ…tkowa.\n\n[collections]: ../std/collections/index.html\n",
        "chapter_title": "WspÃ³lne kolekcje"
    },
    {
        "file_path": "ch08-01-vectors.md",
        "content": "## Przechowywanie list wartoÅ›ci za pomocÄ… wektorÃ³w\n\nPierwszym typem kolekcji, ktÃ³ry omÃ³wimy, jest `Vec<T>`, znany rÃ³wnieÅ¼ jako wektor. Wektory umoÅ¼liwiajÄ… przechowywanie wielu wartoÅ›ci w jednej strukturze danych, ktÃ³ra umieszcza wszystkie wartoÅ›ci obok siebie w pamiÄ™ci. Wektory mogÄ… przechowywaÄ‡ tylko wartoÅ›ci tego samego typu. SÄ… przydatne, gdy masz listÄ™ elementÃ³w, takich jak linie tekstu w pliku lub ceny przedmiotÃ³w w koszyku na zakupy.\n\n### Tworzenie nowego wektora\n\nAby utworzyÄ‡ nowy, pusty wektor, wywoÅ‚ujemy funkcjÄ™ `Vec::new`, jak pokazano w Listing 8-1.\n\n<Listing number=\"8-1\" caption=\"Tworzenie nowego, pustego wektora do przechowywania wartoÅ›ci typu `i32`\">\n\n```rust\n# fn main() {\n    let v: Vec<i32> = Vec::new();\n# }\n```\n\n</Listing>\n\nZauwaÅ¼, Å¼e dodaliÅ›my tutaj adnotacjÄ™ typu. PoniewaÅ¼ nie wstawiamy Å¼adnych wartoÅ›ci do tego wektora, Rust nie wie, jakiego rodzaju elementy zamierzamy przechowywaÄ‡. Jest to waÅ¼na uwaga. Wektory sÄ… implementowane przy uÅ¼yciu generykÃ³w; jak uÅ¼ywaÄ‡ generykÃ³w z wÅ‚asnymi typami, omÃ³wimy w Rozdziale 10. Na razie wiedz, Å¼e typ `Vec<T>` dostarczany przez standardowÄ… bibliotekÄ™ moÅ¼e przechowywaÄ‡ dowolny typ. Kiedy tworzymy wektor do przechowywania okreÅ›lonego typu, moÅ¼emy okreÅ›liÄ‡ typ w nawiasach ostrych. W Listing 8-1 poinformowaliÅ›my Rusta, Å¼e `Vec<T>` w `v` bÄ™dzie przechowywaÄ‡ elementy typu `i32`.\n\nCzÄ™Å›ciej bÄ™dziesz tworzyÄ‡ `Vec<T>` z wartoÅ›ciami poczÄ…tkowymi, a Rust wywnioskuje typ wartoÅ›ci, ktÃ³rÄ… chcesz przechowywaÄ‡, wiÄ™c rzadko bÄ™dziesz musiaÅ‚ dodawaÄ‡ adnotacje typu. Rust wygodnie udostÄ™pnia makro `vec!`, ktÃ³re utworzy nowy wektor przechowujÄ…cy podane wartoÅ›ci. Listing 8-2 tworzy nowy `Vec<i32>` przechowujÄ…cy wartoÅ›ci `1`, `2` i `3`. Typ liczby caÅ‚kowitej to `i32`, poniewaÅ¼ jest to domyÅ›lny typ liczby caÅ‚kowitej, jak omÃ³wiliÅ›my w sekcji [â€Typy danychâ€][data-types]<!-- ignore --> w Rozdziale 3.\n\n<Listing number=\"8-2\" caption=\"Tworzenie nowego wektora zawierajÄ…cego wartoÅ›ci\">\n\n```rust\n# fn main() {\n    let v = vec![1, 2, 3];\n# }\n```\n\n</Listing>\n\nPoniewaÅ¼ podaliÅ›my poczÄ…tkowe wartoÅ›ci `i32`, Rust moÅ¼e wywnioskowaÄ‡, Å¼e typ `v` to `Vec<i32>`, a adnotacja typu nie jest konieczna. NastÄ™pnie przyjrzymy siÄ™, jak modyfikowaÄ‡ wektor.\n\n### Aktualizowanie wektora\n\nAby utworzyÄ‡ wektor, a nastÄ™pnie dodaÄ‡ do niego elementy, moÅ¼emy uÅ¼yÄ‡ metody `push`, jak pokazano w Listing 8-3.\n\n<Listing number=\"8-3\" caption=\"UÅ¼ycie metody `push` do dodawania wartoÅ›ci do wektora\">\n\n```rust\n# fn main() {\n    let mut v = Vec::new();\n\n    v.push(5);\n    v.push(6);\n    v.push(7);\n    v.push(8);\n# }\n```\n\n</Listing>\n\nJak w przypadku kaÅ¼dej zmiennej, jeÅ›li chcemy mÃ³c zmieniaÄ‡ jej wartoÅ›Ä‡, musimy uczyniÄ‡ jÄ… mutowalnÄ… za pomocÄ… sÅ‚owa kluczowego `mut`, jak omÃ³wiono w Rozdziale 3. Liczby, ktÃ³re umieszczamy wewnÄ…trz, sÄ… wszystkie typu `i32`, a Rust wnioskuje to z danych, wiÄ™c nie potrzebujemy adnotacji `Vec<i32>`.\n\n### Odczytywanie elementÃ³w wektorÃ³w\n\nIstniejÄ… dwa sposoby odwoÅ‚ywania siÄ™ do wartoÅ›ci przechowywanej w wektorze: poprzez indeksowanie lub za pomocÄ… metody `get`. W poniÅ¼szych przykÅ‚adach dodaliÅ›my adnotacje typÃ³w wartoÅ›ci zwracanych przez te funkcje dla dodatkowej przejrzystoÅ›ci.\n\nListing 8-4 pokazuje obie metody dostÄ™pu do wartoÅ›ci w wektorze, ze skÅ‚adniÄ… indeksowania i metodÄ… `get`.\n\n<Listing number=\"8-4\" caption=\"UÅ¼ycie skÅ‚adni indeksowania i metody `get` do dostÄ™pu do elementu w wektorze\">\n\n```rust\n# fn main() {\n    let v = vec![1, 2, 3, 4, 5];\n\n    let third: &i32 = &v[2];\n    println!(\"Trzeci element to {third}\");\n\n    let third: Option<&i32> = v.get(2);\n    match third {\n        Some(third) => println!(\"Trzeci element to {third}\"),\n        None => println!(\"Nie ma trzeciego elementu.\"),\n    }\n# }\n```\n\n</Listing>\n\nZauwaÅ¼my kilka szczegÃ³Å‚Ã³w. UÅ¼ywamy wartoÅ›ci indeksu `2`, aby uzyskaÄ‡ trzeci element, poniewaÅ¼ wektory sÄ… indeksowane liczbami, zaczynajÄ…c od zera. UÅ¼ycie `&` i `[]` daje nam odniesienie do elementu o wartoÅ›ci indeksu. Kiedy uÅ¼ywamy metody `get` z indeksem przekazanym jako argument, otrzymujemy `Option<&T>`, ktÃ³rego moÅ¼emy uÅ¼yÄ‡ z `match`.\n\nRust udostÄ™pnia te dwa sposoby odwoÅ‚ywania siÄ™ do elementu, abyÅ› mÃ³gÅ‚ wybraÄ‡, jak program zachowa siÄ™, gdy sprÃ³bujesz uÅ¼yÄ‡ wartoÅ›ci indeksu spoza zakresu istniejÄ…cych elementÃ³w. Na przykÅ‚ad, zobaczmy, co siÄ™ stanie, gdy mamy wektor piÄ™ciu elementÃ³w, a nastÄ™pnie sprÃ³bujemy uzyskaÄ‡ dostÄ™p do elementu o indeksie 100 za pomocÄ… kaÅ¼dej techniki, jak pokazano w Listing 8-5.\n\n<Listing number=\"8-5\" caption=\"PrÃ³ba dostÄ™pu do elementu o indeksie 100 w wektorze zawierajÄ…cym piÄ™Ä‡ elementÃ³w\">\n\n```rust,should_panic,panics\n# fn main() {\n    let v = vec![1, 2, 3, 4, 5];\n\n    let does_not_exist = &v[100];\n    let does_not_exist = v.get(100);\n# }\n```\n\n</Listing>\n\nKiedy uruchomimy ten kod, pierwsza metoda `[]` spowoduje panikÄ™ programu, poniewaÅ¼ odwoÅ‚uje siÄ™ do nieistniejÄ…cego elementu. Ta metoda jest najlepiej uÅ¼ywana, gdy chcesz, aby program ulegÅ‚ awarii, jeÅ›li istnieje prÃ³ba dostÄ™pu do elementu poza koÅ„cem wektora.\n\nJeÅ›li do metody `get` zostanie przekazany indeks spoza zakresu wektora, zwraca `None` bez paniki. UÅ¼yÅ‚byÅ› tej metody, jeÅ›li dostÄ™p do elementu spoza zakresu wektora moÅ¼e sporadycznie wystÄ™powaÄ‡ w normalnych okolicznoÅ›ciach. TwÃ³j kod bÄ™dzie wtedy zawieraÅ‚ logikÄ™ do obsÅ‚ugi `Some(&element)` lub `None`, jak omÃ³wiono w Rozdziale 6. Na przykÅ‚ad, indeks moÅ¼e pochodziÄ‡ od osoby wpisujÄ…cej liczbÄ™. JeÅ›li przypadkowo wpisze zbyt duÅ¼Ä… liczbÄ™, a program otrzyma wartoÅ›Ä‡ `None`, moÅ¼esz poinformowaÄ‡ uÅ¼ytkownika, ile elementÃ³w znajduje siÄ™ w bieÅ¼Ä…cym wektorze i daÄ‡ mu kolejnÄ… szansÄ™ na wprowadzenie prawidÅ‚owej wartoÅ›ci. ByÅ‚oby to bardziej przyjazne dla uÅ¼ytkownika niÅ¼ awaria programu z powodu literÃ³wki!\n\nGdy program ma prawidÅ‚owÄ… referencjÄ™, sprawdzanie poÅ¼yczek (borrow checker) egzekwuje zasady wÅ‚asnoÅ›ci i poÅ¼yczania (omÃ³wione w Rozdziale 4), aby upewniÄ‡ siÄ™, Å¼e ta referencja i wszelkie inne referencje do zawartoÅ›ci wektora pozostajÄ… prawidÅ‚owe.\nPrzypomnijmy sobie zasadÄ™, ktÃ³ra mÃ³wi, Å¼e nie moÅ¼na mieÄ‡ jednoczeÅ›nie mutowalnych i niemutowalnych referencji w tym samym zakresie. Ta zasada ma zastosowanie w Listing 8-6, gdzie trzymamy niemutowalnÄ… referencjÄ™ do pierwszego elementu w wektorze i prÃ³bujemy dodaÄ‡ element na koÅ„cu. Ten program nie zadziaÅ‚a, jeÅ›li pÃ³Åºniej sprÃ³bujemy odwoÅ‚aÄ‡ siÄ™ do tego elementu w funkcji.\n\n<Listing number=\"8-6\" caption=\"PrÃ³ba dodania elementu do wektora przy jednoczesnym utrzymywaniu referencji do elementu\">\n\n```rust,ignore,does_not_compile\n# fn main() {\n    let mut v = vec![1, 2, 3, 4, 5];\n\n    let first = &v[0];\n\n    v.push(6);\n\n    println!(\"Pierwszy element to: {first}\");\n# }\n```\n\n</Listing>\n\nKompilowanie tego kodu spowoduje nastÄ™pujÄ…cy bÅ‚Ä…d:\n\n```console\n$ cargo run\n   Compiling collections v0.1.0 (file:///projects/collections)\nerror[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable\n --> src/main.rs:6:5\n  |\n4 |     let first = &v[0];\n  |                  - immutable borrow occurs here\n5 |\n6 |     v.push(6);\n  |     ^^^^^^^^^ mutable borrow occurs here\n7 |\n8 |     println!(\"The first element is: {first}\");\n  |                                      ----- immutable borrow later used here\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `collections` (bin \"collections\") due to 1 previous error\n```\n\nKod w Listing 8-6 moÅ¼e wyglÄ…daÄ‡, jakby powinien dziaÅ‚aÄ‡: Dlaczego referencja do pierwszego elementu miaÅ‚aby przejmowaÄ‡ siÄ™ zmianami na koÅ„cu wektora? Ten bÅ‚Ä…d wynika ze sposobu dziaÅ‚ania wektorÃ³w: PoniewaÅ¼ wektory umieszczajÄ… wartoÅ›ci obok siebie w pamiÄ™ci, dodanie nowego elementu na koÅ„cu wektora moÅ¼e wymagaÄ‡ alokacji nowej pamiÄ™ci i skopiowania starych elementÃ³w do nowej przestrzeni, jeÅ›li nie ma wystarczajÄ…co duÅ¼o miejsca, aby umieÅ›ciÄ‡ wszystkie elementy obok siebie tam, gdzie wektor jest obecnie przechowywany. W takim przypadku referencja do pierwszego elementu wskazywaÅ‚aby na zwolnionÄ… pamiÄ™Ä‡. Zasady poÅ¼yczania zapobiegajÄ… programom wpadaniu w takÄ… sytuacjÄ™.\n\n> Uwaga: Aby uzyskaÄ‡ wiÄ™cej informacji na temat szczegÃ³Å‚Ã³w implementacji typu `Vec<T>`, zobacz [â€Rustonomiconâ€][nomicon].\n\n### Iteracja po wartoÅ›ciach w wektorze\n\nAby kolejno uzyskiwaÄ‡ dostÄ™p do kaÅ¼dego elementu w wektorze, iterowalibyÅ›my po wszystkich elementach, zamiast uÅ¼ywaÄ‡ indeksÃ³w do jednoczesnego dostÄ™pu do jednego. Listing 8-7 pokazuje, jak uÅ¼yÄ‡ pÄ™tli `for` do uzyskania niemutowalnych referencji do kaÅ¼dego elementu w wektorze wartoÅ›ci `i32` i ich wydrukowania.\n\n<Listing number=\"8-7\" caption=\"Drukowanie kaÅ¼dego elementu w wektorze poprzez iteracjÄ™ po elementach za pomocÄ… pÄ™tli `for`\">\n\n```rust\n# fn main() {\n    let v = vec![100, 32, 57];\n    for i in &v {\n        println!(\"{i}\");\n    }\n# }\n```\n\n</Listing>\n\nMoÅ¼emy rÃ³wnieÅ¼ iterowaÄ‡ po mutowalnych referencjach do kaÅ¼dego elementu w mutowalnym wektorze, aby wprowadziÄ‡ zmiany do wszystkich elementÃ³w. PÄ™tla `for` w Listing 8-8 doda `50` do kaÅ¼dego elementu.\n\n<Listing number=\"8-8\" caption=\"Iteracja po mutowalnych referencjach do elementÃ³w w wektorze\">\n\n```rust\n# fn main() {\n    let mut v = vec![100, 32, 57];\n    for i in &mut v {\n        *i += 50;\n    }\n# }\n```\n\n</Listing>\n\nAby zmieniÄ‡ wartoÅ›Ä‡, do ktÃ³rej odwoÅ‚uje siÄ™ mutowalna referencja, musimy uÅ¼yÄ‡ operatora dereferencji `*`, aby uzyskaÄ‡ dostÄ™p do wartoÅ›ci w `i`, zanim bÄ™dziemy mogli uÅ¼yÄ‡ operatora `+=`. WiÄ™cej o operatorze dereferencji omÃ³wimy w sekcji [â€Åšledzenie referencji do wartoÅ›ciâ€][deref]<!-- ignore --> w Rozdziale 15.\n\nIteracja po wektorze, niezaleÅ¼nie od tego, czy jest niemutowalna, czy mutowalna, jest bezpieczna dziÄ™ki zasadom sprawdzania poÅ¼yczek. GdybyÅ›my prÃ³bowali wstawiaÄ‡ lub usuwaÄ‡ elementy w treÅ›ciach pÄ™tli `for` w Listing 8-7 i Listing 8-8, otrzymalibyÅ›my bÅ‚Ä…d kompilacji podobny do tego, ktÃ³ry otrzymaliÅ›my w kodzie w Listing 8-6. Referencja do wektora, ktÃ³rÄ… przechowuje pÄ™tla `for`, zapobiega jednoczesnej modyfikacji caÅ‚ego wektora.\n\n### UÅ¼ywanie Enum do przechowywania wielu typÃ³w\n\nWektory mogÄ… przechowywaÄ‡ tylko wartoÅ›ci tego samego typu. MoÅ¼e to byÄ‡ niewygodne; z pewnoÅ›ciÄ… istniejÄ… przypadki uÅ¼ycia, w ktÃ³rych trzeba przechowywaÄ‡ listÄ™ elementÃ³w rÃ³Å¼nych typÃ³w. Na szczÄ™Å›cie warianty enum sÄ… zdefiniowane pod tym samym typem enum, wiÄ™c gdy potrzebujemy jednego typu do reprezentowania elementÃ³w rÃ³Å¼nych typÃ³w, moÅ¼emy zdefiniowaÄ‡ i uÅ¼yÄ‡ enum!\n\nNa przykÅ‚ad, powiedzmy, Å¼e chcemy pobraÄ‡ wartoÅ›ci z wiersza w arkuszu kalkulacyjnym, w ktÃ³rym niektÃ³re kolumny w wierszu zawierajÄ… liczby caÅ‚kowite, niektÃ³re liczby zmiennoprzecinkowe, a niektÃ³re ciÄ…gi znakÃ³w. MoÅ¼emy zdefiniowaÄ‡ enum, ktÃ³rego warianty bÄ™dÄ… przechowywaÄ‡ rÃ³Å¼ne typy wartoÅ›ci, a wszystkie warianty enum bÄ™dÄ… traktowane jako ten sam typ: typ enum. NastÄ™pnie moÅ¼emy utworzyÄ‡ wektor do przechowywania tego enum i w ten sposÃ³b ostatecznie przechowywaÄ‡ rÃ³Å¼ne typy. ZilustrowaliÅ›my to w Listing 8-9.\n\n<Listing number=\"8-9\" caption=\"Definiowanie enum do przechowywania wartoÅ›ci rÃ³Å¼nych typÃ³w w jednym wektorze\">\n\n```rust\n# fn main() {\n    enum SpreadsheetCell {\n        Int(i32),\n        Float(f64),\n        Text(String),\n    }\n\n    let row = vec![\n        SpreadsheetCell::Int(3),\n        SpreadsheetCell::Text(String::from(\"niebieski\")),\n        SpreadsheetCell::Float(10.12),\n    ];\n# }\n```\n\n</Listing>\n\nRust musi znaÄ‡ typy, ktÃ³re bÄ™dÄ… znajdowaÄ‡ siÄ™ w wektorze w czasie kompilacji, aby dokÅ‚adnie wiedzieÄ‡, ile pamiÄ™ci na stercie bÄ™dzie potrzebne do przechowywania kaÅ¼dego elementu. Musimy rÃ³wnieÅ¼ wyraÅºnie okreÅ›liÄ‡, jakie typy sÄ… dozwolone w tym wektorze. Gdyby Rust pozwalaÅ‚ na przechowywanie dowolnego typu w wektorze, istniaÅ‚oby ryzyko, Å¼e jeden lub wiÄ™cej typÃ³w spowodowaÅ‚oby bÅ‚Ä™dy w operacjach wykonywanych na elementach wektora. UÅ¼ycie enum plus wyraÅ¼enia `match` oznacza, Å¼e Rust zapewni w czasie kompilacji, Å¼e kaÅ¼dy moÅ¼liwy przypadek zostanie obsÅ‚uÅ¼ony, jak omÃ³wiono w Rozdziale 6.\n\nJeÅ›li nie znasz wyczerpujÄ…cego zestawu typÃ³w, ktÃ³re program otrzyma w czasie wykonywania, aby przechowywaÄ‡ w wektorze, technika enum nie zadziaÅ‚a. Zamiast tego moÅ¼esz uÅ¼yÄ‡ obiektu cechy, ktÃ³ry omÃ³wimy w Rozdziale 18.\n\nTeraz, gdy omÃ³wiliÅ›my niektÃ³re z najczÄ™stszych sposobÃ³w uÅ¼ycia wektorÃ³w, upewnij siÄ™, Å¼e zapoznaÅ‚eÅ› siÄ™ z [dokumentacjÄ… API][vec-api]<!-- ignore -->, aby zapoznaÄ‡ siÄ™ ze wszystkimi wieloma przydatnymi metodami zdefiniowanymi w `Vec<T>` przez standardowÄ… bibliotekÄ™. Na przykÅ‚ad, oprÃ³cz `push`, metoda `pop` usuwa i zwraca ostatni element.\n\n### Usuwanie wektora usuwa jego elementy\n\nPodobnie jak kaÅ¼da inna `struct`, wektor jest zwalniany, gdy wychodzi poza zasiÄ™g, jak to zanotowano w Listing 8-10.\n\n<Listing number=\"8-10\" caption=\"Pokazywanie, gdzie wektor i jego elementy sÄ… usuwane\">\n\n```rust\n# fn main() {\n    {\n        let v = vec![1, 2, 3, 4];\n\n        // rÃ³b coÅ› z v\n    } // <- v wychodzi z zasiÄ™gu i jest zwalniane tutaj\n# }\n```\n\n</Listing>\n\nKiedy wektor zostaje usuniÄ™ty, caÅ‚a jego zawartoÅ›Ä‡ rÃ³wnieÅ¼ zostaje usuniÄ™ta, co oznacza, Å¼e przechowywane w nim liczby caÅ‚kowite zostanÄ… posprzÄ…tane. SprawdzajÄ…cy poÅ¼yczki zapewnia, Å¼e wszelkie referencje do zawartoÅ›ci wektora sÄ… uÅ¼ywane tylko wtedy, gdy sam wektor jest prawidÅ‚owy.\n\nPrzejdÅºmy do nastÄ™pnego typu kolekcji: `String`!\n\n[data-types]: ch03-02-data-types.html#data-types\n[nomicon]: ../nomicon/vec/vec.html\n[vec-api]: ../std/vec/struct.Vec.html\n[deref]: ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator\n",
        "chapter_title": "Przechowywanie list wartoÅ›ci za pomocÄ… wektorÃ³w"
    },
    {
        "file_path": "ch08-02-strings.md",
        "content": "## Przechowywanie tekstu zakodowanego w UTF-8 za pomocÄ… ciÄ…gÃ³w znakÃ³w\n\nO ciÄ…gach znakÃ³w rozmawialiÅ›my w Rozdziale 4, ale teraz przyjrzymy siÄ™ im bardziej szczegÃ³Å‚owo. Nowi uÅ¼ytkownicy Rusta czÄ™sto majÄ… problemy z ciÄ…gami znakÃ³w z powodu poÅ‚Ä…czenia trzech czynnikÃ³w: skÅ‚onnoÅ›ci Rusta do ujawniania moÅ¼liwych bÅ‚Ä™dÃ³w, ciÄ…gÃ³w znakÃ³w bÄ™dÄ…cych bardziej skomplikowanÄ… strukturÄ… danych, niÅ¼ wielu programistÃ³w im przypisuje, oraz UTF-8. Czynniki te Å‚Ä…czÄ… siÄ™ w sposÃ³b, ktÃ³ry moÅ¼e wydawaÄ‡ siÄ™ trudny, gdy pochodzisz z innych jÄ™zykÃ³w programowania.\n\nCiÄ…gi znakÃ³w omawiamy w kontekÅ›cie kolekcji, poniewaÅ¼ sÄ… one implementowane jako kolekcja bajtÃ³w, plus kilka metod zapewniajÄ…cych uÅ¼ytecznÄ… funkcjonalnoÅ›Ä‡, gdy te bajty sÄ… interpretowane jako tekst. W tej sekcji omÃ³wimy operacje na `String`, ktÃ³re posiada kaÅ¼dy typ kolekcji, takie jak tworzenie, aktualizowanie i odczytywanie. OmÃ³wimy rÃ³wnieÅ¼ rÃ³Å¼nice miÄ™dzy `String` a innymi kolekcjami, a mianowicie, jak indeksowanie `String` jest skomplikowane przez rÃ³Å¼nice miÄ™dzy tym, jak ludzie i komputery interpretujÄ… dane `String`.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"what-is-a-string\"></a>\n\n### Definiowanie ciÄ…gÃ³w znakÃ³w\n\nNajpierw zdefiniujemy, co rozumiemy przez termin _ciÄ…g znakÃ³w_. Rust ma tylko jeden typ ciÄ…gu znakÃ³w w podstawowym jÄ™zyku, ktÃ³ry jest wycinkiem ciÄ…gu `str`, zazwyczaj wystÄ™pujÄ…cym w formie poÅ¼yczonej, `&str`. W Rozdziale 4 rozmawialiÅ›my o wycinkach ciÄ…gÃ³w znakÃ³w, ktÃ³re sÄ… referencjami do danych ciÄ…gu znakÃ³w zakodowanych w UTF-8, przechowywanych gdzie indziej. LiteraÅ‚y ciÄ…gÃ³w znakÃ³w, na przykÅ‚ad, sÄ… przechowywane w binarnym pliku programu i dlatego sÄ… wycinkami ciÄ…gÃ³w znakÃ³w.\n\nTyp `String`, ktÃ³ry jest dostarczany przez standardowÄ… bibliotekÄ™ Rusta, a nie zakodowany w podstawowym jÄ™zyku, jest rosnÄ…cym, mutowalnym, posiadajÄ…cym wÅ‚asnoÅ›Ä‡, zakodowanym w UTF-8 typem ciÄ…gu znakÃ³w. Kiedy uÅ¼ytkownicy Rusta odwoÅ‚ujÄ… siÄ™ do â€ciÄ…gÃ³w znakÃ³wâ€ w Rust, mogÄ… odnosiÄ‡ siÄ™ zarÃ³wno do typÃ³w `String`, jak i wycinkÃ³w ciÄ…gu `&str`, a nie tylko do jednego z tych typÃ³w. ChociaÅ¼ ta sekcja dotyczy gÅ‚Ã³wnie `String`, oba typy sÄ… intensywnie uÅ¼ywane w standardowej bibliotece Rusta, a zarÃ³wno `String`, jak i wycinki ciÄ…gÃ³w znakÃ³w sÄ… zakodowane w UTF-8.\n\n### Tworzenie nowego ciÄ…gu znakÃ³w\n\nWiele z tych samych operacji dostÄ™pnych dla `Vec<T>` jest rÃ³wnieÅ¼ dostÄ™pnych dla `String`, poniewaÅ¼ `String` jest faktycznie implementowane jako opakowanie wokÃ³Å‚ wektora bajtÃ³w z dodatkowymi gwarancjami, ograniczeniami i moÅ¼liwoÅ›ciami. PrzykÅ‚adem funkcji, ktÃ³ra dziaÅ‚a w ten sam sposÃ³b z `Vec<T>` i `String`, jest funkcja `new` do tworzenia instancji, pokazana w Listing 8-11.\n\n<Listing number=\"8-11\" caption=\"Tworzenie nowego, pustego `String`\">\n\n```rust\n# fn main() {\n    let mut s = String::new();\n# }\n```\n\n</Listing>\n\nTa linia tworzy nowy, pusty ciÄ…g znakÃ³w o nazwie `s`, do ktÃ³rego moÅ¼emy nastÄ™pnie zaÅ‚adowaÄ‡ dane. CzÄ™sto bÄ™dziemy mieli pewne poczÄ…tkowe dane, ktÃ³rymi chcemy rozpoczÄ…Ä‡ ciÄ…g znakÃ³w. W tym celu uÅ¼ywamy metody `to_string`, ktÃ³ra jest dostÄ™pna dla kaÅ¼dego typu implementujÄ…cego cechÄ™ `Display`, tak jak literaÅ‚y ciÄ…gÃ³w znakÃ³w. Listing 8-12 pokazuje dwa przykÅ‚ady.\n\n<Listing number=\"8-12\" caption=\"UÅ¼ycie metody `to_string` do utworzenia `String` z literaÅ‚u ciÄ…gu znakÃ³w\">\n\n```rust\n# fn main() {\n    let data = \"poczÄ…tkowa zawartoÅ›Ä‡\";\n\n    let s = data.to_string();\n\n    // Metoda dziaÅ‚a rÃ³wnieÅ¼ bezpoÅ›rednio na literale:\n    let s = \"poczÄ…tkowa zawartoÅ›Ä‡\".to_string();\n# }\n```\n\n</Listing>\n\nTen kod tworzy ciÄ…g znakÃ³w zawierajÄ…cy `poczÄ…tkowÄ… zawartoÅ›Ä‡`.\n\nMoÅ¼emy rÃ³wnieÅ¼ uÅ¼yÄ‡ funkcji `String::from` do utworzenia `String` z literaÅ‚u ciÄ…gu znakÃ³w. Kod w Listing 8-13 jest rÃ³wnowaÅ¼ny kodowi w Listing 8-12, ktÃ³ry uÅ¼ywa `to_string`.\n\n<Listing number=\"8-13\" caption=\"UÅ¼ycie funkcji `String::from` do utworzenia `String` z literaÅ‚u ciÄ…gu znakÃ³w\">\n\n```rust\n# fn main() {\n    let s = String::from(\"poczÄ…tkowa zawartoÅ›Ä‡\");\n# }\n```\n\n</Listing>\n\nPoniewaÅ¼ ciÄ…gi znakÃ³w sÄ… uÅ¼ywane do wielu rzeczy, moÅ¼emy uÅ¼ywaÄ‡ wielu rÃ³Å¼nych generycznych API dla ciÄ…gÃ³w znakÃ³w, co daje nam wiele opcji. NiektÃ³re z nich mogÄ… wydawaÄ‡ siÄ™ nadmiarowe, ale wszystkie majÄ… swoje miejsce! W tym przypadku `String::from` i `to_string` robiÄ… to samo, wiÄ™c wybÃ³r zaleÅ¼y od stylu i czytelnoÅ›ci.\n\nPamiÄ™taj, Å¼e ciÄ…gi znakÃ³w sÄ… zakodowane w UTF-8, wiÄ™c moÅ¼emy w nich zawrzeÄ‡ dowolne poprawnie zakodowane dane, jak pokazano w Listing 8-14.\n\n<Listing number=\"8-14\" caption=\"Przechowywanie pozdrowieÅ„ w rÃ³Å¼nych jÄ™zykach w ciÄ…gach znakÃ³w\">\n\n```rust\n# fn main() {\n    let hello = String::from(\"Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…\");\n    let hello = String::from(\"DobrÃ½ den\");\n    let hello = String::from(\"Hello\");\n    let hello = String::from(\"×©×œ×•×\");\n    let hello = String::from(\"à¤¨à¤®à¤¸à¥à¤¤à¥‡\");\n    let hello = String::from(\"ã“ã‚“ã«ã¡ã¯\");\n    let hello = String::from(\"ì•ˆë…•í•˜ì„¸ìš”\");\n    let hello = String::from(\"ä½ å¥½\");\n    let hello = String::from(\"OlÃ¡\");\n    let hello = String::from(\"Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ\");\n    let hello = String::from(\"Hola\");\n# }\n```\n\n</Listing>\n\nWszystkie te wartoÅ›ci `String` sÄ… prawidÅ‚owe.\n\n### Aktualizowanie ciÄ…gu znakÃ³w\n\n`String` moÅ¼e rosnÄ…Ä‡ i zmieniaÄ‡ swojÄ… zawartoÅ›Ä‡, podobnie jak zawartoÅ›Ä‡ `Vec<T>`, jeÅ›li dodasz do niego wiÄ™cej danych. Ponadto moÅ¼esz wygodnie uÅ¼yÄ‡ operatora `+` lub makra `format!` do Å‚Ä…czenia wartoÅ›ci `String`.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"appending-to-a-string-with-push_str-and-push\"></a>\n\n#### DoÅ‚Ä…czanie za pomocÄ… `push_str` lub `push`\n\nMoÅ¼emy powiÄ™kszyÄ‡ `String`, uÅ¼ywajÄ…c metody `push_str` do doÅ‚Ä…czenia wycinka ciÄ…gu znakÃ³w, jak pokazano w Listing 8-15.\n\n<Listing number=\"8-15\" caption=\"DoÅ‚Ä…czanie wycinka ciÄ…gu znakÃ³w do `String` za pomocÄ… metody `push_str`\">\n\n```rust\n# fn main() {\n    let mut s = String::from(\"foo\");\n    s.push_str(\"bar\");\n# }\n```\n\n</Listing>\n\nPo tych dwÃ³ch liniach `s` bÄ™dzie zawieraÄ‡ `foobar`. Metoda `push_str` przyjmuje wycinek ciÄ…gu znakÃ³w, poniewaÅ¼ niekoniecznie chcemy przejÄ…Ä‡ wÅ‚asnoÅ›Ä‡ parametru. Na przykÅ‚ad w kodzie w Listing 8-16 chcemy mÃ³c uÅ¼yÄ‡ `s2` po doÅ‚Ä…czeniu jego zawartoÅ›ci do `s1`.\n\n<Listing number=\"8-16\" caption=\"UÅ¼ycie wycinka ciÄ…gu znakÃ³w po doÅ‚Ä…czeniu jego zawartoÅ›ci do `String`\">\n\n```rust\n# fn main() {\n    let mut s1 = String::from(\"foo\");\n    let s2 = \"bar\";\n    s1.push_str(s2);\n    println!(\"s2 to {s2}\");\n# }\n```\n\n</Listing>\n\nGdyby metoda `push_str` przejÄ™Å‚a wÅ‚asnoÅ›Ä‡ `s2`, nie moglibyÅ›my wydrukowaÄ‡ jego wartoÅ›ci w ostatniej linii. Jednak ten kod dziaÅ‚a zgodnie z oczekiwaniami!\n\nMetoda `push` przyjmuje pojedynczy znak jako parametr i dodaje go do `String`. Listing 8-17 dodaje literÄ™ _l_ do `String` za pomocÄ… metody `push`.\n\n<Listing number=\"8-17\" caption=\"Dodawanie jednego znaku do wartoÅ›ci `String` za pomocÄ… `push`\">\n\n```rust\n# fn main() {\n    let mut s = String::from(\"lo\");\n    s.push('l');\n# }\n```\n\n</Listing>\n\nW rezultacie `s` bÄ™dzie zawieraÄ‡ `lol`.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"concatenation-with-the--operator-or-the-format-macro\"></a>\n\n#### ÅÄ…czenie za pomocÄ… `+` lub `format!`\n\nCzÄ™sto bÄ™dziesz chciaÅ‚ poÅ‚Ä…czyÄ‡ dwa istniejÄ…ce ciÄ…gi znakÃ³w. Jednym ze sposobÃ³w na to jest uÅ¼ycie operatora `+`, jak pokazano w Listing 8-18.\n\n<Listing number=\"8-18\" caption=\"UÅ¼ycie operatora `+` do poÅ‚Ä…czenia dwÃ³ch wartoÅ›ci `String` w nowÄ… wartoÅ›Ä‡ `String`\">\n\n```rust\n# fn main() {\n    let s1 = String::from(\"Witaj, \");\n    let s2 = String::from(\"Å›wiecie!\");\n    let s3 = s1 + &s2; // uwaga, s1 zostaÅ‚o przeniesione i nie moÅ¼e byÄ‡ juÅ¼ uÅ¼yte\n# }\n```\n\n</Listing>\n\nCiÄ…g `s3` bÄ™dzie zawieraÅ‚ `Witaj, Å›wiecie!`. PowÃ³d, dla ktÃ³rego `s1` jest juÅ¼ niewaÅ¼ne po dodaniu, oraz powÃ³d, dla ktÃ³rego uÅ¼yliÅ›my referencji do `s2`, ma zwiÄ…zek z sygnaturÄ… metody, ktÃ³ra jest wywoÅ‚ywana, gdy uÅ¼ywamy operatora `+`. Operator `+` uÅ¼ywa metody `add`, ktÃ³rej sygnatura wyglÄ…da mniej wiÄ™cej tak:\n\n```rust,ignore\nfn add(self, s: &str) -> String {\n```\n\nW standardowej bibliotece zobaczysz `add` zdefiniowane przy uÅ¼yciu generykÃ³w i typÃ³w skojarzonych. Tutaj podstawiliÅ›my konkretne typy, co dzieje siÄ™, gdy wywoÅ‚ujemy tÄ™ metodÄ™ z wartoÅ›ciami `String`. Generyki omÃ³wimy w Rozdziale 10. Ta sygnatura daje nam wskazÃ³wki potrzebne do zrozumienia trudnych aspektÃ³w operatora `+`.\n\nPo pierwsze, `s2` ma `&`, co oznacza, Å¼e dodajemy referencjÄ™ drugiego ciÄ…gu znakÃ³w do pierwszego ciÄ…gu znakÃ³w. Dzieje siÄ™ tak z powodu parametru `s` w funkcji `add`: moÅ¼emy dodaÄ‡ tylko wycinek ciÄ…gu znakÃ³w do `String`; nie moÅ¼emy dodaÄ‡ dwÃ³ch wartoÅ›ci `String` razem. Ale czekaj â€“ typ `&s2` to `&String`, a nie `&str`, jak okreÅ›lono w drugim parametrze `add`. Dlaczego wiÄ™c Listing 8-18 kompiluje siÄ™?\n\nPowodem, dla ktÃ³rego moÅ¼emy uÅ¼yÄ‡ `&s2` w wywoÅ‚aniu `add`, jest to, Å¼e kompilator moÅ¼e wymusiÄ‡ konwersjÄ™ argumentu `&String` na `&str`. Kiedy wywoÅ‚ujemy metodÄ™ `add`, Rust uÅ¼ywa deref coercion, ktÃ³ra tutaj zmienia `&s2` na `&s2[..]`. OmÃ³wimy deref coercion szczegÃ³Å‚owo w Rozdziale 15. PoniewaÅ¼ `add` nie przejmuje wÅ‚asnoÅ›ci parametru `s`, `s2` nadal bÄ™dzie prawidÅ‚owym `String` po tej operacji.\n\nPo drugie, w sygnaturze widzimy, Å¼e `add` przejmuje wÅ‚asnoÅ›Ä‡ `self`, poniewaÅ¼ `self` _nie_ ma `&`. Oznacza to, Å¼e `s1` w Listing 8-18 zostanie przeniesione do wywoÅ‚ania `add` i po tym nie bÄ™dzie juÅ¼ waÅ¼ne. Tak wiÄ™c, chociaÅ¼ `let s3 = s1 + &s2;` wyglÄ…da na to, Å¼e skopiuje oba ciÄ…gi i stworzy nowy, to faktycznie przejmuje wÅ‚asnoÅ›Ä‡ `s1`, doÅ‚Ä…cza kopiÄ™ zawartoÅ›ci `s2`, a nastÄ™pnie zwraca wÅ‚asnoÅ›Ä‡ wyniku. Innymi sÅ‚owy, wyglÄ…da na to, Å¼e wykonuje wiele kopii, ale tak nie jest; implementacja jest bardziej wydajna niÅ¼ kopiowanie.\n\nJeÅ›li potrzebujemy poÅ‚Ä…czyÄ‡ wiele ciÄ…gÃ³w znakÃ³w, zachowanie operatora `+` staje siÄ™ nieporÄ™czne:\n\n```rust\n# fn main() {\n    let s1 = String::from(\"tic\");\n    let s2 = String::from(\"tac\");\n    let s3 = String::from(\"toe\");\n\n    let s = s1 + \"-\" + &s2 + \"-\" + &s3;\n# }\n```\n\nW tym momencie `s` bÄ™dzie `tic-tac-toe`. Z tymi wszystkimi znakami `+` i `\"` trudno jest zrozumieÄ‡, co siÄ™ dzieje. Do Å‚Ä…czenia ciÄ…gÃ³w znakÃ³w w bardziej skomplikowany sposÃ³b moÅ¼emy zamiast tego uÅ¼yÄ‡ makra `format!`:\n\n```rust\n# fn main() {\n    let s1 = String::from(\"tic\");\n    let s2 = String::from(\"tac\");\n    let s3 = String::from(\"toe\");\n\n    let s = format!(\"{s1}-{s2}-{s3}\");\n# }\n```\n\nTen kod rÃ³wnieÅ¼ ustawia `s` na `tic-tac-toe`. Makro `format!` dziaÅ‚a jak `println!`, ale zamiast drukowaÄ‡ wynik na ekranie, zwraca `String` z zawartoÅ›ciÄ…. Wersja kodu uÅ¼ywajÄ…ca `format!` jest znacznie Å‚atwiejsza do odczytania, a kod generowany przez makro `format!` uÅ¼ywa referencji, dziÄ™ki czemu to wywoÅ‚anie nie przejmuje wÅ‚asnoÅ›ci Å¼adnego z jego parametrÃ³w.\n\n### Indeksowanie w ciÄ…gach znakÃ³w\n\nW wielu innych jÄ™zykach programowania, dostÄ™p do pojedynczych znakÃ³w w ciÄ…gu znakÃ³w poprzez odwoÅ‚ywanie siÄ™ do nich za pomocÄ… indeksu jest prawidÅ‚owÄ… i powszechnÄ… operacjÄ…. JednakÅ¼e, jeÅ›li sprÃ³bujesz uzyskaÄ‡ dostÄ™p do czÄ™Å›ci `String` za pomocÄ… skÅ‚adni indeksowania w Rust, otrzymasz bÅ‚Ä…d. RozwaÅ¼ nieprawidÅ‚owy kod w Listing 8-19.\n\n<Listing number=\"8-19\" caption=\"PrÃ³ba uÅ¼ycia skÅ‚adni indeksowania z `String`\">\n\n```rust,ignore,does_not_compile\n# fn main() {\n    let s1 = String::from(\"hi\");\n    let h = s1[0];\n# }\n```\n\n</Listing>\n\nTen kod spowoduje nastÄ™pujÄ…cy bÅ‚Ä…d:\n\n```console\n$ cargo run\n   Compiling collections v0.1.0 (file:///projects/collections)\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n --> src/main.rs:3:16\n  |\n3 |     let h = s1[0];\n  |                ^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n  = note: you can use `.chars().nth()` or `.bytes().nth()`\n          for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `String` to implement `Index<{integer}>`\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `collections` (bin \"collections\") due to 1 previous error\n```\n\nBÅ‚Ä…d opowiada historiÄ™: ciÄ…gi znakÃ³w w Rust nie obsÅ‚ugujÄ… indeksowania. Ale dlaczego? Aby odpowiedzieÄ‡ na to pytanie, musimy omÃ³wiÄ‡, jak Rust przechowuje ciÄ…gi znakÃ³w w pamiÄ™ci.\n\n#### Reprezentacja wewnÄ™trzna\n\n`String` jest opakowaniem na `Vec<u8>`. SpÃ³jrzmy na niektÃ³re z naszych poprawnie zakodowanych przykÅ‚adÃ³w ciÄ…gÃ³w znakÃ³w UTF-8 z Listing 8-14. Najpierw ten:\n\n```rust\n# fn main() {\n#     let hello = String::from(\"Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…\");\n#     let hello = String::from(\"DobrÃ½ den\");\n#     let hello = String::from(\"Hello\");\n#     let hello = String::from(\"×©×œ×•×\");\n#     let hello = String::from(\"à¤¨à¤®à¤¸à¥à¤¤à¥‡\");\n#     let hello = String::from(\"ã“ã‚“ã«ã¡ã¯\");\n#     let hello = String::from(\"ì•ˆë…•í•˜ì„¸ìš”\");\n#     let hello = String::from(\"ä½ å¥½\");\n#     let hello = String::from(\"OlÃ¡\");\n#     let hello = String::from(\"Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ\");\n    let hello = String::from(\"Hola\");\n# }\n```\n\nW tym przypadku `len` bÄ™dzie rÃ³wne `4`, co oznacza, Å¼e wektor przechowujÄ…cy ciÄ…g znakÃ³w `\"Hola\"` ma 4 bajty dÅ‚ugoÅ›ci. KaÅ¼da z tych liter zajmuje 1 bajt po zakodowaniu w UTF-8. NastÄ™pna linia moÅ¼e CiÄ™ jednak zaskoczyÄ‡ (zauwaÅ¼, Å¼e ten ciÄ…g zaczyna siÄ™ od wielkiej cyrylicznej litery _Ze_, a nie liczby 3):\n\n```rust\n# fn main() {\n#     let hello = String::from(\"Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…\");\n#     let hello = String::from(\"DobrÃ½ den\");\n#     let hello = String::from(\"Hello\");\n#     let hello = String::from(\"×©×œ×•×\");\n#     let hello = String::from(\"à¤¨à¤®à¤¸à¥à¤¤à¥‡\");\n#     let hello = String::from(\"ã“ã‚“ã«ã¡ã¯\");\n#     let hello = String::from(\"ì•ˆë…•í•˜ì„¸ìš”\");\n#     let hello = String::from(\"ä½ å¥½\");\n#     let hello = String::from(\"OlÃ¡\");\n    let hello = String::from(\"Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ\");\n#     let hello = String::from(\"Hola\");\n# }\n```\n\nGdybyÅ› zostaÅ‚ zapytany, jak dÅ‚ugi jest ten ciÄ…g znakÃ³w, mÃ³gÅ‚byÅ› powiedzieÄ‡ 12. W rzeczywistoÅ›ci odpowiedÅº Rusta to 24: to liczba bajtÃ³w potrzebna do zakodowania â€Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµâ€ w UTF-8, poniewaÅ¼ kaÅ¼da skalarna wartoÅ›Ä‡ Unicode w tym ciÄ…gu zajmuje 2 bajty pamiÄ™ci. Dlatego indeksowanie bajtÃ³w ciÄ…gu nie zawsze bÄ™dzie korelowaÄ‡ z prawidÅ‚owÄ… skalarnÄ… wartoÅ›ciÄ… Unicode. Aby to zademonstrowaÄ‡, rozwaÅ¼ ten nieprawidÅ‚owy kod w Rust:\n\n```rust,ignore,does_not_compile\nlet hello = \"Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ\";\nlet answer = &hello[0];\n```\n\nWiesz juÅ¼, Å¼e `answer` nie bÄ™dzie `Ğ—`, pierwszÄ… literÄ…. Po zakodowaniu w UTF-8 pierwszy bajt `Ğ—` to `208`, a drugi to `151`, wiÄ™c wydawaÅ‚oby siÄ™, Å¼e `answer` powinien faktycznie wynosiÄ‡ `208`, ale `208` sam w sobie nie jest prawidÅ‚owym znakiem. Zwracanie `208` prawdopodobnie nie jest tym, czego uÅ¼ytkownik chciaÅ‚by, gdyby poprosiÅ‚ o pierwszÄ… literÄ™ tego ciÄ…gu; jednak to jedyne dane, ktÃ³re Rust ma pod indeksem bajtowym 0. UÅ¼ytkownicy generalnie nie chcÄ…, aby zwracana byÅ‚a wartoÅ›Ä‡ bajtowa, nawet jeÅ›li ciÄ…g zawiera tylko litery Å‚aciÅ„skie: Gdyby `&\"hi\"[0]` byÅ‚ prawidÅ‚owym kodem zwracajÄ…cym wartoÅ›Ä‡ bajtowÄ…, zwrÃ³ciÅ‚by `104`, a nie `h`.\n\nOdpowiedÅº brzmi zatem, Å¼e aby uniknÄ…Ä‡ zwracania nieoczekiwanej wartoÅ›ci i powodowania bÅ‚Ä™dÃ³w, ktÃ³re mogÄ… nie zostaÄ‡ natychmiast wykryte, Rust w ogÃ³le nie kompiluje tego kodu i zapobiega nieporozumieniom na wczesnym etapie procesu rozwoju.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"bytes-and-scalar-values-and-grapheme-clusters-oh-my\"></a>\n\n#### Bajty, wartoÅ›ci skalarne i klastry grafemÃ³w\n\nInnÄ… kwestiÄ… dotyczÄ…cÄ… UTF-8 jest to, Å¼e istniejÄ… faktycznie trzy istotne sposoby patrzenia na ciÄ…gi znakÃ³w z perspektywy Rusta: jako bajty, wartoÅ›ci skalarne i klastry grafemÃ³w (najbliÅ¼sze temu, co nazwalibyÅ›my _literami_).\n\nJeÅ›li spojrzymy na hinduskie sÅ‚owo â€à¤¨à¤®à¤¸à¥à¤¤à¥‡â€ napisane pismem dewanagari, jest ono przechowywane jako wektor wartoÅ›ci `u8`, ktÃ³ry wyglÄ…da tak:\n\n```text\n[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,\n224, 165, 135]\n```\n\nTo 18 bajtÃ³w i tak ostatecznie komputery przechowujÄ… te dane. JeÅ›li spojrzymy na nie jako skalarne wartoÅ›ci Unicode, czyli to, czym jest typ `char` w Rust, te bajty wyglÄ…dajÄ… tak:\n\n```text\n['à¤¨', 'à¤®', 'à¤¸', 'à¥', 'à¤¤', 'à¥‡']\n```\n\nJest tu szeÅ›Ä‡ wartoÅ›ci `char`, ale czwarta i szÃ³sta nie sÄ… literami: to znaki diakrytyczne, ktÃ³re same w sobie nie majÄ… sensu. W koÅ„cu, jeÅ›li spojrzymy na nie jako klastry grafemÃ³w, otrzymamy to, co czÅ‚owiek nazwaÅ‚by czterema literami tworzÄ…cymi hinduskie sÅ‚owo:\n\n```text\n[\"à¤¨\", \"à¤®\", \"à¤¸à¥\", \"à¤¤à¥‡\"]\n```\n\nRust udostÄ™pnia rÃ³Å¼ne sposoby interpretacji surowych danych ciÄ…gu znakÃ³w, ktÃ³re przechowujÄ… komputery, tak aby kaÅ¼dy program mÃ³gÅ‚ wybraÄ‡ interpretacjÄ™, ktÃ³rej potrzebuje, niezaleÅ¼nie od tego, w jakim jÄ™zyku ludzkim sÄ… dane.\n\nOstatnim powodem, dla ktÃ³rego Rust nie pozwala nam indeksowaÄ‡ `String` w celu uzyskania znaku, jest to, Å¼e operacje indeksowania majÄ… zawsze zajmowaÄ‡ staÅ‚y czas (O(1)). Nie jest jednak moÅ¼liwe zagwarantowanie takiej wydajnoÅ›ci w przypadku `String`, poniewaÅ¼ Rust musiaÅ‚by przechodziÄ‡ przez zawartoÅ›Ä‡ od poczÄ…tku do indeksu, aby okreÅ›liÄ‡, ile jest prawidÅ‚owych znakÃ³w.\n\n### Krojenie ciÄ…gÃ³w znakÃ³w\n\nIndeksowanie ciÄ…gu znakÃ³w jest czÄ™sto zÅ‚ym pomysÅ‚em, poniewaÅ¼ nie jest jasne, jaki powinien byÄ‡ typ zwracany przez operacjÄ™ indeksowania ciÄ…gu znakÃ³w: wartoÅ›Ä‡ bajtowa, znak, klaster grafemÃ³w czy wycinek ciÄ…gu znakÃ³w. JeÅ›li naprawdÄ™ potrzebujesz uÅ¼ywaÄ‡ indeksÃ³w do tworzenia wycinkÃ³w ciÄ…gu znakÃ³w, Rust prosi o wiÄ™kszÄ… precyzjÄ™.\n\nZamiast indeksowania za pomocÄ… `[]` z pojedynczÄ… liczbÄ…, moÅ¼esz uÅ¼yÄ‡ `[]` z zakresem, aby utworzyÄ‡ wycinek ciÄ…gu znakÃ³w zawierajÄ…cy okreÅ›lone bajty:\n\n```rust\nlet hello = \"Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ\";\n\nlet s = &hello[0..4];\n```\n\nW tym przypadku `s` bÄ™dzie `&str`, ktÃ³ry zawiera pierwsze 4 bajty ciÄ…gu. WczeÅ›niej wspomnieliÅ›my, Å¼e kaÅ¼dy z tych znakÃ³w miaÅ‚ 2 bajty, co oznacza, Å¼e `s` bÄ™dzie `Ğ—Ğ´`.\n\nGdybyÅ›my sprÃ³bowali podzieliÄ‡ tylko czÄ™Å›Ä‡ bajtÃ³w znaku za pomocÄ… czegoÅ› takiego jak `&hello[0..1]`, Rust panikowaÅ‚by w czasie wykonywania w taki sam sposÃ³b, jakbyÅ›my uzyskali dostÄ™p do nieprawidÅ‚owego indeksu w wektorze:\n\n```console\n$ cargo run\n   Compiling collections v0.1.0 (file:///projects/collections)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s\n     Running `target/debug/collections`\n\nthread 'main' panicked at src/main.rs:4:19:\nbyte index 1 is not a char boundary; it is inside 'Ğ—' (bytes 0..2) of `Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ`\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n```\n\nPowinieneÅ› zachowaÄ‡ ostroÅ¼noÅ›Ä‡ podczas tworzenia wycinkÃ³w ciÄ…gÃ³w znakÃ³w za pomocÄ… zakresÃ³w, poniewaÅ¼ moÅ¼e to spowodowaÄ‡ awariÄ™ programu.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"methods-for-iterating-over-strings\"></a>\n\n### Iterowanie po ciÄ…gach znakÃ³w\n\nNajlepszym sposobem na operowanie na fragmentach ciÄ…gÃ³w znakÃ³w jest wyraÅºne okreÅ›lenie, czy chcemy znakÃ³w, czy bajtÃ³w. W przypadku pojedynczych skalarnych wartoÅ›ci Unicode, uÅ¼yj metody `chars`. WywoÅ‚anie `chars` na â€Ğ—Ğ´â€ rozdziela i zwraca dwie wartoÅ›ci typu `char`, i moÅ¼esz iterowaÄ‡ po wyniku, aby uzyskaÄ‡ dostÄ™p do kaÅ¼dego elementu:\n\n```rust\nfor c in \"Ğ—Ğ´\".chars() {\n    println!(\"{c}\");\n}\n```\n\nTen kod wydrukuje nastÄ™pujÄ…ce:\n\n```text\nĞ—\nĞ´\n```\n\nAlternatywnie, metoda `bytes` zwraca kaÅ¼dy surowy bajt, co moÅ¼e byÄ‡ odpowiednie dla twojej domeny:\n\n```rust\nfor b in \"Ğ—Ğ´\".bytes() {\n    println!(\"{b}\");\n}\n```\n\nTen kod wydrukuje 4 bajty, ktÃ³re skÅ‚adajÄ… siÄ™ na ten ciÄ…g znakÃ³w:\n\n```text\n208\n151\n208\n180\n```\n\nAle pamiÄ™taj, Å¼e prawidÅ‚owe skalarne wartoÅ›ci Unicode mogÄ… skÅ‚adaÄ‡ siÄ™ z wiÄ™cej niÅ¼ 1 bajta.\n\nUzyskiwanie klastrÃ³w grafemÃ³w z ciÄ…gÃ³w znakÃ³w, tak jak w przypadku pisma dewanagari, jest zÅ‚oÅ¼one, dlatego ta funkcjonalnoÅ›Ä‡ nie jest dostarczana przez standardowÄ… bibliotekÄ™. Skrzynki sÄ… dostÄ™pne na [crates.io](https://crates.io/)<!-- ignore -->, jeÅ›li to jest funkcjonalnoÅ›Ä‡, ktÃ³rej potrzebujesz.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"strings-are-not-so-simple\"></a>\n\n### ObsÅ‚uga zÅ‚oÅ¼onoÅ›ci ciÄ…gÃ³w znakÃ³w\n\nPodsumowujÄ…c, ciÄ…gi znakÃ³w sÄ… skomplikowane. RÃ³Å¼ne jÄ™zyki programowania podejmujÄ… rÃ³Å¼ne decyzje dotyczÄ…ce tego, jak przedstawiÄ‡ tÄ™ zÅ‚oÅ¼onoÅ›Ä‡ programistom. Rust wybraÅ‚, aby prawidÅ‚owe obchodzenie siÄ™ z danymi `String` byÅ‚o domyÅ›lnym zachowaniem dla wszystkich programÃ³w Rust, co oznacza, Å¼e programiÅ›ci muszÄ… z wyprzedzeniem poÅ›wiÄ™ciÄ‡ wiÄ™cej uwagi obsÅ‚udze danych UTF-8. Ten kompromis ujawnia wiÄ™cej zÅ‚oÅ¼onoÅ›ci ciÄ…gÃ³w znakÃ³w, niÅ¼ jest to widoczne w innych jÄ™zykach programowania, ale zapobiega koniecznoÅ›ci obsÅ‚ugi bÅ‚Ä™dÃ³w zwiÄ…zanych ze znakami spoza ASCII w pÃ³Åºniejszym cyklu rozwoju.\n\nDobrÄ… wiadomoÅ›ciÄ… jest to, Å¼e standardowa biblioteka oferuje wiele funkcjonalnoÅ›ci zbudowanych na typach `String` i `&str`, aby pomÃ³c w prawidÅ‚owym radzeniu sobie z tymi zÅ‚oÅ¼onymi sytuacjami. Koniecznie sprawdÅº dokumentacjÄ™ pod kÄ…tem przydatnych metod, takich jak `contains` do wyszukiwania w ciÄ…gu znakÃ³w i `replace` do zastÄ™powania czÄ™Å›ci ciÄ…gu znakÃ³w innym ciÄ…giem znakÃ³w.\n\nPrzejdÅºmy do czegoÅ› nieco mniej skomplikowanego: mapy haszujÄ…ce!\n",
        "chapter_title": "Przechowywanie tekstu zakodowanego w UTF-8 za pomocÄ… ciÄ…gÃ³w znakÃ³w"
    },
    {
        "file_path": "ch08-03-hash-maps.md",
        "content": "## Przechowywanie kluczy z powiÄ…zanymi wartoÅ›ciami w mapach haszujÄ…cych\n\nOstatniÄ… z naszych wspÃ³lnych kolekcji jest mapa haszujÄ…ca. Typ `HashMap<K, V>` przechowuje mapowanie kluczy typu `K` na wartoÅ›ci typu `V` za pomocÄ… _funkcji haszujÄ…cej_, ktÃ³ra okreÅ›la, w jaki sposÃ³b umieszcza te klucze i wartoÅ›ci w pamiÄ™ci. Wiele jÄ™zykÃ³w programowania obsÅ‚uguje tego rodzaju strukturÄ™ danych, ale czÄ™sto uÅ¼ywajÄ… innej nazwy, takiej jak _hash_, _map_, _object_, _hash table_, _dictionary_ lub _associative array_, by wymieniÄ‡ tylko kilka.\n\nMapy haszujÄ…ce sÄ… przydatne, gdy chcesz wyszukiwaÄ‡ dane nie za pomocÄ… indeksu, jak w przypadku wektorÃ³w, ale za pomocÄ… klucza, ktÃ³ry moÅ¼e byÄ‡ dowolnego typu. Na przykÅ‚ad w grze moÅ¼esz Å›ledziÄ‡ wyniki kaÅ¼dej druÅ¼yny w mapie haszujÄ…cej, w ktÃ³rej kaÅ¼dy klucz to nazwa druÅ¼yny, a wartoÅ›ci to wyniki kaÅ¼dej druÅ¼yny. MajÄ…c nazwÄ™ druÅ¼yny, moÅ¼esz pobraÄ‡ jej wynik.\n\nW tej sekcji omÃ³wimy podstawowe API map haszujÄ…cych, ale wiele innych dobrodziejstw kryje siÄ™ w funkcjach zdefiniowanych dla `HashMap<K, V>` przez standardowÄ… bibliotekÄ™. Jak zawsze, sprawdÅº dokumentacjÄ™ standardowej biblioteki, aby uzyskaÄ‡ wiÄ™cej informacji.\n\n### Tworzenie nowej mapy haszujÄ…cej\n\nJednym ze sposobÃ³w utworzenia pustej mapy haszujÄ…cej jest uÅ¼ycie `new` i dodanie elementÃ³w za pomocÄ… `insert`. W Listing 8-20 Å›ledzimy wyniki dwÃ³ch druÅ¼yn, ktÃ³rych nazwy to _Niebiescy_ i _Å»Ã³Å‚ci_. DruÅ¼yna Niebieskich zaczyna z 10 punktami, a druÅ¼yna Å»Ã³Å‚tych z 50.\n\n<Listing number=\"8-20\" caption=\"Tworzenie nowej mapy haszujÄ…cej i wstawianie niektÃ³rych kluczy i wartoÅ›ci\">\n\n```rust\n# fn main() {\n    use std::collections::HashMap;\n\n    let mut scores = HashMap::new();\n\n    scores.insert(String::from(\"Niebiescy\"), 10);\n    scores.insert(String::from(\"Å»Ã³Å‚ci\"), 50);\n# }\n```\n\n</Listing>\n\nZauwaÅ¼, Å¼e musimy najpierw `use` `HashMap` z czÄ™Å›ci kolekcji standardowej biblioteki. SpoÅ›rÃ³d naszych trzech wspÃ³lnych kolekcji, ta jest najrzadziej uÅ¼ywana, wiÄ™c nie jest ona domyÅ›lnie doÅ‚Ä…czana do zasiÄ™gu w preludium. Mapy haszujÄ…ce majÄ… rÃ³wnieÅ¼ mniejsze wsparcie ze strony standardowej biblioteki; nie ma na przykÅ‚ad wbudowanego makra do ich konstruowania.\n\nPodobnie jak wektory, mapy haszujÄ…ce przechowujÄ… swoje dane na stercie. Ta `HashMap` ma klucze typu `String` i wartoÅ›ci typu `i32`. Podobnie jak wektory, mapy haszujÄ…ce sÄ… jednorodne: wszystkie klucze muszÄ… mieÄ‡ ten sam typ, a wszystkie wartoÅ›ci muszÄ… mieÄ‡ ten sam typ.\n\n### DostÄ™p do wartoÅ›ci w mapie haszujÄ…cej\n\nMoÅ¼emy pobraÄ‡ wartoÅ›Ä‡ z mapy haszujÄ…cej, podajÄ…c jej klucz do metody `get`, jak pokazano w Listing 8-21.\n\n<Listing number=\"8-21\" caption=\"DostÄ™p do wyniku druÅ¼yny Niebieskich przechowywanego w mapie haszujÄ…cej\">\n\n```rust\n# fn main() {\n    use std::collections::HashMap;\n\n    let mut scores = HashMap::new();\n\n    scores.insert(String::from(\"Niebiescy\"), 10);\n    scores.insert(String::from(\"Å»Ã³Å‚ci\"), 50);\n\n    let team_name = String::from(\"Niebiescy\");\n    let score = scores.get(&team_name).copied().unwrap_or(0);\n# }\n```\n\n</Listing>\n\nTutaj `score` bÄ™dzie miaÅ‚o wartoÅ›Ä‡ powiÄ…zanÄ… z druÅ¼ynÄ… Niebieskich, a wynik bÄ™dzie wynosiÅ‚ `10`. Metoda `get` zwraca `Option<&V>`; jeÅ›li dla tego klucza nie ma wartoÅ›ci w mapie haszujÄ…cej, `get` zwrÃ³ci `None`. Ten program obsÅ‚uguje `Option` wywoÅ‚ujÄ…c `copied`, aby uzyskaÄ‡ `Option<i32>` zamiast `Option<&i32>`, a nastÄ™pnie `unwrap_or`, aby ustawiÄ‡ `score` na zero, jeÅ›li `scores` nie ma wpisu dla klucza.\n\nMoÅ¼emy iterowaÄ‡ po kaÅ¼dej parze klucz-wartoÅ›Ä‡ w mapie haszujÄ…cej w podobny sposÃ³b, jak to robimy z wektorami, uÅ¼ywajÄ…c pÄ™tli `for`:\n\n```rust\n# fn main() {\n    use std::collections::HashMap;\n\n    let mut scores = HashMap::new();\n\n    scores.insert(String::from(\"Niebiescy\"), 10);\n    scores.insert(String::from(\"Å»Ã³Å‚ci\"), 50);\n\n    for (key, value) in &scores {\n        println!(\"{key}: {value}\");\n    }\n# }\n```\n\nTen kod wydrukuje kaÅ¼dÄ… parÄ™ w dowolnej kolejnoÅ›ci:\n\n```text\nÅ»Ã³Å‚ci: 50\nNiebiescy: 10\n```\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"hash-maps-and-ownership\"></a>\n\n### ZarzÄ…dzanie wÅ‚asnoÅ›ciÄ… w mapach haszujÄ…cych\n\nW przypadku typÃ³w implementujÄ…cych cechÄ™ `Copy`, takich jak `i32`, wartoÅ›ci sÄ… kopiowane do mapy haszujÄ…cej. W przypadku wartoÅ›ci posiadanych, takich jak `String`, wartoÅ›ci zostanÄ… przeniesione, a mapa haszujÄ…ca bÄ™dzie wÅ‚aÅ›cicielem tych wartoÅ›ci, jak pokazano w Listing 8-22.\n\n<Listing number=\"8-22\" caption=\"Pokazywanie, Å¼e klucze i wartoÅ›ci sÄ… wÅ‚asnoÅ›ciÄ… mapy haszujÄ…cej po ich wstawieniu\">\n\n```rust\n# fn main() {\n    use std::collections::HashMap;\n\n    let field_name = String::from(\"Ulubiony kolor\");\n    let field_value = String::from(\"Niebieski\");\n\n    let mut map = HashMap::new();\n    map.insert(field_name, field_value);\n    // field_name i field_value sÄ… w tym momencie nieprawidÅ‚owe, sprÃ³buj ich uÅ¼yÄ‡ i\n    // zobacz, jaki bÅ‚Ä…d kompilacji otrzymasz!\n# }\n```\n\n</Listing>\n\nNie moÅ¼emy uÅ¼ywaÄ‡ zmiennych `field_name` i `field_value` po ich przeniesieniu do mapy haszujÄ…cej za pomocÄ… wywoÅ‚ania `insert`.\n\nJeÅ›li wstawimy referencje do wartoÅ›ci do mapy haszujÄ…cej, wartoÅ›ci nie zostanÄ… przeniesione do mapy haszujÄ…cej. WartoÅ›ci, na ktÃ³re wskazujÄ… referencje, muszÄ… byÄ‡ waÅ¼ne przynajmniej tak dÅ‚ugo, jak dÅ‚ugo waÅ¼na jest mapa haszujÄ…ca. WiÄ™cej o tych problemach omÃ³wimy w sekcji [â€Walidacja referencji za pomocÄ… czasÃ³w Å¼yciaâ€][validating-references-with-lifetimes]<!-- ignore --> w Rozdziale 10.\n\n### Aktualizowanie mapy haszujÄ…cej\n\nChociaÅ¼ liczba par klucz-wartoÅ›Ä‡ moÅ¼e rosnÄ…Ä‡, kaÅ¼dy unikalny klucz moÅ¼e mieÄ‡ w danym momencie tylko jednÄ… powiÄ…zanÄ… wartoÅ›Ä‡ (ale nie na odwrÃ³t: na przykÅ‚ad, zarÃ³wno druÅ¼yna Niebieskich, jak i druÅ¼yna Å»Ã³Å‚tych mogÅ‚yby mieÄ‡ wartoÅ›Ä‡ `10` przechowywanÄ… w mapie haszujÄ…cej `scores`).\n\nKiedy chcesz zmieniÄ‡ dane w mapie haszujÄ…cej, musisz zdecydowaÄ‡, jak postÄ…piÄ‡ w przypadku, gdy klucz juÅ¼ ma przypisanÄ… wartoÅ›Ä‡. MoÅ¼esz zastÄ…piÄ‡ starÄ… wartoÅ›Ä‡ nowÄ…, caÅ‚kowicie ignorujÄ…c starÄ… wartoÅ›Ä‡. MoÅ¼esz zachowaÄ‡ starÄ… wartoÅ›Ä‡ i zignorowaÄ‡ nowÄ… wartoÅ›Ä‡, dodajÄ…c nowÄ… wartoÅ›Ä‡ tylko wtedy, gdy klucz _nie_ ma jeszcze wartoÅ›ci. Lub moÅ¼esz poÅ‚Ä…czyÄ‡ starÄ… wartoÅ›Ä‡ i nowÄ… wartoÅ›Ä‡. Przyjrzyjmy siÄ™, jak wykonaÄ‡ kaÅ¼dÄ… z tych czynnoÅ›ci!\n\n#### Nadpisywanie wartoÅ›ci\n\nJeÅ›li wstawimy klucz i wartoÅ›Ä‡ do mapy haszujÄ…cej, a nastÄ™pnie wstawimy ten sam klucz z innÄ… wartoÅ›ciÄ…, wartoÅ›Ä‡ powiÄ…zana z tym kluczem zostanie zastÄ…piona. Mimo Å¼e kod w Listing 8-23 wywoÅ‚uje `insert` dwukrotnie, mapa haszujÄ…ca bÄ™dzie zawieraÄ‡ tylko jednÄ… parÄ™ klucz-wartoÅ›Ä‡, poniewaÅ¼ dwukrotnie wstawiamy wartoÅ›Ä‡ dla klucza druÅ¼yny Niebieskich.\n\n<Listing number=\"8-23\" caption=\"ZastÄ™powanie wartoÅ›ci przechowywanej pod okreÅ›lonym kluczem\">\n\n```rust\n# fn main() {\n    use std::collections::HashMap;\n\n    let mut scores = HashMap::new();\n\n    scores.insert(String::from(\"Niebiescy\"), 10);\n    scores.insert(String::from(\"Niebiescy\"), 25);\n\n    println!(\"{scores:?}\");\n# }\n```\n\n</Listing>\n\nTen kod wydrukuje `{\"Niebiescy\": 25}`. Pierwotna wartoÅ›Ä‡ `10` zostaÅ‚a nadpisana.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"only-inserting-a-value-if-the-key-has-no-value\"></a>\n\n#### Dodawanie klucza i wartoÅ›ci tylko wtedy, gdy klucz nie jest obecny\n\nCzÄ™sto sprawdza siÄ™, czy dany klucz juÅ¼ istnieje w mapie haszujÄ…cej z wartoÅ›ciÄ…, a nastÄ™pnie wykonuje nastÄ™pujÄ…ce dziaÅ‚ania: JeÅ›li klucz istnieje w mapie haszujÄ…cej, istniejÄ…ca wartoÅ›Ä‡ powinna pozostaÄ‡ taka, jaka jest; jeÅ›li klucz nie istnieje, wstawia siÄ™ go i wartoÅ›Ä‡ dla niego.\n\nMapy haszujÄ…ce posiadajÄ… specjalne API do tego celu, zwane `entry`, ktÃ³re jako parametr przyjmuje klucz, ktÃ³ry chcesz sprawdziÄ‡. WartoÅ›ciÄ… zwracanÄ… przez metodÄ™ `entry` jest enum o nazwie `Entry`, ktÃ³ry reprezentuje wartoÅ›Ä‡, ktÃ³ra moÅ¼e istnieÄ‡ lub nie. ZaÅ‚Ã³Å¼my, Å¼e chcemy sprawdziÄ‡, czy klucz dla druÅ¼yny Å»Ã³Å‚tych ma przypisanÄ… wartoÅ›Ä‡. JeÅ›li nie, chcemy wstawiÄ‡ wartoÅ›Ä‡ `50`, i to samo dla druÅ¼yny Niebieskich. UÅ¼ywajÄ…c API `entry`, kod wyglÄ…da jak w Listing 8-24.\n\n<Listing number=\"8-24\" caption=\"UÅ¼ycie metody `entry` do wstawiania tylko wtedy, gdy klucz nie ma jeszcze wartoÅ›ci\">\n\n```rust\n# fn main() {\n    use std::collections::HashMap;\n\n    let mut scores = HashMap::new();\n    scores.insert(String::from(\"Niebiescy\"), 10);\n\n    scores.entry(String::from(\"Å»Ã³Å‚ci\")).or_insert(50);\n    scores.entry(String::from(\"Niebiescy\")).or_insert(50);\n\n    println!(\"{scores:?}\");\n# }\n```\n\n</Listing>\n\nMetoda `or_insert` w `Entry` jest zdefiniowana tak, aby zwracaÄ‡ mutowalnÄ… referencjÄ™ do wartoÅ›ci dla odpowiadajÄ…cego klucza `Entry`, jeÅ›li ten klucz istnieje, a jeÅ›li nie, wstawia parametr jako nowÄ… wartoÅ›Ä‡ dla tego klucza i zwraca mutowalnÄ… referencjÄ™ do nowej wartoÅ›ci. Ta technika jest znacznie czystsza niÅ¼ samodzielne pisanie logiki i, co wiÄ™cej, lepiej wspÃ³Å‚pracuje z mechanizmem sprawdzania poÅ¼yczek.\n\nUruchomienie kodu w Listing 8-24 wydrukuje `{\"Å»Ã³Å‚ci\": 50, \"Niebiescy\": 10}`. Pierwsze wywoÅ‚anie `entry` wstawi klucz dla druÅ¼yny Å»Ã³Å‚tych z wartoÅ›ciÄ… `50`, poniewaÅ¼ druÅ¼yna Å»Ã³Å‚tych nie ma jeszcze wartoÅ›ci. Drugie wywoÅ‚anie `entry` nie zmieni mapy haszujÄ…cej, poniewaÅ¼ druÅ¼yna Niebieskich ma juÅ¼ wartoÅ›Ä‡ `10`.\n\n#### Aktualizowanie wartoÅ›ci na podstawie starej wartoÅ›ci\n\nInnym czÄ™stym przypadkiem uÅ¼ycia map haszujÄ…cych jest wyszukiwanie wartoÅ›ci klucza, a nastÄ™pnie aktualizowanie jej na podstawie starej wartoÅ›ci. Na przykÅ‚ad, Listing 8-25 pokazuje kod, ktÃ³ry zlicza, ile razy kaÅ¼de sÅ‚owo pojawia siÄ™ w tekÅ›cie. UÅ¼ywamy mapy haszujÄ…cej ze sÅ‚owami jako kluczami i inkrementujemy wartoÅ›Ä‡, aby Å›ledziÄ‡, ile razy widzieliÅ›my to sÅ‚owo. JeÅ›li jest to pierwszy raz, kiedy widzieliÅ›my sÅ‚owo, najpierw wstawimy wartoÅ›Ä‡ `0`.\n\n<Listing number=\"8-25\" caption=\"Zliczanie wystÄ…pieÅ„ sÅ‚Ã³w za pomocÄ… mapy haszujÄ…cej, ktÃ³ra przechowuje sÅ‚owa i ich liczbÄ™\">\n\n```rust\n# fn main() {\n    use std::collections::HashMap;\n\n    let text = \"czeÅ›Ä‡ Å›wiat cudowny Å›wiat\";\n\n    let mut map = HashMap::new();\n\n    for word in text.split_whitespace() {\n        let count = map.entry(word).or_insert(0);\n        *count += 1;\n    }\n\n    println!(\"{map:?}\");\n# }\n```\n\n</Listing>\n\nTen kod wydrukuje `{\"Å›wiat\": 2, \"czeÅ›Ä‡\": 1, \"cudowny\": 1}`. MoÅ¼esz zobaczyÄ‡ te same pary klucz-wartoÅ›Ä‡ wydrukowane w innej kolejnoÅ›ci: przypomnij sobie z sekcji [â€DostÄ™p do wartoÅ›ci w mapie haszujÄ…cejâ€][access]<!-- ignore -->, Å¼e iteracja po mapie haszujÄ…cej odbywa siÄ™ w dowolnej kolejnoÅ›ci.\n\nMetoda `split_whitespace` zwraca iterator po podsekcjach, rozdzielonych spacjami, wartoÅ›ci w `text`. Metoda `or_insert` zwraca mutowalnÄ… referencjÄ™ (`&mut V`) do wartoÅ›ci dla okreÅ›lonego klucza. Tutaj przechowujemy tÄ™ mutowalnÄ… referencjÄ™ w zmiennej `count`, wiÄ™c aby przypisaÄ‡ do tej wartoÅ›ci, musimy najpierw dereferencjowaÄ‡ `count` za pomocÄ… gwiazdki (`*`). Mutowalna referencja wychodzi poza zasiÄ™g na koÅ„cu pÄ™tli `for`, wiÄ™c wszystkie te zmiany sÄ… bezpieczne i dozwolone przez zasady poÅ¼yczania.\n\n### Funkcje haszujÄ…ce\n\nDomyÅ›lnie `HashMap` uÅ¼ywa funkcji haszujÄ…cej zwanej _SipHash_, ktÃ³ra moÅ¼e zapewniÄ‡ odpornoÅ›Ä‡ na ataki typu denial-of-service (DoS) zwiÄ…zane z tabelami haszujÄ…cymi[^siphash]. Nie jest to najszybszy dostÄ™pny algorytm haszujÄ…cy, ale kompromis miÄ™dzy lepszym bezpieczeÅ„stwem a spadkiem wydajnoÅ›ci jest tego wart. JeÅ›li profilujesz swÃ³j kod i stwierdzisz, Å¼e domyÅ›lna funkcja haszujÄ…ca jest zbyt wolna dla Twoich celÃ³w, moÅ¼esz przeÅ‚Ä…czyÄ‡ siÄ™ na innÄ… funkcjÄ™, okreÅ›lajÄ…c inny haszer. _Haszer_ to typ, ktÃ³ry implementuje cechÄ™ `BuildHasher`. O cechach i sposobie ich implementacji omÃ³wimy w [Rozdziale 10][traits]<!-- ignore -->. Nie musisz koniecznie implementowaÄ‡ wÅ‚asnego haszera od podstaw; [crates.io](https://crates.io/)<!-- ignore --> posiada biblioteki udostÄ™pnione przez innych uÅ¼ytkownikÃ³w Rusta, ktÃ³re dostarczajÄ… haszerÃ³w implementujÄ…cych wiele popularnych algorytmÃ³w haszujÄ…cych.\n\n[^siphash]: [https://en.wikipedia.org/wiki/SipHash](https://en.wikipedia.org/wiki/SipHash)\n\n## Podsumowanie\n\nWektory, ciÄ…gi znakÃ³w i mapy haszujÄ…ce zapewniÄ… duÅ¼Ä… funkcjonalnoÅ›Ä‡ niezbÄ™dnÄ… w programach, gdy trzeba przechowywaÄ‡, uzyskiwaÄ‡ dostÄ™p i modyfikowaÄ‡ dane. Oto kilka Ä‡wiczeÅ„, ktÃ³re powinieneÅ› byÄ‡ teraz w stanie rozwiÄ…zaÄ‡:\n\n1. MajÄ…c listÄ™ liczb caÅ‚kowitych, uÅ¼yj wektora i zwrÃ³Ä‡ medianÄ™ (po posortowaniu, wartoÅ›Ä‡ na Å›rodkowej pozycji) i dominantÄ™ (wartoÅ›Ä‡, ktÃ³ra wystÄ™puje najczÄ™Å›ciej; tutaj pomocna bÄ™dzie mapa haszujÄ…ca) listy.\n1. PrzeksztaÅ‚Ä‡ ciÄ…gi znakÃ³w na jÄ™zyka Pig Latin. Pierwsza spÃ³Å‚gÅ‚oska kaÅ¼dego sÅ‚owa jest przenoszona na koniec sÅ‚owa i dodawane jest _ay_, wiÄ™c _first_ staje siÄ™ _irst-fay_. SÅ‚owa, ktÃ³re zaczynajÄ… siÄ™ samogÅ‚oskÄ…, majÄ… dodane _hay_ na koÅ„cu (_apple_ staje siÄ™ _apple-hay_). PamiÄ™taj o szczegÃ³Å‚ach kodowania UTF-8!\n1. KorzystajÄ…c z mapy haszujÄ…cej i wektorÃ³w, stwÃ³rz interfejs tekstowy, aby umoÅ¼liwiÄ‡ uÅ¼ytkownikowi dodawanie nazw pracownikÃ³w do dziaÅ‚u w firmie; na przykÅ‚ad â€Dodaj Sally do InÅ¼ynieriiâ€ lub â€Dodaj Amira do SprzedaÅ¼yâ€. NastÄ™pnie pozwÃ³l uÅ¼ytkownikowi pobraÄ‡ listÄ™ wszystkich osÃ³b w dziale lub wszystkich osÃ³b w firmie wedÅ‚ug dziaÅ‚u, posortowanych alfabetycznie.\n\nDokumentacja API standardowej biblioteki opisuje metody, ktÃ³re majÄ… wektory, ciÄ…gi znakÃ³w i mapy haszujÄ…ce, ktÃ³re bÄ™dÄ… pomocne w tych Ä‡wiczeniach!\n\nPrzechodzimy do bardziej zÅ‚oÅ¼onych programÃ³w, w ktÃ³rych operacje mogÄ… zakoÅ„czyÄ‡ siÄ™ niepowodzeniem, wiÄ™c to idealny czas, aby omÃ³wiÄ‡ obsÅ‚ugÄ™ bÅ‚Ä™dÃ³w. Zrobimy to w nastÄ™pnej kolejnoÅ›ci!\n\n[validating-references-with-lifetimes]: ch10-03-lifetime-syntax.html#validating-references-with-lifetimes\n[access]: #accessing-values-in-a-hash-map\n[traits]: ch10-02-traits.html\n",
        "chapter_title": "Przechowywanie kluczy z powiÄ…zanymi wartoÅ›ciami w mapach haszujÄ…cych"
    },
    {
        "file_path": "ch09-00-error-handling.md",
        "content": "# ObsÅ‚uga bÅ‚Ä™dÃ³w\n\nBÅ‚Ä™dy sÄ… faktem w oprogramowaniu, dlatego Rust posiada szereg funkcji do obsÅ‚ugi sytuacji, w ktÃ³rych coÅ› idzie nie tak. W wielu przypadkach Rust wymaga od Ciebie uznania moÅ¼liwoÅ›ci bÅ‚Ä™du i podjÄ™cia pewnych dziaÅ‚aÅ„, zanim TwÃ³j kod siÄ™ skompiluje. Ten wymÃ³g sprawia, Å¼e TwÃ³j program jest bardziej niezawodny, zapewniajÄ…c, Å¼e odkryjesz bÅ‚Ä™dy i obsÅ‚uÅ¼ysz je odpowiednio, zanim wdroÅ¼ysz swÃ³j kod do produkcji!\n\nRust dzieli bÅ‚Ä™dy na dwie gÅ‚Ã³wne kategorie: bÅ‚Ä™dy odzyskiwalne i nieodzyskiwalne. W przypadku _bÅ‚Ä™du odzyskiwalnego_, takiego jak bÅ‚Ä…d _pliku nie znaleziono_, najprawdopodobniej chcemy po prostu zgÅ‚osiÄ‡ problem uÅ¼ytkownikowi i ponowiÄ‡ operacjÄ™. _BÅ‚Ä™dy nieodzyskiwalne_ sÄ… zawsze objawami bÅ‚Ä™dÃ³w, takich jak prÃ³ba dostÄ™pu do lokalizacji poza koÅ„cem tablicy, dlatego chcemy natychmiast zatrzymaÄ‡ program.\n\nWiÄ™kszoÅ›Ä‡ jÄ™zykÃ³w nie rozrÃ³Å¼nia tych dwÃ³ch rodzajÃ³w bÅ‚Ä™dÃ³w i obsÅ‚uguje oba w ten sam sposÃ³b, uÅ¼ywajÄ…c mechanizmÃ³w takich jak wyjÄ…tki. Rust nie ma wyjÄ…tkÃ³w. Zamiast tego, ma typ `Result<T, E>` dla bÅ‚Ä™dÃ³w odzyskiwalnych i makro `panic!` ktÃ³re zatrzymuje wykonanie, gdy program napotka bÅ‚Ä…d nieodzyskiwalny. Ten rozdziaÅ‚ najpierw omawia wywoÅ‚ywanie `panic!`, a nastÄ™pnie mÃ³wi o zwracaniu wartoÅ›ci `Result<T, E>`. Dodatkowo, zbadamy rozwaÅ¼ania przy podejmowaniu decyzji, czy sprÃ³bowaÄ‡ odzyskaÄ‡ siÄ™ po bÅ‚Ä™dzie, czy zatrzymaÄ‡ wykonanie.\n",
        "chapter_title": "ObsÅ‚uga bÅ‚Ä™dÃ³w"
    },
    {
        "file_path": "ch09-01-unrecoverable-errors-with-panic.md",
        "content": "## Nieodwracalne bÅ‚Ä™dy z `panic!`\n\nCzasami w twoim kodzie dziejÄ… siÄ™ zÅ‚e rzeczy i nic nie moÅ¼esz na to poradziÄ‡. W takich przypadkach Rust ma makro `panic!`. W praktyce istniejÄ… dwa sposoby wywoÅ‚ania paniki: poprzez wykonanie akcji, ktÃ³ra powoduje panikÄ™ kodu (takiej jak dostÄ™p do tablicy poza jej zakresem) lub poprzez jawne wywoÅ‚anie makra `panic!`. W obu przypadkach powodujemy panikÄ™ w naszym programie. DomyÅ›lnie te paniki wyÅ›wietlÄ… komunikat o bÅ‚Ä™dzie, rozwinÄ… stos, wyczyszczÄ… stos i zakoÅ„czÄ… dziaÅ‚anie. Za pomocÄ… zmiennej Å›rodowiskowej moÅ¼esz rÃ³wnieÅ¼ sprawiÄ‡, Å¼e Rust wyÅ›wietli stos wywoÅ‚aÅ„, gdy wystÄ…pi panika, co uÅ‚atwi Å›ledzenie ÅºrÃ³dÅ‚a paniki.\n\n> ### Rozwijanie stosu lub przerywanie dziaÅ‚ania w odpowiedzi na panikÄ™\n>\n> DomyÅ›lnie, gdy wystÄ…pi panika, program zaczyna siÄ™ _rozwijaÄ‡_, co oznacza, Å¼e Rust cofa siÄ™ po stosie i czyÅ›ci dane z kaÅ¼dej napotkanej funkcji. Jednak cofanie siÄ™ i czyszczenie to duÅ¼o pracy. Rust pozwala zatem wybraÄ‡ alternatywÄ™ natychmiastowego _przerwania_, ktÃ³re koÅ„czy program bez czyszczenia.\n>\n> PamiÄ™Ä‡ uÅ¼ywana przez program bÄ™dzie musiaÅ‚a zostaÄ‡ wyczyszczona przez system operacyjny. JeÅ›li w twoim projekcie musisz sprawiÄ‡, aby wynikowy plik binarny byÅ‚ jak najmniejszy, moÅ¼esz przeÅ‚Ä…czyÄ‡ siÄ™ z rozwijania na przerwanie po panice, dodajÄ…c `panic = 'abort'` do odpowiednich sekcji `[profile]` w pliku _Cargo.toml_. Na przykÅ‚ad, jeÅ›li chcesz przerwaÄ‡ dziaÅ‚anie po panice w trybie wydania, dodaj to:\n>\n> ```toml\n> [profile.release]\n> panic = 'abort'\n> ```\n\nSprÃ³bujmy wywoÅ‚aÄ‡ `panic!` w prostym programie:\n\n<Listing file-name=\"src/main.rs\">\n\n```rust,should_panic,panics\nfn main() {\n    panic!(\"awaria i spalenie\");\n}\n```\n\n</Listing>\n\nPo uruchomieniu programu zobaczysz coÅ› takiego:\n\n```console\n$ cargo run\n   Compiling panic v0.1.0 (file:///projects/panic)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.25s\n     Running `target/debug/panic`\n\nthread 'main' panicked at src/main.rs:2:5:\ncrash and burn\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n```\n\nWywoÅ‚anie `panic!` powoduje komunikat o bÅ‚Ä™dzie zawarty w ostatnich dwÃ³ch liniach. Pierwsza linia pokazuje nasz komunikat paniki i miejsce w kodzie ÅºrÃ³dÅ‚owym, gdzie nastÄ…piÅ‚a panika: _src/main.rs:2:5_ wskazuje, Å¼e jest to druga linia, piÄ…ty znak naszego pliku _src/main.rs_.\n\nW tym przypadku wskazana linia jest czÄ™Å›ciÄ… naszego kodu, a jeÅ›li przejdziemy do tej linii, zobaczymy wywoÅ‚anie makra `panic!`. W innych przypadkach wywoÅ‚anie `panic!` moÅ¼e znajdowaÄ‡ siÄ™ w kodzie, ktÃ³ry wywoÅ‚uje nasz kod, a nazwa pliku i numer linii zgÅ‚oszone przez komunikat o bÅ‚Ä™dzie bÄ™dÄ… kodem kogoÅ› innego, gdzie wywoÅ‚ano makro `panic!`, a nie liniÄ… naszego kodu, ktÃ³ra ostatecznie doprowadziÅ‚a do wywoÅ‚ania `panic!`.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"using-a-panic-backtrace\"></a>\n\nMoÅ¼emy uÅ¼yÄ‡ Å›ledzenia stosu funkcji, z ktÃ³rych pochodzi wywoÅ‚anie `panic!`, aby ustaliÄ‡, ktÃ³ra czÄ™Å›Ä‡ naszego kodu powoduje problem. Aby zrozumieÄ‡, jak uÅ¼ywaÄ‡ Å›ledzenia stosu `panic!`, przyjrzyjmy siÄ™ innemu przykÅ‚adowi i zobaczmy, jak to wyglÄ…da, gdy wywoÅ‚anie `panic!` pochodzi z biblioteki z powodu bÅ‚Ä™du w naszym kodzie, a nie z naszego kodu bezpoÅ›rednio wywoÅ‚ujÄ…cego makro. Listing 9-1 zawiera kod, ktÃ³ry prÃ³buje uzyskaÄ‡ dostÄ™p do indeksu w wektorze poza zakresem prawidÅ‚owych indeksÃ³w.\n\n<Listing number=\"9-1\" file-name=\"src/main.rs\" caption=\"PrÃ³ba dostÄ™pu do elementu poza koÅ„cem wektora, co spowoduje wywoÅ‚anie `panic!`\">\n\n```rust,should_panic,panics\nfn main() {\n    let v = vec![1, 2, 3];\n\n    v[99];\n}\n```\n\n</Listing>\n\nTutaj prÃ³bujemy uzyskaÄ‡ dostÄ™p do 100. elementu naszego wektora (ktÃ³ry znajduje siÄ™ pod indeksem 99, poniewaÅ¼ indeksowanie zaczyna siÄ™ od zera), ale wektor ma tylko trzy elementy. W tej sytuacji Rust wywoÅ‚a panikÄ™. UÅ¼ycie `[]` ma zwrÃ³ciÄ‡ element, ale jeÅ›li podasz nieprawidÅ‚owy indeks, Rust nie mÃ³gÅ‚by zwrÃ³ciÄ‡ Å¼adnego prawidÅ‚owego elementu.\n\nW C, prÃ³ba odczytu poza koÅ„cem struktury danych jest niezdefiniowanym zachowaniem. MoÅ¼esz otrzymaÄ‡ cokolwiek, co znajduje siÄ™ w miejscu w pamiÄ™ci, ktÃ³re odpowiadaÅ‚oby temu elementowi w strukturze danych, mimo Å¼e pamiÄ™Ä‡ nie naleÅ¼y do tej struktury. Nazywa siÄ™ to _przepeÅ‚nieniem bufora_ i moÅ¼e prowadziÄ‡ do luk w zabezpieczeniach, jeÅ›li atakujÄ…cy jest w stanie manipulowaÄ‡ indeksem w taki sposÃ³b, aby odczytaÄ‡ dane, do ktÃ³rych nie powinien mieÄ‡ dostÄ™pu, a ktÃ³re sÄ… przechowywane po strukturze danych.\n\nAby chroniÄ‡ program przed tego rodzaju lukami, jeÅ›li sprÃ³bujesz odczytaÄ‡ element o indeksie, ktÃ³ry nie istnieje, Rust zatrzyma wykonanie i odmÃ³wi kontynuowania. SprÃ³bujmy i zobaczmy:\n\n```console\n$ cargo run\n   Compiling panic v0.1.0 (file:///projects/panic)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s\n     Running `target/debug/panic`\n\nthread 'main' panicked at src/main.rs:4:6:\nindex out of bounds: the len is 3 but the index is 99\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n```\n\nTen bÅ‚Ä…d wskazuje na liniÄ™ 4 naszego _main.rs_, gdzie prÃ³bujemy uzyskaÄ‡ dostÄ™p do indeksu 99 wektora w `v`.\n\nLinia `note:` mÃ³wi nam, Å¼e moÅ¼emy ustawiÄ‡ zmiennÄ… Å›rodowiskowÄ… `RUST_BACKTRACE` na dowolnÄ… wartoÅ›Ä‡ innÄ… niÅ¼ `0`, aby uzyskaÄ‡ Å›ledzenie stosu (backtrace) dokÅ‚adnie tego, co siÄ™ staÅ‚o, aby spowodowaÄ‡ bÅ‚Ä…d. _Åšledzenie stosu_ to lista wszystkich funkcji, ktÃ³re zostaÅ‚y wywoÅ‚ane, aby dojÅ›Ä‡ do tego punktu. Åšledzenia stosu w Rust dziaÅ‚ajÄ… tak samo jak w innych jÄ™zykach: kluczem do odczytania Å›ledzenia stosu jest rozpoczÄ™cie od gÃ³ry i czytanie, aÅ¼ zobaczysz pliki, ktÃ³re napisaÅ‚eÅ›. To jest miejsce, w ktÃ³rym problem siÄ™ rozpoczÄ…Å‚. Linie powyÅ¼ej tego miejsca to kod, ktÃ³ry wywoÅ‚aÅ‚ TwÃ³j kod; linie poniÅ¼ej to kod, ktÃ³ry wywoÅ‚aÅ‚ TwÃ³j kod. Te linie przed i po mogÄ… zawieraÄ‡ podstawowy kod Rust, kod standardowej biblioteki lub skrzynki, ktÃ³rych uÅ¼ywasz. SprÃ³bujmy uzyskaÄ‡ Å›ledzenie stosu, ustawiajÄ…c zmiennÄ… Å›rodowiskowÄ… `RUST_BACKTRACE` na dowolnÄ… wartoÅ›Ä‡ innÄ… niÅ¼ `0`. Listing 9-2 pokazuje wyjÅ›cie podobne do tego, co zobaczysz.\n\n<!-- manual-regeneration\ncd listings/ch09-error-handling/listing-09-01\nRUST_BACKTRACE=1 cargo run\ncopy the backtrace output below\ncheck the backtrace number mentioned in the text below the listing\n-->\n\n<Listing number=\"9-2\" caption=\"Åšledzenie stosu wygenerowane przez wywoÅ‚anie `panic!`, wyÅ›wietlane, gdy zmienna Å›rodowiskowa `RUST_BACKTRACE` jest ustawiona\">\n\n```console\n$ RUST_BACKTRACE=1 cargo run\nthread 'main' panicked at src/main.rs:4:6:\nindex out of bounds: the len is 3 but the index is 99\nstack backtrace:\n   0: rust_begin_unwind\n             at /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/panicking.rs:692:5\n   1: core::panicking::panic_fmt\n             at /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/panicking.rs:75:14\n   2: core::panicking::panic_bounds_check\n             at /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/panicking.rs:273:5\n   3: <usize as core::slice::index::SliceIndex<[T]>>::index\n             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/slice/index.rs:274:10\n   4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index\n             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/slice/index.rs:16:9\n   5: <alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index\n             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3361:9\n   6: panic::main\n             at ./src/main.rs:4:6\n   7: core::ops::function::FnOnce::call_once\n             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/ops/function.rs:250:5\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\n```\n\n</Listing>\n\nTo duÅ¼o danych wyjÅ›ciowych! DokÅ‚adne dane wyjÅ›ciowe mogÄ… siÄ™ rÃ³Å¼niÄ‡ w zaleÅ¼noÅ›ci od systemu operacyjnego i wersji Rusta. Aby uzyskaÄ‡ Å›ledzenia stosu z tymi informacjami, symbole debugowania muszÄ… byÄ‡ wÅ‚Ä…czone. Symbole debugowania sÄ… domyÅ›lnie wÅ‚Ä…czone przy uÅ¼yciu `cargo build` lub `cargo run` bez flagi `--release`, jak to zrobiliÅ›my tutaj.\n\nW danych wyjÅ›ciowych w Listing 9-2, linia 6 Å›ledzenia stosu wskazuje na liniÄ™ w naszym projekcie, ktÃ³ra powoduje problem: linia 4 pliku _src/main.rs_. JeÅ›li nie chcemy, aby nasz program panikowaÅ‚, powinniÅ›my rozpoczÄ…Ä‡ nasze dochodzenie w miejscu wskazanym przez pierwszÄ… liniÄ™ wspomniajÄ…cÄ… o pliku, ktÃ³ry napisaliÅ›my. W Listing 9-1, gdzie celowo napisaliÅ›my kod, ktÃ³ry wywoÅ‚aÅ‚by panikÄ™, sposobem na naprawienie paniki jest nie Å¼Ä…danie elementu poza zakresem indeksÃ³w wektora. Gdy TwÃ³j kod panikuje w przyszÅ‚oÅ›ci, bÄ™dziesz musiaÅ‚ dowiedzieÄ‡ siÄ™, jakÄ… akcjÄ™ podejmuje kod z jakimi wartoÅ›ciami, aby spowodowaÄ‡ panikÄ™, i co kod powinien zrobiÄ‡ zamiast tego.\n\nPowrÃ³cimy do `panic!` i do tego, kiedy powinniÅ›my, a kiedy nie powinniÅ›my uÅ¼ywaÄ‡ `panic!` do obsÅ‚ugi warunkÃ³w bÅ‚Ä™du, w sekcji [â€PanikowaÄ‡ czy nie panikowaÄ‡!â€][to-panic-or-not-to-panic]<!-- ignore --> w dalszej czÄ™Å›ci tego rozdziaÅ‚u. NastÄ™pnie przyjrzymy siÄ™, jak odzyskaÄ‡ siÄ™ po bÅ‚Ä™dzie za pomocÄ… `Result`.\n\n[to-panic-or-not-to-panic]: ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic\n",
        "chapter_title": "Nieodwracalne bÅ‚Ä™dy z panic!"
    },
    {
        "file_path": "ch09-02-recoverable-errors-with-result.md",
        "content": "## BÅ‚Ä™dy odzyskiwalne za pomocÄ… `Result`\n\nWiÄ™kszoÅ›Ä‡ bÅ‚Ä™dÃ³w nie jest na tyle powaÅ¼na, aby wymagaÄ‡ caÅ‚kowitego zatrzymania programu. Czasami, gdy funkcja zawodzi, dzieje siÄ™ tak z powodu, ktÃ³ry moÅ¼na Å‚atwo zinterpretowaÄ‡ i na niego zareagowaÄ‡. Na przykÅ‚ad, jeÅ›li prÃ³bujesz otworzyÄ‡ plik, a ta operacja koÅ„czy siÄ™ niepowodzeniem, poniewaÅ¼ plik nie istnieje, moÅ¼esz chcieÄ‡ utworzyÄ‡ plik zamiast zakoÅ„czyÄ‡ proces.\n\nPrzypomnij sobie z sekcji [â€ObsÅ‚uga potencjalnych awarii za pomocÄ… `Result`â€][handle_failure]<!-- ignore --> w Rozdziale 2, Å¼e enum `Result` jest zdefiniowany tak, aby miaÅ‚ dwa warianty, `Ok` i `Err`, w nastÄ™pujÄ…cy sposÃ³b:\n\n```rust\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```\n\n`T` i `E` to generyczne parametry typu: bardziej szczegÃ³Å‚owo omÃ³wimy generyki w Rozdziale 10. To, co musisz teraz wiedzieÄ‡, to to, Å¼e `T` reprezentuje typ wartoÅ›ci, ktÃ³ra zostanie zwrÃ³cona w przypadku sukcesu w wariancie `Ok`, a `E` reprezentuje typ bÅ‚Ä™du, ktÃ³ry zostanie zwrÃ³cony w przypadku niepowodzenia w wariancie `Err`. PoniewaÅ¼ `Result` ma te generyczne parametry typu, moÅ¼emy uÅ¼ywaÄ‡ typu `Result` i zdefiniowanych na nim funkcji w wielu rÃ³Å¼nych sytuacjach, gdy wartoÅ›Ä‡ sukcesu i wartoÅ›Ä‡ bÅ‚Ä™du, ktÃ³rÄ… chcemy zwrÃ³ciÄ‡, mogÄ… siÄ™ rÃ³Å¼niÄ‡.\n\nWywoÅ‚ajmy funkcjÄ™, ktÃ³ra zwraca wartoÅ›Ä‡ `Result`, poniewaÅ¼ funkcja moÅ¼e zawieÅ›Ä‡. W Listing 9-3 prÃ³bujemy otworzyÄ‡ plik.\n\n<Listing number=\"9-3\" file-name=\"src/main.rs\" caption=\"Otwieranie pliku\">\n\n```rust\nuse std::fs::File;\n\nfn main() {\n    let greeting_file_result = File::open(\"hello.txt\");\n}\n```\n\n</Listing>\n\nTyp zwracany przez `File::open` to `Result<T, E>`. Generyczny parametr `T` zostaÅ‚ wypeÅ‚niony przez implementacjÄ™ `File::open` typem wartoÅ›ci sukcesu, `std::fs::File`, ktÃ³ry jest uchwytem pliku. Typ `E` uÅ¼ywany w wartoÅ›ci bÅ‚Ä™du to `std::io::Error`. Ten typ zwracany oznacza, Å¼e wywoÅ‚anie `File::open` moÅ¼e zakoÅ„czyÄ‡ siÄ™ sukcesem i zwrÃ³ciÄ‡ uchwyt pliku, z ktÃ³rego moÅ¼emy czytaÄ‡ lub do ktÃ³rego moÅ¼emy pisaÄ‡. WywoÅ‚anie funkcji moÅ¼e rÃ³wnieÅ¼ zakoÅ„czyÄ‡ siÄ™ niepowodzeniem: na przykÅ‚ad plik moÅ¼e nie istnieÄ‡ lub moÅ¼emy nie mieÄ‡ uprawnieÅ„ do dostÄ™pu do pliku. Funkcja `File::open` musi mieÄ‡ sposÃ³b, aby poinformowaÄ‡ nas, czy zakoÅ„czyÅ‚a siÄ™ sukcesem, czy niepowodzeniem, i jednoczeÅ›nie podaÄ‡ nam uchwyt pliku lub informacje o bÅ‚Ä™dzie. Te informacje to dokÅ‚adnie to, co przekazuje enum `Result`.\n\nW przypadku, gdy `File::open` zakoÅ„czy siÄ™ sukcesem, wartoÅ›Ä‡ w zmiennej `greeting_file_result` bÄ™dzie instancjÄ… `Ok`, ktÃ³ra zawiera uchwyt pliku. W przypadku, gdy zawiedzie, wartoÅ›Ä‡ w `greeting_file_result` bÄ™dzie instancjÄ… `Err`, ktÃ³ra zawiera wiÄ™cej informacji o rodzaju bÅ‚Ä™du, ktÃ³ry wystÄ…piÅ‚.\n\nMusimy uzupeÅ‚niÄ‡ kod w Listing 9-3, aby podejmowaÄ‡ rÃ³Å¼ne dziaÅ‚ania w zaleÅ¼noÅ›ci od wartoÅ›ci zwracanej przez `File::open`. Listing 9-4 pokazuje jeden ze sposobÃ³w obsÅ‚ugi `Result` za pomocÄ… podstawowego narzÄ™dzia, wyraÅ¼enia `match`, ktÃ³re omÃ³wiliÅ›my w Rozdziale 6.\n\n<Listing number=\"9-4\" file-name=\"src/main.rs\" caption=\"UÅ¼ycie wyraÅ¼enia `match` do obsÅ‚ugi wariantÃ³w `Result`, ktÃ³re mogÄ… zostaÄ‡ zwrÃ³cone\">\n\n```rust,should_panic\nuse std::fs::File;\n\nfn main() {\n    let greeting_file_result = File::open(\"hello.txt\");\n\n    let greeting_file = match greeting_file_result {\n        Ok(file) => file,\n        Err(error) => panic!(\"Problem z otwarciem pliku: {error:?}\"),\n    };\n}\n```\n\n</Listing>\n\nZauwaÅ¼, Å¼e, podobnie jak enum `Option`, enum `Result` i jego warianty zostaÅ‚y wprowadzone do zasiÄ™gu przez preludium, wiÄ™c nie musimy okreÅ›laÄ‡ `Result::` przed wariantami `Ok` i `Err` w ramionach `match`.\n\nKiedy wynik jest `Ok`, ten kod zwrÃ³ci wewnÄ™trznÄ… wartoÅ›Ä‡ `file` z wariantu `Ok`, a nastÄ™pnie przypisujemy tÄ™ wartoÅ›Ä‡ uchwytu pliku do zmiennej `greeting_file`. Po `match` moÅ¼emy uÅ¼yÄ‡ uchwytu pliku do odczytu lub zapisu.\n\nDrugie ramiÄ™ `match` obsÅ‚uguje przypadek, w ktÃ³rym otrzymujemy wartoÅ›Ä‡ `Err` z `File::open`. W tym przykÅ‚adzie zdecydowaliÅ›my siÄ™ wywoÅ‚aÄ‡ makro `panic!`. JeÅ›li w naszym bieÅ¼Ä…cym katalogu nie ma pliku o nazwie _hello.txt_ i uruchomimy ten kod, zobaczymy nastÄ™pujÄ…ce dane wyjÅ›ciowe z makra `panic!`:\n\n```console\n$ cargo run\n   Compiling error-handling v0.1.0 (file:///projects/error-handling)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s\n     Running `target/debug/error-handling`\n\nthread 'main' panicked at src/main.rs:8:23:\nProblem opening the file: Os { code: 2, kind: NotFound, message: \"No such file or directory\" }\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n```\n\nJak zwykle, to wyjÅ›cie mÃ³wi nam dokÅ‚adnie, co poszÅ‚o nie tak.\n\n### Dopasowywanie rÃ³Å¼nych bÅ‚Ä™dÃ³w\n\nKod w Listing 9-4 spowoduje `panic!` niezaleÅ¼nie od tego, dlaczego `File::open` zakoÅ„czyÅ‚o siÄ™ niepowodzeniem. My jednak chcemy podejmowaÄ‡ rÃ³Å¼ne dziaÅ‚ania z rÃ³Å¼nych powodÃ³w awarii. JeÅ›li `File::open` zakoÅ„czyÅ‚o siÄ™ niepowodzeniem, poniewaÅ¼ plik nie istnieje, chcemy utworzyÄ‡ plik i zwrÃ³ciÄ‡ uchwyt do nowego pliku. JeÅ›li `File::open` zakoÅ„czyÅ‚o siÄ™ niepowodzeniem z jakiegokolwiek innego powodu â€” na przykÅ‚ad, poniewaÅ¼ nie mieliÅ›my uprawnieÅ„ do otwarcia pliku â€” nadal chcemy, aby kod spowodowaÅ‚ `panic!` w ten sam sposÃ³b, jak w Listing 9-4. W tym celu dodajemy wewnÄ™trzne wyraÅ¼enie `match`, pokazane w Listing 9-5.\n\n<Listing number=\"9-5\" file-name=\"src/main.rs\" caption=\"ObsÅ‚uga rÃ³Å¼nych rodzajÃ³w bÅ‚Ä™dÃ³w na rÃ³Å¼ne sposoby\">\n\n<!-- ignore this test because otherwise it creates hello.txt which causes other\ntests to fail lol -->\n\n```rust,ignore\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    let greeting_file_result = File::open(\"hello.txt\");\n\n    let greeting_file = match greeting_file_result {\n        Ok(file) => file,\n        Err(error) => match error.kind() {\n            ErrorKind::NotFound => match File::create(\"hello.txt\") {\n                Ok(fc) => fc,\n                Err(e) => panic!(\"Problem z tworzeniem pliku: {e:?}\"),\n            },\n            _ => {\n                panic!(\"Problem z otwarciem pliku: {error:?}\");\n            }\n        },\n    };\n}\n```\n\n</Listing>\n\nTyp wartoÅ›ci zwracanej przez `File::open` w wariancie `Err` to `io::Error`, ktÃ³ry jest strukturÄ… dostarczanÄ… przez standardowÄ… bibliotekÄ™. Ta struktura posiada metodÄ™ `kind`, ktÃ³rÄ… moÅ¼emy wywoÅ‚aÄ‡, aby uzyskaÄ‡ wartoÅ›Ä‡ `io::ErrorKind`. Enum `io::ErrorKind` jest dostarczany przez standardowÄ… bibliotekÄ™ i ma warianty reprezentujÄ…ce rÃ³Å¼ne rodzaje bÅ‚Ä™dÃ³w, ktÃ³re mogÄ… wynikaÄ‡ z operacji `io`. Wariant, ktÃ³rego chcemy uÅ¼yÄ‡, to `ErrorKind::NotFound`, ktÃ³ry wskazuje, Å¼e plik, ktÃ³ry prÃ³bujemy otworzyÄ‡, jeszcze nie istnieje. Zatem dopasowujemy `greeting_file_result`, ale mamy rÃ³wnieÅ¼ wewnÄ™trzne dopasowanie na `error.kind()`.\n\nWarunkiem, ktÃ³ry chcemy sprawdziÄ‡ w wewnÄ™trznym dopasowaniu, jest to, czy wartoÅ›Ä‡ zwrÃ³cona przez `error.kind()` jest wariantem `NotFound` enum `ErrorKind`. JeÅ›li tak, prÃ³bujemy utworzyÄ‡ plik za pomocÄ… `File::create`. JednakÅ¼e, poniewaÅ¼ `File::create` rÃ³wnieÅ¼ moÅ¼e zakoÅ„czyÄ‡ siÄ™ niepowodzeniem, potrzebujemy drugiego ramienia w wewnÄ™trznym wyraÅ¼eniu `match`. Kiedy plik nie moÅ¼e zostaÄ‡ utworzony, wyÅ›wietlany jest inny komunikat o bÅ‚Ä™dzie. Drugie ramiÄ™ zewnÄ™trznego `match` pozostaje takie samo, wiÄ™c program panikuje przy kaÅ¼dym bÅ‚Ä™dzie innym niÅ¼ bÅ‚Ä…d braku pliku.\n\n> #### Alternatywy dla uÅ¼ywania `match` z `Result<T, E>`\n>\n> To duÅ¼o `match`! WyraÅ¼enie `match` jest bardzo przydatne, ale takÅ¼e bardzo prymitywne. W Rozdziale 13 poznasz domkniÄ™cia, ktÃ³re sÄ… uÅ¼ywane z wieloma metodami zdefiniowanymi dla `Result<T, E>`. Te metody mogÄ… byÄ‡ bardziej zwiÄ™zÅ‚e niÅ¼ uÅ¼ywanie `match` podczas obsÅ‚ugi wartoÅ›ci `Result<T, E>` w Twoim kodzie.\n>\n> Na przykÅ‚ad, oto inny sposÃ³b napisania tej samej logiki, jak pokazano w Listing 9-5, tym razem uÅ¼ywajÄ…c domkniÄ™Ä‡ i metody `unwrap_or_else`:\n>\n> <!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->\n>\n> ```rust,ignore\n> use std::fs::File;\n> use std::io::ErrorKind;\n>\n> fn main() {\n>     let greeting_file = File::open(\"hello.txt\").unwrap_or_else(|error| {\n>         if error.kind() == ErrorKind::NotFound {\n>             File::create(\"hello.txt\").unwrap_or_else(|error| {\n>                 panic!(\"Problem z tworzeniem pliku: {error:?}\");\n>             })\n>         } else {\n>             panic!(\"Problem z otwarciem pliku: {error:?}\");\n>         }\n>     });\n> }\n> ```\n>\n> ChociaÅ¼ ten kod ma takie samo zachowanie jak Listing 9-5, nie zawiera Å¼adnych wyraÅ¼eÅ„ `match` i jest czytelniejszy. WrÃ³Ä‡ do tego przykÅ‚adu po przeczytaniu RozdziaÅ‚u 13 i wyszukaj metodÄ™ `unwrap_or_else` w dokumentacji standardowej biblioteki. Wiele innych z tych metod moÅ¼e uporzÄ…dkowaÄ‡ ogromne, zagnieÅ¼dÅ¼one wyraÅ¼enia `match`, gdy masz do czynienia z bÅ‚Ä™dami.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"shortcuts-for-panic-on-error-unwrap-and-expect\"></a>\n\n#### SkrÃ³ty do paniki przy bÅ‚Ä™dzie: `unwrap` i `expect`\n\nUÅ¼ycie `match` dziaÅ‚a wystarczajÄ…co dobrze, ale moÅ¼e byÄ‡ nieco gadatliwe i nie zawsze dobrze komunikuje intencje. Typ `Result<T, E>` ma wiele pomocniczych metod zdefiniowanych na nim do wykonywania rÃ³Å¼nych, bardziej specyficznych zadaÅ„. Metoda `unwrap` jest skrÃ³tem zaimplementowanym tak samo jak wyraÅ¼enie `match`, ktÃ³re napisaliÅ›my w Listing 9-4. JeÅ›li wartoÅ›Ä‡ `Result` jest wariantem `Ok`, `unwrap` zwrÃ³ci wartoÅ›Ä‡ wewnÄ…trz `Ok`. JeÅ›li `Result` jest wariantem `Err`, `unwrap` wywoÅ‚a dla nas makro `panic!`. Oto przykÅ‚ad `unwrap` w dziaÅ‚aniu:\n\n<Listing file-name=\"src/main.rs\">\n\n```rust,should_panic\nuse std::fs::File;\n\nfn main() {\n    let greeting_file = File::open(\"hello.txt\").unwrap();\n}\n```\n\n</Listing>\n\nJeÅ›li uruchomimy ten kod bez pliku _hello.txt_, zobaczymy komunikat o bÅ‚Ä™dzie z wywoÅ‚ania `panic!`, ktÃ³re wykonuje metoda `unwrap`:\n\n<!-- manual-regeneration\ncd listings/ch09-error-handling/no-listing-04-unwrap\ncargo run\ncopy and paste relevant text\n-->\n\n```text\nthread 'main' panicked at src/main.rs:4:49:\ncalled `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: \"No such file or directory\" }\n```\n\nPodobnie, metoda `expect` pozwala nam rÃ³wnieÅ¼ wybraÄ‡ komunikat o bÅ‚Ä™dzie `panic!`. UÅ¼ycie `expect` zamiast `unwrap` i dostarczenie dobrych komunikatÃ³w o bÅ‚Ä™dach moÅ¼e przekazaÄ‡ twoje intencje i uÅ‚atwiÄ‡ Å›ledzenie ÅºrÃ³dÅ‚a paniki. SkÅ‚adnia `expect` wyglÄ…da tak:\n\n<Listing file-name=\"src/main.rs\">\n\n```rust,should_panic\nuse std::fs::File;\n\nfn main() {\n    let greeting_file = File::open(\"hello.txt\")\n        .expect(\"hello.txt powinien byÄ‡ doÅ‚Ä…czony do tego projektu\");\n}\n```\n\n</Listing>\n\nUÅ¼ywamy `expect` w ten sam sposÃ³b co `unwrap`: aby zwrÃ³ciÄ‡ uchwyt pliku lub wywoÅ‚aÄ‡ makro `panic!`. Komunikat o bÅ‚Ä™dzie uÅ¼ywany przez `expect` w jego wywoÅ‚aniu `panic!` bÄ™dzie parametrem, ktÃ³ry przekazujemy do `expect`, zamiast domyÅ›lnego komunikatu `panic!`, ktÃ³rego uÅ¼ywa `unwrap`. Oto jak to wyglÄ…da:\n\n<!-- manual-regeneration\ncd listings/ch09-error-handling/no-listing-05-expect\ncargo run\ncopy and paste relevant text\n-->\n\n```text\nthread 'main' panicked at src/main.rs:5:10:\nhello.txt should be included in this project: Os { code: 2, kind: NotFound, message: \"No such file or directory\" }\n```\n\nW kodzie produkcyjnym wiÄ™kszoÅ›Ä‡ Rustacean preferuje `expect` zamiast `unwrap` i podaje wiÄ™cej kontekstu, dlaczego operacja ma zawsze zakoÅ„czyÄ‡ siÄ™ sukcesem. W ten sposÃ³b, jeÅ›li twoje zaÅ‚oÅ¼enia kiedykolwiek okaÅ¼Ä… siÄ™ bÅ‚Ä™dne, masz wiÄ™cej informacji do wykorzystania w debugowaniu.\n\n### Propagacja bÅ‚Ä™dÃ³w\n\nKiedy implementacja funkcji wywoÅ‚uje coÅ›, co moÅ¼e zawieÅ›Ä‡, zamiast obsÅ‚ugiwaÄ‡ bÅ‚Ä…d w samej funkcji, moÅ¼esz zwrÃ³ciÄ‡ bÅ‚Ä…d do kodu wywoÅ‚ujÄ…cego, aby ten mÃ³gÅ‚ zdecydowaÄ‡, co zrobiÄ‡. Jest to znane jako _propagacja_ bÅ‚Ä™du i daje wiÄ™kszÄ… kontrolÄ™ kodowi wywoÅ‚ujÄ…cemu, gdzie moÅ¼e byÄ‡ wiÄ™cej informacji lub logiki, ktÃ³ra dyktuje, jak bÅ‚Ä…d powinien byÄ‡ obsÅ‚uÅ¼ony, niÅ¼ to, co masz dostÄ™pne w kontekÅ›cie swojego kodu.\n\nNa przykÅ‚ad, Listing 9-6 pokazuje funkcjÄ™, ktÃ³ra odczytuje nazwÄ™ uÅ¼ytkownika z pliku. JeÅ›li plik nie istnieje lub nie moÅ¼na go odczytaÄ‡, funkcja zwrÃ³ci te bÅ‚Ä™dy do kodu, ktÃ³ry wywoÅ‚aÅ‚ funkcjÄ™.\n\n<Listing number=\"9-6\" file-name=\"src/main.rs\" caption=\"Funkcja, ktÃ³ra zwraca bÅ‚Ä™dy do kodu wywoÅ‚ujÄ…cego za pomocÄ… `match`\">\n\n<!-- Deliberately not using rustdoc_include here; the `main` function in the\nfile panics. We do want to include it for reader experimentation purposes, but\ndon't want to include it for rustdoc testing purposes. -->\n\n```rust\nuse std::fs::File;\nuse std::io::{self, Read};\n\nfn read_username_from_file() -> Result<String, io::Error> {\n    let username_file_result = File::open(\"hello.txt\");\n\n    let mut username_file = match username_file_result {\n        Ok(file) => file,\n        Err(e) => return Err(e),\n    };\n\n    let mut username = String::new();\n\n    match username_file.read_to_string(&mut username) {\n        Ok(_) => Ok(username),\n        Err(e) => Err(e),\n    }\n}\n```\n\n</Listing>\n\nTa funkcja moÅ¼e byÄ‡ napisana w znacznie krÃ³tszy sposÃ³b, ale zaczniemy od jej rÄ™cznego implementowania, aby zbadaÄ‡ obsÅ‚ugÄ™ bÅ‚Ä™dÃ³w; na koÅ„cu pokaÅ¼emy krÃ³tszy sposÃ³b. SpÃ³jrzmy najpierw na typ zwracany przez funkcjÄ™: `Result<String, io::Error>`. Oznacza to, Å¼e funkcja zwraca wartoÅ›Ä‡ typu `Result<T, E>`, gdzie generyczny parametr `T` zostaÅ‚ wypeÅ‚niony konkretnym typem `String`, a generyczny typ `E` zostaÅ‚ wypeÅ‚niony konkretnym typem `io::Error`.\n\nJeÅ›li ta funkcja zakoÅ„czy siÄ™ sukcesem bez Å¼adnych problemÃ³w, kod, ktÃ³ry jÄ… wywoÅ‚uje, otrzyma wartoÅ›Ä‡ `Ok`, ktÃ³ra zawiera `String` â€“ `username`, ktÃ³ry ta funkcja odczytaÅ‚a z pliku. JeÅ›li ta funkcja napotka jakiekolwiek problemy, kod wywoÅ‚ujÄ…cy otrzyma wartoÅ›Ä‡ `Err`, ktÃ³ra zawiera wiÄ™cej informacji o tym, jakie byÅ‚y problemy. WybraliÅ›my `io::Error` jako typ zwracany tej funkcji, poniewaÅ¼ jest to typ wartoÅ›ci bÅ‚Ä™du zwracany przez obie operacje, ktÃ³re wywoÅ‚ujemy w treÅ›ci tej funkcji i ktÃ³re mogÄ… zawieÅ›Ä‡: funkcja `File::open` i metoda `read_to_string`.\n\nCiaÅ‚o funkcji zaczyna siÄ™ od wywoÅ‚ania funkcji `File::open`. NastÄ™pnie obsÅ‚ugujemy wartoÅ›Ä‡ `Result` za pomocÄ… `match`, podobnego do `match` w Listing 9-4. JeÅ›li `File::open` zakoÅ„czy siÄ™ sukcesem, uchwyt pliku w zmiennej wzorca `file` staje siÄ™ wartoÅ›ciÄ… w mutowalnej zmiennej `username_file`, a funkcja kontynuuje. W przypadku `Err`, zamiast wywoÅ‚ywaÄ‡ `panic!`, uÅ¼ywamy sÅ‚owa kluczowego `return`, aby natychmiast wyjÅ›Ä‡ z funkcji i przekazaÄ‡ wartoÅ›Ä‡ bÅ‚Ä™du z `File::open`, teraz w zmiennej wzorca `e`, z powrotem do kodu wywoÅ‚ujÄ…cego jako wartoÅ›Ä‡ bÅ‚Ä™du tej funkcji.\n\nZatem, jeÅ›li mamy uchwyt pliku w `username_file`, funkcja nastÄ™pnie tworzy nowy `String` w zmiennej `username` i wywoÅ‚uje metodÄ™ `read_to_string` na uchwycie pliku w `username_file`, aby odczytaÄ‡ zawartoÅ›Ä‡ pliku do `username`. Metoda `read_to_string` rÃ³wnieÅ¼ zwraca `Result`, poniewaÅ¼ moÅ¼e zawieÅ›Ä‡, nawet jeÅ›li `File::open` zakoÅ„czyÅ‚o siÄ™ sukcesem. Musimy wiÄ™c uÅ¼yÄ‡ kolejnego `match` do obsÅ‚ugi tego `Result`: JeÅ›li `read_to_string` zakoÅ„czy siÄ™ sukcesem, to nasza funkcja zakoÅ„czyÅ‚a siÄ™ sukcesem, i zwracamy nazwÄ™ uÅ¼ytkownika z pliku, ktÃ³ra jest teraz w `username`, zawiniÄ™tÄ… w `Ok`. JeÅ›li `read_to_string` zawiedzie, zwracamy wartoÅ›Ä‡ bÅ‚Ä™du w taki sam sposÃ³b, w jaki zwrÃ³ciliÅ›my wartoÅ›Ä‡ bÅ‚Ä™du w `match`, ktÃ³re obsÅ‚ugiwaÅ‚o wartoÅ›Ä‡ zwracanÄ… przez `File::open`. Nie musimy jednak jawnie mÃ³wiÄ‡ `return`, poniewaÅ¼ jest to ostatnie wyraÅ¼enie w funkcji.\n\nKod wywoÅ‚ujÄ…cy ten kod bÄ™dzie nastÄ™pnie obsÅ‚ugiwaÅ‚ otrzymanie wartoÅ›ci `Ok`, ktÃ³ra zawiera nazwÄ™ uÅ¼ytkownika, lub wartoÅ›ci `Err`, ktÃ³ra zawiera `io::Error`. To od kodu wywoÅ‚ujÄ…cego zaleÅ¼y, co zrobiÄ‡ z tymi wartoÅ›ciami. JeÅ›li kod wywoÅ‚ujÄ…cy otrzyma wartoÅ›Ä‡ `Err`, mÃ³gÅ‚by wywoÅ‚aÄ‡ `panic!` i zniszczyÄ‡ program, uÅ¼yÄ‡ domyÅ›lnej nazwy uÅ¼ytkownika lub wyszukaÄ‡ nazwÄ™ uÅ¼ytkownika gdzie indziej niÅ¼ w pliku, na przykÅ‚ad. Nie mamy wystarczajÄ…cych informacji o tym, co kod wywoÅ‚ujÄ…cy faktycznie prÃ³buje zrobiÄ‡, wiÄ™c propagujemy wszystkie informacje o sukcesie lub bÅ‚Ä™dzie w gÃ³rÄ™, aby zostaÅ‚y odpowiednio obsÅ‚uÅ¼one.\n\nTen wzorzec propagacji bÅ‚Ä™dÃ³w jest tak powszechny w Rust, Å¼e Rust udostÄ™pnia operator znak zapytania `?`, aby to uÅ‚atwiÄ‡.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"a-shortcut-for-propagating-errors-the--operator\"></a>\n\n#### SkrÃ³t operatora `?` do propagacji bÅ‚Ä™dÃ³w\n\nListing 9-7 pokazuje implementacjÄ™ `read_username_from_file`, ktÃ³ra ma tÄ™ samÄ… funkcjonalnoÅ›Ä‡ co w Listing 9-6, ale ta implementacja uÅ¼ywa operatora `?`.\n\n<Listing number=\"9-7\" file-name=\"src/main.rs\" caption=\"Funkcja, ktÃ³ra zwraca bÅ‚Ä™dy do kodu wywoÅ‚ujÄ…cego za pomocÄ… operatora `?`\">\n\n<!-- Deliberately not using rustdoc_include here; the `main` function in the\nfile panics. We do want to include it for reader experimentation purposes, but\ndon't want to include it for rustdoc testing purposes. -->\n\n```rust\nuse std::fs::File;\nuse std::io::{self, Read};\n\nfn read_username_from_file() -> Result<String, io::Error> {\n    let mut username_file = File::open(\"hello.txt\")?;\n    let mut username = String::new();\n    username_file.read_to_string(&mut username)?;\n    Ok(username)\n}\n```\n\n</Listing>\n\nOperator `?` umieszczony po wartoÅ›ci `Result` dziaÅ‚a prawie tak samo jak wyraÅ¼enia `match`, ktÃ³re zdefiniowaliÅ›my do obsÅ‚ugi wartoÅ›ci `Result` w Listing 9-6. JeÅ›li wartoÅ›Ä‡ `Result` to `Ok`, wartoÅ›Ä‡ wewnÄ…trz `Ok` zostanie zwrÃ³cona z tego wyraÅ¼enia, a program bÄ™dzie kontynuowaÅ‚. JeÅ›li wartoÅ›Ä‡ to `Err`, `Err` zostanie zwrÃ³cone z caÅ‚ej funkcji tak, jakbyÅ›my uÅ¼yli sÅ‚owa kluczowego `return`, tak aby wartoÅ›Ä‡ bÅ‚Ä™du zostaÅ‚a propagowana do kodu wywoÅ‚ujÄ…cego.\n\nIstnieje rÃ³Å¼nica miÄ™dzy tym, co robi wyraÅ¼enie `match` z Listing 9-6, a tym, co robi operator `?`: wartoÅ›ci bÅ‚Ä™dÃ³w, na ktÃ³rych wywoÅ‚ano operator `?`, przechodzÄ… przez funkcjÄ™ `from`, zdefiniowanÄ… w cesze `From` w standardowej bibliotece, ktÃ³ra jest uÅ¼ywana do konwertowania wartoÅ›ci z jednego typu na inny. Gdy operator `?` wywoÅ‚uje funkcjÄ™ `from`, otrzymany typ bÅ‚Ä™du jest konwertowany na typ bÅ‚Ä™du zdefiniowany w typie zwracanym bieÅ¼Ä…cej funkcji. Jest to przydatne, gdy funkcja zwraca jeden typ bÅ‚Ä™du, aby reprezentowaÄ‡ wszystkie sposoby, w jakie funkcja moÅ¼e zawieÅ›Ä‡, nawet jeÅ›li czÄ™Å›ci mogÄ… zawieÅ›Ä‡ z wielu rÃ³Å¼nych powodÃ³w.\n\nNa przykÅ‚ad, moglibyÅ›my zmieniÄ‡ funkcjÄ™ `read_username_from_file` w Listing 9-7 tak, aby zwracaÅ‚a niestandardowy typ bÅ‚Ä™du o nazwie `OurError`, ktÃ³ry zdefiniujemy. JeÅ›li zdefiniujemy rÃ³wnieÅ¼ `impl From<io::Error> for OurError`, aby skonstruowaÄ‡ instancjÄ™ `OurError` z `io::Error`, to wywoÅ‚ania operatora `?` w ciele `read_username_from_file` wywoÅ‚ajÄ… `from` i przekonwertujÄ… typy bÅ‚Ä™dÃ³w bez potrzeby dodawania do funkcji Å¼adnego dodatkowego kodu.\n\nW kontekÅ›cie Listing 9-7, `?` na koÅ„cu wywoÅ‚ania `File::open` zwrÃ³ci wartoÅ›Ä‡ wewnÄ…trz `Ok` do zmiennej `username_file`. JeÅ›li wystÄ…pi bÅ‚Ä…d, operator `?` natychmiast wyjdzie z caÅ‚ej funkcji i przekaÅ¼e dowolnÄ… wartoÅ›Ä‡ `Err` do kodu wywoÅ‚ujÄ…cego. To samo dotyczy `?` na koÅ„cu wywoÅ‚ania `read_to_string`.\n\nOperator `?` eliminuje wiele szablonowego kodu i upraszcza implementacjÄ™ tej funkcji. MoglibyÅ›my nawet skrÃ³ciÄ‡ ten kod, Å‚Ä…czÄ…c wywoÅ‚ania metod bezpoÅ›rednio po `?`, jak pokazano w Listing 9-8.\n\n<Listing number=\"9-8\" file-name=\"src/main.rs\" caption=\"ÅÄ…czenie wywoÅ‚aÅ„ metod po operatorze `?`\">\n\n<!-- Deliberately not using rustdoc_include here; the `main` function in the\nfile panics. We do want to include it for reader experimentation purposes, but\ndon't want to include it for rustdoc testing purposes. -->\n\n```rust\nuse std::fs::File;\nuse std::io::{self, Read};\n\nfn read_username_from_file() -> Result<String, io::Error> {\n    let mut username = String::new();\n\n    File::open(\"hello.txt\")?.read_to_string(&mut username)?;\n\n    Ok(username)\n}\n```\n\n</Listing>\n\nTworzenie nowego `String` w `username` przenieÅ›liÅ›my na poczÄ…tek funkcji; ta czÄ™Å›Ä‡ nie ulegÅ‚a zmianie. Zamiast tworzyÄ‡ zmiennÄ… `username_file`, poÅ‚Ä…czyliÅ›my wywoÅ‚anie `read_to_string` bezpoÅ›rednio z wynikiem `File::open(\"hello.txt\")?`. Nadal mamy `?` na koÅ„cu wywoÅ‚ania `read_to_string` i nadal zwracamy wartoÅ›Ä‡ `Ok` zawierajÄ…cÄ… `username`, gdy zarÃ³wno `File::open`, jak i `read_to_string` zakoÅ„czÄ… siÄ™ sukcesem, zamiast zwracaÄ‡ bÅ‚Ä™dy. FunkcjonalnoÅ›Ä‡ jest ponownie taka sama jak w Listing 9-6 i Listing 9-7; jest to po prostu inny, bardziej ergonomiczny sposÃ³b zapisu.\n\nListing 9-9 pokazuje sposÃ³b na jeszcze wiÄ™ksze skrÃ³cenie tego za pomocÄ… `fs::read_to_string`.\n\n<Listing number=\"9-9\" file-name=\"src/main.rs\" caption=\"UÅ¼ycie `fs::read_to_string` zamiast otwierania, a nastÄ™pnie czytania pliku\">\n\n<!-- Deliberately not using rustdoc_include here; the `main` function in the\nfile panics. We do want to include it for reader experimentation purposes, but\ndon't want to include it for rustdoc testing purposes. -->\n\n```rust\nuse std::fs;\nuse std::io;\n\nfn read_username_from_file() -> Result<String, io::Error> {\n    fs::read_to_string(\"hello.txt\")\n}\n```\n\n</Listing>\n\nOdczytywanie pliku do ciÄ…gu znakÃ³w jest doÅ›Ä‡ powszechnÄ… operacjÄ…, dlatego standardowa biblioteka udostÄ™pnia wygodnÄ… funkcjÄ™ `fs::read_to_string`, ktÃ³ra otwiera plik, tworzy nowy `String`, odczytuje zawartoÅ›Ä‡ pliku, umieszcza zawartoÅ›Ä‡ w tym `String` i zwraca go. OczywiÅ›cie, uÅ¼ycie `fs::read_to_string` nie daje nam moÅ¼liwoÅ›ci wyjaÅ›nienia caÅ‚ej obsÅ‚ugi bÅ‚Ä™dÃ³w, dlatego najpierw zrobiliÅ›my to w dÅ‚uÅ¼szy sposÃ³b.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"where-the--operator-can-be-used\"></a>\n\n#### Gdzie moÅ¼na uÅ¼ywaÄ‡ operatora `?`\n\nOperator `?` moÅ¼e byÄ‡ uÅ¼ywany tylko w funkcjach, ktÃ³rych typ zwracany jest zgodny z wartoÅ›ciÄ…, na ktÃ³rej uÅ¼yto `?`. Dzieje siÄ™ tak, poniewaÅ¼ operator `?` jest zdefiniowany do wykonania wczesnego zwrÃ³cenia wartoÅ›ci z funkcji, w ten sam sposÃ³b, co wyraÅ¼enie `match`, ktÃ³re zdefiniowaliÅ›my w Listing 9-6. W Listing 9-6 `match` uÅ¼ywaÅ‚ wartoÅ›ci `Result`, a ramiÄ™ wczesnego zwrÃ³cenia zwracaÅ‚o wartoÅ›Ä‡ `Err(e)`. Typ zwracany funkcji musi byÄ‡ `Result`, aby byÅ‚ zgodny z tym `return`.\n\nW Listing 9-10 przyjrzyjmy siÄ™ bÅ‚Ä™dowi, ktÃ³ry otrzymamy, jeÅ›li uÅ¼yjemy operatora `?` w funkcji `main` z typem zwracanym niezgodnym z typem wartoÅ›ci, na ktÃ³rej uÅ¼ywamy `?`.\n\n<Listing number=\"9-10\" file-name=\"src/main.rs\" caption=\"PrÃ³ba uÅ¼ycia `?` w funkcji `main`, ktÃ³ra zwraca `()`, nie skompiluje siÄ™.\">\n\n```rust,ignore,does_not_compile\nuse std::fs::File;\n\nfn main() {\n    let greeting_file = File::open(\"hello.txt\")?;\n}\n```\n\n</Listing>\n\nTen kod otwiera plik, co moÅ¼e zakoÅ„czyÄ‡ siÄ™ niepowodzeniem. Operator `?` nastÄ™puje po wartoÅ›ci `Result` zwracanej przez `File::open`, ale ta funkcja `main` ma typ zwracany `()`, a nie `Result`. Kiedy skompilujemy ten kod, otrzymamy nastÄ™pujÄ…cy komunikat o bÅ‚Ä™dzie:\n\n```console\n$ cargo run\n   Compiling error-handling v0.1.0 (file:///projects/error-handling)\nerror[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)\n --> src/main.rs:4:48\n  |\n3 | fn main() {\n  | --------- this function should return `Result` or `Option` to accept `?`\n4 |     let greeting_file = File::open(\"hello.txt\")?;\n  |                                                ^ cannot use the `?` operator in a function that returns `()`\n  |\nhelp: consider adding return type\n  |\n3 ~ fn main() -> Result<(), Box<dyn std::error::Error>> {\n4 |     let greeting_file = File::open(\"hello.txt\")?;\n5 +     Ok(())\n  |\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `error-handling` (bin \"error-handling\") due to 1 previous error\n```\n\nTen bÅ‚Ä…d wskazuje, Å¼e moÅ¼emy uÅ¼ywaÄ‡ operatora `?` tylko w funkcji, ktÃ³ra zwraca `Result`, `Option` lub inny typ implementujÄ…cy `FromResidual`.\n\nAby naprawiÄ‡ bÅ‚Ä…d, masz dwie moÅ¼liwoÅ›ci. Jedna to zmiana typu zwracanego przez funkcjÄ™, aby byÅ‚ zgodny z wartoÅ›ciÄ…, na ktÃ³rej uÅ¼ywasz operatora `?`, o ile nie ma Å¼adnych ograniczeÅ„, ktÃ³re by to uniemoÅ¼liwiaÅ‚y. Druga to uÅ¼ycie `match` lub jednej z metod `Result<T, E>`, aby obsÅ‚uÅ¼yÄ‡ `Result<T, E>` w dowolny odpowiedni sposÃ³b.\n\nKomunikat o bÅ‚Ä™dzie wspominaÅ‚ rÃ³wnieÅ¼, Å¼e `?` moÅ¼e byÄ‡ uÅ¼ywany z wartoÅ›ciami `Option<T>`. Podobnie jak w przypadku uÅ¼ycia `?` na `Result`, moÅ¼esz uÅ¼ywaÄ‡ `?` na `Option` tylko w funkcji, ktÃ³ra zwraca `Option`. Zachowanie operatora `?` wywoÅ‚ywanego na `Option<T>` jest podobne do jego zachowania wywoÅ‚ywanego na `Result<T, E>`: JeÅ›li wartoÅ›Ä‡ to `None`, `None` zostanie zwrÃ³cone z funkcji w tym momencie. JeÅ›li wartoÅ›Ä‡ to `Some`, wartoÅ›Ä‡ wewnÄ…trz `Some` jest wartoÅ›ciÄ… wynikowÄ… wyraÅ¼enia, a funkcja kontynuuje. Listing 9-11 zawiera przykÅ‚ad funkcji, ktÃ³ra znajduje ostatni znak pierwszej linii w danym tekÅ›cie.\n\n<Listing number=\"9-11\" caption=\"UÅ¼ycie operatora `?` na wartoÅ›ci `Option<T>`\">\n\n```rust\nfn last_char_of_first_line(text: &str) -> Option<char> {\n    text.lines().next()?.chars().last()\n}\n# \n# fn main() {\n#     assert_eq!(\n#         last_char_of_first_line(\"Witaj, Å›wiecie\\nJak siÄ™ masz dzisiaj?\"),\n#         Some('e')\n#     );\n# \n#     assert_eq!(last_char_of_first_line(\"\"), None);\n#     assert_eq!(last_char_of_first_line(\"\\nhi\"), None);\n# }\n```\n\n</Listing>\n\nTa funkcja zwraca `Option<char>`, poniewaÅ¼ moÅ¼liwe jest, Å¼e tam jest znak, ale moÅ¼liwe jest rÃ³wnieÅ¼, Å¼e go nie ma. Ten kod pobiera argument wycinka ciÄ…gu `text` i wywoÅ‚uje na nim metodÄ™ `lines`, ktÃ³ra zwraca iterator po liniach w ciÄ…gu. PoniewaÅ¼ ta funkcja chce zbadaÄ‡ pierwszÄ… liniÄ™, wywoÅ‚uje `next` na iteratorze, aby uzyskaÄ‡ pierwszÄ… wartoÅ›Ä‡ z iteratora. JeÅ›li `text` jest pustym ciÄ…giem, to wywoÅ‚anie `next` zwrÃ³ci `None`, w ktÃ³rym to przypadku uÅ¼ywamy `?`, aby zatrzymaÄ‡ i zwrÃ³ciÄ‡ `None` z `last_char_of_first_line`. JeÅ›li `text` nie jest pustym ciÄ…giem, `next` zwrÃ³ci wartoÅ›Ä‡ `Some` zawierajÄ…cÄ… wycinek ciÄ…gu pierwszej linii w `text`.\n\nOperator `?` wyodrÄ™bnia wycinek ciÄ…gu znakÃ³w, a my moÅ¼emy wywoÅ‚aÄ‡ `chars` na tym wycinku ciÄ…gu znakÃ³w, aby uzyskaÄ‡ iterator jego znakÃ³w. Interesuje nas ostatni znak w tej pierwszej linii, wiÄ™c wywoÅ‚ujemy `last`, aby zwrÃ³ciÄ‡ ostatni element w iteratorze. Jest to `Option`, poniewaÅ¼ moÅ¼liwe jest, Å¼e pierwsza linia jest pustym ciÄ…giem; na przykÅ‚ad, jeÅ›li `text` zaczyna siÄ™ od pustej linii, ale ma znaki w innych liniach, jak w `\"\\nhi\"`. JednakÅ¼e, jeÅ›li istnieje ostatni znak w pierwszej linii, zostanie on zwrÃ³cony w wariancie `Some`. Operator `?` w Å›rodku daje nam zwiÄ™zÅ‚y sposÃ³b wyraÅ¼enia tej logiki, pozwalajÄ…c nam zaimplementowaÄ‡ funkcjÄ™ w jednej linii. GdybyÅ›my nie mogli uÅ¼yÄ‡ operatora `?` na `Option`, musielibyÅ›my zaimplementowaÄ‡ tÄ™ logikÄ™, uÅ¼ywajÄ…c wiÄ™kszej liczby wywoÅ‚aÅ„ metod lub wyraÅ¼enia `match`.\n\nZauwaÅ¼, Å¼e moÅ¼esz uÅ¼ywaÄ‡ operatora `?` na `Result` w funkcji, ktÃ³ra zwraca `Result`, i moÅ¼esz uÅ¼ywaÄ‡ operatora `?` na `Option` w funkcji, ktÃ³ra zwraca `Option`, ale nie moÅ¼esz ich mieszaÄ‡. Operator `?` nie przekonwertuje automatycznie `Result` na `Option` ani na odwrÃ³t; w tych przypadkach moÅ¼esz uÅ¼yÄ‡ metod, takich jak metoda `ok` na `Result` lub metoda `ok_or` na `Option`, aby wykonaÄ‡ konwersjÄ™ jawnie.\n\nDo tej pory wszystkie uÅ¼ywane przez nas funkcje `main` zwracaÅ‚y `()`. Funkcja `main` jest specjalna, poniewaÅ¼ jest punktem wejÅ›cia i wyjÅ›cia programu wykonywalnego, a istniejÄ… ograniczenia dotyczÄ…ce jej typu zwracanego, aby program dziaÅ‚aÅ‚ zgodnie z oczekiwaniami.\n\nNa szczÄ™Å›cie, `main` moÅ¼e rÃ³wnieÅ¼ zwrÃ³ciÄ‡ `Result<(), E>`. Listing 9-12 zawiera kod z Listing 9-10, ale zmieniliÅ›my typ zwracany `main` na `Result<(), Box<dyn Error>>` i dodaliÅ›my wartoÅ›Ä‡ zwracanÄ… `Ok(())` na koÅ„cu. Ten kod teraz siÄ™ skompiluje.\n\n<Listing number=\"9-12\" file-name=\"src/main.rs\" caption=\"Zmiana `main` na zwracanie `Result<(), E>` umoÅ¼liwia uÅ¼ycie operatora `?` na wartoÅ›ciach `Result`.\">\n\n```rust,ignore\nuse std::error::Error;\nuse std::fs::File;\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let greeting_file = File::open(\"hello.txt\")?;\n\n    Ok(())\n}\n```\n\n</Listing>\n\nTyp `Box<dyn Error>` to obiekt cechy, o ktÃ³rym bÄ™dziemy mÃ³wiÄ‡ w sekcji [â€UÅ¼ywanie obiektÃ³w cech do abstrakcji wspÃ³lnego zachowaniaâ€][trait-objects]<!-- ignore --> w Rozdziale 18. Na razie moÅ¼esz czytaÄ‡ `Box<dyn Error>` jako â€dowolny rodzaj bÅ‚Ä™duâ€. UÅ¼ycie `?` na wartoÅ›ci `Result` w funkcji `main` z typem bÅ‚Ä™du `Box<dyn Error>` jest dozwolone, poniewaÅ¼ pozwala to na wczesne zwrÃ³cenie dowolnej wartoÅ›ci `Err`. Mimo Å¼e ciaÅ‚o tej funkcji `main` zawsze bÄ™dzie zwracaÄ‡ bÅ‚Ä™dy typu `std::io::Error`, poprzez okreÅ›lenie `Box<dyn Error>`, ta sygnatura bÄ™dzie nadal poprawna, nawet jeÅ›li do ciaÅ‚a `main` zostanie dodany wiÄ™cej kodu, ktÃ³ry zwraca inne bÅ‚Ä™dy.\n\nKiedy funkcja `main` zwraca `Result<(), E>`, plik wykonywalny zakoÅ„czy dziaÅ‚anie z wartoÅ›ciÄ… `0`, jeÅ›li `main` zwrÃ³ci `Ok(())`, a zakoÅ„czy dziaÅ‚anie z wartoÅ›ciÄ… rÃ³Å¼nÄ… od zera, jeÅ›li `main` zwrÃ³ci wartoÅ›Ä‡ `Err`. Pliki wykonywalne napisane w C zwracajÄ… liczby caÅ‚kowite po zakoÅ„czeniu dziaÅ‚ania: programy, ktÃ³re zakoÅ„czyÅ‚y dziaÅ‚anie pomyÅ›lnie, zwracajÄ… liczbÄ™ caÅ‚kowitÄ… `0`, a programy, ktÃ³re zakoÅ„czyÅ‚y siÄ™ bÅ‚Ä™dem, zwracajÄ… jakÄ…Å› liczbÄ™ caÅ‚kowitÄ… innÄ… niÅ¼ `0`. Rust rÃ³wnieÅ¼ zwraca liczby caÅ‚kowite z plikÃ³w wykonywalnych, aby byÄ‡ zgodnym z tÄ… konwencjÄ….\n\nFunkcja `main` moÅ¼e zwracaÄ‡ dowolne typy implementujÄ…ce [cechÄ™ `std::process::Termination`][termination]<!-- ignore -->, ktÃ³ra zawiera funkcjÄ™ `report` zwracajÄ…cÄ… `ExitCode`. Zapoznaj siÄ™ z dokumentacjÄ… standardowej biblioteki, aby uzyskaÄ‡ wiÄ™cej informacji na temat implementacji cechy `Termination` dla wÅ‚asnych typÃ³w.\n\nTeraz, gdy omÃ³wiliÅ›my szczegÃ³Å‚y wywoÅ‚ywania `panic!` lub zwracania `Result`, wrÃ³Ä‡my do tematu, jak zdecydowaÄ‡, ktÃ³ry z nich jest odpowiedni do uÅ¼ycia w jakich przypadkach.\n\n[handle_failure]: ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-result\n[trait-objects]: ch18-02-trait-objects.html#using-trait-objects-to-abstract-over-shared-behavior\n[termination]: ../std/process/trait.Termination.html\n",
        "chapter_title": "BÅ‚Ä™dy odzyskiwalne za pomocÄ… Result"
    },
    {
        "file_path": "ch09-03-to-panic-or-not-to-panic.md",
        "content": "## PanikowaÄ‡ czy nie panikowaÄ‡!\n\nJak wiÄ™c zdecydowaÄ‡, kiedy naleÅ¼y wywoÅ‚aÄ‡ `panic!`, a kiedy zwrÃ³ciÄ‡ `Result`? Kiedy kod panikuje, nie ma sposobu na odzyskanie. MoÅ¼esz wywoÅ‚aÄ‡ `panic!` w kaÅ¼dej sytuacji bÅ‚Ä™du, niezaleÅ¼nie od tego, czy istnieje moÅ¼liwoÅ›Ä‡ odzyskania, czy nie, ale wtedy podejmujesz decyzjÄ™, Å¼e sytuacja jest nie do odzyskania w imieniu kodu wywoÅ‚ujÄ…cego. Kiedy zdecydujesz siÄ™ zwrÃ³ciÄ‡ wartoÅ›Ä‡ `Result`, dajesz kodowi wywoÅ‚ujÄ…cemu opcje. Kod wywoÅ‚ujÄ…cy moÅ¼e sprÃ³bowaÄ‡ odzyskaÄ‡ siÄ™ w sposÃ³b odpowiedni dla swojej sytuacji, lub moÅ¼e zdecydowaÄ‡, Å¼e wartoÅ›Ä‡ `Err` w tym przypadku jest nie do odzyskania, wiÄ™c moÅ¼e wywoÅ‚aÄ‡ `panic!` i zmieniÄ‡ TwÃ³j odzyskiwalny bÅ‚Ä…d w bÅ‚Ä…d nie do odzyskania. Dlatego zwracanie `Result` jest dobrym domyÅ›lnym wyborem, gdy definiujesz funkcjÄ™, ktÃ³ra moÅ¼e zawieÅ›Ä‡.\n\nW sytuacjach takich jak przykÅ‚ady, kod prototypowy i testy, bardziej odpowiednie jest pisanie kodu, ktÃ³ry panikuje zamiast zwracaÄ‡ `Result`. Zbadajmy dlaczego, a nastÄ™pnie omÃ³wmy sytuacje, w ktÃ³rych kompilator nie moÅ¼e stwierdziÄ‡, Å¼e awaria jest niemoÅ¼liwa, ale Ty jako czÅ‚owiek moÅ¼esz. RozdziaÅ‚ zakoÅ„czy siÄ™ ogÃ³lnymi wytycznymi dotyczÄ…cymi tego, jak zdecydowaÄ‡, czy panikowaÄ‡ w kodzie biblioteki.\n\n### PrzykÅ‚ady, kod prototypowy i testy\n\nKiedy piszesz przykÅ‚ad, aby zilustrowaÄ‡ jakÄ…Å› koncepcjÄ™, rÃ³wnieÅ¼ uwzglÄ™dnianie solidnego kodu do obsÅ‚ugi bÅ‚Ä™dÃ³w moÅ¼e uczyniÄ‡ przykÅ‚ad mniej jasnym. W przykÅ‚adach rozumie siÄ™, Å¼e wywoÅ‚anie metody, takiej jak `unwrap`, ktÃ³ra moÅ¼e spowodowaÄ‡ panikÄ™, ma byÄ‡ jedynie symulatorem sposobu, w jaki Twoja aplikacja obsÅ‚ugiwaÅ‚aby bÅ‚Ä™dy, co moÅ¼e siÄ™ rÃ³Å¼niÄ‡ w zaleÅ¼noÅ›ci od tego, co robi reszta Twojego kodu.\n\nPodobnie, metody `unwrap` i `expect` sÄ… bardzo przydatne, gdy prototypujesz i nie jesteÅ› jeszcze gotowy, aby zdecydowaÄ‡, jak obsÅ‚ugiwaÄ‡ bÅ‚Ä™dy. PozostawiajÄ… one jasne znaczniki w kodzie, na wypadek gdy bÄ™dziesz gotowy, aby uczyniÄ‡ swÃ³j program bardziej niezawodnym.\n\nJeÅ›li wywoÅ‚anie metody zakoÅ„czy siÄ™ niepowodzeniem w teÅ›cie, chciaÅ‚byÅ›, aby caÅ‚y test zakoÅ„czyÅ‚ siÄ™ niepowodzeniem, nawet jeÅ›li ta metoda nie jest testowanÄ… funkcjonalnoÅ›ciÄ…. PoniewaÅ¼ `panic!` oznacza, Å¼e test zakoÅ„czyÅ‚ siÄ™ niepowodzeniem, wywoÅ‚anie `unwrap` lub `expect` jest dokÅ‚adnie tym, co powinno siÄ™ staÄ‡.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"cases-in-which-you-have-more-information-than-the-compiler\"></a>\n\n### Kiedy masz wiÄ™cej informacji niÅ¼ kompilator\n\nOdpowiednie byÅ‚oby rÃ³wnieÅ¼ wywoÅ‚anie `expect`, gdy masz innÄ… logikÄ™, ktÃ³ra gwarantuje, Å¼e `Result` bÄ™dzie miaÅ‚ wartoÅ›Ä‡ `Ok`, ale logika nie jest czymÅ›, co kompilator rozumie. Nadal bÄ™dziesz mieÄ‡ wartoÅ›Ä‡ `Result`, ktÃ³rÄ… musisz obsÅ‚uÅ¼yÄ‡: kaÅ¼da operacja, ktÃ³rÄ… wywoÅ‚ujesz, nadal ma moÅ¼liwoÅ›Ä‡ ogÃ³lnego niepowodzenia, nawet jeÅ›li jest to logicznie niemoÅ¼liwe w Twojej konkretnej sytuacji. JeÅ›li moÅ¼esz upewniÄ‡ siÄ™, rÄ™cznie sprawdzajÄ…c kod, Å¼e nigdy nie bÄ™dziesz mieÄ‡ wariantu `Err`, jest caÅ‚kowicie dopuszczalne wywoÅ‚anie `expect` i udokumentowanie powodu, dla ktÃ³rego uwaÅ¼asz, Å¼e nigdy nie bÄ™dziesz mieÄ‡ wariantu `Err` w tekÅ›cie argumentu. Oto przykÅ‚ad:\n\n```rust\n# fn main() {\n    use std::net::IpAddr;\n\n    let home: IpAddr = \"127.0.0.1\"\n        .parse()\n        .expect(\"Zakodowany na staÅ‚e adres IP powinien byÄ‡ prawidÅ‚owy\");\n# }\n```\n\nTworzymy instancjÄ™ `IpAddr` poprzez parsowanie zakodowanego na staÅ‚e ciÄ…gu znakÃ³w. Widzimy, Å¼e `127.0.0.1` jest prawidÅ‚owym adresem IP, wiÄ™c w tym przypadku uÅ¼ycie `expect` jest dopuszczalne. Jednak posiadanie zakodowanego na staÅ‚e, prawidÅ‚owego ciÄ…gu znakÃ³w nie zmienia typu zwracanego przez metodÄ™ `parse`: nadal otrzymujemy wartoÅ›Ä‡ `Result`, a kompilator nadal bÄ™dzie nas zmuszaÅ‚ do obsÅ‚ugi `Result`, tak jakby wariant `Err` byÅ‚ moÅ¼liwy, poniewaÅ¼ kompilator nie jest wystarczajÄ…co sprytny, aby zobaczyÄ‡, Å¼e ten ciÄ…g znakÃ³w jest zawsze prawidÅ‚owym adresem IP. Gdyby ciÄ…g znakÃ³w adresu IP pochodziÅ‚ od uÅ¼ytkownika, a nie byÅ‚ zakodowany na staÅ‚e w programie i dlatego _miaÅ‚_ moÅ¼liwoÅ›Ä‡ awarii, z pewnoÅ›ciÄ… chcielibyÅ›my obsÅ‚uÅ¼yÄ‡ `Result` w bardziej niezawodny sposÃ³b.\nWspomnienie o zaÅ‚oÅ¼eniu, Å¼e ten adres IP jest zakodowany na staÅ‚e, skÅ‚oni nas do zmiany `expect` na lepszy kod obsÅ‚ugi bÅ‚Ä™dÃ³w, jeÅ›li w przyszÅ‚oÅ›ci bÄ™dziemy musieli uzyskaÄ‡ adres IP z innego ÅºrÃ³dÅ‚a.\n\n### Wytyczne dotyczÄ…ce obsÅ‚ugi bÅ‚Ä™dÃ³w\n\nZaleca siÄ™, aby kod panikowaÅ‚, gdy moÅ¼liwe jest, Å¼e kod moÅ¼e znaleÅºÄ‡ siÄ™ w zÅ‚ym stanie. W tym kontekÅ›cie _zÅ‚y stan_ to sytuacja, w ktÃ³rej zostaÅ‚o naruszone jakieÅ› zaÅ‚oÅ¼enie, gwarancja, kontrakt lub niezmiennik, na przykÅ‚ad, gdy do kodu przekazywane sÄ… nieprawidÅ‚owe wartoÅ›ci, wartoÅ›ci sprzeczne lub brakujÄ…ce wartoÅ›ci â€” plus jeden lub wiÄ™cej z poniÅ¼szych:\n\n- ZÅ‚y stan jest czymÅ› nieoczekiwanym, w przeciwieÅ„stwie do czegoÅ›, co prawdopodobnie bÄ™dzie siÄ™ sporadycznie zdarzaÄ‡, jak na przykÅ‚ad uÅ¼ytkownik wprowadzajÄ…cy dane w niewÅ‚aÅ›ciwym formacie.\n- TwÃ³j kod po tym punkcie musi polegaÄ‡ na tym, Å¼e nie jest w tym zÅ‚ym stanie, zamiast sprawdzaÄ‡ problem na kaÅ¼dym kroku.\n- Nie ma dobrego sposobu na zakodowanie tych informacji w uÅ¼ywanych typach. OmÃ³wimy przykÅ‚ad tego, co mamy na myÅ›li, w sekcji [â€Kodowanie stanÃ³w i zachowaÅ„ jako typyâ€][encoding]<!-- ignore --> w Rozdziale 18.\n\nJeÅ›li ktoÅ› wywoÅ‚a TwÃ³j kod i przekaÅ¼e wartoÅ›ci, ktÃ³re nie majÄ… sensu, najlepiej jest zwrÃ³ciÄ‡ bÅ‚Ä…d, jeÅ›li to moÅ¼liwe, aby uÅ¼ytkownik biblioteki mÃ³gÅ‚ zdecydowaÄ‡, co chce zrobiÄ‡ w takim przypadku. Jednak w przypadkach, gdy kontynuowanie mogÅ‚oby byÄ‡ niebezpieczne lub szkodliwe, najlepszym wyborem moÅ¼e byÄ‡ wywoÅ‚anie `panic!` i ostrzeÅ¼enie osoby uÅ¼ywajÄ…cej Twojej biblioteki o bÅ‚Ä™dzie w jej kodzie, aby mogÅ‚a go naprawiÄ‡ podczas developmentu. Podobnie, `panic!` jest czÄ™sto odpowiednie, jeÅ›li wywoÅ‚ujesz kod zewnÄ™trzny, ktÃ³ry jest poza TwojÄ… kontrolÄ… i zwraca nieprawidÅ‚owy stan, ktÃ³rego nie masz jak naprawiÄ‡.\n\nJednakÅ¼e, gdy awaria jest oczekiwana, bardziej odpowiednie jest zwrÃ³cenie `Result` niÅ¼ wywoÅ‚anie `panic!`. PrzykÅ‚ady obejmujÄ… parser, ktÃ³ry otrzymuje Åºle sformatowane dane, lub Å¼Ä…danie HTTP zwracajÄ…ce status wskazujÄ…cy, Å¼e osiÄ…gniÄ™to limit szybkoÅ›ci. W takich przypadkach zwrÃ³cenie `Result` wskazuje, Å¼e awaria jest oczekiwanÄ… moÅ¼liwoÅ›ciÄ…, ktÃ³rÄ… kod wywoÅ‚ujÄ…cy musi zdecydowaÄ‡, jak obsÅ‚uÅ¼yÄ‡.\n\nKiedy TwÃ³j kod wykonuje operacjÄ™, ktÃ³ra mogÅ‚aby naraziÄ‡ uÅ¼ytkownika na ryzyko, jeÅ›li zostanie wywoÅ‚ana z nieprawidÅ‚owymi wartoÅ›ciami, TwÃ³j kod powinien najpierw zweryfikowaÄ‡, czy wartoÅ›ci sÄ… prawidÅ‚owe, i wywoÅ‚aÄ‡ panikÄ™, jeÅ›li wartoÅ›ci sÄ… nieprawidÅ‚owe. Jest to gÅ‚Ã³wnie ze wzglÄ™dÃ³w bezpieczeÅ„stwa: prÃ³ba operowania na nieprawidÅ‚owych danych moÅ¼e naraziÄ‡ TwÃ³j kod na luki. To gÅ‚Ã³wny powÃ³d, dla ktÃ³rego standardowa biblioteka wywoÅ‚a `panic!`, jeÅ›li sprÃ³bujesz uzyskaÄ‡ dostÄ™p do pamiÄ™ci poza jej granicami: prÃ³ba dostÄ™pu do pamiÄ™ci, ktÃ³ra nie naleÅ¼y do bieÅ¼Ä…cej struktury danych, jest czÄ™stym problemem bezpieczeÅ„stwa. Funkcje czÄ™sto majÄ… _kontrakty_: ich zachowanie jest gwarantowane tylko wtedy, gdy dane wejÅ›ciowe speÅ‚niajÄ… okreÅ›lone wymagania. Panika, gdy kontrakt jest naruszony, ma sens, poniewaÅ¼ naruszenie kontraktu zawsze wskazuje na bÅ‚Ä…d po stronie wywoÅ‚ujÄ…cego, i nie jest to rodzaj bÅ‚Ä™du, ktÃ³ry kod wywoÅ‚ujÄ…cy powinien jawnie obsÅ‚ugiwaÄ‡. W rzeczywistoÅ›ci nie ma rozsÄ…dnego sposobu, aby kod wywoÅ‚ujÄ…cy siÄ™ odzyskaÅ‚; programiÅ›ci wywoÅ‚ujÄ…cy muszÄ… naprawiÄ‡ kod. Kontrakty funkcji, zwÅ‚aszcza gdy naruszenie spowoduje panikÄ™, powinny byÄ‡ wyjaÅ›nione w dokumentacji API funkcji.\n\nJednakÅ¼e, posiadanie wielu kontroli bÅ‚Ä™dÃ³w we wszystkich funkcjach byÅ‚oby rozbudowane i uciÄ…Å¼liwe. Na szczÄ™Å›cie, moÅ¼esz uÅ¼yÄ‡ systemu typÃ³w Rusta (a co za tym idzie, sprawdzania typÃ³w wykonywanego przez kompilator), aby wykonaÄ‡ wiele kontroli za Ciebie. JeÅ›li Twoja funkcja ma okreÅ›lony typ jako parametr, moÅ¼esz kontynuowaÄ‡ logikÄ™ kodu, wiedzÄ…c, Å¼e kompilator juÅ¼ zapewniÅ‚, Å¼e masz prawidÅ‚owÄ… wartoÅ›Ä‡. Na przykÅ‚ad, jeÅ›li masz typ zamiast `Option`, TwÃ³j program oczekuje _czegoÅ›_ zamiast _niczego_. TwÃ³j kod nie musi wtedy obsÅ‚ugiwaÄ‡ dwÃ³ch przypadkÃ³w dla wariantÃ³w `Some` i `None`: bÄ™dzie miaÅ‚ tylko jeden przypadek dla zdecydowanego posiadania wartoÅ›ci. Kod prÃ³bujÄ…cy przekazaÄ‡ nic do Twojej funkcji nawet siÄ™ nie skompiluje, wiÄ™c Twoja funkcja nie musi sprawdzaÄ‡ tego przypadku w czasie wykonywania. Innym przykÅ‚adem jest uÅ¼ycie typu liczby caÅ‚kowitej bez znaku, takiego jak `u32`, co zapewnia, Å¼e parametr nigdy nie jest ujemny.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"creating-custom-types-for-validation\"></a>\n\n### Niestandardowe typy do walidacji\n\nRozwiÅ„my ideÄ™ uÅ¼ywania systemu typÃ³w Rusta do zapewnienia, Å¼e mamy prawidÅ‚owÄ… wartoÅ›Ä‡, idÄ…c o krok dalej i przyjrzyjmy siÄ™ tworzeniu niestandardowego typu do walidacji. Przypomnij sobie grÄ™ zgadywanek z RozdziaÅ‚u 2, w ktÃ³rej nasz kod prosiÅ‚ uÅ¼ytkownika o odgadniÄ™cie liczby od 1 do 100. Nigdy nie walidowaliÅ›my, czy odgadniÄ™ta przez uÅ¼ytkownika liczba mieÅ›ciÅ‚a siÄ™ w tym zakresie, zanim porÃ³wnaliÅ›my jÄ… z naszÄ… tajnÄ… liczbÄ…; walidowaliÅ›my tylko, czy odgadniÄ™ta liczba byÅ‚a dodatnia. W tym przypadku konsekwencje nie byÅ‚y zbyt powaÅ¼ne: nasze komunikaty â€Za maÅ‚aâ€ lub â€Za duÅ¼aâ€ nadal byÅ‚yby poprawne. Ale przydatnym ulepszeniem byÅ‚oby pokierowanie uÅ¼ytkownika w stronÄ™ prawidÅ‚owych zgadywanek i zapewnienie innego zachowania, gdy uÅ¼ytkownik odgadnie liczbÄ™ spoza zakresu, niÅ¼ gdy uÅ¼ytkownik wpisze na przykÅ‚ad litery.\n\nJednym ze sposobÃ³w na to byÅ‚oby parsowanie odgadniÄ™tej liczby jako `i32` zamiast tylko `u32`, aby umoÅ¼liwiÄ‡ potencjalnie ujemne liczby, a nastÄ™pnie dodanie sprawdzenia, czy liczba mieÅ›ci siÄ™ w zakresie, tak jak poniÅ¼ej:\n\n<Listing file-name=\"src/main.rs\">\n\n```rust,ignore\n# use rand::Rng;\n# use std::cmp::Ordering;\n# use std::io;\n# \n# fn main() {\n#     println!(\"Odgadnij liczbÄ™!\");\n# \n#     let secret_number = rand::thread_rng().gen_range(1..=100);\n# \n    loop {\n        // --snip--\n\n#         println!(\"WprowadÅº swoje odgadniÄ™cie.\");\n# \n#         let mut guess = String::new();\n# \n#         io::stdin()\n#             .read_line(&mut guess)\n#             .expect(\"Nie udaÅ‚o siÄ™ odczytaÄ‡ linii\");\n# \n        let guess: i32 = match guess.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n\n        if guess < 1 || guess > 100 {\n            println!(\"Tajny numer bÄ™dzie miÄ™dzy 1 a 100.\");\n            continue;\n        }\n\n        match guess.cmp(&secret_number) {\n            // --snip--\n#             Ordering::Less => println!(\"Za maÅ‚a!\"),\n#             Ordering::Greater => println!(\"Za duÅ¼a!\"),\n#             Ordering::Equal => {\n#                 println!(\"WygraÅ‚eÅ›!\");\n#                 break;\n#             }\n#         }\n    }\n# }\n```\n\n</Listing>\n\nWyraÅ¼enie `if` sprawdza, czy nasza wartoÅ›Ä‡ jest poza zakresem, informuje uÅ¼ytkownika o problemie i wywoÅ‚uje `continue`, aby rozpoczÄ…Ä‡ kolejnÄ… iteracjÄ™ pÄ™tli i poprosiÄ‡ o kolejne odgadniÄ™cie. Po wyraÅ¼eniu `if` moÅ¼emy kontynuowaÄ‡ porÃ³wnania miÄ™dzy `guess` a tajnÄ… liczbÄ…, wiedzÄ…c, Å¼e `guess` znajduje siÄ™ miÄ™dzy 1 a 100.\n\nJednak to nie jest idealne rozwiÄ…zanie: gdyby absolutnie kluczowe byÅ‚o to, aby program operowaÅ‚ tylko na wartoÅ›ciach od 1 do 100, i miaÅ‚ wiele funkcji z tym wymogiem, posiadanie takiego sprawdzenia w kaÅ¼dej funkcji byÅ‚oby uciÄ…Å¼liwe (i mogÅ‚oby wpÅ‚ynÄ…Ä‡ na wydajnoÅ›Ä‡).\n\nZamiast tego, moÅ¼emy utworzyÄ‡ nowy typ w dedykowanym module i umieÅ›ciÄ‡ walidacje w funkcji, aby utworzyÄ‡ instancjÄ™ tego typu, zamiast powtarzaÄ‡ walidacje wszÄ™dzie. W ten sposÃ³b funkcje bÄ™dÄ… mogÅ‚y bezpiecznie uÅ¼ywaÄ‡ nowego typu w swoich sygnaturach i Å›miaÅ‚o uÅ¼ywaÄ‡ otrzymanych wartoÅ›ci. Listing 9-13 pokazuje jeden ze sposobÃ³w definiowania typu `Guess`, ktÃ³ry utworzy instancjÄ™ `Guess` tylko wtedy, gdy funkcja `new` otrzyma wartoÅ›Ä‡ z zakresu od 1 do 100.\n\n<Listing number=\"9-13\" caption=\"Typ `Guess`, ktÃ³ry bÄ™dzie dziaÅ‚aÄ‡ tylko z wartoÅ›ciami od 1 do 100\" file-name=\"src/guessing_game.rs\">\n\n```rust\npub struct Guess {\n    value: i32,\n}\n\nimpl Guess {\n    pub fn new(value: i32) -> Guess {\n        if value < 1 || value > 100 {\n            panic!(\"WartoÅ›Ä‡ odgadniÄ™cia musi byÄ‡ miÄ™dzy 1 a 100, otrzymano {value}.\");\n        }\n\n        Guess { value }\n    }\n\n    pub fn value(&self) -> i32 {\n        self.value\n    }\n}\n```\n\n</Listing>\n\nZauwaÅ¼, Å¼e ten kod w *src/guessing_game.rs* zaleÅ¼y od dodania deklaracji moduÅ‚u `mod guessing_game;` w *src/lib.rs*, ktÃ³rej tutaj nie pokazaliÅ›my. W pliku tego nowego moduÅ‚u definiujemy strukturÄ™ o nazwie `Guess`, ktÃ³ra ma pole o nazwie `value`, przechowujÄ…ce `i32`. Tutaj bÄ™dzie przechowywana liczba.\n\nNastÄ™pnie implementujemy funkcjÄ™ skojarzonÄ… o nazwie `new` dla `Guess`, ktÃ³ra tworzy instancje wartoÅ›ci `Guess`. Funkcja `new` jest zdefiniowana tak, aby miaÅ‚a jeden parametr o nazwie `value` typu `i32` i zwracaÅ‚a `Guess`. Kod w treÅ›ci funkcji `new` testuje `value`, aby upewniÄ‡ siÄ™, Å¼e mieÅ›ci siÄ™ ono w zakresie od 1 do 100. JeÅ›li `value` nie przejdzie tego testu, wywoÅ‚ujemy `panic!`, co ostrzeÅ¼e programistÄ™ piszÄ…cego kod wywoÅ‚ujÄ…cy, Å¼e ma bÅ‚Ä…d do naprawienia, poniewaÅ¼ utworzenie `Guess` z `value` spoza tego zakresu naruszyÅ‚oby kontrakt, na ktÃ³rym polega `Guess::new`. Warunki, w ktÃ³rych `Guess::new` moÅ¼e panikowaÄ‡, powinny byÄ‡ omÃ³wione w jego publicznie dostÄ™pnej dokumentacji API; konwencje dokumentacji wskazujÄ…ce na moÅ¼liwoÅ›Ä‡ paniki w dokumentacji API, ktÃ³rÄ… tworzysz, omÃ³wimy w rozdziale 14. JeÅ›li `value` przejdzie test, tworzymy nowy `Guess` z jego polem `value` ustawionym na parametr `value` i zwracamy `Guess`.\n\nNastÄ™pnie implementujemy metodÄ™ o nazwie `value`, ktÃ³ra poÅ¼ycza `self`, nie ma Å¼adnych innych parametrÃ³w i zwraca `i32`. Taki rodzaj metody jest czasami nazywany _getterem_, poniewaÅ¼ jego celem jest pobranie danych z pÃ³l i zwrÃ³cenie ich. Ta publiczna metoda jest niezbÄ™dna, poniewaÅ¼ pole `value` struktury `Guess` jest prywatne. WaÅ¼ne jest, aby pole `value` byÅ‚o prywatne, aby kod uÅ¼ywajÄ…cy struktury `Guess` nie mÃ³gÅ‚ bezpoÅ›rednio ustawiaÄ‡ `value`: kod spoza moduÅ‚u `guessing_game` _musi_ uÅ¼ywaÄ‡ funkcji `Guess::new` do tworzenia instancji `Guess`, zapewniajÄ…c w ten sposÃ³b, Å¼e nie ma moÅ¼liwoÅ›ci, aby `Guess` miaÅ‚o `value`, ktÃ³re nie zostaÅ‚o sprawdzone przez warunki w funkcji `Guess::new`.\n\nFunkcja, ktÃ³ra ma parametr lub zwraca tylko liczby z zakresu od 1 do 100, mogÅ‚aby nastÄ™pnie zadeklarowaÄ‡ w swojej sygnaturze, Å¼e przyjmuje lub zwraca `Guess` zamiast `i32` i nie musiaÅ‚aby wykonywaÄ‡ Å¼adnych dodatkowych sprawdzeÅ„ w swoim ciele.\n\n## Podsumowanie\n\nFunkcje obsÅ‚ugi bÅ‚Ä™dÃ³w w Rust sÄ… zaprojektowane tak, aby pomÃ³c Ci pisaÄ‡ bardziej niezawodny kod. Makro `panic!` sygnalizuje, Å¼e TwÃ³j program jest w stanie, ktÃ³rego nie jest w stanie obsÅ‚uÅ¼yÄ‡, i pozwala Ci nakazaÄ‡ procesowi zatrzymanie siÄ™, zamiast prÃ³bowaÄ‡ kontynuowaÄ‡ z nieprawidÅ‚owymi lub bÅ‚Ä™dnymi wartoÅ›ciami. Enum `Result` uÅ¼ywa systemu typÃ³w Rusta, aby wskazaÄ‡, Å¼e operacje mogÄ… zakoÅ„czyÄ‡ siÄ™ niepowodzeniem w sposÃ³b, ktÃ³ry TwÃ³j kod mÃ³gÅ‚by odzyskaÄ‡. MoÅ¼esz uÅ¼yÄ‡ `Result`, aby powiedzieÄ‡ kodowi, ktÃ³ry wywoÅ‚uje TwÃ³j kod, Å¼e musi on rÃ³wnieÅ¼ obsÅ‚uÅ¼yÄ‡ potencjalny sukces lub niepowodzenie. UÅ¼ycie `panic!` i `Result` w odpowiednich sytuacjach sprawi, Å¼e TwÃ³j kod bÄ™dzie bardziej niezawodny w obliczu nieuniknionych problemÃ³w.\n\nTeraz, gdy widziaÅ‚eÅ› przydatne sposoby, w jakie standardowa biblioteka uÅ¼ywa generykÃ³w z enumami `Option` i `Result`, porozmawiamy o tym, jak dziaÅ‚ajÄ… generyki i jak moÅ¼esz ich uÅ¼ywaÄ‡ w swoim kodzie.\n\n[encoding]: ch18-03-oo-design-patterns.html#encoding-states-and-behavior-as-types\n",
        "chapter_title": "PanikowaÄ‡ czy nie panikowaÄ‡!"
    },
    {
        "file_path": "ch10-00-generics.md",
        "content": "# Typy generyczne, cechy i czasy Å¼ycia\n\nKaÅ¼dy jÄ™zyk programowania posiada narzÄ™dzia do efektywnego zarzÄ…dzania powtarzalnoÅ›ciÄ… koncepcji. W Rust, jednym z takich narzÄ™dzi sÄ… _generyki_: abstrakcyjne zamienniki dla konkretnych typÃ³w lub innych wÅ‚aÅ›ciwoÅ›ci. MoÅ¼emy wyraziÄ‡ zachowanie generykÃ³w lub ich relacje z innymi generykami, nie wiedzÄ…c, co znajdzie siÄ™ na ich miejscu podczas kompilacji i uruchamiania kodu.\n\nFunkcje mogÄ… przyjmowaÄ‡ parametry jakiegoÅ› typu generycznego, zamiast konkretnego typu, takiego jak `i32` lub `String`, w ten sam sposÃ³b, w jaki przyjmujÄ… parametry o nieznanych wartoÅ›ciach, aby uruchamiaÄ‡ ten sam kod na wielu konkretnych wartoÅ›ciach. W rzeczywistoÅ›ci, juÅ¼ uÅ¼ywaliÅ›my generykÃ³w w Rozdziale 6 z `Option<T>`, w Rozdziale 8 z `Vec<T>` i `HashMap<K, V>`, oraz w Rozdziale 9 z `Result<T, E>`. W tym rozdziale poznasz, jak definiowaÄ‡ wÅ‚asne typy, funkcje i metody za pomocÄ… generykÃ³w!\n\nNajpierw przypomnimy, jak wyodrÄ™bniÄ‡ funkcjÄ™, aby zmniejszyÄ‡ duplikacjÄ™ kodu. NastÄ™pnie uÅ¼yjemy tej samej techniki, aby stworzyÄ‡ funkcjÄ™ generycznÄ… z dwÃ³ch funkcji, ktÃ³re rÃ³Å¼niÄ… siÄ™ tylko typami swoich parametrÃ³w. WyjaÅ›nimy rÃ³wnieÅ¼, jak uÅ¼ywaÄ‡ typÃ³w generycznych w definicjach struktur i wyliczeÅ„.\n\nNastÄ™pnie dowiesz siÄ™, jak uÅ¼ywaÄ‡ cech (traits) do definiowania zachowania w sposÃ³b generyczny. MoÅ¼esz Å‚Ä…czyÄ‡ cechy z typami generycznymi, aby ograniczyÄ‡ typ generyczny do akceptowania tylko tych typÃ³w, ktÃ³re majÄ… okreÅ›lone zachowanie, w przeciwieÅ„stwie do dowolnego typu.\n\nNa koniec omÃ³wimy _czasy Å¼ycia_: odmianÄ™ generykÃ³w, ktÃ³ra dostarcza kompilatorowi informacji o tym, jak referencje odnoszÄ… siÄ™ do siebie. Czasy Å¼ycia pozwalajÄ… nam dostarczyÄ‡ kompilatorowi wystarczajÄ…cych informacji o poÅ¼yczonych wartoÅ›ciach, aby mÃ³gÅ‚ on zapewniÄ‡, Å¼e referencje bÄ™dÄ… waÅ¼ne w wiÄ™kszej liczbie sytuacji, niÅ¼ byÅ‚oby to moÅ¼liwe bez naszej pomocy.\n\n## Usuwanie duplikacji poprzez wyodrÄ™bnianie funkcji\n\nGeneryki pozwalajÄ… nam zastÄ™powaÄ‡ konkretne typy przez placeholder, ktÃ³ry reprezentuje wiele typÃ³w, aby usunÄ…Ä‡ duplikacjÄ™ kodu. Zanim zagÅ‚Ä™bimy siÄ™ w skÅ‚adniÄ™ generykÃ³w, najpierw przyjrzyjmy siÄ™, jak usunÄ…Ä‡ duplikacjÄ™ w sposÃ³b, ktÃ³ry nie obejmuje typÃ³w generycznych, poprzez wyodrÄ™bnienie funkcji, ktÃ³ra zastÄ™puje konkretne wartoÅ›ci przez placeholder reprezentujÄ…cy wiele wartoÅ›ci. NastÄ™pnie zastosujemy tÄ™ samÄ… technikÄ™ do wyodrÄ™bnienia funkcji generycznej! PatrzÄ…c na to, jak rozpoznaÄ‡ zduplikowany kod, ktÃ³ry moÅ¼na wyodrÄ™bniÄ‡ do funkcji, zaczniesz rozpoznawaÄ‡ zduplikowany kod, ktÃ³ry moÅ¼e uÅ¼ywaÄ‡ generykÃ³w.\n\nZaczniemy od krÃ³tkiego programu w Listing 10-1, ktÃ³ry znajduje najwiÄ™kszÄ… liczbÄ™ na liÅ›cie.\n\n<Listing number=\"10-1\" file-name=\"src/main.rs\" caption=\"Znajdowanie najwiÄ™kszej liczby na liÅ›cie liczb\">\n\n```rust\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let mut largest = &number_list[0];\n\n    for number in &number_list {\n        if number > largest {\n            largest = number;\n        }\n    }\n\n    println!(\"NajwiÄ™ksza liczba to {largest}\");\n#     assert_eq!(*largest, 100);\n}\n```\n\n</Listing>\n\nPrzechowujemy listÄ™ liczb caÅ‚kowitych w zmiennej `number_list` i umieszczamy referencjÄ™ do pierwszej liczby na liÅ›cie w zmiennej o nazwie `largest`. NastÄ™pnie iterujemy po wszystkich liczbach na liÅ›cie, a jeÅ›li bieÅ¼Ä…ca liczba jest wiÄ™ksza niÅ¼ liczba przechowywana w `largest`, zastÄ™pujemy referencjÄ™ w tej zmiennej. JednakÅ¼e, jeÅ›li bieÅ¼Ä…ca liczba jest mniejsza lub rÃ³wna najwiÄ™kszej liczbie widzianej do tej pory, zmienna nie zmienia siÄ™, a kod przechodzi do nastÄ™pnej liczby na liÅ›cie. Po rozwaÅ¼eniu wszystkich liczb na liÅ›cie, `largest` powinien odnosiÄ‡ siÄ™ do najwiÄ™kszej liczby, ktÃ³ra w tym przypadku wynosi 100.\n\nTeraz postawiono nam zadanie znalezienia najwiÄ™kszej liczby na dwÃ³ch rÃ³Å¼nych listach liczb. Aby to zrobiÄ‡, moÅ¼emy zdecydowaÄ‡ siÄ™ na zduplikowanie kodu z Listing 10-1 i uÅ¼ycie tej samej logiki w dwÃ³ch rÃ³Å¼nych miejscach w programie, jak pokazano w Listing 10-2.\n\n<Listing number=\"10-2\" file-name=\"src/main.rs\" caption=\"Kod do znajdowania najwiÄ™kszej liczby na *dwÃ³ch* listach liczb\">\n\n```rust\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let mut largest = &number_list[0];\n\n    for number in &number_list {\n        if number > largest {\n            largest = number;\n        }\n    }\n\n    println!(\"NajwiÄ™ksza liczba to {largest}\");\n\n    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];\n\n    let mut largest = &number_list[0];\n\n    for number in &number_list {\n        if number > largest {\n            largest = number;\n        }\n    }\n\n    println!(\"NajwiÄ™ksza liczba to {largest}\");\n}\n```\n\n</Listing>\n\nChociaÅ¼ ten kod dziaÅ‚a, duplikowanie kodu jest uciÄ…Å¼liwe i podatne na bÅ‚Ä™dy. Musimy rÃ³wnieÅ¼ pamiÄ™taÄ‡ o aktualizowaniu kodu w wielu miejscach, gdy chcemy go zmieniÄ‡.\n\nAby wyeliminowaÄ‡ tÄ™ duplikacjÄ™, stworzymy abstrakcjÄ™, definiujÄ…c funkcjÄ™, ktÃ³ra operuje na dowolnej liÅ›cie liczb caÅ‚kowitych przekazanej jako parametr. To rozwiÄ…zanie czyni nasz kod jaÅ›niejszym i pozwala nam abstrakcyjnie wyraziÄ‡ koncepcjÄ™ znajdowania najwiÄ™kszej liczby na liÅ›cie.\n\nW Listing 10-3 wyodrÄ™bniamy kod, ktÃ³ry znajduje najwiÄ™kszÄ… liczbÄ™, do funkcji o nazwie `largest`. NastÄ™pnie wywoÅ‚ujemy funkcjÄ™, aby znaleÅºÄ‡ najwiÄ™kszÄ… liczbÄ™ na dwÃ³ch listach z Listing 10-2. MoglibyÅ›my rÃ³wnieÅ¼ uÅ¼yÄ‡ tej funkcji na dowolnej innej liÅ›cie wartoÅ›ci `i32`, ktÃ³re moglibyÅ›my mieÄ‡ w przyszÅ‚oÅ›ci.\n\n<Listing number=\"10-3\" file-name=\"src/main.rs\" caption=\"Zabstrahowany kod do znajdowania najwiÄ™kszej liczby na dwÃ³ch listach\">\n\n```rust\nfn largest(list: &[i32]) -> &i32 {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item > largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest(&number_list);\n    println!(\"NajwiÄ™ksza liczba to {result}\");\n#     assert_eq!(*result, 100);\n\n    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];\n\n    let result = largest(&number_list);\n    println!(\"NajwiÄ™ksza liczba to {result}\");\n#     assert_eq!(*result, 6000);\n}\n```\n\n</Listing>\n\nFunkcja `largest` ma parametr `list`, ktÃ³ry reprezentuje dowolny konkretny wycinek wartoÅ›ci `i32`, ktÃ³ry moÅ¼emy przekazaÄ‡ do funkcji. W rezultacie, gdy wywoÅ‚ujemy funkcjÄ™, kod dziaÅ‚a na konkretnych wartoÅ›ciach, ktÃ³re przekazujemy.\n\nPodsumowujÄ…c, oto kroki, ktÃ³re podjÄ™liÅ›my, aby zmieniÄ‡ kod z Listing 10-2 na Listing 10-3:\n\n1. Zidentyfikuj zduplikowany kod.\n1. WyodrÄ™bnij zduplikowany kod do ciaÅ‚a funkcji i okreÅ›l wejÅ›cia i wartoÅ›ci zwracane tego kodu w sygnaturze funkcji.\n1. Zaktualizuj dwa wystÄ…pienia zduplikowanego kodu, aby zamiast tego wywoÅ‚ywaÅ‚y funkcjÄ™.\n\nNastÄ™pnie uÅ¼yjemy tych samych krokÃ³w z generykami, aby zmniejszyÄ‡ duplikacjÄ™ kodu. W ten sam sposÃ³b, w jaki ciaÅ‚o funkcji moÅ¼e dziaÅ‚aÄ‡ na abstrakcyjnej `liÅ›cie` zamiast na konkretnych wartoÅ›ciach, generyki pozwalajÄ… kodowi dziaÅ‚aÄ‡ na abstrakcyjnych typach.\n\nNa przykÅ‚ad, powiedzmy, Å¼e mieliÅ›my dwie funkcje: jednÄ…, ktÃ³ra znajduje najwiÄ™kszy element w wycinku wartoÅ›ci `i32`, i drugÄ…, ktÃ³ra znajduje najwiÄ™kszy element w wycinku wartoÅ›ci `char`. Jak wyeliminowalibyÅ›my tÄ™ duplikacjÄ™? Dowiedzmy siÄ™!\n",
        "chapter_title": "Typy generyczne, cechy i czasy Å¼ycia"
    },
    {
        "file_path": "ch10-01-syntax.md",
        "content": "## Generyczne typy danych\n\nUÅ¼ywamy generykÃ³w do tworzenia definicji dla elementÃ³w, takich jak sygnatury funkcji lub struktury, ktÃ³re moÅ¼emy nastÄ™pnie wykorzystaÄ‡ z wieloma rÃ³Å¼nymi konkretnymi typami danych. Najpierw przyjrzymy siÄ™, jak definiowaÄ‡ funkcje, struktury, wyliczenia i metody za pomocÄ… generykÃ³w. NastÄ™pnie omÃ³wimy, jak generyki wpÅ‚ywajÄ… na wydajnoÅ›Ä‡ kodu.\n\n### W definicjach funkcji\n\nPodczas definiowania funkcji uÅ¼ywajÄ…cej generykÃ³w, umieszczamy generyki w sygnaturze funkcji, tam gdzie zazwyczaj okreÅ›lamy typy danych parametrÃ³w i wartoÅ›Ä‡ zwracanÄ…. DziÄ™ki temu nasz kod jest bardziej elastyczny i zapewnia wiÄ™kszÄ… funkcjonalnoÅ›Ä‡ wywoÅ‚ujÄ…cym naszÄ… funkcjÄ™, jednoczeÅ›nie zapobiegajÄ…c duplikacji kodu.\n\nKontynuujÄ…c naszÄ… funkcjÄ™ `largest`, Listing 10-4 pokazuje dwie funkcje, ktÃ³re obie znajdujÄ… najwiÄ™kszÄ… wartoÅ›Ä‡ w wycinku. NastÄ™pnie poÅ‚Ä…czymy je w jednÄ… funkcjÄ™, ktÃ³ra uÅ¼ywa generykÃ³w.\n\n<Listing number=\"10-4\" file-name=\"src/main.rs\" caption=\"Dwie funkcje, ktÃ³re rÃ³Å¼niÄ… siÄ™ tylko nazwami i typami w sygnaturach\">\n\n```rust\nfn largest_i32(list: &[i32]) -> &i32 {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item > largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn largest_char(list: &[char]) -> &char {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item > largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest_i32(&number_list);\n    println!(\"NajwiÄ™ksza liczba to {result}\");\n#     assert_eq!(*result, 100);\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n\n    let result = largest_char(&char_list);\n    println!(\"NajwiÄ™kszy znak to {result}\");\n#     assert_eq!(*result, 'y');\n}\n```\n\n</Listing>\n\nFunkcja `largest_i32` jest tÄ…, ktÃ³rÄ… wyodrÄ™bniliÅ›my w Listing 10-3, ktÃ³ra znajduje najwiÄ™kszÄ… `i32` w wycinku. Funkcja `largest_char` znajduje najwiÄ™kszy `char` w wycinku. CiaÅ‚a funkcji majÄ… ten sam kod, wiÄ™c wyeliminujmy duplikacjÄ™, wprowadzajÄ…c generyczny parametr typu w jednej funkcji.\n\nAby sparametryzowaÄ‡ typy w nowej pojedynczej funkcji, musimy nadaÄ‡ nazwÄ™ parametrowi typu, tak jak to robimy dla parametrÃ³w wartoÅ›ci funkcji. MoÅ¼esz uÅ¼yÄ‡ dowolnego identyfikatora jako nazwy parametru typu. My jednak uÅ¼yjemy `T`, poniewaÅ¼, zgodnie z konwencjÄ…, nazwy parametrÃ³w typu w Rust sÄ… krÃ³tkie, czÄ™sto skÅ‚adajÄ… siÄ™ tylko z jednej litery, a konwencja nazewnictwa typÃ³w w Rust to UpperCamelCase. `T` (skrÃ³t od _type_) jest domyÅ›lnym wyborem wiÄ™kszoÅ›ci programistÃ³w Rusta.\n\nKiedy uÅ¼ywamy parametru w ciele funkcji, musimy zadeklarowaÄ‡ nazwÄ™ parametru w sygnaturze, aby kompilator wiedziaÅ‚, co ta nazwa oznacza. Podobnie, kiedy uÅ¼ywamy nazwy parametru typu w sygnaturze funkcji, musimy zadeklarowaÄ‡ nazwÄ™ parametru typu, zanim jej uÅ¼yjemy. Aby zdefiniowaÄ‡ generycznÄ… funkcjÄ™ `largest`, umieszczamy deklaracje nazw typÃ³w w nawiasach ostrych, `<>`, miÄ™dzy nazwÄ… funkcji a listÄ… parametrÃ³w, tak:\n\n```rust,ignore\nfn largest<T>(list: &[T]) -> &T {\n```\n\nTÄ™ definicjÄ™ czytamy jako â€funkcja `largest` jest generyczna wzglÄ™dem jakiegoÅ› typu `T`â€. Ta funkcja ma jeden parametr o nazwie `list`, ktÃ³ry jest wycinkiem wartoÅ›ci typu `T`. Funkcja `largest` zwrÃ³ci referencjÄ™ do wartoÅ›ci tego samego typu `T`.\n\nListing 10-5 pokazuje poÅ‚Ä…czonÄ… definicjÄ™ funkcji `largest` uÅ¼ywajÄ…cÄ… generycznego typu danych w swojej sygnaturze. Listing pokazuje rÃ³wnieÅ¼, jak moÅ¼emy wywoÅ‚aÄ‡ funkcjÄ™ z wycinkiem wartoÅ›ci `i32` lub `char`. ZauwaÅ¼, Å¼e ten kod jeszcze siÄ™ nie skompiluje.\n\n<Listing number=\"10-5\" file-name=\"src/main.rs\" caption=\"Funkcja `largest` uÅ¼ywajÄ…ca generycznych parametrÃ³w typu; jeszcze siÄ™ nie kompiluje\">\n\n```rust,ignore,does_not_compile\nfn largest<T>(list: &[T]) -> &T {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item > largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest(&number_list);\n    println!(\"NajwiÄ™ksza liczba to {result}\");\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n\n    let result = largest(&char_list);\n    println!(\"NajwiÄ™kszy znak to {result}\");\n}\n```\n\n</Listing>\n\nJeÅ›li skompilujemy ten kod teraz, otrzymamy nastÄ™pujÄ…cy bÅ‚Ä…d:\n\n```console\n$ cargo run\n   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0369]: binary operation `>` cannot be applied to type `&T`\n --> src/main.rs:5:17\n  |\n5 |         if item > largest {\n  |            ---- ^ ------- &T\n  |            |\n  |            &T\n  |\nhelp: consider restricting type parameter `T` with trait `PartialOrd`\n  |\n1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> &T {\n  |             ++++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `chapter10` (bin \"chapter10\") due to 1 previous error\n```\n\nTekst pomocy wspomina o `std::cmp::PartialOrd`, ktÃ³ry jest cechÄ… (trait), a o cechach bÄ™dziemy mÃ³wiÄ‡ w nastÄ™pnej sekcji. Na razie wiedz, Å¼e ten bÅ‚Ä…d oznacza, Å¼e ciaÅ‚o funkcji `largest` nie zadziaÅ‚a dla wszystkich moÅ¼liwych typÃ³w, ktÃ³rymi mogÅ‚oby byÄ‡ `T`. PoniewaÅ¼ chcemy porÃ³wnywaÄ‡ wartoÅ›ci typu `T` w ciele funkcji, moÅ¼emy uÅ¼ywaÄ‡ tylko typÃ³w, ktÃ³rych wartoÅ›ci moÅ¼na uporzÄ…dkowaÄ‡. Aby umoÅ¼liwiÄ‡ porÃ³wnania, standardowa biblioteka posiada cechÄ™ `std::cmp::PartialOrd`, ktÃ³rÄ… moÅ¼na zaimplementowaÄ‡ na typach (wiÄ™cej na temat tej cechy znajdziesz w Dodatku C). Aby naprawiÄ‡ Listing 10-5, moÅ¼emy zastosowaÄ‡ siÄ™ do sugestii tekstu pomocy i ograniczyÄ‡ typy dozwolone dla `T` tylko do tych, ktÃ³re implementujÄ… `PartialOrd`. Listing nastÄ™pnie siÄ™ skompiluje, poniewaÅ¼ standardowa biblioteka implementuje `PartialOrd` zarÃ³wno dla `i32`, jak i `char`.\n\n### W definicjach struktur\n\nMoÅ¼emy rÃ³wnieÅ¼ definiowaÄ‡ struktury, aby uÅ¼ywaÅ‚y generycznego parametru typu w jednym lub wiÄ™cej polach, uÅ¼ywajÄ…c skÅ‚adni `<>`. Listing 10-6 definiuje strukturÄ™ `Point<T>` do przechowywania wartoÅ›ci wspÃ³Å‚rzÄ™dnych `x` i `y` dowolnego typu.\n\n<Listing number=\"10-6\" file-name=\"src/main.rs\" caption=\"Struktura `Point<T>`, ktÃ³ra przechowuje wartoÅ›ci `x` i `y` typu `T`\">\n\n```rust\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nfn main() {\n    let integer = Point { x: 5, y: 10 };\n    let float = Point { x: 1.0, y: 4.0 };\n}\n```\n\n</Listing>\n\nSkÅ‚adnia uÅ¼ywania generykÃ³w w definicjach struktur jest podobna do tej uÅ¼ywanej w definicjach funkcji. Najpierw deklarujemy nazwÄ™ parametru typu w nawiasach ostrych tuÅ¼ po nazwie struktury. NastÄ™pnie uÅ¼ywamy typu generycznego w definicji struktury tam, gdzie w przeciwnym razie okreÅ›lilibyÅ›my konkretne typy danych.\n\nZauwaÅ¼, Å¼e poniewaÅ¼ uÅ¼yliÅ›my tylko jednego typu generycznego do zdefiniowania `Point<T>`, ta definicja mÃ³wi, Å¼e struktura `Point<T>` jest generyczna wzglÄ™dem jakiegoÅ› typu `T`, a pola `x` i `y` sÄ… _obydwa_ tego samego typu, niezaleÅ¼nie od tego, jaki to typ. JeÅ›li stworzymy instancjÄ™ `Point<T>`, ktÃ³ra ma wartoÅ›ci rÃ³Å¼nych typÃ³w, jak w Listing 10-7, nasz kod siÄ™ nie skompiluje.\n\n<Listing number=\"10-7\" file-name=\"src/main.rs\" caption=\"Pola `x` i `y` muszÄ… byÄ‡ tego samego typu, poniewaÅ¼ oba majÄ… ten sam generyczny typ danych `T`.\">\n\n```rust,ignore,does_not_compile\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nfn main() {\n    let wont_work = Point { x: 5, y: 4.0 };\n}\n```\n\n</Listing>\n\nW tym przykÅ‚adzie, gdy przypisujemy wartoÅ›Ä‡ caÅ‚kowitÄ… `5` do `x`, informujemy kompilator, Å¼e generyczny typ `T` bÄ™dzie liczbÄ… caÅ‚kowitÄ… dla tej instancji `Point<T>`. NastÄ™pnie, gdy okreÅ›lamy `4.0` dla `y`, ktÃ³re zdefiniowaliÅ›my jako majÄ…ce ten sam typ co `x`, otrzymamy bÅ‚Ä…d niezgodnoÅ›ci typÃ³w, taki jak ten:\n\n```console\n$ cargo run\n   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0308]: mismatched types\n --> src/main.rs:7:38\n  |\n7 |     let wont_work = Point { x: 5, y: 4.0 };\n  |                                      ^^^ expected integer, found floating-point number\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `chapter10` (bin \"chapter10\") due to 1 previous error\n```\n\nAby zdefiniowaÄ‡ strukturÄ™ `Point`, w ktÃ³rej `x` i `y` sÄ… obydwa generyczne, ale mogÄ… mieÄ‡ rÃ³Å¼ne typy, moÅ¼emy uÅ¼yÄ‡ wielu generycznych parametrÃ³w typu. Na przykÅ‚ad, w Listing 10-8 zmieniamy definicjÄ™ `Point` tak, aby byÅ‚a generyczna wzglÄ™dem typÃ³w `T` i `U`, gdzie `x` jest typu `T`, a `y` jest typu `U`.\n\n<Listing number=\"10-8\" file-name=\"src/main.rs\" caption=\"`Point<T, U>` generyczny wzglÄ™dem dwÃ³ch typÃ³w, tak aby `x` i `y` mogÅ‚y byÄ‡ wartoÅ›ciami rÃ³Å¼nych typÃ³w\">\n\n```rust\nstruct Point<T, U> {\n    x: T,\n    y: U,\n}\n\nfn main() {\n    let both_integer = Point { x: 5, y: 10 };\n    let both_float = Point { x: 1.0, y: 4.0 };\n    let integer_and_float = Point { x: 5, y: 4.0 };\n}\n```\n\n</Listing>\n\nTeraz wszystkie pokazane instancje `Point` sÄ… dozwolone! MoÅ¼esz uÅ¼ywaÄ‡ tylu generycznych parametrÃ³w typu w definicji, ile chcesz, ale uÅ¼ywanie wiÄ™cej niÅ¼ kilku utrudnia czytanie kodu. JeÅ›li okaÅ¼e siÄ™, Å¼e potrzebujesz wielu typÃ³w generycznych w swoim kodzie, moÅ¼e to wskazywaÄ‡ na potrzebÄ™ restrukturyzacji kodu na mniejsze czÄ™Å›ci.\n\n### W definicjach wyliczeÅ„\n\nPodobnie jak w przypadku struktur, moÅ¼emy definiowaÄ‡ wyliczenia, aby zawieraÅ‚y generyczne typy danych w swoich wariantach. Przyjrzyjmy siÄ™ ponownie wyliczeniu `Option<T>` dostarczanemu przez standardowÄ… bibliotekÄ™, ktÃ³rego uÅ¼yliÅ›my w Rozdziale 6:\n\n```rust\nenum Option<T> {\n    Some(T),\n    None,\n}\n```\n\nTa definicja powinna byÄ‡ teraz bardziej zrozumiaÅ‚a. Jak widaÄ‡, enum `Option<T>` jest generyczny wzglÄ™dem typu `T` i ma dwa warianty: `Some`, ktÃ³ry przechowuje jednÄ… wartoÅ›Ä‡ typu `T`, oraz wariant `None`, ktÃ³ry nie przechowuje Å¼adnej wartoÅ›ci. UÅ¼ywajÄ…c enum `Option<T>`, moÅ¼emy wyraziÄ‡ abstrakcyjnÄ… koncepcjÄ™ wartoÅ›ci opcjonalnej, a poniewaÅ¼ `Option<T>` jest generyczny, moÅ¼emy uÅ¼ywaÄ‡ tej abstrakcji niezaleÅ¼nie od typu wartoÅ›ci opcjonalnej.\n\nWyliczenia mogÄ… rÃ³wnieÅ¼ uÅ¼ywaÄ‡ wielu typÃ³w generycznych. Definicja wyliczenia `Result`, ktÃ³rego uÅ¼yliÅ›my w Rozdziale 9, jest jednym z przykÅ‚adÃ³w:\n\n```rust\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```\n\nEnum `Result` jest generyczny wzglÄ™dem dwÃ³ch typÃ³w, `T` i `E`, i ma dwa warianty: `Ok`, ktÃ³ry przechowuje wartoÅ›Ä‡ typu `T`, oraz `Err`, ktÃ³ry przechowuje wartoÅ›Ä‡ typu `E`. Ta definicja sprawia, Å¼e wygodnie jest uÅ¼ywaÄ‡ enum `Result` wszÄ™dzie tam, gdzie mamy operacjÄ™, ktÃ³ra moÅ¼e zakoÅ„czyÄ‡ siÄ™ sukcesem (zwrÃ³ciÄ‡ wartoÅ›Ä‡ jakiegoÅ› typu `T`) lub niepowodzeniem (zwrÃ³ciÄ‡ bÅ‚Ä…d jakiegoÅ› typu `E`). W rzeczywistoÅ›ci, tego wÅ‚aÅ›nie uÅ¼yliÅ›my do otwarcia pliku w Listing 9-3, gdzie `T` zostaÅ‚o wypeÅ‚nione typem `std::fs::File`, gdy plik zostaÅ‚ pomyÅ›lnie otwarty, a `E` zostaÅ‚o wypeÅ‚nione typem `std::io::Error`, gdy wystÄ…piÅ‚y problemy z otwarciem pliku.\n\nKiedy rozpoznajesz sytuacje w swoim kodzie z wieloma definicjami struktur lub wyliczeÅ„, ktÃ³re rÃ³Å¼niÄ… siÄ™ tylko typami przechowywanych wartoÅ›ci, moÅ¼esz uniknÄ…Ä‡ duplikacji, uÅ¼ywajÄ…c zamiast tego typÃ³w generycznych.\n\n### W definicjach metod\n\nMoÅ¼emy implementowaÄ‡ metody na strukturach i wyliczeniach (jak to zrobiliÅ›my w Rozdziale 5) i uÅ¼ywaÄ‡ generycznych typÃ³w rÃ³wnieÅ¼ w ich definicjach. Listing 10-9 pokazuje strukturÄ™ `Point<T>`, ktÃ³rÄ… zdefiniowaliÅ›my w Listing 10-6 z zaimplementowanÄ… na niej metodÄ… o nazwie `x`.\n\n<Listing number=\"10-9\" file-name=\"src/main.rs\" caption=\"Implementacja metody o nazwie `x` na strukturze `Point<T>`, ktÃ³ra zwrÃ³ci referencjÄ™ do pola `x` typu `T`\">\n\n```rust\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Point<T> {\n    fn x(&self) -> &T {\n        &self.x\n    }\n}\n\nfn main() {\n    let p = Point { x: 5, y: 10 };\n\n    println!(\"p.x = {}\", p.x());\n}\n```\n\n</Listing>\n\nTutaj zdefiniowaliÅ›my metodÄ™ o nazwie `x` na `Point<T>`, ktÃ³ra zwraca referencjÄ™ do danych w polu `x`.\n\nZauwaÅ¼, Å¼e musimy zadeklarowaÄ‡ `T` tuÅ¼ po `impl`, abyÅ›my mogli uÅ¼yÄ‡ `T` do okreÅ›lenia, Å¼e implementujemy metody na typie `Point<T>`. DeklarujÄ…c `T` jako typ generyczny po `impl`, Rust moÅ¼e zidentyfikowaÄ‡, Å¼e typ w nawiasach ostrych w `Point` jest typem generycznym, a nie typem konkretnym. MoglibyÅ›my wybraÄ‡ innÄ… nazwÄ™ dla tego parametru generycznego niÅ¼ parametr generyczny zadeklarowany w definicji struktury, ale uÅ¼ywanie tej samej nazwy jest konwencjonalne. JeÅ›li napiszesz metodÄ™ w `impl`, ktÃ³ra deklaruje typ generyczny, ta metoda zostanie zdefiniowana dla kaÅ¼dej instancji typu, niezaleÅ¼nie od tego, jaki konkretny typ ostatecznie zastÄ…pi typ generyczny.\n\nMoÅ¼emy rÃ³wnieÅ¼ okreÅ›laÄ‡ ograniczenia dla typÃ³w generycznych podczas definiowania metod na tym typie. MoglibyÅ›my, na przykÅ‚ad, zaimplementowaÄ‡ metody tylko na instancjach `Point<f32>` zamiast na instancjach `Point<T>` z dowolnym typem generycznym. W Listing 10-10 uÅ¼ywamy konkretnego typu `f32`, co oznacza, Å¼e nie deklarujemy Å¼adnych typÃ³w po `impl`.\n\n<Listing number=\"10-10\" file-name=\"src/main.rs\" caption=\"Blok `impl`, ktÃ³ry ma zastosowanie tylko do struktury z okreÅ›lonym typem konkretnym dla generycznego parametru typu `T`\">\n\n```rust\n# struct Point<T> {\n#     x: T,\n#     y: T,\n# }\n# \n# impl<T> Point<T> {\n#     fn x(&self) -> &T {\n#         &self.x\n#     }\n# }\n# \nimpl Point<f32> {\n    fn distance_from_origin(&self) -> f32 {\n        (self.x.powi(2) + self.y.powi(2)).sqrt()\n    }\n}\n# \n# fn main() {\n#     let p = Point { x: 5, y: 10 };\n# \n#     println!(\"p.x = {}\", p.x());\n# }\n```\n\n</Listing>\n\nTen kod oznacza, Å¼e typ `Point<f32>` bÄ™dzie miaÅ‚ metodÄ™ `distance_from_origin`; inne instancje `Point<T>`, gdzie `T` nie jest typu `f32`, nie bÄ™dÄ… miaÅ‚y tej metody zdefiniowanej. Metoda mierzy, jak daleko nasz punkt znajduje siÄ™ od punktu o wspÃ³Å‚rzÄ™dnych (0.0, 0.0) i uÅ¼ywa operacji matematycznych, ktÃ³re sÄ… dostÄ™pne tylko dla typÃ³w zmiennoprzecinkowych.\n\nGeneryczne parametry typu w definicji struktury nie zawsze sÄ… takie same, jak te, ktÃ³rych uÅ¼ywasz w sygnaturach metod tej samej struktury. Listing 10-11 uÅ¼ywa generycznych typÃ³w `X1` i `Y1` dla struktury `Point` oraz `X2` i `Y2` dla sygnatury metody `mixup`, aby przykÅ‚ad byÅ‚ jaÅ›niejszy. Metoda tworzy nowÄ… instancjÄ™ `Point` z wartoÅ›ciÄ… `x` z `self` `Point` (typu `X1`) i wartoÅ›ciÄ… `y` z przekazanego `Point` (typu `Y2`).\n\n<Listing number=\"10-11\" file-name=\"src/main.rs\" caption=\"Metoda uÅ¼ywajÄ…ca typÃ³w generycznych, ktÃ³re rÃ³Å¼niÄ… siÄ™ od definicji jej struktury\">\n\n```rust\nstruct Point<X1, Y1> {\n    x: X1,\n    y: Y1,\n}\n\nimpl<X1, Y1> Point<X1, Y1> {\n    fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {\n        Point {\n            x: self.x,\n            y: other.y,\n        }\n    }\n}\n\nfn main() {\n    let p1 = Point { x: 5, y: 10.4 };\n    let p2 = Point { x: \"Witaj\", y: 'c' };\n\n    let p3 = p1.mixup(p2);\n\n    println!(\"p3.x = {}, p3.y = {}\", p3.x, p3.y);\n}\n```\n\n</Listing>\n\nW funkcji `main` zdefiniowaliÅ›my `Point`, ktÃ³ry ma `i32` dla `x` (o wartoÅ›ci `5`) i `f64` dla `y` (o wartoÅ›ci `10.4`). Zmienna `p2` to struktura `Point`, ktÃ³ra ma wycinek ciÄ…gu znakÃ³w dla `x` (o wartoÅ›ci `\"Witaj\"`) i `char` dla `y` (o wartoÅ›ci `c`). WywoÅ‚anie `mixup` na `p1` z argumentem `p2` daje nam `p3`, ktÃ³ry bÄ™dzie miaÅ‚ `i32` dla `x`, poniewaÅ¼ `x` pochodzi z `p1`. Zmienna `p3` bÄ™dzie miaÅ‚a `char` dla `y`, poniewaÅ¼ `y` pochodzi z `p2`. WywoÅ‚anie makra `println!` wydrukuje `p3.x = 5, p3.y = c`.\n\nCelem tego przykÅ‚adu jest zademonstrowanie sytuacji, w ktÃ³rej niektÃ³re parametry generyczne sÄ… zadeklarowane za pomocÄ… `impl`, a niektÃ³re za pomocÄ… definicji metody. Tutaj parametry generyczne `X1` i `Y1` sÄ… zadeklarowane po `impl`, poniewaÅ¼ pasujÄ… do definicji struktury. Parametry generyczne `X2` i `Y2` sÄ… zadeklarowane po `fn mixup`, poniewaÅ¼ sÄ… istotne tylko dla metody.\n\n### WydajnoÅ›Ä‡ kodu uÅ¼ywajÄ…cego generykÃ³w\n\nMoÅ¼esz zastanawiaÄ‡ siÄ™, czy istnieje koszt czasu wykonania przy uÅ¼ywaniu generycznych parametrÃ³w typu. Dobra wiadomoÅ›Ä‡ jest taka, Å¼e uÅ¼ywanie typÃ³w generycznych nie spowolni programu bardziej niÅ¼ uÅ¼ycie konkretnych typÃ³w.\n\nRust osiÄ…ga to, wykonujÄ…c monomorfizacjÄ™ kodu uÅ¼ywajÄ…cego generykÃ³w w czasie kompilacji. _Monomorfizacja_ to proces przeksztaÅ‚cania kodu generycznego w kod specyficzny poprzez wypeÅ‚nienie konkretnych typÃ³w uÅ¼ywanych podczas kompilacji. W tym procesie kompilator wykonuje przeciwieÅ„stwo krokÃ³w, ktÃ³rych uÅ¼yliÅ›my do utworzenia funkcji generycznej w Listing 10-5: kompilator przeglÄ…da wszystkie miejsca, w ktÃ³rych wywoÅ‚ywany jest kod generyczny, i generuje kod dla konkretnych typÃ³w, z ktÃ³rymi wywoÅ‚ywany jest kod generyczny.\n\nPrzyjrzyjmy siÄ™, jak to dziaÅ‚a, uÅ¼ywajÄ…c generycznego enum `Option<T>` ze standardowej biblioteki:\n\n```rust\nlet integer = Some(5);\nlet float = Some(5.0);\n```\n\nKiedy Rust kompiluje ten kod, wykonuje monomorfizacjÄ™. Podczas tego procesu kompilator odczytuje wartoÅ›ci, ktÃ³re zostaÅ‚y uÅ¼yte w instancjach `Option<T>`, i identyfikuje dwa rodzaje `Option<T>`: jeden to `i32`, a drugi to `f64`. W zwiÄ…zku z tym rozszerza generycznÄ… definicjÄ™ `Option<T>` na dwie definicje wyspecjalizowane dla `i32` i `f64`, zastÄ™pujÄ…c w ten sposÃ³b generycznÄ… definicjÄ™ specyficznymi.\n\nMonomorfizowana wersja kodu wyglÄ…da podobnie do nastÄ™pujÄ…cej (kompilator uÅ¼ywa innych nazw niÅ¼ te, ktÃ³rych uÅ¼ywamy tutaj dla ilustracji):\n\n<Listing file-name=\"src/main.rs\">\n\n```rust\nenum Option_i32 {\n    Some(i32),\n    None,\n}\n\nenum Option_f64 {\n    Some(f64),\n    None,\n}\n\nfn main() {\n    let integer = Option_i32::Some(5);\n    let float = Option_f64::Some(5.0);\n}\n```\n\n</Listing>\n\nGeneryczny `Option<T>` jest zastÄ™powany przez specyficzne definicje utworzone przez kompilator. PoniewaÅ¼ Rust kompiluje kod generyczny do kodu, ktÃ³ry okreÅ›la typ w kaÅ¼dej instancji, nie ponosimy kosztÃ³w wykonania za uÅ¼ywanie generykÃ³w. Gdy kod dziaÅ‚a, zachowuje siÄ™ tak samo, jakbyÅ›my rÄ™cznie zduplikowali kaÅ¼dÄ… definicjÄ™. Proces monomorfizacji sprawia, Å¼e generyki Rusta sÄ… niezwykle wydajne w czasie wykonywania.\n",
        "chapter_title": "Generyczne typy danych"
    },
    {
        "file_path": "ch10-02-traits.md",
        "content": "<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"traits-defining-shared-behavior\"></a>\n\n## Definiowanie wspÃ³lnego zachowania za pomocÄ… cech\n\n_Cecha_ (trait) definiuje funkcjonalnoÅ›Ä‡, ktÃ³rÄ… posiada dany typ i ktÃ³rÄ… moÅ¼e dzieliÄ‡ z innymi typami. MoÅ¼emy uÅ¼ywaÄ‡ cech do definiowania wspÃ³lnego zachowania w sposÃ³b abstrakcyjny. MoÅ¼emy uÅ¼ywaÄ‡ _ograniczeÅ„ cech_ (trait bounds) do okreÅ›lania, Å¼e typ generyczny moÅ¼e byÄ‡ dowolnym typem, ktÃ³ry ma okreÅ›lone zachowanie.\n\n> Uwaga: Cechy sÄ… podobne do funkcji czÄ™sto nazywanych _interfejsami_ w innych jÄ™zykach, choÄ‡ z pewnymi rÃ³Å¼nicami.\n\n### Definiowanie cechy\n\nZachowanie typu skÅ‚ada siÄ™ z metod, ktÃ³re moÅ¼emy wywoÅ‚aÄ‡ dla tego typu. RÃ³Å¼ne typy dzielÄ… to samo zachowanie, jeÅ›li moÅ¼emy wywoÅ‚aÄ‡ te same metody dla wszystkich tych typÃ³w. Definicje cech to sposÃ³b grupowania sygnatur metod w celu zdefiniowania zestawu zachowaÅ„ niezbÄ™dnych do osiÄ…gniÄ™cia pewnego celu.\n\nNa przykÅ‚ad, powiedzmy, Å¼e mamy wiele struktur, ktÃ³re przechowujÄ… rÃ³Å¼ne rodzaje i iloÅ›ci tekstu: struktura `NewsArticle`, ktÃ³ra przechowuje artykuÅ‚ informacyjny z okreÅ›lonej lokalizacji, i `SocialPost`, ktÃ³ra moÅ¼e mieÄ‡ co najwyÅ¼ej 280 znakÃ³w wraz z metadanymi wskazujÄ…cymi, czy byÅ‚ to nowy post, repost, czy odpowiedÅº na inny post.\n\nChcemy stworzyÄ‡ skrzynkÄ™ bibliotecznÄ… agregujÄ…cÄ… media o nazwie `aggregator`, ktÃ³ra bÄ™dzie mogÅ‚a wyÅ›wietlaÄ‡ podsumowania danych przechowywanych w instancji `NewsArticle` lub `SocialPost`. Aby to zrobiÄ‡, potrzebujemy podsumowania z kaÅ¼dego typu, a to podsumowanie uzyskamy, wywoÅ‚ujÄ…c metodÄ™ `summarize` na instancji. Listing 10-12 pokazuje definicjÄ™ publicznej cechy `Summary`, ktÃ³ra wyraÅ¼a to zachowanie.\n\n<Listing number=\"10-12\" file-name=\"src/lib.rs\" caption=\"Cecha `Summary`, ktÃ³ra skÅ‚ada siÄ™ z zachowania zapewnianego przez metodÄ™ `summarize`\">\n\n```rust,noplayground\npub trait Summary {\n    fn summarize(&self) -> String;\n}\n```\n\n</Listing>\n\nTutaj deklarujemy cechÄ™ za pomocÄ… sÅ‚owa kluczowego `trait`, a nastÄ™pnie nazwÄ™ cechy, ktÃ³ra w tym przypadku to `Summary`. Deklarujemy rÃ³wnieÅ¼ cechÄ™ jako `pub`, aby skrzynki zaleÅ¼ne od tej skrzynki mogÅ‚y rÃ³wnieÅ¼ korzystaÄ‡ z tej cechy, jak zobaczymy w kilku przykÅ‚adach. W nawiasach klamrowych deklarujemy sygnatury metod, ktÃ³re opisujÄ… zachowania typÃ³w implementujÄ…cych tÄ™ cechÄ™, co w tym przypadku jest `fn summarize(&self) -> String`.\n\nPo sygnaturze metody, zamiast dostarczaÄ‡ implementacji w nawiasach klamrowych, uÅ¼ywamy Å›rednika. KaÅ¼dy typ implementujÄ…cy tÄ™ cechÄ™ musi dostarczyÄ‡ wÅ‚asne, niestandardowe zachowanie dla ciaÅ‚a metody. Kompilator wymusi, aby kaÅ¼dy typ posiadajÄ…cy cechÄ™ `Summary` miaÅ‚ metodÄ™ `summarize` zdefiniowanÄ… dokÅ‚adnie z tÄ… sygnaturÄ….\n\nCecha moÅ¼e mieÄ‡ wiele metod w swoim ciele: sygnatury metod sÄ… wymienione jedna na liniÄ™, a kaÅ¼da linia koÅ„czy siÄ™ Å›rednikiem.\n\n### Implementowanie cechy na typie\n\nTeraz, gdy zdefiniowaliÅ›my poÅ¼Ä…dane sygnatury metod cechy `Summary`, moÅ¼emy zaimplementowaÄ‡ jÄ… na typach w naszym agregatorze mediÃ³w. Listing 10-13 pokazuje implementacjÄ™ cechy `Summary` na strukturze `NewsArticle`, ktÃ³ra uÅ¼ywa nagÅ‚Ã³wka, autora i lokalizacji do utworzenia wartoÅ›ci zwracanej przez `summarize`. Dla struktury `SocialPost` definiujemy `summarize` jako nazwÄ™ uÅ¼ytkownika, a nastÄ™pnie caÅ‚y tekst posta, zakÅ‚adajÄ…c, Å¼e zawartoÅ›Ä‡ posta jest juÅ¼ ograniczona do 280 znakÃ³w.\n\n<Listing number=\"10-13\" file-name=\"src/lib.rs\" caption=\"Implementacja cechy `Summary` na typach `NewsArticle` i `SocialPost`\">\n\n```rust,noplayground\n# pub trait Summary {\n#     fn summarize(&self) -> String;\n# }\n# \npub struct NewsArticle {\n    pub headline: String,\n    pub location: String,\n    pub author: String,\n    pub content: String,\n}\n\nimpl Summary for NewsArticle {\n    fn summarize(&self) -> String {\n        format!(\"{}, by {} ({})\", self.headline, self.author, self.location)\n    }\n}\n\npub struct SocialPost {\n    pub username: String,\n    pub content: String,\n    pub reply: bool,\n    pub repost: bool,\n}\n\nimpl Summary for SocialPost {\n    fn summarize(&self) -> String {\n        format!(\"{}: {}\", self.username, self.content)\n    }\n}\n```\n\n</Listing>\n\nImplementowanie cechy na typie jest podobne do implementowania zwykÅ‚ych metod. RÃ³Å¼nica polega na tym, Å¼e po `impl` umieszczamy nazwÄ™ cechy, ktÃ³rÄ… chcemy zaimplementowaÄ‡, nastÄ™pnie uÅ¼ywamy sÅ‚owa kluczowego `for`, a nastÄ™pnie okreÅ›lamy nazwÄ™ typu, dla ktÃ³rego chcemy zaimplementowaÄ‡ cechÄ™. W bloku `impl` umieszczamy sygnatury metod, ktÃ³re zdefiniowano w definicji cechy. Zamiast dodawaÄ‡ Å›rednik po kaÅ¼dej sygnaturze, uÅ¼ywamy nawiasÃ³w klamrowych i wypeÅ‚niamy ciaÅ‚o metody konkretnym zachowaniem, ktÃ³re chcemy, aby metody cechy miaÅ‚y dla danego typu.\n\nTeraz, gdy biblioteka zaimplementowaÅ‚a cechÄ™ `Summary` dla `NewsArticle` i `SocialPost`, uÅ¼ytkownicy skrzynki mogÄ… wywoÅ‚ywaÄ‡ metody cech na instancjach `NewsArticle` i `SocialPost` w taki sam sposÃ³b, jak wywoÅ‚ujemy zwykÅ‚e metody. JedynÄ… rÃ³Å¼nicÄ… jest to, Å¼e uÅ¼ytkownik musi wprowadziÄ‡ cechÄ™ do zasiÄ™gu, a takÅ¼e typy. Oto przykÅ‚ad, jak skrzynka binarna mogÅ‚aby uÅ¼yÄ‡ naszej skrzynki bibliotecznej `aggregator`:\n\n```rust,ignore\nuse aggregator::{SocialPost, Summary};\n\nfn main() {\n    let post = SocialPost {\n        username: String::from(\"horse_ebooks\"),\n        content: String::from(\n            \"oczywiÅ›cie, jak zapewne juÅ¼ wiesz, ludzie\",\n        ),\n        reply: false,\n        repost: false,\n    };\n\n    println!(\"1 nowy post: {}\", post.summarize());\n}\n```\n\nTen kod drukuje `1 nowy post: horse_ebooks: oczywiÅ›cie, jak zapewne juÅ¼ wiesz, ludzie`.\n\nInne skrzynki zaleÅ¼ne od skrzynki `aggregator` mogÄ… rÃ³wnieÅ¼ wprowadziÄ‡ cechÄ™ `Summary` do zasiÄ™gu, aby zaimplementowaÄ‡ `Summary` na swoich wÅ‚asnych typach. Jednym z ograniczeÅ„ jest to, Å¼e moÅ¼emy zaimplementowaÄ‡ cechÄ™ na typie tylko wtedy, gdy cecha lub typ, albo oba, sÄ… lokalne dla naszej skrzynki. Na przykÅ‚ad, moÅ¼emy zaimplementowaÄ‡ cechy standardowej biblioteki, takie jak `Display`, na niestandardowym typie, takim jak `SocialPost`, jako czÄ™Å›Ä‡ funkcjonalnoÅ›ci naszej skrzynki `aggregator`, poniewaÅ¼ typ `SocialPost` jest lokalny dla naszej skrzynki `aggregator`. MoÅ¼emy rÃ³wnieÅ¼ zaimplementowaÄ‡ `Summary` na `Vec<T>` w naszej skrzynce `aggregator`, poniewaÅ¼ cecha `Summary` jest lokalna dla naszej skrzynki `aggregator`.\n\nAle nie moÅ¼emy implementowaÄ‡ zewnÄ™trznych cech na zewnÄ™trznych typach. Na przykÅ‚ad, nie moÅ¼emy implementowaÄ‡ cechy `Display` na `Vec<T>` w naszej skrzynce `aggregator`, poniewaÅ¼ `Display` i `Vec<T>` sÄ… zdefiniowane w standardowej bibliotece i nie sÄ… lokalne dla naszej skrzynki `aggregator`. To ograniczenie jest czÄ™Å›ciÄ… wÅ‚aÅ›ciwoÅ›ci zwanej _spÃ³jnoÅ›ciÄ…_, a dokÅ‚adniej _zasadÄ… sieroty_ (orphan rule), nazwanÄ… tak, poniewaÅ¼ typ nadrzÄ™dny nie jest obecny. Ta zasada zapewnia, Å¼e kod innych ludzi nie moÅ¼e zepsuÄ‡ twojego kodu i vice versa. Bez tej zasady, dwie skrzynki mogÅ‚yby zaimplementowaÄ‡ tÄ™ samÄ… cechÄ™ dla tego samego typu, a Rust nie wiedziaÅ‚by, ktÃ³rej implementacji uÅ¼yÄ‡.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"default-implementations\"></a>\n\n### UÅ¼ywanie domyÅ›lnych implementacji\n\nCzasami przydatne jest posiadanie domyÅ›lnego zachowania dla niektÃ³rych lub wszystkich metod w cesze, zamiast wymagaÄ‡ implementacji dla wszystkich metod na kaÅ¼dym typie. NastÄ™pnie, implementujÄ…c cechÄ™ na konkretnym typie, moÅ¼emy zachowaÄ‡ lub nadpisaÄ‡ domyÅ›lne zachowanie kaÅ¼dej metody.\n\nW Listing 10-14 okreÅ›lamy domyÅ›lny ciÄ…g znakÃ³w dla metody `summarize` cechy `Summary`, zamiast definiowaÄ‡ tylko sygnaturÄ™ metody, jak to zrobiliÅ›my w Listing 10-12.\n\n<Listing number=\"10-14\" file-name=\"src/lib.rs\" caption=\"Definiowanie cechy `Summary` z domyÅ›lnÄ… implementacjÄ… metody `summarize`\">\n\n```rust,noplayground\npub trait Summary {\n    fn summarize(&self) -> String {\n        String::from(\"(Czytaj wiÄ™cej...)\")\n    }\n}\n# \n# pub struct NewsArticle {\n#     pub headline: String,\n#     pub location: String,\n#     pub author: String,\n#     pub content: String,\n# }\n# \n# impl Summary for NewsArticle {}\n# \n# pub struct SocialPost {\n#     pub username: String,\n#     pub content: String,\n#     pub reply: bool,\n#     pub repost: bool,\n# }\n# \n# impl Summary for SocialPost {\n#     fn summarize(&self) -> String {\n#         format!(\"{}: {}\", self.username, self.content)\n#     }\n# }\n```\n\n</Listing>\n\nAby uÅ¼yÄ‡ domyÅ›lnej implementacji do podsumowywania instancji `NewsArticle`, okreÅ›lamy pusty blok `impl` za pomocÄ… `impl Summary for NewsArticle {}`.\n\nChociaÅ¼ nie definiujemy juÅ¼ bezpoÅ›rednio metody `summarize` w `NewsArticle`, dostarczyliÅ›my domyÅ›lnÄ… implementacjÄ™ i okreÅ›liliÅ›my, Å¼e `NewsArticle` implementuje cechÄ™ `Summary`. W rezultacie nadal moÅ¼emy wywoÅ‚aÄ‡ metodÄ™ `summarize` na instancji `NewsArticle`, tak jak poniÅ¼ej:\n\n```rust,ignore\n# use aggregator::{self, NewsArticle, Summary};\n# \n# fn main() {\n    let article = NewsArticle {\n        headline: String::from(\"Pingwiny wygrywajÄ… Puchar Stanleya!\"),\n        location: String::from(\"Pittsburgh, PA, USA\"),\n        author: String::from(\"Iceburgh\"),\n        content: String::from(\n            \"Pittsburgh Penguins po raz kolejny sÄ… najlepszÄ… \\\n             druÅ¼ynÄ… hokejowÄ… w NHL.\",\n        ),\n    };\n\n    println!(\"Nowy artykuÅ‚ dostÄ™pny! {}\", article.summarize());\n# }\n```\n\nTen kod drukuje `Nowy artykuÅ‚ dostÄ™pny! (Czytaj wiÄ™cej...)`.\n\nStworzenie domyÅ›lnej implementacji nie wymaga od nas zmiany czegokolwiek w implementacji `Summary` na `SocialPost` w Listing 10-13. Powodem jest to, Å¼e skÅ‚adnia nadpisywania domyÅ›lnej implementacji jest taka sama jak skÅ‚adnia implementacji metody cechy, ktÃ³ra nie ma domyÅ›lnej implementacji.\n\nDomyÅ›lne implementacje mogÄ… wywoÅ‚ywaÄ‡ inne metody w tej samej cesze, nawet jeÅ›li te inne metody nie majÄ… domyÅ›lnej implementacji. W ten sposÃ³b cecha moÅ¼e dostarczyÄ‡ wiele uÅ¼ytecznej funkcjonalnoÅ›ci i wymagaÄ‡ od implementatorÃ³w jedynie okreÅ›lenia jej maÅ‚ej czÄ™Å›ci. Na przykÅ‚ad, moglibyÅ›my zdefiniowaÄ‡ cechÄ™ `Summary` tak, aby miaÅ‚a metodÄ™ `summarize_author`, ktÃ³rej implementacja jest wymagana, a nastÄ™pnie zdefiniowaÄ‡ metodÄ™ `summarize`, ktÃ³ra ma domyÅ›lnÄ… implementacjÄ™, ktÃ³ra wywoÅ‚uje metodÄ™ `summarize_author`:\n\n```rust,noplayground\npub trait Summary {\n    fn summarize_author(&self) -> String;\n\n    fn summarize(&self) -> String {\n        format!(\"(Czytaj wiÄ™cej od {}...)\", self.summarize_author())\n    }\n}\n# \n# pub struct SocialPost {\n#     pub username: String,\n#     pub content: String,\n#     pub reply: bool,\n#     pub repost: bool,\n# }\n# \n# impl Summary for SocialPost {\n#     fn summarize_author(&self) -> String {\n#         format!(\"@{}\", self.username)\n#     }\n# }\n```\n\nAby uÅ¼yÄ‡ tej wersji `Summary`, wystarczy zdefiniowaÄ‡ `summarize_author` podczas implementacji cechy na typie:\n\n```rust,ignore\n# pub trait Summary {\n#     fn summarize_author(&self) -> String;\n# \n#     fn summarize(&self) -> String {\n#         format!(\"(Czytaj wiÄ™cej od {}...)\", self.summarize_author())\n#     }\n# }\n# \n# pub struct SocialPost {\n#     pub username: String,\n#     pub content: String,\n#     pub reply: bool,\n#     pub repost: bool,\n# }\n# \nimpl Summary for SocialPost {\n    fn summarize_author(&self) -> String {\n        format!(\"@{}\", self.username)\n    }\n}\n```\n\nPo zdefiniowaniu `summarize_author` moÅ¼emy wywoÅ‚aÄ‡ `summarize` na instancjach struktury `SocialPost`, a domyÅ›lna implementacja `summarize` wywoÅ‚a zdefiniowanÄ… przez nas `summarize_author`. PoniewaÅ¼ zaimplementowaliÅ›my `summarize_author`, cecha `Summary` daÅ‚a nam zachowanie metody `summarize` bez koniecznoÅ›ci pisania dodatkowego kodu. Oto jak to wyglÄ…da:\n\n```rust,ignore\n# use aggregator::{self, SocialPost, Summary};\n# \n# fn main() {\n    let post = SocialPost {\n        username: String::from(\"horse_ebooks\"),\n        content: String::from(\n            \"oczywiÅ›cie, jak zapewne juÅ¼ wiesz, ludzie\",\n        ),\n        reply: false,\n        repost: false,\n    };\n\n    println!(\"1 nowy post: {}\", post.summarize());\n# }\n```\n\nTen kod drukuje `1 nowy post: (Czytaj wiÄ™cej od @horse_ebooks...)`.\n\nZauwaÅ¼, Å¼e nie jest moÅ¼liwe wywoÅ‚anie domyÅ›lnej implementacji z nadpisujÄ…cej implementacji tej samej metody.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"traits-as-parameters\"></a>\n\n### UÅ¼ywanie cech jako parametrÃ³w\n\nTeraz, gdy wiesz, jak definiowaÄ‡ i implementowaÄ‡ cechy, moÅ¼emy zbadaÄ‡, jak uÅ¼ywaÄ‡ cech do definiowania funkcji, ktÃ³re akceptujÄ… wiele rÃ³Å¼nych typÃ³w. UÅ¼yjemy cechy `Summary`, ktÃ³rÄ… zaimplementowaliÅ›my na typach `NewsArticle` i `SocialPost` w Listing 10-13, aby zdefiniowaÄ‡ funkcjÄ™ `notify`, ktÃ³ra wywoÅ‚uje metodÄ™ `summarize` na swoim parametrze `item`, ktÃ³ry jest jakiegoÅ› typu implementujÄ…cego cechÄ™ `Summary`. Aby to zrobiÄ‡, uÅ¼ywamy skÅ‚adni `impl Trait`, tak jak poniÅ¼ej:\n\n```rust,ignore\n# pub trait Summary {\n#     fn summarize(&self) -> String;\n# }\n# \n# pub struct NewsArticle {\n#     pub headline: String,\n#     pub location: String,\n#     pub author: String,\n#     pub content: String,\n# }\n# \n# impl Summary for NewsArticle {\n#     fn summarize(&self) -> String {\n#         format!(\"{}, by {} ({})\", self.headline, self.author, self.location)\n#     }\n# }\n# \n# pub struct SocialPost {\n#     pub username: String,\n#     pub content: String,\n#     pub reply: bool,\n#     pub repost: bool,\n# }\n# \n# impl Summary for SocialPost {\n#     fn summarize(&self) -> String {\n#         format!(\"{}: {}\", self.username, self.content)\n#     }\n# }\n# \npub fn notify(item: &impl Summary) {\n    println!(\"NajÅ›wieÅ¼sze wiadomoÅ›ci! {}\", item.summarize());\n}\n```\n\nZamiast konkretnego typu dla parametru `item`, okreÅ›lamy sÅ‚owo kluczowe `impl` i nazwÄ™ cechy. Ten parametr akceptuje dowolny typ, ktÃ³ry implementuje okreÅ›lonÄ… cechÄ™. W ciele `notify` moÅ¼emy wywoÅ‚aÄ‡ dowolne metody na `item`, ktÃ³re pochodzÄ… z cechy `Summary`, takie jak `summarize`. MoÅ¼emy wywoÅ‚aÄ‡ `notify` i przekazaÄ‡ dowolnÄ… instancjÄ™ `NewsArticle` lub `SocialPost`. Kod, ktÃ³ry wywoÅ‚uje funkcjÄ™ z dowolnym innym typem, takim jak `String` lub `i32`, nie skompiluje siÄ™, poniewaÅ¼ te typy nie implementujÄ… `Summary`.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"fixing-the-largest-function-with-trait-bounds\"></a>\n\n#### SkÅ‚adnia ograniczeÅ„ cech\n\nSkÅ‚adnia `impl Trait` dziaÅ‚a w prostych przypadkach, ale w rzeczywistoÅ›ci jest to cukier syntaktyczny dla dÅ‚uÅ¼szej formy znanej jako _ograniczenie cechy_ (trait bound); wyglÄ…da to tak:\n\n```rust,ignore\npub fn notify<T: Summary>(item: &T) {\n    println!(\"NajÅ›wieÅ¼sze wiadomoÅ›ci! {}\", item.summarize());\n}\n```\n\nTa dÅ‚uÅ¼sza forma jest rÃ³wnowaÅ¼na przykÅ‚adowi z poprzedniej sekcji, ale jest bardziej rozwlekÅ‚a. Ograniczenia cech umieszczamy wraz z deklaracjÄ… generycznego parametru typu po dwukropku i w nawiasach ostrych.\n\nSkÅ‚adnia `impl Trait` jest wygodna i sprawia, Å¼e kod jest bardziej zwiÄ™zÅ‚y w prostych przypadkach, podczas gdy peÅ‚niejsza skÅ‚adnia ograniczeÅ„ cech moÅ¼e wyraÅ¼aÄ‡ wiÄ™kszÄ… zÅ‚oÅ¼onoÅ›Ä‡ w innych przypadkach. Na przykÅ‚ad, moÅ¼emy mieÄ‡ dwa parametry, ktÃ³re implementujÄ… `Summary`. UÅ¼ycie skÅ‚adni `impl Trait` wyglÄ…da tak:\n\n```rust,ignore\npub fn notify(item1: &impl Summary, item2: &impl Summary) {\n```\n\nUÅ¼ycie `impl Trait` jest odpowiednie, jeÅ›li chcemy, aby ta funkcja pozwalaÅ‚a `item1` i `item2` na posiadanie rÃ³Å¼nych typÃ³w (o ile oba typy implementujÄ… `Summary`). JeÅ›li jednak chcemy wymusiÄ‡, aby oba parametry miaÅ‚y ten sam typ, musimy uÅ¼yÄ‡ ograniczenia cechy, tak jak poniÅ¼ej:\n\n```rust,ignore\npub fn notify<T: Summary>(item1: &T, item2: &T) {\n```\n\nGeneryczny typ `T` okreÅ›lony jako typ parametrÃ³w `item1` i `item2` ogranicza funkcjÄ™ tak, Å¼e konkretny typ wartoÅ›ci przekazanej jako argument dla `item1` i `item2` musi byÄ‡ taki sam.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"specifying-multiple-trait-bounds-with-the--syntax\"></a>\n\n#### Wiele ograniczeÅ„ cech za pomocÄ… skÅ‚adni `+`\n\nMoÅ¼emy rÃ³wnieÅ¼ okreÅ›liÄ‡ wiÄ™cej niÅ¼ jedno ograniczenie cechy. Powiedzmy, Å¼e chcieliÅ›my, aby `notify` uÅ¼ywaÅ‚o formatowania wyÅ›wietlania, a takÅ¼e `summarize` na `item`: okreÅ›lamy w definicji `notify`, Å¼e `item` musi implementowaÄ‡ zarÃ³wno `Display`, jak i `Summary`. MoÅ¼emy to zrobiÄ‡ za pomocÄ… skÅ‚adni `+`:\n\n```rust,ignore\npub fn notify(item: &(impl Summary + Display)) {\n```\n\nSkÅ‚adnia `+` jest rÃ³wnieÅ¼ prawidÅ‚owa z ograniczeniami cech na typach generycznych:\n\n```rust,ignore\npub fn notify<T: Summary + Display>(item: &T) {\n```\n\nDziÄ™ki dwÃ³m okreÅ›lonym ograniczeniom cech, ciaÅ‚o `notify` moÅ¼e wywoÅ‚ywaÄ‡ `summarize` i uÅ¼ywaÄ‡ `{}` do formatowania `item`.\n\n#### JaÅ›niejsze ograniczenia cech za pomocÄ… klauzul `where`\n\nZbyt wiele ograniczeÅ„ cech ma swoje wady. KaÅ¼dy typ generyczny ma swoje wÅ‚asne ograniczenia cech, wiÄ™c funkcje z wieloma generycznymi parametrami typu mogÄ… zawieraÄ‡ wiele informacji o ograniczeniach cech miÄ™dzy nazwÄ… funkcji a listÄ… jej parametrÃ³w, co utrudnia czytanie sygnatury funkcji. Z tego powodu Rust ma alternatywnÄ… skÅ‚adniÄ™ do okreÅ›lania ograniczeÅ„ cech w klauzuli `where` po sygnaturze funkcji. Tak wiÄ™c, zamiast pisaÄ‡ tak:\n\n```rust,ignore\nfn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {\n```\n\nmoÅ¼emy uÅ¼yÄ‡ klauzuli `where`, tak jak poniÅ¼ej:\n\n```rust,ignore\nfn some_function<T, U>(t: &T, u: &U) -> i32\nwhere\n    T: Display + Clone,\n    U: Clone + Debug,\n{\n#     unimplemented!()\n# }\n```\n\nSygnatura tej funkcji jest mniej zaÅ›miecona: nazwa funkcji, lista parametrÃ³w i typ zwracany sÄ… blisko siebie, podobnie jak w funkcji bez wielu ograniczeÅ„ cech.\n\n### Zwracanie typÃ³w, ktÃ³re implementujÄ… cechy\n\nMoÅ¼emy rÃ³wnieÅ¼ uÅ¼yÄ‡ skÅ‚adni `impl Trait` w pozycji zwracanej, aby zwrÃ³ciÄ‡ wartoÅ›Ä‡ jakiegoÅ› typu, ktÃ³ry implementuje cechÄ™, jak pokazano tutaj:\n\n```rust,ignore\n# pub trait Summary {\n#     fn summarize(&self) -> String;\n# }\n# \n# pub struct NewsArticle {\n#     pub headline: String,\n#     pub location: String,\n#     pub author: String,\n#     pub content: String,\n# }\n# \n# impl Summary for NewsArticle {\n#     fn summarize(&self) -> String {\n#         format!(\"{}, by {} ({})\", self.headline, self.author, self.location)\n#     }\n# }\n# \n# pub struct SocialPost {\n#     pub username: String,\n#     pub content: String,\n#     pub reply: bool,\n#     pub repost: bool,\n# }\n# \n# impl Summary for SocialPost {\n#     fn summarize(&self) -> String {\n#         format!(\"{}: {}\", self.username, self.content)\n#     }\n# }\n# \nfn returns_summarizable() -> impl Summary {\n    SocialPost {\n        username: String::from(\"horse_ebooks\"),\n        content: String::from(\n            \"oczywiÅ›cie, jak zapewne juÅ¼ wiesz, ludzie\",\n        ),\n        reply: false,\n        repost: false,\n    }\n}\n```\n\nUÅ¼ywajÄ…c `impl Summary` jako typu zwracanego, okreÅ›lamy, Å¼e funkcja `returns_summarizable` zwraca pewien typ, ktÃ³ry implementuje cechÄ™ `Summary`, bez nazywania konkretnego typu. W tym przypadku `returns_summarizable` zwraca `SocialPost`, ale kod wywoÅ‚ujÄ…cy tÄ™ funkcjÄ™ nie musi o tym wiedzieÄ‡.\n\nMoÅ¼liwoÅ›Ä‡ okreÅ›lenia typu zwracanego tylko przez cechÄ™, ktÃ³rÄ… implementuje, jest szczegÃ³lnie przydatna w kontekÅ›cie domkniÄ™Ä‡ i iteratorÃ³w, ktÃ³re omÃ³wimy w Rozdziale 13. DomkniÄ™cia i iteratory tworzÄ… typy, ktÃ³re zna tylko kompilator, lub typy, ktÃ³re sÄ… bardzo dÅ‚ugie do okreÅ›lenia. SkÅ‚adnia `impl Trait` pozwala zwiÄ™Åºle okreÅ›liÄ‡, Å¼e funkcja zwraca jakiÅ› typ, ktÃ³ry implementuje cechÄ™ `Iterator`, bez koniecznoÅ›ci wypisywania bardzo dÅ‚ugiego typu.\n\nMoÅ¼esz jednak uÅ¼ywaÄ‡ `impl Trait` tylko wtedy, gdy zwracasz pojedynczy typ. Na przykÅ‚ad, ten kod, ktÃ³ry zwraca `NewsArticle` lub `SocialPost` z typem zwracanym okreÅ›lonym jako `impl Summary`, nie zadziaÅ‚a:\n\n```rust,ignore,does_not_compile\n# pub trait Summary {\n#     fn summarize(&self) -> String;\n# }\n# \n# pub struct NewsArticle {\n#     pub headline: String,\n#     pub location: String,\n#     pub author: String,\n#     pub content: String,\n# }\n# \n# impl Summary for NewsArticle {\n#     fn summarize(&self) -> String {\n#         format!(\"{}, by {} ({})\", self.headline, self.author, self.location)\n#     }\n# }\n# \n# pub struct SocialPost {\n#     pub username: String,\n#     pub content: String,\n#     pub reply: bool,\n#     pub repost: bool,\n# }\n# \n# impl Summary for SocialPost {\n#     fn summarize(&self) -> String {\n#         format!(\"{}: {}\", self.username, self.content)\n#     }\n# }\n# \nfn returns_summarizable(switch: bool) -> impl Summary {\n    if switch {\n        NewsArticle {\n            headline: String::from(\n                \"Pingwiny wygrywajÄ… Puchar Stanleya!\",\n            ),\n            location: String::from(\"Pittsburgh, PA, USA\"),\n            author: String::from(\"Iceburgh\"),\n            content: String::from(\n                \"Pittsburgh Penguins po raz kolejny sÄ… najlepszÄ… \\\n                 druÅ¼ynÄ… hokejowÄ… w NHL.\",\n            ),\n        }\n    } else {\n        SocialPost {\n            username: String::from(\"horse_ebooks\"),\n            content: String::from(\n                \"oczywiÅ›cie, jak zapewne juÅ¼ wiesz, ludzie\",\n            ),\n            reply: false,\n            repost: false,\n        }\n    }\n}\n```\n\nZwracanie `NewsArticle` lub `SocialPost` nie jest dozwolone z powodu ograniczeÅ„ zwiÄ…zanych z implementacjÄ… skÅ‚adni `impl Trait` w kompilatorze. OmÃ³wimy, jak napisaÄ‡ funkcjÄ™ o takim zachowaniu w sekcji [â€UÅ¼ywanie obiektÃ³w cech do abstrakcji wspÃ³lnego zachowaniaâ€][trait-objects]<!-- ignore --> w Rozdziale 18.\n\n### UÅ¼ywanie ograniczeÅ„ cech do warunkowej implementacji metod\n\nUÅ¼ywajÄ…c ograniczenia cechy z blokiem `impl`, ktÃ³ry uÅ¼ywa generycznych parametrÃ³w typu, moÅ¼emy warunkowo implementowaÄ‡ metody dla typÃ³w, ktÃ³re implementujÄ… okreÅ›lone cechy. Na przykÅ‚ad, typ `Pair<T>` w Listing 10-15 zawsze implementuje funkcjÄ™ `new`, aby zwrÃ³ciÄ‡ nowÄ… instancjÄ™ `Pair<T>` (przypomnij sobie z sekcji [â€SkÅ‚adnia metodyâ€][methods]<!-- ignore --> w Rozdziale 5, Å¼e `Self` jest aliasem typu dla typu bloku `impl`, ktÃ³ry w tym przypadku to `Pair<T>`). Ale w nastÄ™pnym bloku `impl`, `Pair<T>` implementuje metodÄ™ `cmp_display` tylko wtedy, gdy jej wewnÄ™trzny typ `T` implementuje cechÄ™ `PartialOrd`, ktÃ³ra umoÅ¼liwia porÃ³wnanie _i_ cechÄ™ `Display`, ktÃ³ra umoÅ¼liwia drukowanie.\n\n<Listing number=\"10-15\" file-name=\"src/lib.rs\" caption=\"Warunkowe implementowanie metod na typie generycznym w zaleÅ¼noÅ›ci od ograniczeÅ„ cech\">\n\n```rust,noplayground\nuse std::fmt::Display;\n\nstruct Pair<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Pair<T> {\n    fn new(x: T, y: T) -> Self {\n        Self { x, y }\n    }\n}\n\nimpl<T: Display + PartialOrd> Pair<T> {\n    fn cmp_display(&self) {\n        if self.x >= self.y {\n            println!(\"NajwiÄ™kszy element to x = {}\", self.x);\n        } else {\n            println!(\"NajwiÄ™kszy element to y = {}\", self.y);\n        }\n    }\n}\n```\n\n</Listing>\n\nMoÅ¼emy rÃ³wnieÅ¼ warunkowo implementowaÄ‡ cechÄ™ dla dowolnego typu, ktÃ³ry implementuje innÄ… cechÄ™. Implementacje cechy na dowolnym typie, ktÃ³ry speÅ‚nia ograniczenia cechy, nazywane sÄ… _implementacjami ogÃ³lnymi_ (blanket implementations) i sÄ… szeroko stosowane w standardowej bibliotece Rusta. Na przykÅ‚ad, standardowa biblioteka implementuje cechÄ™ `ToString` dla kaÅ¼dego typu, ktÃ³ry implementuje cechÄ™ `Display`. Blok `impl` w standardowej bibliotece wyglÄ…da podobnie do tego kodu:\n\n```rust,ignore\nimpl<T: Display> ToString for T {\n    // --snip--\n}\n```\n\nPoniewaÅ¼ standardowa biblioteka ma tÄ™ ogÃ³lnÄ… implementacjÄ™, moÅ¼emy wywoÅ‚aÄ‡ metodÄ™ `to_string` zdefiniowanÄ… przez cechÄ™ `ToString` na dowolnym typie, ktÃ³ry implementuje cechÄ™ `Display`. Na przykÅ‚ad, moÅ¼emy zamieniÄ‡ liczby caÅ‚kowite na odpowiadajÄ…ce im wartoÅ›ci `String` w ten sposÃ³b, poniewaÅ¼ liczby caÅ‚kowite implementujÄ… `Display`:\n\n```rust\nlet s = 3.to_string();\n```\n\nImplementacje ogÃ³lne pojawiajÄ… siÄ™ w dokumentacji cechy w sekcji â€Implementacjeâ€.\n\nCechy i ograniczenia cech pozwalajÄ… nam pisaÄ‡ kod, ktÃ³ry uÅ¼ywa generycznych parametrÃ³w typu, aby zmniejszyÄ‡ duplikacjÄ™, ale takÅ¼e okreÅ›laÄ‡ kompilatorowi, Å¼e chcemy, aby generyczny typ miaÅ‚ okreÅ›lone zachowanie. Kompilator moÅ¼e nastÄ™pnie uÅ¼yÄ‡ informacji o ograniczeniach cech, aby sprawdziÄ‡, czy wszystkie konkretne typy uÅ¼ywane z naszym kodem zapewniajÄ… prawidÅ‚owe zachowanie. W jÄ™zykach z dynamicznym typowaniem otrzymalibyÅ›my bÅ‚Ä…d w czasie wykonywania, gdybyÅ›my wywoÅ‚ali metodÄ™ na typie, ktÃ³ry nie definiuje tej metody. Ale Rust przenosi te bÅ‚Ä™dy do czasu kompilacji, tak abyÅ›my byli zmuszeni do naprawienia problemÃ³w, zanim nasz kod w ogÃ³le bÄ™dzie mÃ³gÅ‚ dziaÅ‚aÄ‡. Dodatkowo, nie musimy pisaÄ‡ kodu, ktÃ³ry sprawdza zachowanie w czasie wykonywania, poniewaÅ¼ sprawdziliÅ›my to juÅ¼ w czasie kompilacji. Robienie tego poprawia wydajnoÅ›Ä‡ bez koniecznoÅ›ci rezygnacji z elastycznoÅ›ci generykÃ³w.\n\n[trait-objects]: ch18-02-trait-objects.html#using-trait-objects-to-abstract-over-shared-behavior\n[methods]: ch05-03-method-syntax.html#method-syntax\n",
        "chapter_title": "Definiowanie wspÃ³lnego zachowania za pomocÄ… cech"
    },
    {
        "file_path": "ch10-03-lifetime-syntax.md",
        "content": "## Walidacja referencji za pomocÄ… czasÃ³w Å¼ycia\n\nCzasy Å¼ycia to kolejny rodzaj generykÃ³w, ktÃ³rych juÅ¼ uÅ¼ywaliÅ›my. Zamiast zapewniaÄ‡, Å¼e typ ma poÅ¼Ä…dane przez nas zachowanie, czasy Å¼ycia zapewniajÄ…, Å¼e referencje sÄ… waÅ¼ne tak dÅ‚ugo, jak tego potrzebujemy.\n\nJednym szczegÃ³Å‚em, o ktÃ³rym nie rozmawialiÅ›my w sekcji [â€Referencje i poÅ¼yczanieâ€][references-and-borrowing]<!-- ignore --> w Rozdziale 4, jest to, Å¼e kaÅ¼da referencja w Rust ma czas Å¼ycia, ktÃ³ry jest zasiÄ™giem, w ktÃ³rym ta referencja jest waÅ¼na. Przez wiÄ™kszoÅ›Ä‡ czasu, czasy Å¼ycia sÄ… domyÅ›lne i wnioskowane, tak jak przez wiÄ™kszoÅ›Ä‡ czasu, typy sÄ… wnioskowane. JesteÅ›my zobowiÄ…zani do adnotowania typÃ³w tylko wtedy, gdy moÅ¼liwych jest wiele typÃ³w. W podobny sposÃ³b musimy adnotowaÄ‡ czasy Å¼ycia, gdy czasy Å¼ycia referencji mogÄ… byÄ‡ powiÄ…zane na kilka rÃ³Å¼nych sposobÃ³w. Rust wymaga od nas adnotowania relacji za pomocÄ… ogÃ³lnych parametrÃ³w czasÃ³w Å¼ycia, aby zapewniÄ‡, Å¼e rzeczywiste referencje uÅ¼ywane w czasie wykonania bÄ™dÄ… z pewnoÅ›ciÄ… waÅ¼ne.\n\nAdnotowanie czasÃ³w Å¼ycia nie jest nawet koncepcjÄ…, ktÃ³rÄ… posiada wiÄ™kszoÅ›Ä‡ innych jÄ™zykÃ³w programowania, wiÄ™c bÄ™dzie to wydawaÄ‡ siÄ™ nieznane. ChociaÅ¼ w tym rozdziale nie omÃ³wimy czasÃ³w Å¼ycia w caÅ‚oÅ›ci, to jednak przedstawimy typowe sposoby, w jakie moÅ¼na napotkaÄ‡ skÅ‚adniÄ™ czasÃ³w Å¼ycia, aby moÅ¼na byÅ‚o siÄ™ z niÄ… oswoiÄ‡.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"preventing-dangling-references-with-lifetimes\"></a>\n\n### WiszÄ…ce referencje\n\nGÅ‚Ã³wnym celem czasÃ³w Å¼ycia jest zapobieganie wiszÄ…cym referencjom, ktÃ³re, gdyby byÅ‚y dozwolone, spowodowaÅ‚yby, Å¼e program odnosiÅ‚by siÄ™ do danych innych niÅ¼ te, do ktÃ³rych miaÅ‚ siÄ™ odnosiÄ‡. RozwaÅ¼ program z Listingu 10-16, ktÃ³ry ma zasiÄ™g zewnÄ™trzny i zasiÄ™g wewnÄ™trzny.\n\n<Listing number=\"10-16\" caption=\"PrÃ³ba uÅ¼ycia referencji, ktÃ³rej wartoÅ›Ä‡ wyszÅ‚a poza zasiÄ™g\">\n\n```rust,ignore,does_not_compile\nfn main() {\n    let r;\n\n    {\n        let x = 5;\n        r = &x;\n    }\n\n    println!(\"r: {r}\");\n}\n```\n\n</Listing>\n\n> Uwaga: PrzykÅ‚ady z ListingÃ³w 10-16, 10-17 i 10-23 deklarujÄ… zmienne bez nadawania im wartoÅ›ci poczÄ…tkowej, wiÄ™c nazwa zmiennej istnieje w zasiÄ™gu zewnÄ™trznym. Na pierwszy rzut oka moÅ¼e to wydawaÄ‡ siÄ™ sprzeczne z tym, Å¼e Rust nie ma wartoÅ›ci null. JednakÅ¼e, jeÅ›li sprÃ³bujemy uÅ¼yÄ‡ zmiennej przed nadaniem jej wartoÅ›ci, otrzymamy bÅ‚Ä…d kompilacji, co pokazuje, Å¼e Rust faktycznie nie zezwala na wartoÅ›ci null.\n\nZasiÄ™g zewnÄ™trzny deklaruje zmiennÄ… `r` bez wartoÅ›ci poczÄ…tkowej, a zasiÄ™g wewnÄ™trzny deklaruje zmiennÄ… `x` z wartoÅ›ciÄ… poczÄ…tkowÄ… `5`. WewnÄ…trz zasiÄ™gu wewnÄ™trznego prÃ³bujemy ustawiÄ‡ wartoÅ›Ä‡ `r` jako referencjÄ™ do `x`. NastÄ™pnie zasiÄ™g wewnÄ™trzny koÅ„czy siÄ™, a my prÃ³bujemy wypisaÄ‡ wartoÅ›Ä‡ `r`. Ten kod nie skompiluje siÄ™, poniewaÅ¼ wartoÅ›Ä‡, do ktÃ³rej odnosi siÄ™ `r`, wyszÅ‚a poza zasiÄ™g, zanim sprÃ³bowaliÅ›my jej uÅ¼yÄ‡. Oto komunikat o bÅ‚Ä™dzie:\n\n```console\n$ cargo run\n   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0597]: `x` does not live long enough\n --> src/main.rs:6:13\n  |\n5 |         let x = 5;\n  |             - binding `x` declared here\n6 |         r = &x;\n  |             ^^ borrowed value does not live long enough\n7 |     }\n  |     - `x` dropped here while still borrowed\n8 |\n9 |     println!(\"r: {r}\");\n  |                   - borrow later used here\n\nFor more information about this error, try `rustc --explain E0597`.\nerror: could not compile `chapter10` (bin \"chapter10\") due to 1 previous error\n```\n\nKomunikat o bÅ‚Ä™dzie mÃ³wi, Å¼e zmienna `x` â€nie Å¼yje wystarczajÄ…co dÅ‚ugoâ€. Powodem jest to, Å¼e `x` wyjdzie poza zasiÄ™g, gdy zasiÄ™g wewnÄ™trzny zakoÅ„czy siÄ™ w wierszu 7. Ale `r` jest nadal waÅ¼ne dla zasiÄ™gu zewnÄ™trznego; poniewaÅ¼ jego zasiÄ™g jest wiÄ™kszy, mÃ³wimy, Å¼e â€Å¼yje dÅ‚uÅ¼ejâ€. Gdyby Rust pozwoliÅ‚ na dziaÅ‚anie tego kodu, `r` odwoÅ‚ywaÅ‚oby siÄ™ do pamiÄ™ci, ktÃ³ra zostaÅ‚a zwolniona, gdy `x` wyszÅ‚o poza zasiÄ™g, a wszystko, co prÃ³bowalibyÅ›my zrobiÄ‡ z `r`, nie dziaÅ‚aÅ‚oby poprawnie. Jak wiÄ™c Rust ustala, Å¼e ten kod jest nieprawidÅ‚owy? UÅ¼ywa sprawdzacza poÅ¼yczeÅ„.\n\n### Sprawdzacz poÅ¼yczeÅ„\n\nKompilator Rust posiada _sprawdzacz poÅ¼yczeÅ„_, ktÃ³ry porÃ³wnuje zasiÄ™gi, aby okreÅ›liÄ‡, czy wszystkie poÅ¼yczki sÄ… waÅ¼ne. Listing 10-17 przedstawia ten sam kod co Listing 10-16, ale z adnotacjami pokazujÄ…cymi czasy Å¼ycia zmiennych.\n\n<Listing number=\"10-17\" caption=\"Adnotacje czasÃ³w Å¼ycia `r` i `x`, nazwane odpowiednio `'a` i `'b`\">\n\n```rust,ignore,does_not_compile\nfn main() {\n    let r;                // ---------+-- 'a\n                          //          |\n    {                     //          |\n        let x = 5;        // -+-- 'b  |\n        r = &x;           //  |       |\n    }                     // -+       |\n                          //          |\n    println!(\"r: {r}\");   //          |\n}                         // ---------+\n```\n\n</Listing>\n\nTutaj oznaczyliÅ›my czas Å¼ycia `r` jako `'a`, a czas Å¼ycia `x` jako `'b`. Jak widaÄ‡, wewnÄ™trzny blok `'b` jest znacznie mniejszy niÅ¼ zewnÄ™trzny blok czasu Å¼ycia `'a`. W czasie kompilacji Rust porÃ³wnuje rozmiar tych dwÃ³ch czasÃ³w Å¼ycia i widzi, Å¼e `r` ma czas Å¼ycia `'a`, ale odnosi siÄ™ do pamiÄ™ci z czasem Å¼ycia `'b`. Program jest odrzucany, poniewaÅ¼ `'b` jest krÃ³tsze niÅ¼ `'a`: podmiot referencji nie Å¼yje tak dÅ‚ugo, jak sama referencja.\n\nListing 10-18 naprawia kod, tak aby nie miaÅ‚ wiszÄ…cej referencji i kompilowaÅ‚ siÄ™ bez Å¼adnych bÅ‚Ä™dÃ³w.\n\n<Listing number=\"10-18\" caption=\"PrawidÅ‚owa referencja, poniewaÅ¼ dane majÄ… dÅ‚uÅ¼szy czas Å¼ycia niÅ¼ referencja\">\n\n```rust\nfn main() {\n    let x = 5;            // ----------+-- 'b\n                          //           |\n    let r = &x;           // --+-- 'a  |\n                          //   |       |\n    println!(\"r: {r}\");   //   |       |\n                          // --+       |\n}                         // ----------+\n```\n\n</Listing>\n\nTutaj `x` ma czas Å¼ycia `'b`, ktÃ³ry w tym przypadku jest wiÄ™kszy niÅ¼ `'a`. Oznacza to, Å¼e `r` moÅ¼e odwoÅ‚ywaÄ‡ siÄ™ do `x`, poniewaÅ¼ Rust wie, Å¼e referencja w `r` zawsze bÄ™dzie waÅ¼na, dopÃ³ki `x` jest waÅ¼ne.\n\nTeraz, gdy wiesz, gdzie znajdujÄ… siÄ™ czasy Å¼ycia referencji i jak Rust analizuje czasy Å¼ycia, aby zapewniÄ‡, Å¼e referencje zawsze bÄ™dÄ… waÅ¼ne, przejdÅºmy do ogÃ³lnych czasÃ³w Å¼ycia w parametrach funkcji i wartoÅ›ciach zwracanych.\n\n### OgÃ³lne czasy Å¼ycia w funkcjach\n\nNapiszemy funkcjÄ™, ktÃ³ra zwraca dÅ‚uÅ¼szy z dwÃ³ch wycinkÃ³w ciÄ…gÃ³w znakÃ³w. Funkcja ta przyjmie dwa wycinki ciÄ…gÃ³w znakÃ³w i zwrÃ³ci pojedynczy wycinek ciÄ…gu znakÃ³w. Po zaimplementowaniu funkcji `longest`, kod z Listingu 10-19 powinien wypisaÄ‡ `The longest string is abcd`.\n\n<Listing number=\"10-19\" file-name=\"src/main.rs\" caption=\"Funkcja `main` wywoÅ‚ujÄ…ca funkcjÄ™ `longest` w celu znalezienia dÅ‚uÅ¼szego z dwÃ³ch wycinkÃ³w ciÄ…gÃ³w znakÃ³w\">\n\n```rust,ignore\nfn main() {\n    let string1 = String::from(\"abcd\");\n    let string2 = \"xyz\";\n\n    let result = longest(string1.as_str(), string2);\n    println!(\"The longest string is {result}\");\n}\n```\n\n</Listing>\n\nZauwaÅ¼, Å¼e chcemy, aby funkcja przyjmowaÅ‚a wycinki ciÄ…gÃ³w znakÃ³w, ktÃ³re sÄ… referencjami, a nie ciÄ…gami znakÃ³w, poniewaÅ¼ nie chcemy, aby funkcja `longest` przejmowaÅ‚a wÅ‚asnoÅ›Ä‡ swoich parametrÃ³w. WiÄ™cej informacji na temat tego, dlaczego parametry uÅ¼yte w Listingu 10-19 sÄ… tymi, ktÃ³rych chcemy, znajduje siÄ™ w sekcji [â€Wycinki ciÄ…gÃ³w znakÃ³w jako parametryâ€][string-slices-as-parameters]<!-- ignore --> w Rozdziale 4.\n\nJeÅ›li sprÃ³bujemy zaimplementowaÄ‡ funkcjÄ™ `longest` tak, jak pokazano w Listingu 10-20, nie skompiluje siÄ™ ona.\n\n<Listing number=\"10-20\" file-name=\"src/main.rs\" caption=\"Implementacja funkcji `longest`, ktÃ³ra zwraca dÅ‚uÅ¼szy z dwÃ³ch wycinkÃ³w ciÄ…gÃ³w znakÃ³w, ale jeszcze siÄ™ nie kompiluje\">\n\n```rust,ignore,does_not_compile\n# fn main() {\n#     let string1 = String::from(\"abcd\");\n#     let string2 = \"xyz\";\n# \n#     let result = longest(string1.as_str(), string2);\n#     println!(\"The longest string is {result}\");\n# }\n# \nfn longest(x: &str, y: &str) -> &str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n</Listing>\n\nZamiast tego otrzymujemy nastÄ™pujÄ…cy bÅ‚Ä…d, ktÃ³ry dotyczy czasÃ³w Å¼ycia:\n\n```console\n$ cargo run\n   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0106]: missing lifetime specifier\n --> src/main.rs:9:33\n  |\n9 | fn longest(x: &str, y: &str) -> &str {\n  |               ----     ----     ^ expected named lifetime parameter\n  |\n  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`\nhelp: consider introducing a named lifetime parameter\n  |\n9 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n  |           ++++     ++          ++          ++\n\nFor more information about this error, try `rustc --explain E0106`.\nerror: could not compile `chapter10` (bin \"chapter10\") due to 1 previous error\n```\n\nTekst pomocy ujawnia, Å¼e typ zwracany wymaga parametru ogÃ³lnego czasu Å¼ycia, poniewaÅ¼ Rust nie moÅ¼e okreÅ›liÄ‡, czy zwracana referencja odnosi siÄ™ do `x` czy do `y`. Tak naprawdÄ™ my teÅ¼ tego nie wiemy, poniewaÅ¼ blok `if` w ciele tej funkcji zwraca referencjÄ™ do `x`, a blok `else` zwraca referencjÄ™ do `y`!\n\nKiedy definiujemy tÄ™ funkcjÄ™, nie znamy konkretnych wartoÅ›ci, ktÃ³re zostanÄ… do niej przekazane, wiÄ™c nie wiemy, czy wykona siÄ™ przypadek `if` czy `else`. Nie znamy rÃ³wnieÅ¼ konkretnych czasÃ³w Å¼ycia referencji, ktÃ³re zostanÄ… przekazane, wiÄ™c nie moÅ¼emy spojrzeÄ‡ na zasiÄ™gi, jak to zrobiliÅ›my w Listingach 10-17 i 10-18, aby okreÅ›liÄ‡, czy zwracana referencja bÄ™dzie zawsze waÅ¼na. Sprawdzacz poÅ¼yczeÅ„ rÃ³wnieÅ¼ nie moÅ¼e tego ustaliÄ‡, poniewaÅ¼ nie wie, jak czasy Å¼ycia `x` i `y` odnoszÄ… siÄ™ do czasu Å¼ycia wartoÅ›ci zwracanej. Aby naprawiÄ‡ ten bÅ‚Ä…d, dodamy ogÃ³lne parametry czasÃ³w Å¼ycia, ktÃ³re zdefiniujÄ… relacjÄ™ miÄ™dzy referencjami, aby sprawdzacz poÅ¼yczeÅ„ mÃ³gÅ‚ przeprowadziÄ‡ swojÄ… analizÄ™.\n\n### SkÅ‚adnia adnotacji czasÃ³w Å¼ycia\n\nAdnotacje czasÃ³w Å¼ycia nie zmieniajÄ… dÅ‚ugoÅ›ci Å¼ycia Å¼adnych referencji. Raczej opisujÄ… one relacje miÄ™dzy czasami Å¼ycia wielu referencji, nie wpÅ‚ywajÄ…c na same czasy Å¼ycia. Tak jak funkcje mogÄ… przyjmowaÄ‡ dowolny typ, gdy sygnatura okreÅ›la ogÃ³lny parametr typu, tak samo funkcje mogÄ… przyjmowaÄ‡ referencje z dowolnym czasem Å¼ycia, okreÅ›lajÄ…c ogÃ³lny parametr czasu Å¼ycia.\n\nAdnotacje czasÃ³w Å¼ycia majÄ… nieco nietypowÄ… skÅ‚adniÄ™: nazwy parametrÃ³w czasu Å¼ycia muszÄ… zaczynaÄ‡ siÄ™ od apostrofu (`'`) i zazwyczaj sÄ… maÅ‚ymi literami i bardzo krÃ³tkie, podobnie jak typy ogÃ³lne. WiÄ™kszoÅ›Ä‡ ludzi uÅ¼ywa nazwy `'a` dla pierwszej adnotacji czasu Å¼ycia. Adnotacje parametrÃ³w czasu Å¼ycia umieszczamy po `&` referencji, uÅ¼ywajÄ…c spacji do oddzielenia adnotacji od typu referencji.\n\nOto kilka przykÅ‚adÃ³w â€“ referencja do `i32` bez parametru czasu Å¼ycia, referencja do `i32` z parametrem czasu Å¼ycia o nazwie `'a`, oraz zmienna referencja do `i32`, ktÃ³ra rÃ³wnieÅ¼ ma czas Å¼ycia `'a`:\n\n```rust,ignore\n&i32        // referencja\n&'a i32     // referencja z jawnym czasem Å¼ycia\n&'a mut i32 // zmienna referencja z jawnym czasem Å¼ycia\n```\n\nJedna adnotacja czasu Å¼ycia sama w sobie nie ma wiÄ™kszego znaczenia, poniewaÅ¼ adnotacje majÄ… na celu poinformowanie Rust, jak ogÃ³lne parametry czasu Å¼ycia wielu referencji odnoszÄ… siÄ™ do siebie. Przyjrzyjmy siÄ™, jak adnotacje czasu Å¼ycia odnoszÄ… siÄ™ do siebie w kontekÅ›cie funkcji `longest`.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"lifetime-annotations-in-function-signatures\"></a>\n\n### W sygnaturach funkcji\n\nAby uÅ¼ywaÄ‡ adnotacji czasÃ³w Å¼ycia w sygnaturach funkcji, musimy zadeklarowaÄ‡ ogÃ³lne parametry czasÃ³w Å¼ycia w nawiasach kÄ…towych miÄ™dzy nazwÄ… funkcji a listÄ… parametrÃ³w, tak jak robiliÅ›my to z ogÃ³lnymi parametrami typÃ³w.\n\nChcemy, aby sygnatura wyraÅ¼aÅ‚a nastÄ™pujÄ…ce ograniczenie: zwracana referencja bÄ™dzie waÅ¼na tak dÅ‚ugo, jak dÅ‚ugo oba parametry sÄ… waÅ¼ne. Jest to relacja miÄ™dzy czasami Å¼ycia parametrÃ³w a wartoÅ›ciÄ… zwracanÄ…. Nazwiemy czas Å¼ycia `'a`, a nastÄ™pnie dodamy go do kaÅ¼dej referencji, jak pokazano w Listingu 10-21.\n\n<Listing number=\"10-21\" file-name=\"src/main.rs\" caption=\"Definicja funkcji `longest` okreÅ›lajÄ…ca, Å¼e wszystkie referencje w sygnaturze muszÄ… mieÄ‡ ten sam czas Å¼ycia `'a`\">\n\n```rust\n# fn main() {\n#     let string1 = String::from(\"abcd\");\n#     let string2 = \"xyz\";\n# \n#     let result = longest(string1.as_str(), string2);\n#     println!(\"The longest string is {result}\");\n# }\n# \nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n</Listing>\n\nTen kod powinien siÄ™ skompilowaÄ‡ i daÄ‡ poÅ¼Ä…dany rezultat, gdy uÅ¼yjemy go z funkcjÄ… `main` z Listingu 10-19.\n\nSygnatura funkcji informuje teraz Rust, Å¼e dla pewnego czasu Å¼ycia `'a`, funkcja przyjmuje dwa parametry, z ktÃ³rych oba sÄ… wycinkami ciÄ…gÃ³w znakÃ³w, ktÃ³re Å¼yjÄ… co najmniej tak dÅ‚ugo, jak czas Å¼ycia `'a`. Sygnatura funkcji informuje rÃ³wnieÅ¼ Rust, Å¼e wycinek ciÄ…gu znakÃ³w zwrÃ³cony z funkcji bÄ™dzie Å¼yÅ‚ co najmniej tak dÅ‚ugo, jak czas Å¼ycia `'a`. W praktyce oznacza to, Å¼e czas Å¼ycia referencji zwrÃ³conej przez funkcjÄ™ `longest` jest taki sam, jak krÃ³tszy z czasÃ³w Å¼ycia wartoÅ›ci, do ktÃ³rych odwoÅ‚ujÄ… siÄ™ argumenty funkcji. Te relacje to to, czego chcemy, aby Rust uÅ¼ywaÅ‚ podczas analizy tego kodu.\n\nPamiÄ™taj, Å¼e kiedy okreÅ›lamy parametry czasu Å¼ycia w sygnaturze tej funkcji, nie zmieniamy czasÃ³w Å¼ycia Å¼adnych wartoÅ›ci przekazanych ani zwracanych. Raczej okreÅ›lamy, Å¼e sprawdzacz poÅ¼yczeÅ„ powinien odrzuciÄ‡ wszelkie wartoÅ›ci, ktÃ³re nie przestrzegajÄ… tych ograniczeÅ„. ZauwaÅ¼, Å¼e funkcja `longest` nie musi dokÅ‚adnie wiedzieÄ‡, jak dÅ‚ugo bÄ™dÄ… Å¼yÅ‚y `x` i `y`, tylko Å¼e pewien zasiÄ™g moÅ¼e zostaÄ‡ podstawiony za `'a`, ktÃ³ry speÅ‚ni tÄ™ sygnaturÄ™.\n\nPodczas adnotowania czasÃ³w Å¼ycia w funkcjach, adnotacje umieszcza siÄ™ w sygnaturze funkcji, a nie w jej ciele. Adnotacje czasÃ³w Å¼ycia stajÄ… siÄ™ czÄ™Å›ciÄ… kontraktu funkcji, podobnie jak typy w sygnaturze. Posiadanie sygnatur funkcji zawierajÄ…cych kontrakt czasÃ³w Å¼ycia oznacza, Å¼e analiza wykonywana przez kompilator Rust moÅ¼e byÄ‡ prostsza. JeÅ›li wystÄ…pi problem z adnotacjÄ… funkcji lub sposobem jej wywoÅ‚ania, bÅ‚Ä™dy kompilatora mogÄ… wskazaÄ‡ precyzyjniej na czÄ™Å›Ä‡ naszego kodu i ograniczenia. Gdyby kompilator Rust wyciÄ…gaÅ‚ wiÄ™cej wnioskÃ³w na temat tego, jakie relacje czasÃ³w Å¼ycia zamierzaliÅ›my, kompilator mÃ³gÅ‚by wskazaÄ‡ tylko na uÅ¼ycie naszego kodu wiele krokÃ³w od przyczyny problemu.\n\nKiedy przekazujemy konkretne referencje do `longest`, konkretny czas Å¼ycia, ktÃ³ry jest podstawiany za `'a`, to czÄ™Å›Ä‡ zasiÄ™gu `x`, ktÃ³ra nakÅ‚ada siÄ™ na zasiÄ™g `y`. Innymi sÅ‚owy, ogÃ³lny czas Å¼ycia `'a` przyjmie konkretny czas Å¼ycia, ktÃ³ry jest rÃ³wny krÃ³tszemu z czasÃ³w Å¼ycia `x` i `y`. PoniewaÅ¼ oznaczyliÅ›my zwracanÄ… referencjÄ™ tym samym parametrem czasu Å¼ycia `'a`, zwracana referencja bÄ™dzie rÃ³wnieÅ¼ waÅ¼na przez czas trwania krÃ³tszego z czasÃ³w Å¼ycia `x` i `y`.\n\nPrzyjrzyjmy siÄ™, jak adnotacje czasÃ³w Å¼ycia ograniczajÄ… funkcjÄ™ `longest` poprzez przekazywanie referencji, ktÃ³re majÄ… rÃ³Å¼ne konkretne czasy Å¼ycia. Listing 10-22 to prosty przykÅ‚ad.\n\n<Listing number=\"10-22\" file-name=\"src/main.rs\" caption=\"UÅ¼ywanie funkcji `longest` z referencjami do wartoÅ›ci `String`, ktÃ³re majÄ… rÃ³Å¼ne konkretne czasy Å¼ycia\">\n\n```rust\nfn main() {\n    let string1 = String::from(\"long string is long\");\n\n    {\n        let string2 = String::from(\"xyz\");\n        let result = longest(string1.as_str(), string2.as_str());\n        println!(\"The longest string is {result}\");\n    }\n}\n# \n# fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n#     if x.len() > y.len() { x } else { y }\n# }\n```\n\n</Listing>\n\nW tym przykÅ‚adzie `string1` jest waÅ¼ne do koÅ„ca zewnÄ™trznego zasiÄ™gu, `string2` jest waÅ¼ne do koÅ„ca wewnÄ™trznego zasiÄ™gu, a `result` odwoÅ‚uje siÄ™ do czegoÅ›, co jest waÅ¼ne do koÅ„ca wewnÄ™trznego zasiÄ™gu. Uruchom ten kod, a zobaczysz, Å¼e sprawdzacz poÅ¼yczeÅ„ zatwierdza; skompiluje siÄ™ i wypisze `The longest string is long string is long`.\n\nNastÄ™pnie sprÃ³bujmy przykÅ‚adu, ktÃ³ry pokazuje, Å¼e czas Å¼ycia referencji w `result` musi byÄ‡ krÃ³tszym czasem Å¼ycia z dwÃ³ch argumentÃ³w. Przeniesiemy deklaracjÄ™ zmiennej `result` poza zasiÄ™g wewnÄ™trzny, ale pozostawimy przypisanie wartoÅ›ci do zmiennej `result` wewnÄ…trz zasiÄ™gu z `string2`. NastÄ™pnie przeniesiemy `println!`, ktÃ³re uÅ¼ywa `result`, poza zasiÄ™g wewnÄ™trzny, po zakoÅ„czeniu zasiÄ™gu wewnÄ™trznego. Kod z Listingu 10-23 nie skompiluje siÄ™.\n\n<Listing number=\"10-23\" file-name=\"src/main.rs\" caption=\"PrÃ³ba uÅ¼ycia `result` po tym, jak `string2` wyszÅ‚o poza zasiÄ™g\">\n\n```rust,ignore,does_not_compile\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = String::from(\"xyz\");\n        result = longest(string1.as_str(), string2.as_str());\n    }\n    println!(\"The longest string is {result}\");\n}\n# \n# fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n#     if x.len() > y.len() { x } else { y }\n# }\n```\n\n</Listing>\n\nKiedy prÃ³bujemy skompilowaÄ‡ ten kod, otrzymujemy nastÄ™pujÄ…cy bÅ‚Ä…d:\n\n```console\n$ cargo run\n   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0597]: `string2` does not live long enough\n --> src/main.rs:6:44\n  |\n5 |         let string2 = String::from(\"xyz\");\n  |             ------- binding `string2` declared here\n6 |         result = longest(string1.as_str(), string2.as_str());\n  |                                            ^^^^^^^ borrowed value does not live long enough\n7 |     }\n  |     - `string2` dropped here while still borrowed\n8 |     println!(\"The longest string is {result}\");\n  |                                      ------ borrow later used here\n\nFor more information about this error, try `rustc --explain E0597`.\nerror: could not compile `chapter10` (bin \"chapter10\") due to 1 previous error\n```\n\nBÅ‚Ä…d pokazuje, Å¼e aby `result` byÅ‚o waÅ¼ne dla instrukcji `println!`, `string2` musiaÅ‚oby byÄ‡ waÅ¼ne do koÅ„ca zasiÄ™gu zewnÄ™trznego. Rust wie o tym, poniewaÅ¼ oznaczyliÅ›my czasy Å¼ycia parametrÃ³w funkcji i wartoÅ›ci zwracanych, uÅ¼ywajÄ…c tego samego parametru czasu Å¼ycia `'a`.\n\nJako ludzie, moÅ¼emy spojrzeÄ‡ na ten kod i zobaczyÄ‡, Å¼e `string1` jest dÅ‚uÅ¼sze niÅ¼ `string2`, a zatem `result` bÄ™dzie zawieraÄ‡ referencjÄ™ do `string1`. PoniewaÅ¼ `string1` nie wyszÅ‚o jeszcze poza zasiÄ™g, referencja do `string1` bÄ™dzie nadal waÅ¼na dla instrukcji `println!`. Jednak kompilator nie widzi, Å¼e referencja jest waÅ¼na w tym przypadku. PowiedzieliÅ›my Rust, Å¼e czas Å¼ycia referencji zwrÃ³conej przez funkcjÄ™ `longest` jest taki sam, jak krÃ³tszy z czasÃ³w Å¼ycia referencji przekazanych. Dlatego sprawdzacz poÅ¼yczeÅ„ nie zezwala na kod z Listingu 10-23, poniewaÅ¼ moÅ¼e on zawieraÄ‡ nieprawidÅ‚owÄ… referencjÄ™.\n\nSprÃ³buj zaprojektowaÄ‡ wiÄ™cej eksperymentÃ³w, ktÃ³re zmieniajÄ… wartoÅ›ci i czasy Å¼ycia referencji przekazywanych do funkcji `longest` oraz sposÃ³b uÅ¼ycia zwrÃ³conej referencji. Postaw hipotezy, czy Twoje eksperymenty przejdÄ… sprawdzacz poÅ¼yczeÅ„, zanim skompilujesz; nastÄ™pnie sprawdÅº, czy masz racjÄ™!\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"thinking-in-terms-of-lifetimes\"></a>\n\n### Relacje\n\nSposÃ³b, w jaki musisz okreÅ›liÄ‡ parametry czasu Å¼ycia, zaleÅ¼y od tego, co robi twoja funkcja. Na przykÅ‚ad, gdybyÅ›my zmienili implementacjÄ™ funkcji `longest` tak, aby zawsze zwracaÅ‚a pierwszy parametr zamiast najdÅ‚uÅ¼szego wycinka ciÄ…gu znakÃ³w, nie musielibyÅ›my okreÅ›laÄ‡ czasu Å¼ycia dla parametru `y`. PoniÅ¼szy kod skompiluje siÄ™:\n\n<Listing file-name=\"src/main.rs\">\n\n```rust\n# fn main() {\n#     let string1 = String::from(\"abcd\");\n#     let string2 = \"efghijklmnopqrstuvwxyz\";\n# \n#     let result = longest(string1.as_str(), string2);\n#     println!(\"The longest string is {result}\");\n# }\n# \nfn longest<'a>(x: &'a str, y: &str) -> &'a str {\n    x\n}\n```\n\n</Listing>\n\nOkreÅ›liliÅ›my parametr czasu Å¼ycia `'a` dla parametru `x` i typu zwracanego, ale nie dla parametru `y`, poniewaÅ¼ czas Å¼ycia `y` nie ma Å¼adnego zwiÄ…zku z czasem Å¼ycia `x` ani wartoÅ›ciÄ… zwracanÄ….\n\nPodczas zwracania referencji z funkcji, parametr czasu Å¼ycia dla typu zwracanego musi odpowiadaÄ‡ parametrowi czasu Å¼ycia jednego z parametrÃ³w. JeÅ›li zwracana referencja _nie_ odnosi siÄ™ do jednego z parametrÃ³w, musi odnosiÄ‡ siÄ™ do wartoÅ›ci utworzonej wewnÄ…trz tej funkcji. ByÅ‚aby to jednak wiszÄ…ca referencja, poniewaÅ¼ wartoÅ›Ä‡ wyjdzie poza zasiÄ™g na koÅ„cu funkcji. RozwaÅ¼ tÄ™ prÃ³bÄ™ implementacji funkcji `longest`, ktÃ³ra siÄ™ nie skompiluje:\n\n<Listing file-name=\"src/main.rs\">\n\n```rust,ignore,does_not_compile\n# fn main() {\n#     let string1 = String::from(\"abcd\");\n#     let string2 = \"xyz\";\n# \n#     let result = longest(string1.as_str(), string2);\n#     println!(\"The longest string is {result}\");\n# }\n# \nfn longest<'a>(x: &str, y: &str) -> &'a str {\n    let result = String::from(\"really long string\");\n    result.as_str()\n}\n```\n\n</Listing>\n\nTutaj, mimo Å¼e okreÅ›liliÅ›my parametr czasu Å¼ycia `'a` dla typu zwracanego, ta implementacja nie skompiluje siÄ™, poniewaÅ¼ czas Å¼ycia wartoÅ›ci zwracanej nie jest w ogÃ³le powiÄ…zany z czasem Å¼ycia parametrÃ³w. Oto komunikat o bÅ‚Ä™dzie, ktÃ³ry otrzymujemy:\n\n```console\n$ cargo run\n   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0515]: cannot return value referencing local variable `result`\n  --> src/main.rs:11:5\n   |\n11 |     result.as_str()\n   |     ------^^^^^^^^^\n   |     |\n   |     returns a value referencing data owned by the current function\n   |     `result` is borrowed here\n\nFor more information about this error, try `rustc --explain E0515`.\nerror: could not compile `chapter10` (bin \"chapter10\") due to 1 previous error\n```\n\nProblem polega na tym, Å¼e `result` wychodzi poza zasiÄ™g i zostaje oczyszczone na koÅ„cu funkcji `longest`. PrÃ³bujemy rÃ³wnieÅ¼ zwrÃ³ciÄ‡ referencjÄ™ do `result` z funkcji. Nie ma sposobu, abyÅ›my mogli okreÅ›liÄ‡ parametry czasu Å¼ycia, ktÃ³re zmieniÅ‚yby wiszÄ…cÄ… referencjÄ™, a Rust nie pozwoli nam na utworzenie wiszÄ…cej referencji. W tym przypadku najlepszym rozwiÄ…zaniem byÅ‚oby zwrÃ³cenie wÅ‚asnego typu danych zamiast referencji, tak aby funkcja wywoÅ‚ujÄ…ca byÅ‚a odpowiedzialna za oczyszczenie wartoÅ›ci.\n\nOstatecznie skÅ‚adnia czasÃ³w Å¼ycia sÅ‚uÅ¼y do Å‚Ä…czenia czasÃ³w Å¼ycia rÃ³Å¼nych parametrÃ³w i wartoÅ›ci zwracanych funkcji. Po ich poÅ‚Ä…czeniu Rust ma wystarczajÄ…ce informacje, aby zezwalaÄ‡ na operacje bezpieczne dla pamiÄ™ci i odrzucaÄ‡ operacje, ktÃ³re mogÅ‚yby stworzyÄ‡ wiszÄ…ce wskaÅºniki lub w inny sposÃ³b naruszyÄ‡ bezpieczeÅ„stwo pamiÄ™ci.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"lifetime-annotations-in-struct-definitions\"></a>\n\n### W definicjach struktur\n\nDotychczasowe struktury, ktÃ³re zdefiniowaliÅ›my, zawsze przechowywaÅ‚y typy posiadane. MoÅ¼emy zdefiniowaÄ‡ struktury, ktÃ³re przechowujÄ… referencje, ale w takim przypadku musielibyÅ›my dodaÄ‡ adnotacjÄ™ czasu Å¼ycia do kaÅ¼dej referencji w definicji struktury. Listing 10-24 przedstawia strukturÄ™ o nazwie `ImportantExcerpt`, ktÃ³ra przechowuje wycinek ciÄ…gu znakÃ³w.\n\n<Listing number=\"10-24\" file-name=\"src/main.rs\" caption=\"Struktura, ktÃ³ra przechowuje referencjÄ™, wymagajÄ…ca adnotacji czasu Å¼ycia\">\n\n```rust\nstruct ImportantExcerpt<'a> {\n    part: &'a str,\n}\n\nfn main() {\n    let novel = String::from(\"Call me Ishmael. Some years ago...\");\n    let first_sentence = novel.split('.').next().unwrap();\n    let i = ImportantExcerpt {\n        part: first_sentence,\n    };\n}\n```\n\n</Listing>\n\nTa struktura ma jedno pole `part`, ktÃ³re przechowuje wycinek ciÄ…gu znakÃ³w, czyli referencjÄ™. Podobnie jak w przypadku ogÃ³lnych typÃ³w danych, nazwÄ™ ogÃ³lnego parametru czasu Å¼ycia deklarujemy w nawiasach kÄ…towych po nazwie struktury, abyÅ›my mogli uÅ¼yÄ‡ parametru czasu Å¼ycia w ciele definicji struktury. Ta adnotacja oznacza, Å¼e instancja `ImportantExcerpt` nie moÅ¼e przeÅ¼yÄ‡ referencji, ktÃ³rÄ… przechowuje w swoim polu `part`.\n\nFunkcja `main` tworzy tutaj instancjÄ™ struktury `ImportantExcerpt`, ktÃ³ra przechowuje referencjÄ™ do pierwszego zdania `String` bÄ™dÄ…cego wÅ‚asnoÅ›ciÄ… zmiennej `novel`. Dane w `novel` istniejÄ… przed utworzeniem instancji `ImportantExcerpt`. Ponadto `novel` nie wychodzi poza zasiÄ™g, dopÃ³ki `ImportantExcerpt` nie wyjdzie poza zasiÄ™g, wiÄ™c referencja w instancji `ImportantExcerpt` jest waÅ¼na.\n\n### Elizja czasÃ³w Å¼ycia\n\nDowiedziaÅ‚eÅ› siÄ™, Å¼e kaÅ¼da referencja ma czas Å¼ycia i Å¼e musisz okreÅ›liÄ‡ parametry czasu Å¼ycia dla funkcji lub struktur, ktÃ³re uÅ¼ywajÄ… referencji. Jednak w Listingu 4-9 mieliÅ›my funkcjÄ™, ponownie pokazanÄ… w Listingu 10-25, ktÃ³ra kompilowaÅ‚a siÄ™ bez adnotacji czasÃ³w Å¼ycia.\n\n<Listing number=\"10-25\" file-name=\"src/lib.rs\" caption=\"Funkcja, ktÃ³rÄ… zdefiniowaliÅ›my w Listingu 4-9, skompilowaÅ‚a siÄ™ bez adnotacji czasÃ³w Å¼ycia, mimo Å¼e parametr i typ zwracany sÄ… referencjami\">\n\n```rust\nfn first_word(s: &str) -> &str {\n    let bytes = s.as_bytes();\n\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &s[0..i];\n        }\n    }\n\n    &s[..]\n}\n# \n# fn main() {\n#     let my_string = String::from(\"hello world\");\n# \n#     // first_word works on slices of `String`s\n#     let word = first_word(&my_string[..]);\n# \n#     let my_string_literal = \"hello world\";\n# \n#     // first_word works on slices of string literals\n#     let word = first_word(&my_string_literal[..]);\n# \n#     // Because string literals *are* string slices already,\n#     // this works too, without the slice syntax!\n#     let word = first_word(my_string_literal);\n# }\n```\n\n</Listing>\n\nPowodem, dla ktÃ³rego ta funkcja kompiluje siÄ™ bez adnotacji czasÃ³w Å¼ycia, jest historia: we wczesnych wersjach (przed 1.0) Rust, ten kod by siÄ™ nie skompilowaÅ‚, poniewaÅ¼ kaÅ¼da referencja wymagaÅ‚a jawnego czasu Å¼ycia. W tamtym czasie sygnatura funkcji byÅ‚aby napisana tak:\n\n```rust,ignore\nfn first_word<'a>(s: &'a str) -> &'a str {\n```\n\nPo napisaniu duÅ¼ej iloÅ›ci kodu w Rust, zespÃ³Å‚ Rust odkryÅ‚, Å¼e programiÅ›ci Rust wpisywali te same adnotacje czasÃ³w Å¼ycia wielokrotnie w konkretnych sytuacjach. Sytuacje te byÅ‚y przewidywalne i postÄ™powaÅ‚y zgodnie z kilkoma deterministycznymi wzorcami. Deweloperzy zaprogramowali te wzorce w kodzie kompilatora, aby sprawdzacz poÅ¼yczeÅ„ mÃ³gÅ‚ wnioskowaÄ‡ o czasach Å¼ycia w tych sytuacjach i nie potrzebowaÅ‚ jawnych adnotacji.\n\nTen kawaÅ‚ek historii Rust jest istotny, poniewaÅ¼ moÅ¼liwe jest, Å¼e pojawi siÄ™ wiÄ™cej deterministycznych wzorcÃ³w i zostanie dodanych do kompilatora. W przyszÅ‚oÅ›ci moÅ¼e byÄ‡ wymagane jeszcze mniej adnotacji czasÃ³w Å¼ycia.\n\nWzorce zaprogramowane w analizie referencji przez Rust nazywane sÄ… _zasadami elizji czasÃ³w Å¼ycia_. Nie sÄ… to zasady, ktÃ³rymi programiÅ›ci majÄ… siÄ™ kierowaÄ‡; to zbiÃ³r konkretnych przypadkÃ³w, ktÃ³re kompilator weÅºmie pod uwagÄ™, a jeÅ›li twÃ³j kod pasuje do tych przypadkÃ³w, nie musisz jawnie pisaÄ‡ czasÃ³w Å¼ycia.\n\nZasady elizji nie zapewniajÄ… peÅ‚nego wnioskowania. JeÅ›li po zastosowaniu zasad nadal istnieje niejasnoÅ›Ä‡ co do czasÃ³w Å¼ycia referencji, kompilator nie zgadnie, jakie powinny byÄ‡ czasy Å¼ycia pozostaÅ‚ych referencji. Zamiast zgadywaÄ‡, kompilator wyÅ›wietli bÅ‚Ä…d, ktÃ³ry moÅ¼na rozwiÄ…zaÄ‡, dodajÄ…c adnotacje czasÃ³w Å¼ycia.\n\nCzasy Å¼ycia na parametrach funkcji lub metod nazywane sÄ… _czasami Å¼ycia wejÅ›ciowymi_, a czasy Å¼ycia na wartoÅ›ciach zwracanych nazywane sÄ… _czasami Å¼ycia wyjÅ›ciowymi_.\n\nKompilator uÅ¼ywa trzech zasad, aby ustaliÄ‡ czasy Å¼ycia referencji, gdy nie ma jawnych adnotacji. Pierwsza zasada dotyczy czasÃ³w Å¼ycia wejÅ›ciowych, a druga i trzecia zasada dotyczÄ… czasÃ³w Å¼ycia wyjÅ›ciowych. JeÅ›li kompilator dojdzie do koÅ„ca trzech zasad, a nadal istniejÄ… referencje, dla ktÃ³rych nie moÅ¼e ustaliÄ‡ czasÃ³w Å¼ycia, kompilator zatrzyma siÄ™ z bÅ‚Ä™dem. Zasady te majÄ… zastosowanie zarÃ³wno do definicji `fn`, jak i blokÃ³w `impl`.\n\nPierwsza zasada mÃ³wi, Å¼e kompilator przypisuje parametr czasu Å¼ycia kaÅ¼demu parametrowi, ktÃ³ry jest referencjÄ…. Innymi sÅ‚owy, funkcja z jednym parametrem otrzymuje jeden parametr czasu Å¼ycia: `fn foo<'a>(x: &'a i32)`; funkcja z dwoma parametrami otrzymuje dwa oddzielne parametry czasu Å¼ycia: `fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`; i tak dalej.\n\nDruga zasada mÃ³wi, Å¼e jeÅ›li istnieje dokÅ‚adnie jeden parametr czasu Å¼ycia wejÅ›ciowego, to ten czas Å¼ycia jest przypisywany do wszystkich parametrÃ³w czasu Å¼ycia wyjÅ›ciowego: `fn foo<'a>(x: &'a i32) -> &'a i32`.\n\nTrzecia zasada mÃ³wi, Å¼e jeÅ›li istnieje wiele parametrÃ³w czasu Å¼ycia wejÅ›ciowego, ale jeden z nich to `&self` lub `&mut self`, poniewaÅ¼ jest to metoda, czas Å¼ycia `self` jest przypisywany do wszystkich parametrÃ³w czasu Å¼ycia wyjÅ›ciowego. Ta trzecia zasada sprawia, Å¼e metody sÄ… znacznie przyjemniejsze w czytaniu i pisaniu, poniewaÅ¼ potrzeba mniej symboli.\n\nUdawajmy, Å¼e jesteÅ›my kompilatorem. Zastosujemy te zasady, aby ustaliÄ‡ czasy Å¼ycia referencji w sygnaturze funkcji `first_word` z Listingu 10-25. Sygnatura zaczyna siÄ™ bez Å¼adnych czasÃ³w Å¼ycia przypisanych do referencji:\n\n```rust,ignore\nfn first_word(s: &str) -> &str {\n```\n\nNastÄ™pnie kompilator stosuje pierwszÄ… zasadÄ™, ktÃ³ra okreÅ›la, Å¼e kaÅ¼dy parametr otrzymuje swÃ³j wÅ‚asny czas Å¼ycia. Nazwiemy go jak zwykle `'a`, wiÄ™c sygnatura wyglÄ…da teraz tak:\n\n```rust,ignore\nfn first_word<'a>(s: &'a str) -> &str {\n```\n\nDruga zasada ma zastosowanie, poniewaÅ¼ istnieje dokÅ‚adnie jeden czas Å¼ycia wejÅ›ciowego. Druga zasada okreÅ›la, Å¼e czas Å¼ycia jednego parametru wejÅ›ciowego jest przypisywany do czasu Å¼ycia wyjÅ›ciowego, wiÄ™c sygnatura wyglÄ…da teraz tak:\n\n```rust,ignore\nfn first_word<'a>(s: &'a str) -> &'a str {\n```\n\nTeraz wszystkie referencje w sygnaturze tej funkcji majÄ… czasy Å¼ycia, a kompilator moÅ¼e kontynuowaÄ‡ swojÄ… analizÄ™ bez potrzeby, aby programista adnotowaÅ‚ czasy Å¼ycia w sygnaturze tej funkcji.\n\nPrzyjrzyjmy siÄ™ innemu przykÅ‚adowi, tym razem uÅ¼ywajÄ…c funkcji `longest`, ktÃ³ra nie miaÅ‚a parametrÃ³w czasu Å¼ycia, kiedy zaczÄ™liÅ›my z niÄ… pracowaÄ‡ w Listingu 10-20:\n\n```rust,ignore\nfn longest(x: &str, y: &str) -> &str {\n```\n\nZastosujmy pierwszÄ… zasadÄ™: kaÅ¼dy parametr otrzymuje swÃ³j wÅ‚asny czas Å¼ycia. Tym razem mamy dwa parametry zamiast jednego, wiÄ™c mamy dwa czasy Å¼ycia:\n\n```rust,ignore\nfn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {\n```\n\nWidzisz, Å¼e druga zasada nie ma zastosowania, poniewaÅ¼ istnieje wiÄ™cej niÅ¼ jeden czas Å¼ycia wejÅ›ciowego. Trzecia zasada rÃ³wnieÅ¼ nie ma zastosowania, poniewaÅ¼ `longest` jest funkcjÄ…, a nie metodÄ…, wiÄ™c Å¼aden z parametrÃ³w nie jest `self`. Po przejÅ›ciu przez wszystkie trzy zasady, nadal nie ustaliliÅ›my, jaki jest czas Å¼ycia typu zwracanego. Dlatego otrzymaliÅ›my bÅ‚Ä…d podczas prÃ³by kompilacji kodu z Listingu 10-20: kompilator przeanalizowaÅ‚ zasady elizji czasÃ³w Å¼ycia, ale nadal nie byÅ‚ w stanie ustaliÄ‡ wszystkich czasÃ³w Å¼ycia referencji w sygnaturze.\n\nPoniewaÅ¼ trzecia zasada dotyczy tak naprawdÄ™ tylko sygnatur metod, przyjrzyjmy siÄ™ teraz czasom Å¼ycia w tym kontekÅ›cie, aby zobaczyÄ‡, dlaczego trzecia zasada oznacza, Å¼e nie musimy zbyt czÄ™sto adnotowaÄ‡ czasÃ³w Å¼ycia w sygnaturach metod.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"lifetime-annotations-in-method-definitions\"></a>\n\n### W definicjach metod\n\nKiedy implementujemy metody w strukturze z czasami Å¼ycia, uÅ¼ywamy tej samej skÅ‚adni co w przypadku ogÃ³lnych parametrÃ³w typÃ³w, jak pokazano w Listingu 10-11. Gdzie deklarujemy i uÅ¼ywamy parametrÃ³w czasu Å¼ycia, zaleÅ¼y od tego, czy sÄ… one zwiÄ…zane z polami struktury, czy z parametrami metody i wartoÅ›ciami zwracanymi.\n\nNazwy czasÃ³w Å¼ycia dla pÃ³l struktury zawsze muszÄ… byÄ‡ deklarowane po sÅ‚owie kluczowym `impl`, a nastÄ™pnie uÅ¼ywane po nazwie struktury, poniewaÅ¼ te czasy Å¼ycia sÄ… czÄ™Å›ciÄ… typu struktury.\n\nW sygnaturach metod w bloku `impl`, referencje mogÄ… byÄ‡ powiÄ…zane z czasem Å¼ycia referencji w polach struktury, lub mogÄ… byÄ‡ niezaleÅ¼ne. Ponadto, zasady elizji czasÃ³w Å¼ycia czÄ™sto powodujÄ…, Å¼e adnotacje czasÃ³w Å¼ycia nie sÄ… konieczne w sygnaturach metod. Przyjrzyjmy siÄ™ kilku przykÅ‚adom, uÅ¼ywajÄ…c struktury `ImportantExcerpt`, ktÃ³rÄ… zdefiniowaliÅ›my w Listingu 10-24.\n\nNajpierw uÅ¼yjemy metody o nazwie `level`, ktÃ³rej jedynym parametrem jest referencja do `self`, a zwracana wartoÅ›Ä‡ to `i32`, ktÃ³ra nie jest referencjÄ… do niczego:\n\n```rust\n# struct ImportantExcerpt<'a> {\n#     part: &'a str,\n# }\n# \nimpl<'a> ImportantExcerpt<'a> {\n    fn level(&self) -> i32 {\n        3\n    }\n}\n# \n# impl<'a> ImportantExcerpt<'a> {\n#     fn announce_and_return_part(&self, announcement: &str) -> &str {\n#         println!(\"Attention please: {announcement}\");\n#         self.part\n#     }\n# }\n# \n# fn main() {\n#     let novel = String::from(\"Call me Ishmael. Some years ago...\");\n#     let first_sentence = novel.split('.').next().unwrap();\n#     let i = ImportantExcerpt {\n#         part: first_sentence,\n#     };\n# }\n```\n\nDeklaracja parametru czasu Å¼ycia po `impl` i jego uÅ¼ycie po nazwie typu sÄ… wymagane, ale ze wzglÄ™du na pierwszÄ… zasadÄ™ elizji, nie musimy adnotowaÄ‡ czasu Å¼ycia referencji do `self`.\n\nOto przykÅ‚ad, w ktÃ³rym ma zastosowanie trzecia zasada elizji czasu Å¼ycia:\n\n```rust\n# struct ImportantExcerpt<'a> {\n#     part: &'a str,\n# }\n# \n# impl<'a> ImportantExcerpt<'a> {\n#     fn level(&self) -> i32 {\n#         3\n#     }\n# }\n# \nimpl<'a> ImportantExcerpt<'a> {\n    fn announce_and_return_part(&self, announcement: &str) -> &str {\n        println!(\"Attention please: {announcement}\");\n        self.part\n    }\n}\n# \n# fn main() {\n#     let novel = String::from(\"Call me Ishmael. Some years ago...\");\n#     let first_sentence = novel.split('.').next().unwrap();\n#     let i = ImportantExcerpt {\n#         part: first_sentence,\n#     };\n# }\n```\n\nIstniejÄ… dwa wejÅ›ciowe czasy Å¼ycia, wiÄ™c Rust stosuje pierwszÄ… zasadÄ™ elizji czasu Å¼ycia i nadaje zarÃ³wno `&self`, jak i `announcement` ich wÅ‚asne czasy Å¼ycia. NastÄ™pnie, poniewaÅ¼ jeden z parametrÃ³w to `&self`, typ zwracany otrzymuje czas Å¼ycia `&self`, a wszystkie czasy Å¼ycia zostaÅ‚y uwzglÄ™dnione.\n\n### Statyczny czas Å¼ycia\n\nJeden specjalny czas Å¼ycia, o ktÃ³rym musimy porozmawiaÄ‡, to `'static`, ktÃ³ry oznacza, Å¼e dotkniÄ™ta referencja _moÅ¼e_ Å¼yÄ‡ przez caÅ‚y czas trwania programu. Wszystkie literaÅ‚y ciÄ…gÃ³w znakÃ³w majÄ… czas Å¼ycia `'static`, ktÃ³ry moÅ¼emy adnotowaÄ‡ w nastÄ™pujÄ…cy sposÃ³b:\n\n```rust\nlet s: &'static str = \"I have a static lifetime.\";\n```\n\nTekst tego ciÄ…gu znakÃ³w jest przechowywany bezpoÅ›rednio w pliku binarnym programu, ktÃ³ry jest zawsze dostÄ™pny. Dlatego czas Å¼ycia wszystkich literaÅ‚Ã³w ciÄ…gÃ³w znakÃ³w jest `'static`.\n\nMoÅ¼esz zobaczyÄ‡ sugestie w komunikatach o bÅ‚Ä™dach, aby uÅ¼yÄ‡ czasu Å¼ycia `'static`. Ale zanim okreÅ›lisz `'static` jako czas Å¼ycia dla referencji, zastanÃ³w siÄ™, czy referencja, ktÃ³rÄ… masz, faktycznie Å¼yje przez caÅ‚y czas trwania twojego programu i czy tego chcesz. Przez wiÄ™kszoÅ›Ä‡ czasu komunikat o bÅ‚Ä™dzie sugerujÄ…cy czas Å¼ycia `'static` wynika z prÃ³by utworzenia wiszÄ…cej referencji lub niezgodnoÅ›ci dostÄ™pnych czasÃ³w Å¼ycia. W takich przypadkach rozwiÄ…zaniem jest naprawienie tych problemÃ³w, a nie okreÅ›lanie czasu Å¼ycia `'static`.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"generic-type-parameters-trait-bounds-and-lifetimes-together\"></a>\n\n## OgÃ³lne parametry typÃ³w, ograniczenia cech i czasy Å¼ycia\n\nPrzyjrzyjmy siÄ™ krÃ³tko skÅ‚adni okreÅ›lania ogÃ³lnych parametrÃ³w typÃ³w, ograniczeÅ„ cech i czasÃ³w Å¼ycia w jednej funkcji!\n\n```rust\n# fn main() {\n#     let string1 = String::from(\"abcd\");\n#     let string2 = \"xyz\";\n# \n#     let result = longest_with_an_announcement(\n#         string1.as_str(),\n#         string2,\n#         \"Today is someone's birthday!\",\n#     );\n#     println!(\"The longest string is {result}\");\n# }\n# \nuse std::fmt::Display;\n\nfn longest_with_an_announcement<'a, T>(\n    x: &'a str,\n    y: &'a str,\n    ann: T,\n) -> &'a str\nwhere\n    T: Display,\n{\n    println!(\"Announcement! {ann}\");\n    if x.len() > y.len() { x } else { y }\n}\n```\n\nTo funkcja `longest` z Listingu 10-21, ktÃ³ra zwraca dÅ‚uÅ¼szy z dwÃ³ch wycinkÃ³w ciÄ…gÃ³w znakÃ³w. Ale teraz ma dodatkowy parametr o nazwie `ann` typu ogÃ³lnego `T`, ktÃ³ry moÅ¼e byÄ‡ wypeÅ‚niony dowolnym typem implementujÄ…cym cechÄ™ `Display`, zgodnie z klauzulÄ… `where`. Ten dodatkowy parametr zostanie wypisany za pomocÄ… `{}`, dlatego konieczne jest ograniczenie cechy `Display`. PoniewaÅ¼ czasy Å¼ycia sÄ… rodzajem generykÃ³w, deklaracje parametru czasu Å¼ycia `'a` i ogÃ³lnego parametru typu `T` znajdujÄ… siÄ™ na tej samej liÅ›cie w nawiasach kÄ…towych po nazwie funkcji.\n\n## Podsumowanie\n\nW tym rozdziale omÃ³wiliÅ›my wiele zagadnieÅ„! Teraz, gdy znasz ogÃ³lne parametry typÃ³w, cechy i ograniczenia cech oraz ogÃ³lne parametry czasÃ³w Å¼ycia, jesteÅ› gotowy do pisania kodu bez powtÃ³rzeÅ„, ktÃ³ry dziaÅ‚a w wielu rÃ³Å¼nych sytuacjach. OgÃ³lne parametry typÃ³w pozwalajÄ… zastosowaÄ‡ kod do rÃ³Å¼nych typÃ³w. Cechy i ograniczenia cech zapewniajÄ…, Å¼e mimo iÅ¼ typy sÄ… ogÃ³lne, bÄ™dÄ… miaÅ‚y zachowanie, ktÃ³rego kod potrzebuje. NauczyÅ‚eÅ› siÄ™, jak uÅ¼ywaÄ‡ adnotacji czasÃ³w Å¼ycia, aby zapewniÄ‡, Å¼e ten elastyczny kod nie bÄ™dzie miaÅ‚ Å¼adnych wiszÄ…cych referencji. I caÅ‚a ta analiza odbywa siÄ™ w czasie kompilacji, co nie wpÅ‚ywa na wydajnoÅ›Ä‡ w czasie wykonania!\n\nWierz lub nie, ale jest znacznie wiÄ™cej do nauczenia siÄ™ na tematy, ktÃ³re omÃ³wiliÅ›my w tym rozdziale: RozdziaÅ‚ 18 omawia obiekty cech, ktÃ³re sÄ… innym sposobem uÅ¼ywania cech. IstniejÄ… rÃ³wnieÅ¼ bardziej zÅ‚oÅ¼one scenariusze zwiÄ…zane z adnotacjami czasÃ³w Å¼ycia, ktÃ³re bÄ™dÄ… ci potrzebne tylko w bardzo zaawansowanych przypadkach; w ich przypadku powinieneÅ› przeczytaÄ‡ [Rust Reference][reference]. Ale nastÄ™pnie dowiesz siÄ™, jak pisaÄ‡ testy w Rust, aby upewniÄ‡ siÄ™, Å¼e twÃ³j kod dziaÅ‚a tak, jak powinien.\n\n[references-and-borrowing]: ch04-02-references-and-borrowing.html#references-and-borrowing\n[string-slices-as-parameters]: ch04-03-slices.html#string-slices-as-parameters\n[reference]: ../reference/trait-bounds.html",
        "chapter_title": "Walidacja referencji za pomocÄ… czasÃ³w Å¼ycia"
    },
    {
        "file_path": "ch11-00-testing.md",
        "content": "# Pisanie automatycznych testÃ³w\n\nW swoim eseju â€Skromny programistaâ€ z 1972 roku, Edsger W. Dijkstra powiedziaÅ‚, Å¼e â€testowanie programu moÅ¼e byÄ‡ bardzo efektywnym sposobem na wykazanie obecnoÅ›ci bÅ‚Ä™dÃ³w, ale jest beznadziejnie niewystarczajÄ…ce do wykazania ich brakuâ€. To nie znaczy, Å¼e nie powinniÅ›my prÃ³bowaÄ‡ testowaÄ‡ jak najwiÄ™cej!\n\n_PoprawnoÅ›Ä‡_ w naszych programach to zakres, w jakim nasz kod robi to, co zamierzamy. Rust zostaÅ‚ zaprojektowany z duÅ¼Ä… troskÄ… o poprawnoÅ›Ä‡ programÃ³w, ale poprawnoÅ›Ä‡ jest zÅ‚oÅ¼ona i nieÅ‚atwa do udowodnienia. System typÃ³w Rust bierze na siebie duÅ¼Ä… czÄ™Å›Ä‡ tego ciÄ™Å¼aru, ale system typÃ³w nie jest w stanie wyÅ‚apaÄ‡ wszystkiego. W zwiÄ…zku z tym Rust zawiera wsparcie dla pisania automatycznych testÃ³w oprogramowania.\n\nPowiedzmy, Å¼e piszemy funkcjÄ™ `add_two`, ktÃ³ra dodaje 2 do dowolnej liczby przekazanej do niej. Sygnatura tej funkcji akceptuje liczbÄ™ caÅ‚kowitÄ… jako parametr i zwraca liczbÄ™ caÅ‚kowitÄ… jako wynik. Kiedy implementujemy i kompilujemy tÄ™ funkcjÄ™, Rust wykonuje wszystkie sprawdzanie typÃ³w i sprawdzanie poÅ¼yczeÅ„, o ktÃ³rych uczyÅ‚eÅ› siÄ™ do tej pory, aby zapewniÄ‡, Å¼e na przykÅ‚ad nie przekazujemy wartoÅ›ci `String` ani nieprawidÅ‚owej referencji do tej funkcji. Ale Rust _nie_ jest w stanie sprawdziÄ‡, czy ta funkcja zrobi dokÅ‚adnie to, co zamierzamy, czyli zwrÃ³ci parametr plus 2, a nie na przykÅ‚ad parametr plus 10 lub parametr minus 50! WÅ‚aÅ›nie tutaj wchodzÄ… testy.\n\nMoÅ¼emy pisaÄ‡ testy, ktÃ³re potwierdzajÄ…, na przykÅ‚ad, Å¼e gdy przekazujemy `3` do funkcji `add_two`, zwrÃ³cona wartoÅ›Ä‡ to `5`. MoÅ¼emy uruchamiaÄ‡ te testy za kaÅ¼dym razem, gdy wprowadzamy zmiany w naszym kodzie, aby upewniÄ‡ siÄ™, Å¼e istniejÄ…ce prawidÅ‚owe zachowanie nie ulegÅ‚o zmianie.\n\nTestowanie to zÅ‚oÅ¼ona umiejÄ™tnoÅ›Ä‡: ChociaÅ¼ w jednym rozdziale nie moÅ¼emy omÃ³wiÄ‡ kaÅ¼dego szczegÃ³Å‚u dotyczÄ…cego tego, jak pisaÄ‡ dobre testy, w tym rozdziale omÃ³wimy mechanikÄ™ funkcji testowych Rust. Porozmawiamy o dostÄ™pnych adnotacjach i makrach podczas pisania testÃ³w, domyÅ›lnym zachowaniu i opcjach dostÄ™pnych do uruchamiania testÃ³w oraz o tym, jak organizowaÄ‡ testy w testy jednostkowe i testy integracyjne.\n",
        "chapter_title": "Pisanie automatycznych testÃ³w"
    },
    {
        "file_path": "ch11-02-running-tests.md",
        "content": "## Kontrolowanie sposobu uruchamiania testÃ³w\n\nTak jak `cargo run` kompiluje TwÃ³j kod, a nastÄ™pnie uruchamia wynikowy plik binarny, tak `cargo test` kompiluje TwÃ³j kod w trybie testowym i uruchamia wynikowy plik binarny testÃ³w. DomyÅ›lne zachowanie pliku binarnego wyprodukowanego przez `cargo test` to uruchamianie wszystkich testÃ³w rÃ³wnolegle i przechwytywanie danych wyjÅ›ciowych generowanych podczas przebiegÃ³w testÃ³w, co zapobiega wyÅ›wietlaniu danych wyjÅ›ciowych i uÅ‚atwia czytanie danych wyjÅ›ciowych zwiÄ…zanych z wynikami testÃ³w. MoÅ¼esz jednak okreÅ›liÄ‡ opcje wiersza poleceÅ„, aby zmieniÄ‡ to domyÅ›lne zachowanie.\n\nNiektÃ³re opcje wiersza poleceÅ„ trafiajÄ… do `cargo test`, a niektÃ³re do wynikowego pliku binarnego testÃ³w. Aby rozdzieliÄ‡ te dwa typy argumentÃ³w, naleÅ¼y wymieniÄ‡ argumenty, ktÃ³re trafiajÄ… do `cargo test`, po ktÃ³rych nastÄ™puje separator `--`, a nastÄ™pnie te, ktÃ³re trafiajÄ… do pliku binarnego testÃ³w. Uruchomienie `cargo test --help` wyÅ›wietla opcje, ktÃ³rych moÅ¼na uÅ¼yÄ‡ z `cargo test`, a uruchomienie `cargo test -- --help` wyÅ›wietla opcje, ktÃ³rych moÅ¼na uÅ¼yÄ‡ po separatorze. Opcje te sÄ… rÃ³wnieÅ¼ udokumentowane w sekcji [â€Testyâ€ w _The `rustc` Book_][tests].\n\n[tests]: https://doc.rust-lang.org/rustc/tests/index.html\n\n### Uruchamianie testÃ³w rÃ³wnolegle lub sekwencyjnie\n\nKiedy uruchamiasz wiele testÃ³w, domyÅ›lnie dziaÅ‚ajÄ… one rÃ³wnolegle, uÅ¼ywajÄ…c wÄ…tkÃ³w, co oznacza, Å¼e koÅ„czÄ… siÄ™ szybciej i otrzymujesz informacjÄ™ zwrotnÄ… wczeÅ›niej. PoniewaÅ¼ testy dziaÅ‚ajÄ… jednoczeÅ›nie, musisz upewniÄ‡ siÄ™, Å¼e Twoje testy nie zaleÅ¼Ä… od siebie nawzajem ani od Å¼adnego wspÃ³Å‚dzielonego stanu, w tym wspÃ³Å‚dzielonego Å›rodowiska, takiego jak bieÅ¼Ä…cy katalog roboczy lub zmienne Å›rodowiskowe.\n\nNa przykÅ‚ad, powiedzmy, Å¼e kaÅ¼dy z twoich testÃ³w uruchamia pewien kod, ktÃ³ry tworzy plik na dysku o nazwie _test-output.txt_ i zapisuje do niego pewne dane. NastÄ™pnie, kaÅ¼dy test odczytuje dane z tego pliku i twierdzi, Å¼e plik zawiera okreÅ›lonÄ… wartoÅ›Ä‡, ktÃ³ra jest rÃ³Å¼na w kaÅ¼dym teÅ›cie. PoniewaÅ¼ testy dziaÅ‚ajÄ… jednoczeÅ›nie, jeden test moÅ¼e nadpisaÄ‡ plik w czasie miÄ™dzy zapisem a odczytem pliku przez inny test. Drugi test zakoÅ„czy siÄ™ niepowodzeniem, nie dlatego, Å¼e kod jest niepoprawny, ale dlatego, Å¼e testy wzajemnie siÄ™ zakÅ‚Ã³caÅ‚y podczas dziaÅ‚ania rÃ³wnolegÅ‚ego. Jednym z rozwiÄ…zaÅ„ jest upewnienie siÄ™, Å¼e kaÅ¼dy test zapisuje do innego pliku; innym rozwiÄ…zaniem jest uruchamianie testÃ³w jeden po drugim.\n\nJeÅ›li nie chcesz uruchamiaÄ‡ testÃ³w rÃ³wnolegle lub jeÅ›li chcesz mieÄ‡ bardziej precyzyjnÄ… kontrolÄ™ nad liczbÄ… uÅ¼ywanych wÄ…tkÃ³w, moÅ¼esz przekazaÄ‡ flagÄ™ `--test-threads` oraz liczbÄ™ wÄ…tkÃ³w, ktÃ³rych chcesz uÅ¼yÄ‡, do binarnego pliku testowego. SpÃ³jrz na nastÄ™pujÄ…cy przykÅ‚ad:\n\n```console\n$ cargo test -- --test-threads=1\n```\n\nUstawiamy liczbÄ™ wÄ…tkÃ³w testowych na `1`, informujÄ…c program, aby nie uÅ¼ywaÅ‚ Å¼adnego paralelizmu. Uruchamianie testÃ³w na jednym wÄ…tku zajmie wiÄ™cej czasu niÅ¼ uruchamianie ich rÃ³wnolegle, ale testy nie bÄ™dÄ… ze sobÄ… kolidowaÄ‡, jeÅ›li wspÃ³Å‚dzielÄ… stan.\n\n### WyÅ›wietlanie wyjÅ›cia funkcji\n\nDomyÅ›lnie, jeÅ›li test przechodzi, biblioteka testowa Rust przechwytuje wszystko, co jest wypisywane na standardowe wyjÅ›cie. Na przykÅ‚ad, jeÅ›li wywoÅ‚amy `println!` w teÅ›cie, a test przejdzie, nie zobaczymy wyjÅ›cia `println!` w terminalu; zobaczymy tylko wiersz wskazujÄ…cy, Å¼e test przeszedÅ‚. JeÅ›li test zakoÅ„czy siÄ™ niepowodzeniem, zobaczymy wszystko, co zostaÅ‚o wypisane na standardowe wyjÅ›cie, wraz z resztÄ… komunikatu o bÅ‚Ä™dzie.\n\nJako przykÅ‚ad, Listing 11-10 zawiera prostÄ… funkcjÄ™, ktÃ³ra wypisuje wartoÅ›Ä‡ swojego parametru i zwraca 10, a takÅ¼e test, ktÃ³ry przechodzi, i test, ktÃ³ry koÅ„czy siÄ™ niepowodzeniem.\n\n<Listing number=\"11-10\" file-name=\"src/lib.rs\" caption=\"Testy funkcji wywoÅ‚ujÄ…cej `println!`\">\n\n```rust,panics,noplayground\nfn prints_and_returns_10(a: i32) -> i32 {\n    println!(\"I got the value {a}\");\n    10\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn this_test_will_pass() {\n        let value = prints_and_returns_10(4);\n        assert_eq!(value, 10);\n    }\n\n    #[test]\n    fn this_test_will_fail() {\n        let value = prints_and_returns_10(8);\n        assert_eq!(value, 5);\n    }\n}\n```\n\n</Listing>\n\nKiedy uruchomimy te testy za pomocÄ… `cargo test`, zobaczymy nastÄ™pujÄ…ce dane wyjÅ›ciowe:\n\n```console\n$ cargo test\n   Compiling silly-function v0.1.0 (file:///projects/silly-function)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s\n     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)\n\nrunning 2 tests\ntest tests::this_test_will_fail ... FAILED\ntest tests::this_test_will_pass ... ok\n\nfailures:\n\n---- tests::this_test_will_fail stdout ----\nI got the value 8\n\nthread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:\nassertion `left == right` failed\n  left: 10\n right: 5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::this_test_will_fail\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n```\n\nZauwaÅ¼, Å¼e w tym wyjÅ›ciu nigdzie nie widzimy `I got the value 4`, ktÃ³re jest wypisywane, gdy test, ktÃ³ry przechodzi, jest uruchamiany. To wyjÅ›cie zostaÅ‚o przechwycone. WyjÅ›cie z testu, ktÃ³ry zakoÅ„czyÅ‚ siÄ™ niepowodzeniem, `I got the value 8`, pojawia siÄ™ w sekcji podsumowania testÃ³w, ktÃ³ra rÃ³wnieÅ¼ pokazuje przyczynÄ™ niepowodzenia testu.\n\nJeÅ›li chcemy zobaczyÄ‡ wypisane wartoÅ›ci rÃ³wnieÅ¼ dla przechodzÄ…cych testÃ³w, moÅ¼emy nakazaÄ‡ Rustowi wyÅ›wietlanie danych wyjÅ›ciowych udanych testÃ³w za pomocÄ… `--show-output`:\n\n```console\n$ cargo test -- --show-output\n```\n\nKiedy ponownie uruchomimy testy z Listingu 11-10 z flagÄ… `--show-output`, zobaczymy nastÄ™pujÄ…ce dane wyjÅ›ciowe:\n\n```console\n$ cargo test -- --show-output\n   Compiling silly-function v0.1.0 (file:///projects/silly-function)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s\n     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)\n\nrunning 2 tests\ntest tests::this_test_will_fail ... FAILED\ntest tests::this_test_will_pass ... ok\n\nsuccesses:\n\n---- tests::this_test_will_pass stdout ----\nI got the value 4\n\n\nsuccesses:\n    tests::this_test_will_pass\n\nfailures:\n\n---- tests::this_test_will_fail stdout ----\nI got the value 8\n\nthread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:\nassertion `left == right` failed\n  left: 10\n right: 5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::this_test_will_fail\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n```\n\n### Uruchamianie podzbioru testÃ³w po nazwie\n\nUruchamianie peÅ‚nego zestawu testÃ³w moÅ¼e czasem zajÄ…Ä‡ duÅ¼o czasu. JeÅ›li pracujesz nad kodem w okreÅ›lonym obszarze, moÅ¼esz chcieÄ‡ uruchomiÄ‡ tylko testy dotyczÄ…ce tego kodu. MoÅ¼esz wybraÄ‡, ktÃ³re testy uruchomiÄ‡, przekazujÄ…c `cargo test` nazwÄ™ lub nazwy testÃ³w, ktÃ³re chcesz uruchomiÄ‡, jako argument.\n\nAby zademonstrowaÄ‡, jak uruchomiÄ‡ podzbiÃ³r testÃ³w, najpierw utworzymy trzy testy dla naszej funkcji `add_two`, jak pokazano w Listingu 11-11, i wybierzemy, ktÃ³re z nich uruchomiÄ‡.\n\n<Listing number=\"11-11\" file-name=\"src/lib.rs\" caption=\"Trzy testy z trzema rÃ³Å¼nymi nazwami\">\n\n```rust,noplayground\npub fn add_two(a: u64) -> u64 {\n    a + 2\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn add_two_and_two() {\n        let result = add_two(2);\n        assert_eq!(result, 4);\n    }\n\n    #[test]\n    fn add_three_and_two() {\n        let result = add_two(3);\n        assert_eq!(result, 5);\n    }\n\n    #[test]\n    fn one_hundred() {\n        let result = add_two(100);\n        assert_eq!(result, 102);\n    }\n}\n```\n\n</Listing>\n\nJeÅ›li uruchomimy testy bez przekazywania Å¼adnych argumentÃ³w, jak widzieliÅ›my wczeÅ›niej, wszystkie testy zostanÄ… uruchomione rÃ³wnolegle:\n\n```console\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 3 tests\ntest tests::add_three_and_two ... ok\ntest tests::add_two_and_two ... ok\ntest tests::one_hundred ... ok\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n```\n\n#### Uruchamianie pojedynczych testÃ³w\n\nMoÅ¼emy przekazaÄ‡ nazwÄ™ dowolnej funkcji testowej do `cargo test`, aby uruchomiÄ‡ tylko ten test:\n\n```console\n$ cargo test one_hundred\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.69s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::one_hundred ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s\n\n```\n\nUruchomiono tylko test o nazwie `one_hundred`; pozostaÅ‚e dwa testy nie pasowaÅ‚y do tej nazwy. Wyniki testÃ³w informujÄ… nas, Å¼e byÅ‚o wiÄ™cej testÃ³w, ktÃ³re nie zostaÅ‚y uruchomione, wyÅ›wietlajÄ…c na koÅ„cu `2 filtered out`.\n\nW ten sposÃ³b nie moÅ¼na okreÅ›laÄ‡ nazw wielu testÃ³w; uÅ¼yta zostanie tylko pierwsza wartoÅ›Ä‡ podana `cargo test`. Ale istnieje sposÃ³b na uruchamianie wielu testÃ³w.\n\n#### Filtrowanie w celu uruchomienia wielu testÃ³w\n\nMoÅ¼emy okreÅ›liÄ‡ czÄ™Å›Ä‡ nazwy testu, a kaÅ¼dy test, ktÃ³rego nazwa pasuje do tej wartoÅ›ci, zostanie uruchomiony. Na przykÅ‚ad, poniewaÅ¼ nazwy dwÃ³ch naszych testÃ³w zawierajÄ… `add`, moÅ¼emy uruchomiÄ‡ te dwa, uruchamiajÄ…c `cargo test add`:\n\n```console\n$ cargo test add\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 2 tests\ntest tests::add_three_and_two ... ok\ntest tests::add_two_and_two ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s\n\n```\n\nTo polecenie uruchomiÅ‚o wszystkie testy zawierajÄ…ce `add` w nazwie i odfiltrowaÅ‚o test o nazwie `one_hundred`. ZwrÃ³Ä‡ rÃ³wnieÅ¼ uwagÄ™, Å¼e moduÅ‚, w ktÃ³rym pojawia siÄ™ test, staje siÄ™ czÄ™Å›ciÄ… nazwy testu, wiÄ™c moÅ¼emy uruchomiÄ‡ wszystkie testy w module, filtrujÄ…c po nazwie moduÅ‚u.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"ignoring-some-tests-unless-specifically-requested\"></a>\n\n### Ignorowanie testÃ³w, chyba Å¼e sÄ… wyraÅºnie Å¼Ä…dane\n\nCzasami kilka konkretnych testÃ³w moÅ¼e byÄ‡ bardzo czasochÅ‚onnych w wykonaniu, wiÄ™c moÅ¼esz chcieÄ‡ je wykluczyÄ‡ podczas wiÄ™kszoÅ›ci uruchomieÅ„ `cargo test`. Zamiast wymieniaÄ‡ jako argumenty wszystkie testy, ktÃ³re chcesz uruchomiÄ‡, moÅ¼esz zamiast tego opatrzyÄ‡ czasochÅ‚onne testy atrybutem `ignore`, aby je wykluczyÄ‡, jak pokazano tutaj:\n\n<span class=\"filename\">Nazwa pliku: src/lib.rs</span>\n\n```rust,noplayground\n# pub fn add(left: u64, right: u64) -> u64 {\n#     left + right\n# }\n# \n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_works() {\n        let result = add(2, 2);\n        assert_eq!(result, 4);\n    }\n\n    #[test]\n    #[ignore]\n    fn expensive_test() {\n        // code that takes an hour to run\n    }\n}\n```\n\nPo `#[test]` dodajemy wiersz `#[ignore]` do testu, ktÃ³ry chcemy wykluczyÄ‡. Teraz, gdy uruchomimy nasze testy, `it_works` zostanie uruchomione, ale `expensive_test` nie:\n\n```console\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 2 tests\ntest tests::expensive_test ... ignored\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n```\n\nFunkcja `expensive_test` jest wymieniona jako `ignored`. JeÅ›li chcemy uruchomiÄ‡ tylko ignorowane testy, moÅ¼emy uÅ¼yÄ‡ `cargo test -- --ignored`:\n\n```console\n$ cargo test -- --ignored\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::expensive_test ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n```\n\nKontrolujÄ…c, ktÃ³re testy sÄ… uruchamiane, moÅ¼esz mieÄ‡ pewnoÅ›Ä‡, Å¼e wyniki `cargo test` zostanÄ… zwrÃ³cone szybko. Kiedy nadejdzie moment, w ktÃ³rym sensowne jest sprawdzenie wynikÃ³w testÃ³w `ignored` i masz czas, aby poczekaÄ‡ na wyniki, moÅ¼esz zamiast tego uruchomiÄ‡ `cargo test -- --ignored`. JeÅ›li chcesz uruchomiÄ‡ wszystkie testy, niezaleÅ¼nie od tego, czy sÄ… ignorowane, czy nie, moÅ¼esz uruchomiÄ‡ `cargo test -- --include-ignored`.\n",
        "chapter_title": "Kontrolowanie sposobu uruchamiania testÃ³w"
    },
    {
        "file_path": "ch11-03-test-organization.md",
        "content": "## Organizacja testÃ³w\n\nJak wspomniano na poczÄ…tku rozdziaÅ‚u, testowanie jest zÅ‚oÅ¼onÄ… dyscyplinÄ…, a rÃ³Å¼ni ludzie uÅ¼ywajÄ… rÃ³Å¼nej terminologii i organizacji. SpoÅ‚ecznoÅ›Ä‡ Rust rozwaÅ¼a testy w kategoriach dwÃ³ch gÅ‚Ã³wnych kategorii: testÃ³w jednostkowych i testÃ³w integracyjnych. _Testy jednostkowe_ sÄ… maÅ‚e i bardziej skoncentrowane, testujÄ… jeden moduÅ‚ w izolacji, i mogÄ… testowaÄ‡ interfejsy prywatne. _Testy integracyjne_ sÄ… caÅ‚kowicie zewnÄ™trzne w stosunku do Twojej biblioteki i uÅ¼ywajÄ… Twojego kodu w taki sam sposÃ³b, jak kaÅ¼dy inny kod zewnÄ™trzny, uÅ¼ywajÄ…c tylko publicznego interfejsu i potencjalnie testujÄ…c wiele moduÅ‚Ã³w na test.\n\nPisanie obu rodzajÃ³w testÃ³w jest waÅ¼ne, aby upewniÄ‡ siÄ™, Å¼e czÄ™Å›ci twojej biblioteki dziaÅ‚ajÄ… tak, jak tego oczekujesz, zarÃ³wno oddzielnie, jak i razem.\n\n### Testy jednostkowe\n\nCelem testÃ³w jednostkowych jest przetestowanie kaÅ¼dej jednostki kodu w izolacji od reszty kodu, aby szybko zlokalizowaÄ‡, gdzie kod dziaÅ‚a, a gdzie nie, zgodnie z oczekiwaniami. Testy jednostkowe umieszcza siÄ™ w katalogu _src_ w kaÅ¼dym pliku z kodem, ktÃ³ry testujÄ…. KonwencjÄ… jest tworzenie w kaÅ¼dym pliku moduÅ‚u o nazwie `tests`, ktÃ³ry zawiera funkcje testowe i oznaczanie moduÅ‚u atrybutem `cfg(test)`.\n\n#### ModuÅ‚ `tests` i `#[cfg(test)]`\n\nAdnotacja `#[cfg(test)]` na module `tests` informuje Rust, aby kompilowaÅ‚ i uruchamiaÅ‚ kod testowy tylko wtedy, gdy uruchamiasz `cargo test`, a nie gdy uruchamiasz `cargo build`. To oszczÄ™dza czas kompilacji, gdy chcesz tylko zbudowaÄ‡ bibliotekÄ™, i oszczÄ™dza miejsce w wynikowym skompilowanym artefakcie, poniewaÅ¼ testy nie sÄ… wÅ‚Ä…czone. Zobaczysz, Å¼e poniewaÅ¼ testy integracyjne znajdujÄ… siÄ™ w innym katalogu, nie potrzebujÄ… adnotacji `#[cfg(test)]`. JednakÅ¼e, poniewaÅ¼ testy jednostkowe znajdujÄ… siÄ™ w tych samych plikach co kod, bÄ™dziesz uÅ¼ywaÅ‚ `#[cfg(test)]` do okreÅ›lenia, Å¼e nie powinny byÄ‡ one uwzglÄ™dniane w skompilowanym wyniku.\n\nPamiÄ™taj, Å¼e kiedy generowaliÅ›my nowy projekt `adder` w pierwszej sekcji tego rozdziaÅ‚u, Cargo wygenerowaÅ‚ dla nas ten kod:\n\n<span class=\"filename\">Nazwa pliku: src/lib.rs</span>\n\n```rust,noplayground\npub fn add(left: u64, right: u64) -> u64 {\n    left + right\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_works() {\n        let result = add(2, 2);\n        assert_eq!(result, 4);\n    }\n}\n```\n\nNa automatycznie wygenerowanym module `tests` atrybut `cfg` oznacza _konfiguracjÄ™_ i informuje Rust, Å¼e nastÄ™pny element powinien byÄ‡ uwzglÄ™dniony tylko przy okreÅ›lonej opcji konfiguracji. W tym przypadku opcjÄ… konfiguracji jest `test`, ktÃ³ra jest dostarczana przez Rust do kompilowania i uruchamiania testÃ³w. UÅ¼ywajÄ…c atrybutu `cfg`, Cargo kompiluje nasz kod testowy tylko wtedy, gdy aktywnie uruchamiamy testy za pomocÄ… `cargo test`. Dotyczy to wszelkich funkcji pomocniczych, ktÃ³re mogÄ… znajdowaÄ‡ siÄ™ w tym module, oprÃ³cz funkcji oznaczonych `#[test]`.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"testing-private-functions\"></a>\n\n#### Testy funkcji prywatnych\n\nIstnieje debata w Å›rodowisku testowym na temat tego, czy funkcje prywatne powinny byÄ‡ testowane bezpoÅ›rednio, a inne jÄ™zyki utrudniajÄ… lub uniemoÅ¼liwiajÄ… testowanie funkcji prywatnych. NiezaleÅ¼nie od tego, ktÃ³rej ideologii testowania przestrzegasz, zasady prywatnoÅ›ci Rust pozwalajÄ… testowaÄ‡ funkcje prywatne. RozwaÅ¼ kod w Listingu 11-12 z prywatnÄ… funkcjÄ… `internal_adder`.\n\n<Listing number=\"11-12\" file-name=\"src/lib.rs\" caption=\"Testowanie funkcji prywatnej\">\n\n```rust,noplayground\npub fn add_two(a: u64) -> u64 {\n    internal_adder(a, 2)\n}\n\nfn internal_adder(left: u64, right: u64) -> u64 {\n    left + right\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn internal() {\n        let result = internal_adder(2, 2);\n        assert_eq!(result, 4);\n    }\n}\n```\n\n</Listing>\n\nZauwaÅ¼, Å¼e funkcja `internal_adder` nie jest oznaczona jako `pub`. Testy to po prostu kod Rust, a moduÅ‚ `tests` to tylko kolejny moduÅ‚. Jak omÃ³wiliÅ›my w sekcji [â€ÅšcieÅ¼ki do odwoÅ‚ywania siÄ™ do elementu w drzewie moduÅ‚Ã³wâ€][paths]<!-- ignore -->, elementy w podmoduÅ‚ach mogÄ… uÅ¼ywaÄ‡ elementÃ³w w swoich moduÅ‚ach nadrzÄ™dnych. W tym teÅ›cie wprowadzamy wszystkie elementy naleÅ¼Ä…ce do rodzica moduÅ‚u `tests` do zasiÄ™gu za pomocÄ… `use super::*`, a nastÄ™pnie test moÅ¼e wywoÅ‚aÄ‡ `internal_adder`. JeÅ›li nie uwaÅ¼asz, Å¼e funkcje prywatne powinny byÄ‡ testowane, w Rust nie ma niczego, co by CiÄ™ do tego zmuszaÅ‚o.\n\n### Testy integracyjne\n\nW Rust testy integracyjne sÄ… caÅ‚kowicie zewnÄ™trzne w stosunku do twojej biblioteki. UÅ¼ywajÄ… one twojej biblioteki w taki sam sposÃ³b, jak kaÅ¼dy inny kod, co oznacza, Å¼e mogÄ… wywoÅ‚ywaÄ‡ tylko funkcje, ktÃ³re sÄ… czÄ™Å›ciÄ… publicznego API twojej biblioteki. Ich celem jest sprawdzenie, czy wiele czÄ™Å›ci twojej biblioteki dziaÅ‚a poprawnie razem. Jednostki kodu, ktÃ³re dziaÅ‚ajÄ… poprawnie samodzielnie, mogÄ… mieÄ‡ problemy po zintegrowaniu, dlatego pokrycie testowe zintegrowanego kodu jest rÃ³wnieÅ¼ waÅ¼ne. Aby utworzyÄ‡ testy integracyjne, najpierw potrzebujesz katalogu _tests_.\n\n#### Katalog _tests_\n\nTworzymy katalog _tests_ na najwyÅ¼szym poziomie naszego katalogu projektu, obok _src_. Cargo wie, Å¼e powinien szukaÄ‡ plikÃ³w testÃ³w integracyjnych w tym katalogu. MoÅ¼emy nastÄ™pnie tworzyÄ‡ dowolnÄ… liczbÄ™ plikÃ³w testowych, a Cargo skompiluje kaÅ¼dy z tych plikÃ³w jako oddzielnÄ… skrzynkÄ™.\n\nUtwÃ³rzmy test integracyjny. Z kodem z Listingu 11-12, ktÃ³ry nadal znajduje siÄ™ w pliku _src/lib.rs_, utwÃ³rz katalog _tests_ i stwÃ³rz nowy plik o nazwie _tests/integration_test.rs_. Struktura katalogÃ³w powinna wyglÄ…daÄ‡ nastÄ™pujÄ…co:\n\n```text\nadder\nâ”œâ”€â”€ Cargo.lock\nâ”œâ”€â”€ Cargo.toml\nâ”œâ”€â”€ src\nâ”‚Â Â  â””â”€â”€ lib.rs\nâ””â”€â”€ tests\n    â””â”€â”€ integration_test.rs\n```\n\nWprowadÅº kod z Listingu 11-13 do pliku _tests/integration_test.rs_.\n\n<Listing number=\"11-13\" file-name=\"tests/integration_test.rs\" caption=\"Test integracyjny funkcji ze skrzynki `adder`\">\n\n```rust,ignore\nuse adder::add_two;\n\n#[test]\nfn it_adds_two() {\n    let result = add_two(2);\n    assert_eq!(result, 4);\n}\n```\n\n</Listing>\n\nKaÅ¼dy plik w katalogu _tests_ jest oddzielnÄ… skrzynkÄ…, wiÄ™c musimy wprowadziÄ‡ naszÄ… bibliotekÄ™ do zasiÄ™gu kaÅ¼dej skrzynki testowej. Z tego powodu na poczÄ…tku kodu dodajemy `use adder::add_two;`, czego nie potrzebowaliÅ›my w testach jednostkowych.\n\nNie musimy adnotowaÄ‡ Å¼adnego kodu w _tests/integration_test.rs_ atrybutem `#[cfg(test)]`. Cargo traktuje katalog _tests_ w specjalny sposÃ³b i kompiluje pliki w tym katalogu tylko wtedy, gdy uruchamiamy `cargo test`. Uruchom `cargo test` teraz:\n\n```console\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.31s\n     Running unittests src/lib.rs (target/debug/deps/adder-1082c4b063a8fbe6)\n\nrunning 1 test\ntest tests::internal ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)\n\nrunning 1 test\ntest it_adds_two ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n```\n\nTrzy sekcje wynikÃ³w obejmujÄ… testy jednostkowe, testy integracyjne i testy dokumentacji. ZauwaÅ¼, Å¼e jeÅ›li jakikolwiek test w sekcji zakoÅ„czy siÄ™ niepowodzeniem, nastÄ™pne sekcje nie zostanÄ… uruchomione. Na przykÅ‚ad, jeÅ›li test jednostkowy zakoÅ„czy siÄ™ niepowodzeniem, nie bÄ™dzie Å¼adnych danych wyjÅ›ciowych dla testÃ³w integracyjnych i dokumentacji, poniewaÅ¼ te testy zostanÄ… uruchomione tylko wtedy, gdy wszystkie testy jednostkowe przejdÄ….\n\nPierwsza sekcja dla testÃ³w jednostkowych jest taka sama, jak widzieliÅ›my wczeÅ›niej: jeden wiersz dla kaÅ¼dego testu jednostkowego (jeden o nazwie `internal`, ktÃ³ry dodaliÅ›my w Listingu 11-12), a nastÄ™pnie wiersz podsumowania dla testÃ³w jednostkowych.\n\nSekcja testÃ³w integracyjnych zaczyna siÄ™ od wiersza `Running tests/integration_test.rs`. NastÄ™pnie, dla kaÅ¼dej funkcji testowej w tym teÅ›cie integracyjnym znajduje siÄ™ wiersz i wiersz podsumowania wynikÃ³w testu integracyjnego tuÅ¼ przed sekcjÄ… `Doc-tests adder`.\n\nKaÅ¼dy plik testÃ³w integracyjnych ma swojÄ… wÅ‚asnÄ… sekcjÄ™, wiÄ™c jeÅ›li dodamy wiÄ™cej plikÃ³w do katalogu _tests_, bÄ™dzie wiÄ™cej sekcji testÃ³w integracyjnych.\n\nNadal moÅ¼emy uruchomiÄ‡ konkretnÄ… funkcjÄ™ testowÄ… integracji, okreÅ›lajÄ…c nazwÄ™ funkcji testowej jako argument dla `cargo test`. Aby uruchomiÄ‡ wszystkie testy w konkretnym pliku testowym integracji, uÅ¼yj argumentu `--test` `cargo test`, po ktÃ³rym nastÄ™puje nazwa pliku:\n\n```console\n$ cargo test --test integration_test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.64s\n     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)\n\nrunning 1 test\ntest it_adds_two ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n```\n\nTo polecenie uruchamia tylko testy z pliku _tests/integration_test.rs_.\n\n#### PodmoduÅ‚y w testach integracyjnych\n\nW miarÄ™ dodawania kolejnych testÃ³w integracyjnych, moÅ¼esz chcieÄ‡ utworzyÄ‡ wiÄ™cej plikÃ³w w katalogu _tests_, aby pomÃ³c w ich organizacji; na przykÅ‚ad, moÅ¼esz grupowaÄ‡ funkcje testowe wedÅ‚ug testowanej przez nie funkcjonalnoÅ›ci. Jak wspomniano wczeÅ›niej, kaÅ¼dy plik w katalogu _tests_ jest kompilowany jako oddzielna skrzynka, co jest przydatne do tworzenia oddzielnych zasiÄ™gÃ³w, aby dokÅ‚adniej naÅ›ladowaÄ‡ sposÃ³b, w jaki uÅ¼ytkownicy koÅ„cowi bÄ™dÄ… uÅ¼ywaÄ‡ Twojej skrzynki. Oznacza to jednak, Å¼e pliki w katalogu _tests_ nie majÄ… tego samego zachowania, co pliki w _src_, o czym dowiedziaÅ‚eÅ› siÄ™ w Rozdziale 7, dotyczÄ…cym sposobu dzielenia kodu na moduÅ‚y i pliki.\n\nRÃ³Å¼ne zachowanie plikÃ³w z katalogu _tests_ jest najbardziej zauwaÅ¼alne, gdy masz zestaw funkcji pomocniczych do uÅ¼ycia w wielu plikach testÃ³w integracyjnych i prÃ³bujesz postÄ™powaÄ‡ zgodnie z instrukcjami w sekcji [â€Dzielenie moduÅ‚Ã³w na rÃ³Å¼ne plikiâ€][separating-modules-into-files]<!-- ignore --> w Rozdziale 7, aby wyodrÄ™bniÄ‡ je do wspÃ³lnego moduÅ‚u. Na przykÅ‚ad, jeÅ›li utworzymy _tests/common.rs_ i umieÅ›cimy w nim funkcjÄ™ o nazwie `setup`, moÅ¼emy dodaÄ‡ do `setup` kod, ktÃ³ry chcemy wywoÅ‚aÄ‡ z wielu funkcji testowych w wielu plikach testowych:\n\n<span class=\"filename\">Nazwa pliku: tests/common.rs</span>\n\n```rust,noplayground\npub fn setup() {\n    // setup code specific to your library's tests would go here\n}\n```\n\nKiedy ponownie uruchomimy testy, zobaczymy nowÄ… sekcjÄ™ w wynikach testÃ³w dla pliku _common.rs_, mimo Å¼e ten plik nie zawiera Å¼adnych funkcji testowych ani nie wywoÅ‚aliÅ›my funkcji `setup` z Å¼adnego miejsca:\n\n```console\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.89s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::internal ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)\n\nrunning 1 test\ntest it_adds_two ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n```\n\nPojawienie siÄ™ `common` w wynikach testÃ³w z wyÅ›wietlonym `running 0 tests` nie byÅ‚o tym, czego chcieliÅ›my. ChcieliÅ›my tylko udostÄ™pniÄ‡ kod innym plikom testÃ³w integracyjnych. Aby uniknÄ…Ä‡ pojawiania siÄ™ `common` w wynikach testÃ³w, zamiast tworzenia _tests/common.rs_, utworzymy _tests/common/mod.rs_. Katalog projektu wyglÄ…da teraz tak:\n\n```text\nâ”œâ”€â”€ Cargo.lock\nâ”œâ”€â”€ Cargo.toml\nâ”œâ”€â”€ src\nâ”‚Â Â  â””â”€â”€ lib.rs\nâ””â”€â”€ tests\n    â”œâ”€â”€ common\n    â”‚Â Â  â””â”€â”€ mod.rs\n    â””â”€â”€ integration_test.rs\n```\n\nJest to starsza konwencja nazewnictwa, ktÃ³rÄ… Rust rÃ³wnieÅ¼ rozumie i o ktÃ³rej wspomnieliÅ›my w sekcji [â€Alternatywne Å›cieÅ¼ki plikÃ³wâ€][alt-paths]<!-- ignore --> w Rozdziale 7. Nazwanie pliku w ten sposÃ³b informuje Rust, aby nie traktowaÅ‚ moduÅ‚u `common` jako pliku testÃ³w integracyjnych. Kiedy przeniesiemy kod funkcji `setup` do _tests/common/mod.rs_ i usuniemy plik _tests/common.rs_, sekcja w wynikach testÃ³w przestanie siÄ™ pojawiaÄ‡. Pliki w podkatalogach katalogu _tests_ nie sÄ… kompilowane jako oddzielne skrzynki ani nie majÄ… sekcji w wynikach testÃ³w.\n\nPo utworzeniu _tests/common/mod.rs_ moÅ¼emy go uÅ¼ywaÄ‡ z dowolnego pliku testÃ³w integracyjnych jako moduÅ‚u. Oto przykÅ‚ad wywoÅ‚ania funkcji `setup` z testu `it_adds_two` w _tests/integration_test.rs_:\n\n<span class=\"filename\">Nazwa pliku: tests/integration_test.rs</span>\n\n```rust,ignore\nuse adder::add_two;\n\nmod common;\n\n#[test]\nfn it_adds_two() {\n    common::setup();\n\n    let result = add_two(2);\n    assert_eq!(result, 4);\n}\n```\n\nZauwaÅ¼, Å¼e deklaracja `mod common;` jest taka sama jak deklaracja moduÅ‚u, ktÃ³rÄ… zademonstrowaliÅ›my w Listingu 7-21. NastÄ™pnie w funkcji testowej moÅ¼emy wywoÅ‚aÄ‡ funkcjÄ™ `common::setup()`.\n\n#### Testy integracyjne dla binarnych skrzynek\n\nJeÅ›li nasz projekt jest binarnÄ… skrzynkÄ…, ktÃ³ra zawiera tylko plik _src/main.rs_ i nie ma pliku _src/lib.rs_, nie moÅ¼emy tworzyÄ‡ testÃ³w integracyjnych w katalogu _tests_ i wprowadzaÄ‡ funkcji zdefiniowanych w pliku _src/main.rs_ do zasiÄ™gu za pomocÄ… instrukcji `use`. Tylko skrzynki biblioteczne udostÄ™pniajÄ… funkcje, ktÃ³rych mogÄ… uÅ¼ywaÄ‡ inne skrzynki; skrzynki binarne sÄ… przeznaczone do samodzielnego uruchamiania.\n\nJest to jeden z powodÃ³w, dla ktÃ³rych projekty Rust, ktÃ³re udostÄ™pniajÄ… plik binarny, majÄ… prosty plik _src/main.rs_, ktÃ³ry wywoÅ‚uje logikÄ™ znajdujÄ…cÄ… siÄ™ w pliku _src/lib.rs_. KorzystajÄ…c z tej struktury, testy integracyjne _mogÄ…_ testowaÄ‡ skrzynkÄ™ bibliotecznÄ… za pomocÄ… `use`, aby udostÄ™pniÄ‡ waÅ¼nÄ… funkcjonalnoÅ›Ä‡. JeÅ›li waÅ¼na funkcjonalnoÅ›Ä‡ dziaÅ‚a, maÅ‚a iloÅ›Ä‡ kodu w pliku _src/main.rs_ rÃ³wnieÅ¼ bÄ™dzie dziaÅ‚aÄ‡, a ta maÅ‚a iloÅ›Ä‡ kodu nie musi byÄ‡ testowana.\n\n## Podsumowanie\n\nFunkcje testowe Rust zapewniajÄ… sposÃ³b na okreÅ›lenie, jak kod powinien dziaÅ‚aÄ‡, aby zapewniÄ‡, Å¼e bÄ™dzie on nadal dziaÅ‚aÅ‚ zgodnie z oczekiwaniami, nawet po wprowadzeniu zmian. Testy jednostkowe sprawdzajÄ… rÃ³Å¼ne czÄ™Å›ci biblioteki oddzielnie i mogÄ… testowaÄ‡ prywatne szczegÃ³Å‚y implementacji. Testy integracyjne sprawdzajÄ…, czy wiele czÄ™Å›ci biblioteki dziaÅ‚a poprawnie razem, i uÅ¼ywajÄ… publicznego API biblioteki do testowania kodu w taki sam sposÃ³b, w jaki bÄ™dzie go uÅ¼ywaÅ‚ kod zewnÄ™trzny. Mimo Å¼e system typÃ³w i zasady wÅ‚asnoÅ›ci Rust pomagajÄ… zapobiegaÄ‡ niektÃ³rym rodzajom bÅ‚Ä™dÃ³w, testy sÄ… nadal waÅ¼ne, aby zmniejszyÄ‡ liczbÄ™ bÅ‚Ä™dÃ³w logicznych zwiÄ…zanych z oczekiwanym zachowaniem kodu.\n\nPoÅ‚Ä…czmy wiedzÄ™ zdobytÄ… w tym i poprzednich rozdziaÅ‚ach, aby popracowaÄ‡ nad projektem!\n\n[paths]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\n[separating-modules-into-files]: ch07-05-separating-modules-into-different-files.html\n[alt-paths]: ch07-05-separating-modules-into-different-files.html#alternate-file-paths",
        "chapter_title": "Organizacja testÃ³w"
    },
    {
        "file_path": "ch12-00-an-io-project.md",
        "content": "# Projekt I/O: Budowa programu wiersza poleceÅ„\n\nTen rozdziaÅ‚ to podsumowanie wielu umiejÄ™tnoÅ›ci, ktÃ³rych nauczyÅ‚eÅ› siÄ™ do tej pory, oraz eksploracja kilku dodatkowych funkcji biblioteki standardowej. Zbudujemy narzÄ™dzie wiersza poleceÅ„, ktÃ³re bÄ™dzie wspÃ³Å‚pracowaÄ‡ z plikowym i wierszowym wejÅ›ciem/wyjÅ›ciem, aby przeÄ‡wiczyÄ‡ niektÃ³re pojÄ™cia Rust, ktÃ³re masz juÅ¼ opanowane.\n\nSzybkoÅ›Ä‡, bezpieczeÅ„stwo, pojedynczy plik binarny i wsparcie miÄ™dzyplatformowe Rust sprawiajÄ…, Å¼e jest to idealny jÄ™zyk do tworzenia narzÄ™dzi wiersza poleceÅ„. Dlatego w naszym projekcie stworzymy wÅ‚asnÄ… wersjÄ™ klasycznego narzÄ™dzia wyszukiwania wiersza poleceÅ„ `grep` (**g**lobally search a **r**egular **e**xpression and **p**rint). W najprostszym przypadku `grep` wyszukuje w okreÅ›lonym pliku okreÅ›lony ciÄ…g znakÃ³w. Aby to zrobiÄ‡, `grep` przyjmuje jako argumenty Å›cieÅ¼kÄ™ do pliku i ciÄ…g znakÃ³w. NastÄ™pnie odczytuje plik, znajduje w nim wiersze zawierajÄ…ce argument ciÄ…gu znakÃ³w i wypisuje te wiersze.\n\nPo drodze pokaÅ¼emy, jak sprawiÄ‡, by nasze narzÄ™dzie wiersza poleceÅ„ korzystaÅ‚o z funkcji terminala, ktÃ³rych uÅ¼ywa wiele innych narzÄ™dzi wiersza poleceÅ„. Odczytamy wartoÅ›Ä‡ zmiennej Å›rodowiskowej, aby umoÅ¼liwiÄ‡ uÅ¼ytkownikowi skonfigurowanie zachowania naszego narzÄ™dzia. BÄ™dziemy rÃ³wnieÅ¼ wypisywaÄ‡ komunikaty o bÅ‚Ä™dach do standardowego strumienia bÅ‚Ä™dÃ³w konsoli (`stderr`) zamiast standardowego wyjÅ›cia (`stdout`), aby na przykÅ‚ad uÅ¼ytkownik mÃ³gÅ‚ przekierowaÄ‡ udane dane wyjÅ›ciowe do pliku, nadal widzÄ…c komunikaty o bÅ‚Ä™dach na ekranie.\n\nJeden z czÅ‚onkÃ³w spoÅ‚ecznoÅ›ci Rust, Andrew Gallant, stworzyÅ‚ juÅ¼ w peÅ‚ni funkcjonalnÄ…, bardzo szybkÄ… wersjÄ™ `grep`, nazwanÄ… `ripgrep`. W porÃ³wnaniu, nasza wersja bÄ™dzie raczej prosta, ale ten rozdziaÅ‚ da ci podstawowÄ… wiedzÄ™, ktÃ³rej potrzebujesz, aby zrozumieÄ‡ rzeczywisty projekt, taki jak `ripgrep`.\n\nNasz projekt `grep` poÅ‚Ä…czy wiele pojÄ™Ä‡, ktÃ³rych nauczyÅ‚eÅ› siÄ™ do tej pory:\n\n- Organizowanie kodu ([RozdziaÅ‚ 7][ch7]<!-- ignore -->)\n- UÅ¼ywanie wektorÃ³w i ciÄ…gÃ³w znakÃ³w ([RozdziaÅ‚ 8][ch8]<!-- ignore -->)\n- ObsÅ‚uga bÅ‚Ä™dÃ³w ([RozdziaÅ‚ 9][ch9]<!-- ignore -->)\n- UÅ¼ywanie cech i czasÃ³w Å¼ycia tam, gdzie jest to stosowne ([RozdziaÅ‚ 10][ch10]<!-- ignore -->)\n- Pisanie testÃ³w ([RozdziaÅ‚ 11][ch11]<!-- ignore -->)\n\nPonadto pokrÃ³tce przedstawimy domkniÄ™cia, iteratory i obiekty cech, ktÃ³re [RozdziaÅ‚ 13][ch13]<!-- ignore --> i [RozdziaÅ‚ 18][ch18]<!-- ignore --> omÃ³wiÄ… szczegÃ³Å‚owo.\n\n[ch7]: ch07-00-managing-growing-projects-with-packages-crates-and-modules.html\n[ch8]: ch08-00-common-collections.html\n[ch9]: ch09-00-error-handling.html\n[ch10]: ch10-00-generics.html\n[ch11]: ch11-00-testing.html\n[ch13]: ch13-00-functional-features.html\n[ch18]: ch18-00-oop.html",
        "chapter_title": "Projekt I/O: Budowa programu wiersza poleceÅ„"
    },
    {
        "file_path": "ch12-01-accepting-command-line-arguments.md",
        "content": "## Akceptowanie argumentÃ³w wiersza poleceÅ„\n\nUtwÃ³rzmy nowy projekt, jak zawsze, za pomocÄ… `cargo new`. Nasz projekt nazwiemy `minigrep`, aby odrÃ³Å¼niÄ‡ go od narzÄ™dzia `grep`, ktÃ³re moÅ¼esz juÅ¼ mieÄ‡ w swoim systemie:\n\n```console\n$ cargo new minigrep\n     Created binary (application) `minigrep` project\n$ cd minigrep\n```\n\nPierwszym zadaniem jest sprawienie, aby `minigrep` akceptowaÅ‚ dwa argumenty wiersza poleceÅ„: Å›cieÅ¼kÄ™ do pliku i ciÄ…g znakÃ³w do wyszukania. Oznacza to, Å¼e chcemy mÃ³c uruchamiaÄ‡ nasz program za pomocÄ… `cargo run`, dwÃ³ch myÅ›lnikÃ³w wskazujÄ…cych, Å¼e nastÄ™pujÄ…ce argumenty sÄ… przeznaczone dla naszego programu, a nie dla `cargo`, ciÄ…gu znakÃ³w do wyszukania i Å›cieÅ¼ki do pliku, w ktÃ³rym ma siÄ™ odbywaÄ‡ wyszukiwanie, w nastÄ™pujÄ…cy sposÃ³b:\n\n```console\n$ cargo run -- searchstring example-filename.txt\n```\n\nObecnie program wygenerowany przez `cargo new` nie moÅ¼e przetwarzaÄ‡ podanych mu argumentÃ³w. IstniejÄ…ce biblioteki na [crates.io](https://crates.io/)<!-- ignore --> mogÄ… pomÃ³c w pisaniu programu, ktÃ³ry akceptuje argumenty wiersza poleceÅ„, ale poniewaÅ¼ dopiero uczysz siÄ™ tej koncepcji, zaimplementujmy tÄ™ funkcjonalnoÅ›Ä‡ samodzielnie.\n\n### Odczytywanie wartoÅ›ci argumentÃ³w\n\nAby `minigrep` mÃ³gÅ‚ odczytywaÄ‡ wartoÅ›ci argumentÃ³w wiersza poleceÅ„, ktÃ³re do niego przekazujemy, bÄ™dziemy potrzebowaÄ‡ funkcji `std::env::args` udostÄ™pnionej w standardowej bibliotece Rust. Funkcja ta zwraca iterator argumentÃ³w wiersza poleceÅ„ przekazanych do `minigrep`. WyczerpujÄ…co omÃ³wimy iteratory w [Rozdziale 13][ch13]<!-- ignore -->. Na razie musisz znaÄ‡ tylko dwa szczegÃ³Å‚y dotyczÄ…ce iteratorÃ³w: iteratory produkujÄ… seriÄ™ wartoÅ›ci, a metodÄ™ `collect` moÅ¼emy wywoÅ‚aÄ‡ na iteratorze, aby zamieniÄ‡ go w kolekcjÄ™, takÄ… jak wektor, ktÃ³ra zawiera wszystkie elementy produkowane przez iterator.\n\nKod z Listingu 12-1 pozwala programowi `minigrep` odczytaÄ‡ wszelkie argumenty wiersza poleceÅ„, ktÃ³re do niego przekazano, a nastÄ™pnie zebraÄ‡ wartoÅ›ci w wektor.\n\n<Listing number=\"12-1\" file-name=\"src/main.rs\" caption=\"Zbieranie argumentÃ³w wiersza poleceÅ„ w wektor i ich wypisywanie\">\n\n```rust\nuse std::env;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    dbg!(args);\n}\n```\n\n</Listing>\n\nNajpierw wprowadzamy moduÅ‚ `std::env` do zasiÄ™gu za pomocÄ… instrukcji `use`, abyÅ›my mogli uÅ¼ywaÄ‡ jego funkcji `args`. ZauwaÅ¼, Å¼e funkcja `std::env::args` jest zagnieÅ¼dÅ¼ona na dwÃ³ch poziomach moduÅ‚Ã³w. Jak omÃ³wiliÅ›my w [Rozdziale 7][ch7-idiomatic-use]<!-- ignore -->, w przypadkach, gdy poÅ¼Ä…dana funkcja jest zagnieÅ¼dÅ¼ona w wiÄ™cej niÅ¼ jednym module, zdecydowaliÅ›my siÄ™ wprowadziÄ‡ moduÅ‚ nadrzÄ™dny do zasiÄ™gu, a nie funkcjÄ™. DziÄ™ki temu moÅ¼emy Å‚atwo uÅ¼ywaÄ‡ innych funkcji z `std::env`. Jest to rÃ³wnieÅ¼ mniej dwuznaczne niÅ¼ dodawanie `use std::env::args`, a nastÄ™pnie wywoÅ‚ywanie funkcji tylko za pomocÄ… `args`, poniewaÅ¼ `args` moÅ¼na by Å‚atwo pomyliÄ‡ z funkcjÄ… zdefiniowanÄ… w bieÅ¼Ä…cym module.\n\nW pierwszym wierszu `main` wywoÅ‚ujemy `env::args` i natychmiast uÅ¼ywamy `collect`, aby zamieniÄ‡ iterator w wektor zawierajÄ…cy wszystkie wartoÅ›ci wyprodukowane przez iterator. MoÅ¼emy uÅ¼yÄ‡ funkcji `collect` do tworzenia wielu rodzajÃ³w kolekcji, wiÄ™c jawnie adnotujemy typ `args`, aby okreÅ›liÄ‡, Å¼e chcemy wektora ciÄ…gÃ³w znakÃ³w. ChociaÅ¼ w Rust bardzo rzadko trzeba adnotowaÄ‡ typy, `collect` jest jednÄ… z funkcji, ktÃ³rÄ… czÄ™sto trzeba adnotowaÄ‡, poniewaÅ¼ Rust nie jest w stanie wywnioskowaÄ‡, jakiego rodzaju kolekcjÄ™ chcemy.\n\nNa koniec wypisujemy wektor za pomocÄ… makra debugowania. SprÃ³bujmy uruchomiÄ‡ kod najpierw bez argumentÃ³w, a nastÄ™pnie z dwoma argumentami:\n\n```console\n$ cargo run\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s\n     Running `target/debug/minigrep`\n[src/main.rs:5:5] args = [\n    \"target/debug/minigrep\",\n]\n```\n\n```console\n$ cargo run -- needle haystack\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.57s\n     Running `target/debug/minigrep needle haystack`\n[src/main.rs:5:5] args = [\n    \"target/debug/minigrep\",\n    \"needle\",\n    \"haystack\",\n]\n```\n\nZauwaÅ¼, Å¼e pierwszÄ… wartoÅ›ciÄ… w wektorze jest `\"target/debug/minigrep\"`, co jest nazwÄ… naszego pliku binarnego. Odpowiada to zachowaniu listy argumentÃ³w w C, pozwalajÄ…c programom uÅ¼ywaÄ‡ nazwy, za pomocÄ… ktÃ³rej zostaÅ‚y wywoÅ‚ane, w swoim wykonaniu. CzÄ™sto wygodnie jest mieÄ‡ dostÄ™p do nazwy programu w przypadku, gdy chcesz jÄ… wypisaÄ‡ w komunikatach lub zmieniÄ‡ zachowanie programu na podstawie aliasu wiersza poleceÅ„, ktÃ³ry zostaÅ‚ uÅ¼yty do wywoÅ‚ania programu. Ale dla celÃ³w tego rozdziaÅ‚u zignorujemy to i zapiszemy tylko dwa argumenty, ktÃ³rych potrzebujemy.\n\n### Zapisywanie wartoÅ›ci argumentÃ³w w zmiennych\n\nProgram jest obecnie w stanie uzyskaÄ‡ dostÄ™p do wartoÅ›ci okreÅ›lonych jako argumenty wiersza poleceÅ„. Teraz musimy zapisaÄ‡ wartoÅ›ci tych dwÃ³ch argumentÃ³w w zmiennych, abyÅ›my mogli uÅ¼ywaÄ‡ ich w pozostaÅ‚ej czÄ™Å›ci programu. Robimy to w Listingu 12-2.\n\n<Listing number=\"12-2\" file-name=\"src/main.rs\" caption=\"Tworzenie zmiennych do przechowywania argumentu zapytania i argumentu Å›cieÅ¼ki pliku\">\n\n```rust,should_panic,noplayground\nuse std::env;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let query = &args[1];\n    let file_path = &args[2];\n\n    println!(\"Searching for {query}\");\n    println!(\"In file {file_path}\");\n}\n```\n\n</Listing>\n\nJak widzieliÅ›my, wypisujÄ…c wektor, nazwa programu zajmuje pierwszÄ… wartoÅ›Ä‡ w wektorze pod `args[0]`, wiÄ™c zaczynamy argumenty od indeksu 1. Pierwszym argumentem, ktÃ³ry przyjmuje `minigrep`, jest ciÄ…g znakÃ³w, ktÃ³rego szukamy, wiÄ™c umieszczamy referencjÄ™ do pierwszego argumentu w zmiennej `query`. Drugim argumentem bÄ™dzie Å›cieÅ¼ka do pliku, wiÄ™c umieszczamy referencjÄ™ do drugiego argumentu w zmiennej `file_path`.\n\nTymczasowo wypisujemy wartoÅ›ci tych zmiennych, aby udowodniÄ‡, Å¼e kod dziaÅ‚a zgodnie z naszym zamierzeniem. Uruchommy ten program ponownie z argumentami `test` i `sample.txt`:\n\n```console\n$ cargo run -- test sample.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep test sample.txt`\nSearching for test\nIn file sample.txt\n```\n\nÅšwietnie, program dziaÅ‚a! Potrzebne nam wartoÅ›ci argumentÃ³w sÄ… zapisywane w odpowiednich zmiennych. PÃ³Åºniej dodamy obsÅ‚ugÄ™ bÅ‚Ä™dÃ³w, aby poradziÄ‡ sobie z pewnymi potencjalnie bÅ‚Ä™dnymi sytuacjami, takimi jak brak argumentÃ³w podanych przez uÅ¼ytkownika; na razie zignorujemy tÄ™ sytuacjÄ™ i zajmiemy siÄ™ dodaniem moÅ¼liwoÅ›ci odczytu plikÃ³w.\n\n[ch13]: ch13-00-functional-features.html\n[ch7-idiomatic-use]: ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-paths",
        "chapter_title": "Akceptowanie argumentÃ³w wiersza poleceÅ„"
    },
    {
        "file_path": "ch12-02-reading-a-file.md",
        "content": "## Odczytywanie pliku\n\nTeraz dodamy funkcjonalnoÅ›Ä‡ do odczytywania pliku okreÅ›lonego w argumencie `file_path`. Najpierw potrzebujemy przykÅ‚adowego pliku do przetestowania: uÅ¼yjemy pliku z niewielkÄ… iloÅ›ciÄ… tekstu na wielu liniach z kilkoma powtÃ³rzonymi sÅ‚owami. Listing 12-3 zawiera wiersz Emily Dickinson, ktÃ³ry bÄ™dzie dobrze dziaÅ‚aÅ‚! UtwÃ³rz plik o nazwie _poem.txt_ w katalogu gÅ‚Ã³wnym projektu i wprowadÅº wiersz â€Iâ€™m Nobody! Who are you?â€\n\n<Listing number=\"12-3\" file-name=\"poem.txt\" caption=\"Wiersz Emily Dickinson stanowi dobry przypadek testowy.\">\n\n```text\nI'm nobody! Who are you?\nAre you nobody, too?\nThen there's a pair of us - don't tell!\nThey'd banish us, you know.\n\nHow dreary to be somebody!\nHow public, like a frog\nTo tell your name the livelong day\nTo an admiring bog!\n```\n\n</Listing>\n\nGdy tekst jest juÅ¼ na miejscu, edytuj _src/main.rs_ i dodaj kod do odczytywania pliku, jak pokazano w Listingu 12-4.\n\n<Listing number=\"12-4\" file-name=\"src/main.rs\" caption=\"Odczytywanie zawartoÅ›ci pliku okreÅ›lonego przez drugi argument\">\n\n```rust,should_panic,noplayground\nuse std::env;\nuse std::fs;\n\nfn main() {\n    // --snip--\n#     let args: Vec<String> = env::args().collect();\n# \n#     let query = &args[1];\n#     let file_path = &args[2];\n# \n#     println!(\"Searching for {query}\");\n    println!(\"In file {file_path}\");\n\n    let contents = fs::read_to_string(file_path)\n        .expect(\"Should have been able to read the file\");\n\n    println!(\"With text:\\n{contents}\");\n}\n```\n\n</Listing>\n\nNajpierw wprowadzamy do zasiÄ™gu odpowiedniÄ… czÄ™Å›Ä‡ biblioteki standardowej za pomocÄ… instrukcji `use`: Potrzebujemy `std::fs` do obsÅ‚ugi plikÃ³w.\n\nW `main` nowa instrukcja `fs::read_to_string` przyjmuje `file_path`, otwiera ten plik i zwraca wartoÅ›Ä‡ typu `std::io::Result<String>`, ktÃ³ra zawiera zawartoÅ›Ä‡ pliku.\n\nNastÄ™pnie ponownie dodajemy tymczasowÄ… instrukcjÄ™ `println!`, ktÃ³ra wypisuje wartoÅ›Ä‡ `contents` po odczytaniu pliku, abyÅ›my mogli sprawdziÄ‡, czy program dziaÅ‚a do tej pory.\n\nUruchommy ten kod z dowolnym ciÄ…giem znakÃ³w jako pierwszym argumentem wiersza poleceÅ„ (poniewaÅ¼ nie zaimplementowaliÅ›my jeszcze czÄ™Å›ci wyszukiwania) i plikiem _poem.txt_ jako drugim argumentem:\n\n```console\n$ cargo run -- the poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep the poem.txt`\nSearching for the\nIn file poem.txt\nWith text:\nI'm nobody! Who are you?\nAre you nobody, too?\nThen there's a pair of us - don't tell!\nThey'd banish us, you know.\n\nHow dreary to be somebody!\nHow public, like a frog\nTo tell your name the livelong day\nTo an admiring bog!\n\n```\n\nÅšwietnie! Kod odczytaÅ‚, a nastÄ™pnie wypisaÅ‚ zawartoÅ›Ä‡ pliku. Ale kod ma kilka wad. W tej chwili funkcja `main` peÅ‚ni wiele rÃ³l: parsuje argumenty i odczytuje pliki. W miarÄ™ rozrostu programu, liczba oddzielnych zadaÅ„ obsÅ‚ugiwanych przez funkcjÄ™ `main` bÄ™dzie wzrastaÄ‡. W miarÄ™ zwiÄ™kszania odpowiedzialnoÅ›ci funkcji, staje siÄ™ ona trudniejsza do zrozumienia, trudniejsza do testowania i trudniejsza do zmiany bez uszkodzenia jednej z jej czÄ™Å›ci. Najlepiej jest rozdzieliÄ‡ funkcjonalnoÅ›Ä‡ tak, aby kaÅ¼da funkcja byÅ‚a odpowiedzialna tylko za jedno zadanie.\n\nTen problem wiÄ…Å¼e siÄ™ rÃ³wnieÅ¼ z drugim problemem: chociaÅ¼ `query` i `file_path` sÄ… zmiennymi konfiguracyjnymi naszego programu, zmienne takie jak `contents` sÄ… uÅ¼ywane do wykonywania logiki programu. Im dÅ‚uÅ¼szy staje siÄ™ `main`, tym wiÄ™cej zmiennych bÄ™dziemy musieli wprowadziÄ‡ do zasiÄ™gu; im wiÄ™cej zmiennych mamy w zasiÄ™gu, tym trudniej bÄ™dzie Å›ledziÄ‡ cel kaÅ¼dej z nich. Najlepiej jest zgrupowaÄ‡ zmienne konfiguracyjne w jednÄ… strukturÄ™, aby ich cel byÅ‚ jasny.\n\nTrzeci problem polega na tym, Å¼e uÅ¼yliÅ›my `expect` do wypisania komunikatu o bÅ‚Ä™dzie, gdy odczyt pliku siÄ™ nie powiedzie, ale komunikat o bÅ‚Ä™dzie wypisuje tylko `Should have been able to read the file`. Odczyt pliku moÅ¼e zakoÅ„czyÄ‡ siÄ™ niepowodzeniem na wiele sposobÃ³w: na przykÅ‚ad, plik moÅ¼e brakowaÄ‡, lub moÅ¼emy nie mieÄ‡ uprawnieÅ„ do jego otwarcia. W tej chwili, niezaleÅ¼nie od sytuacji, wypisywalibyÅ›my ten sam komunikat o bÅ‚Ä™dzie dla wszystkiego, co nie daÅ‚oby uÅ¼ytkownikowi Å¼adnych informacji!\n\nPo czwarte, uÅ¼ywamy `expect` do obsÅ‚ugi bÅ‚Ä™du, a jeÅ›li uÅ¼ytkownik uruchomi nasz program bez okreÅ›lenia wystarczajÄ…cej liczby argumentÃ³w, otrzyma bÅ‚Ä…d `index out of bounds` z Rust, ktÃ³ry nie wyjaÅ›nia jasno problemu. Najlepiej byÅ‚oby, gdyby caÅ‚y kod obsÅ‚ugi bÅ‚Ä™dÃ³w znajdowaÅ‚ siÄ™ w jednym miejscu, tak aby przyszli konserwatorzy mieli tylko jedno miejsce do konsultowania kodu, jeÅ›li logika obsÅ‚ugi bÅ‚Ä™dÃ³w wymagaÅ‚a zmiany. Posiadanie caÅ‚ego kodu obsÅ‚ugi bÅ‚Ä™dÃ³w w jednym miejscu zapewni rÃ³wnieÅ¼, Å¼e bÄ™dziemy wypisywaÄ‡ komunikaty, ktÃ³re bÄ™dÄ… zrozumiaÅ‚e dla naszych uÅ¼ytkownikÃ³w koÅ„cowych.\n\nZajmiemy siÄ™ tymi czterema problemami, refaktoryzujÄ…c nasz projekt.\n",
        "chapter_title": "Odczytywanie pliku"
    },
    {
        "file_path": "ch12-04-testing-the-librarys-functionality.md",
        "content": "<!-- Old headings. Do not remove or links may break. -->\n<a id=\"developing-the-librarys-functionality-with-test-driven-development\"></a>\n\n## Dodawanie funkcjonalnoÅ›ci z wykorzystaniem programowania sterowanego testami\n\nTeraz, gdy logika wyszukiwania znajduje siÄ™ w pliku _src/lib.rs_ oddzielnie od funkcji `main`, znacznie Å‚atwiej jest pisaÄ‡ testy dla podstawowej funkcjonalnoÅ›ci naszego kodu. MoÅ¼emy wywoÅ‚ywaÄ‡ funkcje bezpoÅ›rednio z rÃ³Å¼nymi argumentami i sprawdzaÄ‡ wartoÅ›ci zwracane bez koniecznoÅ›ci wywoÅ‚ywania naszego pliku binarnego z wiersza poleceÅ„.\n\nW tej sekcji dodamy logikÄ™ wyszukiwania do programu `minigrep` przy uÅ¼yciu procesu programowania sterowanego testami (TDD) zgodnie z nastÄ™pujÄ…cymi krokami:\n\n1. Napisz test, ktÃ³ry zawodzi, i uruchom go, aby upewniÄ‡ siÄ™, Å¼e zawodzi z oczekiwanej przyczyny.\n2. Napisz lub zmodyfikuj wystarczajÄ…co duÅ¼o kodu, aby nowy test przeszedÅ‚.\n3. Zrefaktoruj kod, ktÃ³ry wÅ‚aÅ›nie dodaÅ‚eÅ› lub zmieniÅ‚eÅ›, i upewnij siÄ™, Å¼e testy nadal przechodzÄ….\n4. PowtÃ³rz od kroku 1!\n\nChociaÅ¼ jest to tylko jeden z wielu sposobÃ³w pisania oprogramowania, TDD moÅ¼e pomÃ³c w kierowaniu projektem kodu. Pisanie testu przed napisaniem kodu, ktÃ³ry sprawia, Å¼e test przechodzi, pomaga utrzymaÄ‡ wysokie pokrycie testami przez caÅ‚y proces.\n\nBÄ™dziemy testowaÄ‡ implementacjÄ™ funkcjonalnoÅ›ci, ktÃ³ra faktycznie bÄ™dzie wyszukiwaÄ‡ ciÄ…g zapytania w zawartoÅ›ci pliku i generowaÄ‡ listÄ™ pasujÄ…cych wierszy. TÄ™ funkcjonalnoÅ›Ä‡ dodamy w funkcji nazwanej `search`.\n\n### Pisanie nieudanego testu\n\nW pliku _src/lib.rs_ dodamy moduÅ‚ `tests` z funkcjÄ… testowÄ…, tak jak to zrobiliÅ›my w [Rozdziale 11][ch11-anatomy]<!-- ignore -->. Funkcja testowa okreÅ›la zachowanie, jakie chcemy, aby funkcja `search` miaÅ‚a: BÄ™dzie przyjmowaÄ‡ zapytanie i tekst do przeszukania, i bÄ™dzie zwracaÄ‡ tylko te wiersze z tekstu, ktÃ³re zawierajÄ… zapytanie. Listing 12-15 pokazuje ten test.\n\n<Listing number=\"12-15\" file-name=\"src/lib.rs\" caption=\"Tworzenie nieudanego testu dla funkcji `search` dla funkcjonalnoÅ›ci, ktÃ³rÄ… chcielibyÅ›my mieÄ‡\">\n\n```rust,ignore,does_not_compile\n# pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n#     unimplemented!();\n# }\n# \n// --snip--\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn one_result() {\n        let query = \"duct\";\n        let contents = \"\\\nRust:\nsafe, fast, productive.\nPick three.\";\n\n        assert_eq!(vec![\"safe, fast, productive.\"], search(query, contents));\n    }\n}\n```\n\n</Listing>\n\nTen test wyszukuje ciÄ…g `\"duct\"`. Tekst, ktÃ³ry przeszukujemy, ma trzy wiersze, z ktÃ³rych tylko jeden zawiera `\"duct\"` (zauwaÅ¼, Å¼e ukoÅ›nik wsteczny po otwierajÄ…cym cudzysÅ‚owie podwÃ³jnym informuje Rusta, aby nie umieszczaÅ‚ znaku nowej linii na poczÄ…tku zawartoÅ›ci tego literaÅ‚u ciÄ…gu znakÃ³w). Twierdzimy, Å¼e wartoÅ›Ä‡ zwrÃ³cona przez funkcjÄ™ `search` zawiera tylko oczekiwany wiersz.\n\nJeÅ›li uruchomimy ten test, obecnie siÄ™ nie powiedzie, poniewaÅ¼ makro `unimplemented!` panikuje z komunikatem â€not implementedâ€. Zgodnie z zasadami TDD, zrobimy maÅ‚y krok, dodajÄ…c wystarczajÄ…co duÅ¼o kodu, aby test nie panikowaÅ‚ podczas wywoÅ‚ywania funkcji, definiujÄ…c funkcjÄ™ `search` tak, aby zawsze zwracaÅ‚a pusty wektor, jak pokazano w Listing 12-16. NastÄ™pnie test powinien siÄ™ skompilowaÄ‡ i zakoÅ„czyÄ‡ niepowodzeniem, poniewaÅ¼ pusty wektor nie pasuje do wektora zawierajÄ…cego wiersz `\"safe, fast, productive.\"`.\n\n<Listing number=\"12-16\" file-name=\"src/lib.rs\" caption=\"Definiowanie wystarczajÄ…cej czÄ™Å›ci funkcji `search`, aby jej wywoÅ‚anie nie panikowaÅ‚o\">\n\n```rust,noplayground\npub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n    vec![]\n}\n# \n# #[cfg(test)]\n# mod tests {\n#     use super::*;\n# \n#     #[test]\n#     fn one_result() {\n#         let query = \"duct\";\n#         let contents = \"\\\n# Rust:\n# safe, fast, productive.\n# Pick three.\";\n# \n#         assert_eq!(vec![\"safe, fast, productive.\"], search(query, contents));\n#     }\n# }\n```\n\n</Listing>\n\nTeraz omÃ³wmy, dlaczego musimy zdefiniowaÄ‡ jawnÄ… Å¼ywotnoÅ›Ä‡ `'a` w sygnaturze `search` i uÅ¼yÄ‡ tej Å¼ywotnoÅ›ci z argumentem `contents` i wartoÅ›ciÄ… zwracanÄ…. Przypomnij sobie z [RozdziaÅ‚u 10][ch10-lifetimes]<!-- ignore -->, Å¼e parametry Å¼ywotnoÅ›ci okreÅ›lajÄ…, ktÃ³ra Å¼ywotnoÅ›Ä‡ argumentu jest poÅ‚Ä…czona z Å¼ywotnoÅ›ciÄ… wartoÅ›ci zwracanej. W tym przypadku wskazujemy, Å¼e zwrÃ³cony wektor powinien zawieraÄ‡ wycinki ciÄ…gÃ³w znakÃ³w, ktÃ³re odwoÅ‚ujÄ… siÄ™ do wycinkÃ³w argumentu `contents` (a nie argumentu `query`).\n\nInnymi sÅ‚owy, mÃ³wimy Rustowi, Å¼e dane zwrÃ³cone przez funkcjÄ™ `search` bÄ™dÄ… Å¼yÅ‚y tak dÅ‚ugo, jak dane przekazane do funkcji `search` w argumencie `contents`. To jest waÅ¼ne! Dane, do ktÃ³rych odwoÅ‚uje siÄ™ wycinek, muszÄ… byÄ‡ waÅ¼ne, aby referencja byÅ‚a waÅ¼na; jeÅ›li kompilator zaÅ‚oÅ¼y, Å¼e tworzymy wycinki ciÄ…gÃ³w znakÃ³w z `query` zamiast z `contents`, to jego sprawdzanie bezpieczeÅ„stwa bÄ™dzie nieprawidÅ‚owe.\n\nJeÅ›li zapomnimy o adnotacjach Å¼ywotnoÅ›ci i sprÃ³bujemy skompilowaÄ‡ tÄ™ funkcjÄ™, otrzymamy nastÄ™pujÄ…cy bÅ‚Ä…d:\n\n```console\n$ cargo build\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\nerror[E0106]: missing lifetime specifier\n --> src/lib.rs:1:51\n  |\n1 | pub fn search(query: &str, contents: &str) -> Vec<&str> {\n  |                      ----            ----         ^ expected named lifetime parameter\n  |\n  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`\nhelp: consider introducing a named lifetime parameter\n  |\n1 | pub fn search<'a>(query: &'a str, contents: &'a str) -> Vec<&'a str> {\n  |              ++++         ++                 ++              ++\n\nFor more information about this error, try `rustc --explain E0106`.\nerror: could not compile `minigrep` (lib) due to 1 previous error\n```\n\nRust nie moÅ¼e wiedzieÄ‡, ktÃ³ry z dwÃ³ch parametrÃ³w jest nam potrzebny do wyjÅ›cia, wiÄ™c musimy mu to jawnie powiedzieÄ‡. ZauwaÅ¼, Å¼e tekst pomocy sugeruje okreÅ›lenie tego samego parametru czasu Å¼ycia dla wszystkich parametrÃ³w i typu wyjÅ›ciowego, co jest nieprawidÅ‚owe! PoniewaÅ¼ `contents` jest parametrem, ktÃ³ry zawiera caÅ‚y nasz tekst i chcemy zwrÃ³ciÄ‡ pasujÄ…ce fragmenty tego tekstu, wiemy, Å¼e `contents` jest jedynym parametrem, ktÃ³ry powinien byÄ‡ poÅ‚Ä…czony z wartoÅ›ciÄ… zwracanÄ… za pomocÄ… skÅ‚adni czasu Å¼ycia.\n\nInne jÄ™zyki programowania nie wymagajÄ… Å‚Ä…czenia argumentÃ³w z wartoÅ›ciami zwracanymi w sygnaturze, ale ta praktyka z czasem stanie siÄ™ Å‚atwiejsza. MoÅ¼esz porÃ³wnaÄ‡ ten przykÅ‚ad z przykÅ‚adami w sekcji [â€Walidowanie referencji za pomocÄ… Å¼ywotnoÅ›ciâ€][validating-references-with-lifetimes]<!-- ignore --> w Rozdziale 10.\n\n### Pisanie kodu, aby test przeszedÅ‚\n\nObecnie nasz test zawodzi, poniewaÅ¼ zawsze zwracamy pusty wektor. Aby to naprawiÄ‡ i zaimplementowaÄ‡ `search`, nasz program musi wykonaÄ‡ nastÄ™pujÄ…ce kroki:\n\n1. Iteruj przez kaÅ¼dy wiersz zawartoÅ›ci.\n2. SprawdÅº, czy wiersz zawiera nasz ciÄ…g zapytania.\n3. JeÅ›li tak, dodaj go do listy wartoÅ›ci, ktÃ³re zwracamy.\n4. JeÅ›li nie, nie rÃ³b nic.\n5. ZwrÃ³Ä‡ listÄ™ pasujÄ…cych wynikÃ³w.\n\nPrzejdÅºmy przez kaÅ¼dy krok, zaczynajÄ…c od iteracji przez wiersze.\n\n#### Iterowanie przez wiersze za pomocÄ… metody `lines`\n\nRust ma przydatnÄ… metodÄ™ do obsÅ‚ugi iteracji po ciÄ…gach znakÃ³w wiersz po wierszu, wygodnie nazwanÄ… `lines`, ktÃ³ra dziaÅ‚a tak, jak pokazano w Listing 12-17. ZauwaÅ¼, Å¼e to jeszcze siÄ™ nie skompiluje.\n\n<Listing number=\"12-17\" file-name=\"src/lib.rs\" caption=\"Iterowanie przez kaÅ¼dy wiersz w `contents`\">\n\n```rust,ignore,does_not_compile\npub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n    for line in contents.lines() {\n        // do something with line\n    }\n}\n# \n# #[cfg(test)]\n# mod tests {\n#     use super::*;\n# \n#     #[test]\n#     fn one_result() {\n#         let query = \"duct\";\n#         let contents = \"\\\n# Rust:\n# safe, fast, productive.\n# Pick three.\";\n# \n#         assert_eq!(vec![\"safe, fast, productive.\"], search(query, contents));\n#     }\n# }\n```\n\n</Listing>\n\nMetoda `lines` zwraca iterator. DogÅ‚Ä™bnie omÃ³wimy iteratory w [Rozdziale 13][ch13-iterators]<!-- ignore -->. Ale przypomnij sobie, Å¼e widziaÅ‚eÅ› ten sposÃ³b uÅ¼ywania iteratora w [Listing 3-5][ch3-iter]<!-- ignore -->, gdzie uÅ¼ywaliÅ›my pÄ™tli `for` z iteratorem, aby wykonaÄ‡ kod na kaÅ¼dym elemencie w kolekcji.\n\n#### Wyszukiwanie zapytania w kaÅ¼dym wierszu\n\nNastÄ™pnie sprawdzimy, czy bieÅ¼Ä…cy wiersz zawiera nasz ciÄ…g zapytania. Na szczÄ™Å›cie ciÄ…gi znakÃ³w majÄ… przydatnÄ… metodÄ™ o nazwie `contains`, ktÃ³ra to dla nas robi! Dodaj wywoÅ‚anie metody `contains` w funkcji `search`, jak pokazano w Listing 12-18. ZauwaÅ¼, Å¼e to nadal siÄ™ nie skompiluje.\n\n<Listing number=\"12-18\" file-name=\"src/lib.rs\" caption=\"Dodawanie funkcjonalnoÅ›ci, aby sprawdziÄ‡, czy wiersz zawiera ciÄ…g znakÃ³w z `query`\">\n\n```rust,ignore,does_not_compile\npub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n    for line in contents.lines() {\n        if line.contains(query) {\n            // do something with line\n        }\n    }\n}\n# \n# #[cfg(test)]\n# mod tests {\n#     use super::*;\n# \n#     #[test]\n#     fn one_result() {\n#         let query = \"duct\";\n#         let contents = \"\\\n# Rust:\n# safe, fast, productive.\n# Pick three.\";\n# \n#         assert_eq!(vec![\"safe, fast, productive.\"], search(query, contents));\n#     }\n# }\n```\n\n</Listing>\n\nW tej chwili budujemy funkcjonalnoÅ›Ä‡. Aby kod siÄ™ skompilowaÅ‚, musimy zwrÃ³ciÄ‡ wartoÅ›Ä‡ z ciaÅ‚a, zgodnie z tym, co wskazaliÅ›my w sygnaturze funkcji.\n\n#### Przechowywanie pasujÄ…cych wierszy\n\nAby zakoÅ„czyÄ‡ tÄ™ funkcjÄ™, potrzebujemy sposobu na przechowywanie pasujÄ…cych wierszy, ktÃ³re chcemy zwrÃ³ciÄ‡. W tym celu moÅ¼emy stworzyÄ‡ modyfikowalny wektor przed pÄ™tlÄ… `for` i wywoÅ‚aÄ‡ metodÄ™ `push`, aby zapisaÄ‡ `line` w wektorze. Po pÄ™tli `for` zwracamy wektor, jak pokazano w Listing 12-19.\n\n<Listing number=\"12-19\" file-name=\"src/lib.rs\" caption=\"Przechowywanie pasujÄ…cych wierszy, abyÅ›my mogli je zwrÃ³ciÄ‡\">\n\n```rust,ignore\npub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n    let mut results = Vec::new();\n\n    for line in contents.lines() {\n        if line.contains(query) {\n            results.push(line);\n        }\n    }\n\n    results\n}\n# \n# #[cfg(test)]\n# mod tests {\n#     use super::*;\n# \n#     #[test]\n#     fn one_result() {\n#         let query = \"duct\";\n#         let contents = \"\\\n# Rust:\n# safe, fast, productive.\n# Pick three.\";\n# \n#         assert_eq!(vec![\"safe, fast, productive.\"], search(query, contents));\n#     }\n# }\n```\n\n</Listing>\n\nTeraz funkcja `search` powinna zwracaÄ‡ tylko wiersze zawierajÄ…ce `query`, a nasz test powinien przejÅ›Ä‡. Uruchommy test:\n\n```console\n$ cargo test\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.22s\n     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)\n\nrunning 1 test\ntest tests::one_result ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests minigrep\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n```\n\nNasz test przeszedÅ‚, wiÄ™c wiemy, Å¼e dziaÅ‚a!\n\nW tym momencie moglibyÅ›my rozwaÅ¼yÄ‡ moÅ¼liwoÅ›ci refaktoryzacji implementacji funkcji wyszukiwania, jednoczeÅ›nie utrzymujÄ…c testy przechodzÄ…ce, aby zachowaÄ‡ tÄ™ samÄ… funkcjonalnoÅ›Ä‡. Kod w funkcji wyszukiwania nie jest zbyt zÅ‚y, ale nie wykorzystuje niektÃ³rych przydatnych funkcji iteratorÃ³w. WrÃ³cimy do tego przykÅ‚adu w [Rozdziale 13][ch13-iterators]<!-- ignore -->, gdzie szczegÃ³Å‚owo omÃ³wimy iteratory i przyjrzymy siÄ™, jak go ulepszyÄ‡.\n\nTeraz caÅ‚y program powinien dziaÅ‚aÄ‡! WyprÃ³bujmy go najpierw ze sÅ‚owem, ktÃ³re powinno zwrÃ³ciÄ‡ dokÅ‚adnie jeden wiersz z wiersza Emily Dickinson: _frog_.\n\n```console\n$ cargo run -- frog poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.38s\n     Running `target/debug/minigrep frog poem.txt`\nHow public, like a frog\n```\n\nÅšwietnie! Teraz sprÃ³bujmy sÅ‚owa, ktÃ³re bÄ™dzie pasowaÄ‡ do wielu wierszy, na przykÅ‚ad _body_:\n\n```console\n$ cargo run -- body poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep body poem.txt`\nI'm nobody! Who are you?\nAre you nobody, too?\nHow dreary to be somebody!\n```\n\nI na koniec, upewnijmy siÄ™, Å¼e nie otrzymujemy Å¼adnych wierszy, gdy szukamy sÅ‚owa, ktÃ³rego nie ma w wierszu, na przykÅ‚ad _monomorfization_:\n\n```console\n$ cargo run -- monomorphization poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep monomorphization poem.txt`\n```\n\nDoskonale! ZbudowaliÅ›my naszÄ… mini wersjÄ™ klasycznego narzÄ™dzia i wiele nauczyliÅ›my siÄ™ o tym, jak strukturyzowaÄ‡ aplikacje. NauczyliÅ›my siÄ™ rÃ³wnieÅ¼ trochÄ™ o wejÅ›ciu i wyjÅ›ciu plikowym, Å¼ywotnoÅ›ci, testowaniu i parsowaniu wiersza poleceÅ„.\n\nAby zakoÅ„czyÄ‡ ten projekt, krÃ³tko zademonstrujemy, jak pracowaÄ‡ ze zmiennymi Å›rodowiskowymi i jak drukowaÄ‡ do standardowego strumienia bÅ‚Ä™dÃ³w, co jest przydatne podczas pisania programÃ³w wiersza poleceÅ„.\n\n[validating-references-with-lifetimes]: ch10-03-lifetime-syntax.html#validating-references-with-lifetimes\n[ch11-anatomy]: ch11-01-writing-tests.html#the-anatomy-of-a-test-function\n[ch10-lifetimes]: ch10-03-lifetime-syntax.html\n[ch3-iter]: ch03-05-control-flow.html#looping-through-a-collection-with-for\n[ch13-iterators]: ch13-02-iterators.html",
        "chapter_title": "Dodawanie funkcjonalnoÅ›ci z wykorzystaniem programowania sterowanego testami"
    },
    {
        "file_path": "ch12-05-working-with-environment-variables.md",
        "content": "## Praca ze zmiennymi Å›rodowiskowymi\n\nUdoskonalimy plik binarny `minigrep`, dodajÄ…c dodatkowÄ… funkcjÄ™: opcjÄ™ wyszukiwania bez uwzglÄ™dniania wielkoÅ›ci liter, ktÃ³rÄ… uÅ¼ytkownik moÅ¼e wÅ‚Ä…czyÄ‡ za pomocÄ… zmiennej Å›rodowiskowej. MoglibyÅ›my uczyniÄ‡ tÄ™ funkcjÄ™ opcjÄ… wiersza poleceÅ„ i wymagaÄ‡ od uÅ¼ytkownikÃ³w wprowadzania jej za kaÅ¼dym razem, gdy chcÄ… jÄ… zastosowaÄ‡, ale zamiast tego, tworzÄ…c zmiennÄ… Å›rodowiskowÄ…, pozwalamy naszym uÅ¼ytkownikom ustawiÄ‡ zmiennÄ… Å›rodowiskowÄ… raz i mieÄ‡ wszystkie ich wyszukiwania bez uwzglÄ™dniania wielkoÅ›ci liter w tej sesji terminala.\n\n<!-- Old headings. Do not remove or links may break. -->\n<a id=\"writing-a-failing-test-for-the-case-insensitive-search-function\"></a>\n\n### Pisanie nieudanego testu dla wyszukiwania bez uwzglÄ™dniania wielkoÅ›ci liter\n\nNajpierw dodajemy nowÄ… funkcjÄ™ `search_case_insensitive` do biblioteki `minigrep`, ktÃ³ra zostanie wywoÅ‚ana, gdy zmienna Å›rodowiskowa bÄ™dzie miaÅ‚a wartoÅ›Ä‡. BÄ™dziemy kontynuowaÄ‡ proces TDD, wiÄ™c pierwszym krokiem ponownie jest napisanie nieudanego testu. Dodamy nowy test dla nowej funkcji `search_case_insensitive` i zmienimy nazwÄ™ naszego starego testu z `one_result` na `case_sensitive`, aby wyjaÅ›niÄ‡ rÃ³Å¼nice miÄ™dzy dwoma testami, jak pokazano w Listing 12-20.\n\n<Listing number=\"12-20\" file-name=\"src/lib.rs\" caption=\"Dodawanie nowego nieudanego testu dla funkcji bez uwzglÄ™dniania wielkoÅ›ci liter, ktÃ³rÄ… zamierzamy dodaÄ‡\">\n\n```rust,ignore,does_not_compile\n# pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n#     let mut results = Vec::new();\n# \n#     for line in contents.lines() {\n#         if line.contains(query) {\n#             results.push(line);\n#         }\n#     }\n# \n#     results\n# }\n# \n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn case_sensitive() {\n        let query = \"duct\";\n        let contents = \"\\\nRust:\nsafe, fast, productive.\nPick three.\nDuct tape.\";\n\n        assert_eq!(vec![\"safe, fast, productive.\"], search(query, contents));\n    }\n\n    #[test]\n    fn case_insensitive() {\n        let query = \"rUsT\";\n        let contents = \"\\\nRust:\nsafe, fast, productive.\nPick three.\nTrust me.\";\n\n        assert_eq!(\n            vec![\"Rust:\", \"Trust me.\"],\n            search_case_insensitive(query, contents)\n        );\n    }\n}\n```\n\n</Listing>\n\nZauwaÅ¼, Å¼e zmodyfikowaliÅ›my rÃ³wnieÅ¼ `contents` starego testu. DodaliÅ›my nowy wiersz z tekstem `\"Duct tape.\"` z wielkÄ… literÄ… _D_, ktÃ³ry nie powinien pasowaÄ‡ do zapytania `\"duct\"` podczas wyszukiwania z uwzglÄ™dnieniem wielkoÅ›ci liter. Zmiana starego testu w ten sposÃ³b pomaga upewniÄ‡ siÄ™, Å¼e nie uszkodzimy przypadkowo funkcjonalnoÅ›ci wyszukiwania z uwzglÄ™dnieniem wielkoÅ›ci liter, ktÃ³rÄ… juÅ¼ zaimplementowaliÅ›my. Ten test powinien teraz przejÅ›Ä‡ i powinien nadal przechodziÄ‡ podczas pracy nad wyszukiwaniem bez uwzglÄ™dniania wielkoÅ›ci liter.\n\nNowy test dla wyszukiwania bez uwzglÄ™dniania wielkoÅ›ci liter (case-_insensitive_) uÅ¼ywa `\"rUsT\"` jako zapytania. W funkcji `search_case_insensitive`, ktÃ³rÄ… zaraz dodamy, zapytanie `\"rUsT\"` powinno pasowaÄ‡ do wiersza zawierajÄ…cego `\"Rust:\"` z wielkÄ… literÄ… _R_ oraz do wiersza `\"Trust me.\"` mimo Å¼e oba majÄ… innÄ… wielkoÅ›Ä‡ liter niÅ¼ zapytanie. To jest nasz test, ktÃ³ry zakoÅ„czy siÄ™ niepowodzeniem, poniewaÅ¼ nie zdefiniowaliÅ›my jeszcze funkcji `search_case_insensitive`. MoÅ¼esz dodaÄ‡ szkieletowÄ… implementacjÄ™, ktÃ³ra zawsze zwraca pusty wektor, podobnie jak zrobiliÅ›my to dla funkcji `search` w Listing 12-16, aby zobaczyÄ‡, jak test siÄ™ kompiluje i koÅ„czy niepowodzeniem.\n\n### Implementowanie funkcji `search_case_insensitive`\n\nFunkcja `search_case_insensitive`, pokazana w Listing 12-21, bÄ™dzie prawie taka sama jak funkcja `search`. JedynÄ… rÃ³Å¼nicÄ… jest to, Å¼e zmienimy `query` i kaÅ¼dy `line` na maÅ‚e litery, tak aby niezaleÅ¼nie od wielkoÅ›ci liter w argumentach wejÅ›ciowych, miaÅ‚y one tÄ™ samÄ… wielkoÅ›Ä‡ liter, gdy sprawdzamy, czy wiersz zawiera zapytanie.\n\n<Listing number=\"12-21\" file-name=\"src/lib.rs\" caption=\"Definiowanie funkcji `search_case_insensitive`, ktÃ³ra zamienia zapytanie i wiersz na maÅ‚e litery przed ich porÃ³wnaniem\">\n\n```rust,noplayground\n# pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n#     let mut results = Vec::new();\n# \n#     for line in contents.lines() {\n#         if line.contains(query) {\n#             results.push(line);\n#         }\n#     }\n# \n#     results\n# }\n# \npub fn search_case_insensitive<'a>(\n    query: &str,\n    contents: &'a str,\n) -> Vec<&'a str> {\n    let query = query.to_lowercase();\n    let mut results = Vec::new();\n\n    for line in contents.lines() {\n        if line.to_lowercase().contains(&query) {\n            results.push(line);\n        }\n    }\n\n    results\n}\n# \n# #[cfg(test)]\n# mod tests {\n#     use super::*;\n# \n#     #[test]\n#     fn case_sensitive() {\n#         let query = \"duct\";\n#         let contents = \"\\\n# Rust:\n# safe, fast, productive.\n# Pick three.\n# Duct tape.\";\n# \n#         assert_eq!(vec![\"safe, fast, productive.\"], search(query, contents));\n#     }\n# \n#     #[test]\n#     fn case_insensitive() {\n#         let query = \"rUsT\";\n#         let contents = \"\\\n# Rust:\n# safe, fast, productive.\n# Pick three.\n# Trust me.\";\n# \n#         assert_eq!(\n#             vec![\"Rust:\", \"Trust me.\"],\n#             search_case_insensitive(query, contents)\n#         );\n#     }\n# }\n```\n\n</Listing>\n\nNajpierw zmieniamy ciÄ…g znakÃ³w `query` na maÅ‚e litery i przechowujemy go w nowej zmiennej o tej samej nazwie, zasÅ‚aniajÄ…c oryginalny `query`. WywoÅ‚anie `to_lowercase` na zapytaniu jest konieczne, aby niezaleÅ¼nie od tego, czy zapytanie uÅ¼ytkownika to `\"rust\"`, `\"RUST\"`, `\"Rust\"`, czy `\"rUsT\"`, traktowaÄ‡ zapytanie tak, jakby byÅ‚o `\"rust\"` i ignorowaÄ‡ wielkoÅ›Ä‡ liter. ChociaÅ¼ `to_lowercase` poradzi sobie z podstawowym Unicode, nie bÄ™dzie w 100 procentach dokÅ‚adne. GdybyÅ›my pisali prawdziwÄ… aplikacjÄ™, chcielibyÅ›my wÅ‚oÅ¼yÄ‡ w to wiÄ™cej pracy, ale ta sekcja dotyczy zmiennych Å›rodowiskowych, a nie Unicode, wiÄ™c na tym poprzestaniemy.\n\nZauwaÅ¼, Å¼e `query` jest teraz `String`, a nie wycinkiem ciÄ…gu znakÃ³w, poniewaÅ¼ wywoÅ‚anie `to_lowercase` tworzy nowe dane, zamiast odwoÅ‚ywaÄ‡ siÄ™ do istniejÄ…cych. Na przykÅ‚ad, jeÅ›li zapytanie to `\"rUsT\"`: ten wycinek ciÄ…gu znakÃ³w nie zawiera maÅ‚ych liter `u` ani `t`, ktÃ³rych moglibyÅ›my uÅ¼yÄ‡, wiÄ™c musimy zaalokowaÄ‡ nowy `String` zawierajÄ…cy `\"rust\"`. Kiedy teraz przekazujemy `query` jako argument do metody `contains`, musimy dodaÄ‡ ampersand, poniewaÅ¼ sygnatura `contains` jest zdefiniowana tak, aby przyjmowaÅ‚a wycinek ciÄ…gu znakÃ³w.\n\nNastÄ™pnie dodajemy wywoÅ‚anie `to_lowercase` na kaÅ¼dym `line`, aby zmieniÄ‡ wszystkie znaki na maÅ‚e litery. Teraz, gdy przekonwertowaliÅ›my `line` i `query` na maÅ‚e litery, znajdziemy dopasowania niezaleÅ¼nie od wielkoÅ›ci liter w zapytaniu.\n\nSprawdÅºmy, czy ta implementacja przechodzi testy:\n\n```console\n$ cargo test\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.33s\n     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)\n\nrunning 2 tests\ntest tests::case_insensitive ... ok\ntest tests::case_sensitive ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests minigrep\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n```\n\nÅšwietnie! Testy przeszÅ‚y. Teraz wywoÅ‚ajmy nowÄ… funkcjÄ™ `search_case_insensitive` z funkcji `run`. Najpierw dodamy opcjÄ™ konfiguracji do struktury `Config`, aby przeÅ‚Ä…czaÄ‡ siÄ™ miÄ™dzy wyszukiwaniem z uwzglÄ™dnianiem wielkoÅ›ci liter a wyszukiwaniem bez uwzglÄ™dniania wielkoÅ›ci liter. Dodanie tego pola spowoduje bÅ‚Ä™dy kompilacji, poniewaÅ¼ nigdzie jeszcze nie inicjalizujemy tego pola:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust,ignore,does_not_compile\n# use std::env;\n# use std::error::Error;\n# use std::fs;\n# use std::process;\n# \n# use minigrep::{search, search_case_insensitive};\n# \n# // --snip--\n# \n# \n# fn main() {\n#     let args: Vec<String> = env::args().collect();\n# \n#     let config = Config::build(&args).unwrap_or_else(|err| {\n#         println!(\"Problem parsing arguments: {err}\");\n#         process::exit(1);\n#     });\n# \n#     if let Err(e) = run(config) {\n#         println!(\"Application error: {e}\");\n#         process::exit(1);\n#     }\n# }\n# \npub struct Config {\n    pub query: String,\n    pub file_path: String,\n    pub ignore_case: bool,\n}\n# \n# impl Config {\n#     fn build(args: &[String]) -> Result<Config, &'static str> {\n#         if args.len() < 3 {\n#             return Err(\"not enough arguments\");\n#         }\n# \n#         let query = args[1].clone();\n#         let file_path = args[2].clone();\n# \n#         Ok(Config { query, file_path })\n#     }\n# }\n# \n# fn run(config: Config) -> Result<(), Box<dyn Error>> {\n#     let contents = fs::read_to_string(config.file_path)?;\n# \n#     let results = if config.ignore_case {\n#         search_case_insensitive(&config.query, &contents)\n#     } else {\n#         search(&config.query, &contents)\n#     };\n# \n#     for line in results {\n#         println!(\"{line}\");\n#     }\n# \n#     Ok(())\n# }\n```\n\nDodaliÅ›my pole `ignore_case`, ktÃ³re przechowuje wartoÅ›Ä‡ typu boolean. NastÄ™pnie funkcja `run` musi sprawdziÄ‡ wartoÅ›Ä‡ pola `ignore_case` i na tej podstawie zdecydowaÄ‡, czy wywoÅ‚aÄ‡ funkcjÄ™ `search`, czy funkcjÄ™ `search_case_insensitive`, jak pokazano w Listing 12-22. To jeszcze siÄ™ nie skompiluje.\n\n<Listing number=\"12-22\" file-name=\"src/main.rs\" caption=\"WywoÅ‚ywanie `search` lub `search_case_insensitive` w zaleÅ¼noÅ›ci od wartoÅ›ci w `config.ignore_case`\">\n\n```rust,ignore,does_not_compile\n# use std::env;\n# use std::error::Error;\n# use std::fs;\n# use std::process;\n# \nuse minigrep::{search, search_case_insensitive};\n\n// --snip--\n\n# \n# fn main() {\n#     let args: Vec<String> = env::args().collect();\n# \n#     let config = Config::build(&args).unwrap_or_else(|err| {\n#         println!(\"Problem parsing arguments: {err}\");\n#         process::exit(1);\n#     });\n# \n#     if let Err(e) = run(config) {\n#         println!(\"Application error: {e}\");\n#         process::exit(1);\n#     }\n# }\n# \n# pub struct Config {\n#     pub query: String,\n#     pub file_path: String,\n#     pub ignore_case: bool,\n# }\n# \n# impl Config {\n#     fn build(args: &[String]) -> Result<Config, &'static str> {\n#         if args.len() < 3 {\n#             return Err(\"not enough arguments\");\n#         }\n# \n#         let query = args[1].clone();\n#         let file_path = args[2].clone();\n# \n#         Ok(Config { query, file_path })\n#     }\n# }\n# \nfn run(config: Config) -> Result<(), Box<dyn Error>> {\n    let contents = fs::read_to_string(config.file_path)?;\n\n    let results = if config.ignore_case {\n        search_case_insensitive(&config.query, &contents)\n    } else {\n        search(&config.query, &contents)\n    };\n\n    for line in results {\n        println!(\"{line}\");\n    }\n\n    Ok(())\n}\n```\n\n</Listing>\n\nNa koniec musimy sprawdziÄ‡ zmiennÄ… Å›rodowiskowÄ…. Funkcje do pracy ze zmiennymi Å›rodowiskowymi znajdujÄ… siÄ™ w module `env` w standardowej bibliotece, ktÃ³ry jest juÅ¼ w zakresie na poczÄ…tku pliku _src/main.rs_. UÅ¼yjemy funkcji `var` z moduÅ‚u `env`, aby sprawdziÄ‡, czy jakakolwiek wartoÅ›Ä‡ zostaÅ‚a ustawiona dla zmiennej Å›rodowiskowej o nazwie `IGNORE_CASE`, jak pokazano w Listing 12-23.\n\n<Listing number=\"12-23\" file-name=\"src/main.rs\" caption=\"Sprawdzanie dowolnej wartoÅ›ci w zmiennej Å›rodowiskowej o nazwie `IGNORE_CASE`\">\n\n```rust,ignore,noplayground\n# use std::env;\n# use std::error::Error;\n# use std::fs;\n# use std::process;\n# \n# use minigrep::{search, search_case_insensitive};\n# \n# fn main() {\n#     let args: Vec<String> = env::args().collect();\n# \n#     let config = Config::build(&args).unwrap_or_else(|err| {\n#         println!(\"Problem parsing arguments: {err}\");\n#         process::exit(1);\n#     });\n# \n#     if let Err(e) = run(config) {\n#         println!(\"Application error: {e}\");\n#         process::exit(1);\n#     }\n# }\n# \n# pub struct Config {\n#     pub query: String,\n#     pub file_path: String,\n#     pub ignore_case: bool,\n# }\n# \nimpl Config {\n    fn build(args: &[String]) -> Result<Config, &'static str> {\n        if args.len() < 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        let ignore_case = env::var(\"IGNORE_CASE\").is_ok();\n\n        Ok(Config {\n            query,\n            file_path,\n            ignore_case,\n        })\n    }\n}\n# \n# fn run(config: Config) -> Result<(), Box<dyn Error>> {\n#     let contents = fs::read_to_string(config.file_path)?;\n# \n#     let results = if config.ignore_case {\n#         search_case_insensitive(&config.query, &contents)\n#     } else {\n#         search(&config.query, &contents)\n#     };\n# \n#     for line in results {\n#         println!(\"{line}\");\n#     }\n# \n#     Ok(())\n# }\n```\n\n</Listing>\n\nTutaj tworzymy nowÄ… zmiennÄ… `ignore_case`. Aby ustawiÄ‡ jej wartoÅ›Ä‡, wywoÅ‚ujemy funkcjÄ™ `env::var` i przekazujemy jej nazwÄ™ zmiennej Å›rodowiskowej `IGNORE_CASE`. Funkcja `env::var` zwraca `Result`, ktÃ³ry bÄ™dzie wariantem `Ok` zawierajÄ…cym wartoÅ›Ä‡ zmiennej Å›rodowiskowej, jeÅ›li zmienna Å›rodowiskowa jest ustawiona na jakÄ…kolwiek wartoÅ›Ä‡. ZwrÃ³ci wariant `Err`, jeÅ›li zmienna Å›rodowiskowa nie jest ustawiona.\n\nUÅ¼ywamy metody `is_ok` na `Result`, aby sprawdziÄ‡, czy zmienna Å›rodowiskowa jest ustawiona, co oznacza, Å¼e program powinien przeprowadziÄ‡ wyszukiwanie bez uwzglÄ™dniania wielkoÅ›ci liter. JeÅ›li zmienna Å›rodowiskowa `IGNORE_CASE` nie jest ustawiona na nic, `is_ok` zwrÃ³ci `false`, a program przeprowadzi wyszukiwanie z uwzglÄ™dnieniem wielkoÅ›ci liter. Nie obchodzi nas _wartoÅ›Ä‡_ zmiennej Å›rodowiskowej, tylko to, czy jest ustawiona, czy nie, wiÄ™c sprawdzamy `is_ok` zamiast uÅ¼ywaÄ‡ `unwrap`, `expect` lub innych metod, ktÃ³re widzieliÅ›my na `Result`.\n\nPrzekazujemy wartoÅ›Ä‡ zmiennej `ignore_case` do instancji `Config`, aby funkcja `run` mogÅ‚a odczytaÄ‡ tÄ™ wartoÅ›Ä‡ i zdecydowaÄ‡, czy wywoÅ‚aÄ‡ `search_case_insensitive`, czy `search`, jak zaimplementowaliÅ›my w Listing 12-22.\n\nWyprÃ³bujmy to! Najpierw uruchomimy nasz program bez ustawionej zmiennej Å›rodowiskowej i z zapytaniem `to`, ktÃ³re powinno pasowaÄ‡ do kaÅ¼dego wiersza zawierajÄ…cego sÅ‚owo _to_ pisanego maÅ‚ymi literami:\n\n```console\n$ cargo run -- to poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep to poem.txt`\nAre you nobody, too?\nHow dreary to be somebody!\n```\n\nWyglÄ…da na to, Å¼e to nadal dziaÅ‚a! Teraz uruchommy program z `IGNORE_CASE` ustawionym na `1`, ale z tym samym zapytaniem `to`:\n\n```console\n$ IGNORE_CASE=1 cargo run -- to poem.txt\n```\n\nJeÅ›li uÅ¼ywasz PowerShell, musisz ustawiÄ‡ zmiennÄ… Å›rodowiskowÄ… i uruchomiÄ‡ program jako osobne polecenia:\n\n```console\nPS> $Env:IGNORE_CASE=1; cargo run -- to poem.txt\n```\n\nSpowoduje to, Å¼e `IGNORE_CASE` bÄ™dzie obowiÄ…zywaÄ‡ przez resztÄ™ sesji powÅ‚oki. MoÅ¼na go usunÄ…Ä‡ za pomocÄ… polecenia `Remove-Item`:\n\n```console\nPS> Remove-Item Env:IGNORE_CASE\n```\n\nPpowinniÅ›my otrzymaÄ‡ wiersze, ktÃ³re zawierajÄ… _to_ z ewentualnymi duÅ¼ymi literami:\n\n<!-- manual-regeneration\ncd listings/ch12-an-io-project/listing-12-23\nIGNORE_CASE=1 cargo run -- to poem.txt\ncan't extract because of the environment variable\n-->\n\n```console\nAre you nobody, too?\nHow dreary to be somebody!\nTo tell your name the livelong day\nTo an admiring bog!\n```\n\nDoskonale, dostaliÅ›my teÅ¼ linie zawierajÄ…ce _To_! Nasz program `minigrep` moÅ¼e teraz przeprowadzaÄ‡ wyszukiwanie bez uwzglÄ™dniania wielkoÅ›ci liter, sterowane zmiennÄ… Å›rodowiskowÄ…. Teraz wiesz, jak zarzÄ…dzaÄ‡ opcjami ustawionymi za pomocÄ… argumentÃ³w wiersza poleceÅ„ lub zmiennych Å›rodowiskowych.\n\nNiektÃ³re programy pozwalajÄ… na uÅ¼ycie argumentÃ³w _i_ zmiennych Å›rodowiskowych dla tej samej konfiguracji. W takich przypadkach programy decydujÄ…, ktÃ³re z nich majÄ… pierwszeÅ„stwo. W ramach samodzielnego Ä‡wiczenia sprÃ³buj kontrolowaÄ‡ czuÅ‚oÅ›Ä‡ na wielkoÅ›Ä‡ liter za pomocÄ… argumentu wiersza poleceÅ„ lub zmiennej Å›rodowiskowej. Zdecyduj, czy argument wiersza poleceÅ„, czy zmienna Å›rodowiskowa powinna mieÄ‡ pierwszeÅ„stwo, jeÅ›li program jest uruchamiany z jednym ustawionym na uwzglÄ™dnianie wielkoÅ›ci liter, a drugim na ignorowanie wielkoÅ›ci liter.\n\nModuÅ‚ `std::env` zawiera wiele innych przydatnych funkcji do obsÅ‚ugi zmiennych Å›rodowiskowych: zajrzyj do jego dokumentacji, aby zobaczyÄ‡, co jest dostÄ™pne.",
        "chapter_title": "Praca ze zmiennymi Å›rodowiskowymi"
    },
    {
        "file_path": "ch12-06-writing-to-stderr-instead-of-stdout.md",
        "content": "<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"writing-error-messages-to-standard-error-instead-of-standard-output\"></a>\n\n## Przekierowywanie bÅ‚Ä™dÃ³w do standardowego strumienia bÅ‚Ä™dÃ³w\n\nW tej chwili wszystkie nasze dane wyjÅ›ciowe zapisujemy do terminala za pomocÄ… makra `println!`. W wiÄ™kszoÅ›ci terminali istniejÄ… dwa rodzaje danych wyjÅ›ciowych: _standardowe wyjÅ›cie_ (`stdout`) dla ogÃ³lnych informacji i _standardowy bÅ‚Ä…d_ (`stderr`) dla komunikatÃ³w o bÅ‚Ä™dach. To rozrÃ³Å¼nienie umoÅ¼liwia uÅ¼ytkownikom skierowanie pomyÅ›lnych danych wyjÅ›ciowych programu do pliku, ale nadal wyÅ›wietlanie komunikatÃ³w o bÅ‚Ä™dach na ekranie.\n\nMakro `println!` jest w stanie drukowaÄ‡ tylko na standardowe wyjÅ›cie, wiÄ™c musimy uÅ¼yÄ‡ czegoÅ› innego do drukowania na standardowy bÅ‚Ä…d.\n\n### Sprawdzanie, gdzie sÄ… zapisywane bÅ‚Ä™dy\n\nNajpierw zaobserwujmy, jak zawartoÅ›Ä‡ drukowana przez `minigrep` jest obecnie zapisywana na standardowe wyjÅ›cie, w tym wszelkie komunikaty o bÅ‚Ä™dach, ktÃ³re chcielibyÅ›my zamiast tego zapisaÄ‡ na standardowy strumieÅ„ bÅ‚Ä™dÃ³w. Zrobimy to, przekierowujÄ…c standardowy strumieÅ„ wyjÅ›ciowy do pliku, celowo powodujÄ…c bÅ‚Ä…d. Nie bÄ™dziemy przekierowywaÄ‡ standardowego strumienia bÅ‚Ä™dÃ³w, wiÄ™c wszelka zawartoÅ›Ä‡ wysÅ‚ana na standardowy strumieÅ„ bÅ‚Ä™dÃ³w bÄ™dzie nadal wyÅ›wietlana na ekranie.\n\nOczekuje siÄ™, Å¼e programy wiersza poleceÅ„ wysyÅ‚ajÄ… komunikaty o bÅ‚Ä™dach do standardowego strumienia bÅ‚Ä™dÃ³w, abyÅ›my mogli nadal widzieÄ‡ komunikaty o bÅ‚Ä™dach na ekranie, nawet jeÅ›li przekierujemy standardowy strumieÅ„ wyjÅ›ciowy do pliku. Nasz program nie zachowuje siÄ™ obecnie poprawnie: zaraz zobaczymy, Å¼e zapisuje komunikaty o bÅ‚Ä™dach do pliku!\n\nAby zademonstrowaÄ‡ to zachowanie, uruchomimy program z `>` i Å›cieÅ¼kÄ… pliku _output.txt_, do ktÃ³rej chcemy przekierowaÄ‡ standardowy strumieÅ„ wyjÅ›ciowy. Nie bÄ™dziemy przekazywaÄ‡ Å¼adnych argumentÃ³w, co powinno spowodowaÄ‡ bÅ‚Ä…d:\n\n```console\n$ cargo run > output.txt\n```\n\nSkÅ‚adnia `>` informuje powÅ‚okÄ™, aby zapisaÅ‚a zawartoÅ›Ä‡ standardowego wyjÅ›cia do _output.txt_ zamiast na ekran. Nie zobaczyliÅ›my komunikatu o bÅ‚Ä™dzie, ktÃ³rego siÄ™ spodziewaliÅ›my, na ekranie, wiÄ™c musi on trafiÄ‡ do pliku. Oto co zawiera _output.txt_:\n\n```text\nProblem parsing arguments: not enough arguments\n```\n\nTak, nasz komunikat o bÅ‚Ä™dzie jest drukowany na standardowe wyjÅ›cie. DuÅ¼o bardziej uÅ¼yteczne jest drukowanie takich komunikatÃ³w o bÅ‚Ä™dach na standardowy strumieÅ„ bÅ‚Ä™dÃ³w, tak aby do pliku trafiaÅ‚y tylko dane z pomyÅ›lnego uruchomienia. Zmienimy to.\n\n### Drukowanie bÅ‚Ä™dÃ³w na standardowy strumieÅ„ bÅ‚Ä™dÃ³w\n\nUÅ¼yjemy kodu z Listing 12-24, aby zmieniÄ‡ sposÃ³b drukowania komunikatÃ³w o bÅ‚Ä™dach. DziÄ™ki refaktoryzacji, ktÃ³rÄ… przeprowadziliÅ›my wczeÅ›niej w tym rozdziale, caÅ‚y kod drukujÄ…cy komunikaty o bÅ‚Ä™dach znajduje siÄ™ w jednej funkcji, `main`. Standardowa biblioteka dostarcza makro `eprintln!`, ktÃ³re drukuje na standardowy strumieÅ„ bÅ‚Ä™dÃ³w, wiÄ™c zmieÅ„my dwa miejsca, w ktÃ³rych wywoÅ‚ywaliÅ›my `println!` do drukowania bÅ‚Ä™dÃ³w, aby zamiast tego uÅ¼yÄ‡ `eprintln!`.\n\n<Listing number=\"12-24\" file-name=\"src/main.rs\" caption=\"Zapisywanie komunikatÃ³w o bÅ‚Ä™dach na standardowy strumieÅ„ bÅ‚Ä™dÃ³w zamiast na standardowe wyjÅ›cie za pomocÄ… `eprintln!`\">\n\n```rust,ignore\n# use std::env;\n# use std::error::Error;\n# use std::fs;\n# use std::process;\n# \n# use minigrep::{search, search_case_insensitive};\n# \nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let config = Config::build(&args).unwrap_or_else(|err| {\n        eprintln!(\"Problem parsing arguments: {err}\");\n        process::exit(1);\n    });\n\n    if let Err(e) = run(config) {\n        eprintln!(\"Application error: {e}\");\n        process::exit(1);\n    }\n}\n# \n# pub struct Config {\n#     pub query: String,\n#     pub file_path: String,\n#     pub ignore_case: bool,\n# }\n# \n# impl Config {\n#     fn build(args: &[String]) -> Result<Config, &'static str> {\n#         if args.len() < 3 {\n#             return Err(\"not enough arguments\");\n#         }\n# \n#         let query = args[1].clone();\n#         let file_path = args[2].clone();\n# \n#         let ignore_case = env::var(\"IGNORE_CASE\").is_ok();\n# \n#         Ok(Config {\n#             query,\n#             file_path,\n#             ignore_case,\n#         })\n#     }\n# }\n# \n# fn run(config: Config) -> Result<(), Box<dyn Error>> {\n#     let contents = fs::read_to_string(config.file_path)?;\n# \n#     let results = if config.ignore_case {\n#         search_case_insensitive(&config.query, &contents)\n#     } else {\n#         search(&config.query, &contents)\n#     };\n# \n#     for line in results {\n#         println!(\"{line}\");\n#     }\n# \n#     Ok(())\n# }\n```\n\n</Listing>\n\nUruchommy teraz program ponownie w ten sam sposÃ³b, bez Å¼adnych argumentÃ³w i przekierowujÄ…c standardowe wyjÅ›cie za pomocÄ… `>`:\n\n```console\n$ cargo run > output.txt\nProblem parsing arguments: not enough arguments\n```\n\nTeraz widzimy bÅ‚Ä…d na ekranie, a plik _output.txt_ jest pusty, co jest zachowaniem, ktÃ³rego oczekujemy od programÃ³w wiersza poleceÅ„.\n\nUruchommy program ponownie z argumentami, ktÃ³re nie powodujÄ… bÅ‚Ä™du, ale nadal przekierowujÄ… standardowe wyjÅ›cie do pliku, w nastÄ™pujÄ…cy sposÃ³b:\n\n```console\n$ cargo run -- to poem.txt > output.txt\n```\n\nNie zobaczymy Å¼adnych danych wyjÅ›ciowych w terminalu, a plik _output.txt_ bÄ™dzie zawieraÅ‚ nasze wyniki:\n\n<span class=\"filename\">Nazwa pliku: output.txt</span>\n\n```text\nAre you nobody, too?\nHow dreary to be somebody!\n```\n\nTo pokazuje, Å¼e teraz uÅ¼ywamy standardowego wyjÅ›cia dla pomyÅ›lnych wynikÃ³w i standardowego strumienia bÅ‚Ä™dÃ³w dla komunikatÃ³w o bÅ‚Ä™dach, stosownie do potrzeb.\n\n## Podsumowanie\n\nTen rozdziaÅ‚ podsumowaÅ‚ niektÃ³re z gÅ‚Ã³wnych pojÄ™Ä‡, ktÃ³re poznaÅ‚eÅ› do tej pory, i omÃ³wiÅ‚, jak wykonywaÄ‡ typowe operacje wejÅ›cia/wyjÅ›cia w Rust. KorzystajÄ…c z argumentÃ³w wiersza poleceÅ„, plikÃ³w, zmiennych Å›rodowiskowych i makra `eprintln!` do drukowania bÅ‚Ä™dÃ³w, jesteÅ› teraz przygotowany do pisania aplikacji wiersza poleceÅ„. W poÅ‚Ä…czeniu z koncepcjami z poprzednich rozdziaÅ‚Ã³w, TwÃ³j kod bÄ™dzie dobrze zorganizowany, skutecznie przechowywaÅ‚ dane w odpowiednich strukturach danych, Å‚adnie obsÅ‚ugiwaÅ‚ bÅ‚Ä™dy i bÄ™dzie dobrze przetestowany.\n\nNastÄ™pnie zbadamy niektÃ³re funkcje Rusta, ktÃ³re zostaÅ‚y zainspirowane jÄ™zykami funkcyjnymi: domkniÄ™cia i iteratory.\n",
        "chapter_title": "Przekierowywanie bÅ‚Ä™dÃ³w do standardowego strumienia bÅ‚Ä™dÃ³w"
    },
    {
        "file_path": "ch13-00-functional-features.md",
        "content": "# Funkcjonalne cechy jÄ™zyka: Iteratory i domkniÄ™cia\n\nProjekt Rusta czerpie inspiracjÄ™ z wielu istniejÄ…cych jÄ™zykÃ³w i technik, a jednym z istotnych wpÅ‚ywÃ³w jest _programowanie funkcyjne_. Programowanie w stylu funkcyjnym czÄ™sto obejmuje uÅ¼ywanie funkcji jako wartoÅ›ci, przekazywanie ich w argumentach, zwracanie ich z innych funkcji, przypisywanie ich do zmiennych do pÃ³Åºniejszego wykonania i tak dalej.\n\nW tym rozdziale nie bÄ™dziemy debatowaÄ‡ nad tym, czym jest lub nie jest programowanie funkcyjne, ale zamiast tego omÃ³wimy niektÃ³re cechy Rusta, ktÃ³re sÄ… podobne do cech w wielu jÄ™zykach czÄ™sto okreÅ›lanych jako funkcyjne.\n\nBardziej szczegÃ³Å‚owo omÃ³wimy:\n\n- _DomkniÄ™cia_, konstrukcje podobne do funkcji, ktÃ³re moÅ¼na przechowywaÄ‡ w zmiennej\n- _Iteratory_, sposÃ³b przetwarzania serii elementÃ³w\n- Jak uÅ¼ywaÄ‡ domkniÄ™Ä‡ i iteratorÃ³w do ulepszenia projektu I/O z RozdziaÅ‚u 12\n- WydajnoÅ›Ä‡ domkniÄ™Ä‡ i iteratorÃ³w (spoiler: sÄ… szybsze, niÅ¼ mogÅ‚oby siÄ™ wydawaÄ‡!)\n\nOmÃ³wiliÅ›my juÅ¼ inne cechy Rusta, takie jak dopasowywanie wzorcÃ³w i wyliczenia, ktÃ³re rÃ³wnieÅ¼ sÄ… inspirowane stylem funkcyjnym. PoniewaÅ¼ opanowanie domkniÄ™Ä‡ i iteratorÃ³w jest waÅ¼nÄ… czÄ™Å›ciÄ… pisania szybkiego, idiomatycznego kodu w Rust, poÅ›wiÄ™cimy im caÅ‚y ten rozdziaÅ‚.\n",
        "chapter_title": "Funkcjonalne cechy jÄ™zyka: Iteratory i domkniÄ™cia"
    },
    {
        "file_path": "ch13-01-closures.md",
        "content": "<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"closures-anonymous-functions-that-can-capture-their-environment\"></a>\n<a id=\"closures-anonymous-functions-that-capture-their-environment\"></a>\n\n## DomkniÄ™cia\n\nDomkniÄ™cia w Rust to anonimowe funkcje, ktÃ³re moÅ¼na zapisaÄ‡ w zmiennej lub przekazaÄ‡ jako argumenty do innych funkcji. MoÅ¼na utworzyÄ‡ domkniÄ™cie w jednym miejscu, a nastÄ™pnie wywoÅ‚aÄ‡ je w innym, aby je oceniÄ‡ w innym kontekÅ›cie. W przeciwieÅ„stwie do funkcji, domkniÄ™cia mogÄ… przechwytywaÄ‡ wartoÅ›ci ze Å›rodowiska, w ktÃ³rym sÄ… zdefiniowane. Zdemonstrujemy, jak te cechy domkniÄ™Ä‡ pozwalajÄ… na ponowne uÅ¼ycie kodu i dostosowanie zachowania.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"creating-an-abstraction-of-behavior-with-closures\"></a>\n<a id=\"refactoring-using-functions\"></a>\n<a id=\"refactoring-with-closures-to-store-code\"></a>\n<a id=\"capturing-the-environment-with-closures\"></a>\n\n### Przechwytywanie Å›rodowiska\n\nNajpierw zbadamy, jak moÅ¼emy uÅ¼ywaÄ‡ domkniÄ™Ä‡ do przechwytywania wartoÅ›ci ze Å›rodowiska, w ktÃ³rym sÄ… zdefiniowane, do pÃ³Åºniejszego uÅ¼ycia. Oto scenariusz: Co jakiÅ› czas nasza firma produkujÄ…ca koszulki rozdaje ekskluzywnÄ… koszulkÄ™ z limitowanej edycji osobie z naszej listy mailingowej w ramach promocji. Osoby z listy mailingowej mogÄ… opcjonalnie dodaÄ‡ swÃ³j ulubiony kolor do swojego profilu. JeÅ›li osoba wybrana do darmowej koszulki ma ustawiony ulubiony kolor, otrzymuje koszulkÄ™ w tym kolorze. JeÅ›li osoba nie okreÅ›liÅ‚a ulubionego koloru, otrzymuje koszulkÄ™ w kolorze, ktÃ³rego firma ma obecnie najwiÄ™cej.\n\nIstnieje wiele sposobÃ³w na zaimplementowanie tego. W tym przykÅ‚adzie uÅ¼yjemy wyliczenia `ShirtColor`, ktÃ³re ma warianty `Red` i `Blue` (dla uproszczenia ograniczamy liczbÄ™ dostÄ™pnych kolorÃ³w). Reprezentujemy stan magazynowy firmy za pomocÄ… struktury `Inventory`, ktÃ³ra ma pole `shirts` zawierajÄ…ce `Vec<ShirtColor>` reprezentujÄ…ce kolory koszulek aktualnie w magazynie. Metoda `giveaway` zdefiniowana dla `Inventory` pobiera opcjonalne preferencje koloru koszulki zwyciÄ™zcy darmowej koszulki i zwraca kolor koszulki, ktÃ³rÄ… osoba otrzyma. Ta konfiguracja jest pokazana w Listing 13-1.\n\n<Listing number=\"13-1\" file-name=\"src/main.rs\" caption=\"Sytuacja z rozdawaniem koszulek przez firmÄ™\">\n\n```rust,noplayground\n#[derive(Debug, PartialEq, Copy, Clone)]\nenum ShirtColor {\n    Red,\n    Blue,\n}\n\nstruct Inventory {\n    shirts: Vec<ShirtColor>,\n}\n\nimpl Inventory {\n    fn giveaway(&self, user_preference: Option<ShirtColor>) -> ShirtColor {\n        user_preference.unwrap_or_else(|| self.most_stocked())\n    }\n\n    fn most_stocked(&self) -> ShirtColor {\n        let mut num_red = 0;\n        let mut num_blue = 0;\n\n        for color in &self.shirts {\n            match color {\n                ShirtColor::Red => num_red += 1,\n                ShirtColor::Blue => num_blue += 1,\n            }\n        }\n        if num_red > num_blue {\n            ShirtColor::Red\n        } else {\n            ShirtColor::Blue\n        }\n    }\n}\n\nfn main() {\n    let store = Inventory {\n        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],\n    };\n\n    let user_pref1 = Some(ShirtColor::Red);\n    let giveaway1 = store.giveaway(user_pref1);\n    println!(\n        \"UÅ¼ytkownik z preferencjÄ… {:?} dostaje {:?}\",\n        user_pref1, giveaway1\n    );\n\n    let user_pref2 = None;\n    let giveaway2 = store.giveaway(user_pref2);\n    println!(\n        \"UÅ¼ytkownik z preferencjÄ… {:?} dostaje {:?}\",\n        user_pref2, giveaway2\n    );\n}\n```\n\n</Listing>\n\n`store` zdefiniowany w `main` ma dwie niebieskie i jednÄ… czerwonÄ… koszulkÄ™ do rozdania w ramach tej limitowanej promocji. WywoÅ‚ujemy metodÄ™ `giveaway` dla uÅ¼ytkownika preferujÄ…cego czerwonÄ… koszulkÄ™ i dla uÅ¼ytkownika bez Å¼adnych preferencji.\n\nPonownie, ten kod mÃ³gÅ‚by byÄ‡ zaimplementowany na wiele sposobÃ³w, a tutaj, aby skupiÄ‡ siÄ™ na domkniÄ™ciach, trzymaliÅ›my siÄ™ pojÄ™Ä‡, ktÃ³re juÅ¼ znasz, z wyjÄ…tkiem ciaÅ‚a metody `giveaway`, ktÃ³ra uÅ¼ywa domkniÄ™cia. W metodzie `giveaway` otrzymujemy preferencjÄ™ uÅ¼ytkownika jako parametr typu `Option<ShirtColor>` i wywoÅ‚ujemy metodÄ™ `unwrap_or_else` na `user_preference`. Metoda [`unwrap_or_else` w `Option<T>`][unwrap-or-else]<!-- ignore --> jest zdefiniowana przez standardowÄ… bibliotekÄ™. Przyjmuje jeden argument: domkniÄ™cie bez Å¼adnych argumentÃ³w, ktÃ³re zwraca wartoÅ›Ä‡ `T` (tego samego typu co przechowywany w wariancie `Some` `Option<T>`, w tym przypadku `ShirtColor`). JeÅ›li `Option<T>` jest wariantem `Some`, `unwrap_or_else` zwraca wartoÅ›Ä‡ z `Some`. JeÅ›li `Option<T>` jest wariantem `None`, `unwrap_or_else` wywoÅ‚uje domkniÄ™cie i zwraca wartoÅ›Ä‡ zwrÃ³conÄ… przez domkniÄ™cie.\n\nOkreÅ›lamy wyraÅ¼enie domkniÄ™cia `|| self.most_stocked()` jako argument dla `unwrap_or_else`. Jest to domkniÄ™cie, ktÃ³re samo nie przyjmuje parametrÃ³w (gdyby domkniÄ™cie miaÅ‚o parametry, pojawiÅ‚yby siÄ™ one miÄ™dzy dwoma pionowymi kreskami). CiaÅ‚o domkniÄ™cia wywoÅ‚uje `self.most_stocked()`. Definiujemy tutaj domkniÄ™cie, a implementacja `unwrap_or_else` oceni domkniÄ™cie pÃ³Åºniej, jeÅ›li wynik bÄ™dzie potrzebny.\n\nUruchomienie tego kodu wyÅ›wietli nastÄ™pujÄ…ce informacje:\n\n```console\n$ cargo run\n   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s\n     Running `target/debug/shirt-company`\nUÅ¼ytkownik z preferencjÄ… Some(Red) dostaje Red\nUÅ¼ytkownik z preferencjÄ… None dostaje Blue\n```\n\nJednym interesujÄ…cym aspektem jest to, Å¼e przekazaliÅ›my domkniÄ™cie, ktÃ³re wywoÅ‚uje `self.most_stocked()` na bieÅ¼Ä…cej instancji `Inventory`. Standardowa biblioteka nie musiaÅ‚a wiedzieÄ‡ nic o typach `Inventory` ani `ShirtColor`, ktÃ³re zdefiniowaliÅ›my, ani o logice, ktÃ³rej chcemy uÅ¼yÄ‡ w tym scenariuszu. DomkniÄ™cie przechwytuje niezmiennÄ… referencjÄ™ do instancji `self` `Inventory` i przekazuje jÄ… z okreÅ›lonym przez nas kodem do metody `unwrap_or_else`. Funkcje natomiast nie sÄ… w stanie przechwytywaÄ‡ swojego Å›rodowiska w ten sposÃ³b.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"closure-type-inference-and-annotation\"></a>\n\n### Wywnioskowanie i adnotowanie typÃ³w domkniÄ™Ä‡\n\nIstnieje wiÄ™cej rÃ³Å¼nic miÄ™dzy funkcjami a domkniÄ™ciami. DomkniÄ™cia zazwyczaj nie wymagajÄ… adnotowania typÃ³w parametrÃ³w ani wartoÅ›ci zwracanej, tak jak funkcje `fn`. Adnotacje typÃ³w sÄ… wymagane w funkcjach, poniewaÅ¼ typy sÄ… czÄ™Å›ciÄ… jawnego interfejsu udostÄ™pnianego uÅ¼ytkownikom. Sztywne definiowanie tego interfejsu jest waÅ¼ne dla zapewnienia, Å¼e wszyscy zgadzajÄ… siÄ™ co do tego, jakich typÃ³w wartoÅ›ci funkcja uÅ¼ywa i zwraca. DomkniÄ™cia natomiast nie sÄ… uÅ¼ywane w takim udostÄ™pnionym interfejsie: sÄ… przechowywane w zmiennych i uÅ¼ywane bez nazywania ich i udostÄ™pniania uÅ¼ytkownikom naszej biblioteki.\n\nDomkniÄ™cia sÄ… zazwyczaj krÃ³tkie i istotne tylko w wÄ…skim kontekÅ›cie, a nie w dowolnym scenariuszu. W tych ograniczonych kontekstach kompilator moÅ¼e wywnioskowaÄ‡ typy parametrÃ³w i typ zwracany, podobnie jak jest w stanie wywnioskowaÄ‡ typy wiÄ™kszoÅ›ci zmiennych (istniejÄ… rzadkie przypadki, w ktÃ³rych kompilator rÃ³wnieÅ¼ potrzebuje adnotacji typÃ³w domkniÄ™Ä‡).\n\nPodobnie jak w przypadku zmiennych, moÅ¼emy dodaÄ‡ adnotacje typÃ³w, jeÅ›li chcemy zwiÄ™kszyÄ‡ jawnoÅ›Ä‡ i klarownoÅ›Ä‡ kosztem wiÄ™kszej szczegÃ³Å‚owoÅ›ci, niÅ¼ jest to Å›ciÅ›le konieczne. Adnotowanie typÃ³w dla domkniÄ™cia wyglÄ…daÅ‚oby jak definicja pokazana w Listing 13-2. W tym przykÅ‚adzie definiujemy domkniÄ™cie i przechowujemy je w zmiennej, zamiast definiowaÄ‡ domkniÄ™cie w miejscu, w ktÃ³rym przekazujemy je jako argument, jak to zrobiliÅ›my w Listing 13-1.\n\n<Listing number=\"13-2\" file-name=\"src/main.rs\" caption=\"Dodawanie opcjonalnych adnotacji typÃ³w parametrÃ³w i wartoÅ›ci zwracanych w domkniÄ™ciu\">\n\n```rust\n# use std::thread;\n# use std::time::Duration;\n# \n# fn generate_workout(intensity: u32, random_number: u32) {\n    let expensive_closure = |num: u32| -> u32 {\n        println!(\"obliczanie powoli...\");\n        thread::sleep(Duration::from_secs(2));\n        num\n    };\n# \n#     if intensity < 25 {\n#         println!(\"DziÅ›, zrÃ³b {} pompek!\", expensive_closure(intensity));\n#         println!(\"NastÄ™pnie, zrÃ³b {} brzuszkÃ³w!\", expensive_closure(intensity));\n#     } else {\n#         if random_number == 3 {\n#             println!(\"ZrÃ³b sobie dziÅ› przerwÄ™! PamiÄ™taj o nawodnieniu!\");\n#         } else {\n#             println!(\n#                 \"DziÅ›, biegnij przez {} minut!\",\n#                 expensive_closure(intensity)\n#             );\n#         }\n#     }\n# }\n# \n# fn main() {\n#     let simulated_user_specified_value = 10;\n#     let simulated_random_number = 7;\n# \n#     generate_workout(simulated_user_specified_value, simulated_random_number);\n# }\n```\n\n</Listing>\n\nPo dodaniu adnotacji typÃ³w skÅ‚adnia domkniÄ™Ä‡ wyglÄ…da bardziej podobnie do skÅ‚adni funkcji. Tutaj definiujemy funkcjÄ™, ktÃ³ra dodaje 1 do swojego parametru, i domkniÄ™cie, ktÃ³re ma takie samo zachowanie, dla porÃ³wnania. DodaliÅ›my kilka spacji, aby wyrÃ³wnaÄ‡ odpowiednie czÄ™Å›ci. Pokazuje to, jak skÅ‚adnia domkniÄ™cia jest podobna do skÅ‚adni funkcji, z wyjÄ…tkiem uÅ¼ycia pionowych kresek i iloÅ›ci skÅ‚adni, ktÃ³ra jest opcjonalna:\n\n```rust,ignore\nfn  add_one_v1   (x: u32) -> u32 { x + 1 }\nlet add_one_v2 = |x: u32| -> u32 { x + 1 };\nlet add_one_v3 = |x|             { x + 1 };\nlet add_one_v4 = |x|               x + 1  ;\n```\n\nPierwsza linia pokazuje definicjÄ™ funkcji, a druga definicjÄ™ domkniÄ™cia z peÅ‚nymi adnotacjami. W trzeciej linii usuwamy adnotacje typÃ³w z definicji domkniÄ™cia. W czwartej linii usuwamy nawiasy klamrowe, ktÃ³re sÄ… opcjonalne, poniewaÅ¼ ciaÅ‚o domkniÄ™cia ma tylko jedno wyraÅ¼enie. Wszystkie te definicje sÄ… poprawne i bÄ™dÄ… dawaÄ‡ to samo zachowanie po ich wywoÅ‚aniu. Linie `add_one_v3` i `add_one_v4` wymagajÄ… oceny domkniÄ™Ä‡, aby mogÅ‚y siÄ™ skompilowaÄ‡, poniewaÅ¼ typy zostanÄ… wywnioskowane z ich uÅ¼ycia. Jest to podobne do `let v = Vec::new();`, ktÃ³re wymaga albo adnotacji typÃ³w, albo wartoÅ›ci jakiegoÅ› typu do wstawienia do `Vec`, aby Rust mÃ³gÅ‚ wywnioskowaÄ‡ typ.\n\nDla definicji domkniÄ™Ä‡ kompilator wywnioskuje jeden konkretny typ dla kaÅ¼dego z ich parametrÃ³w i dla ich wartoÅ›ci zwracanej. Na przykÅ‚ad, Listing 13-3 pokazuje definicjÄ™ krÃ³tkiego domkniÄ™cia, ktÃ³re po prostu zwraca wartoÅ›Ä‡, ktÃ³rÄ… otrzymuje jako parametr. To domkniÄ™cie nie jest zbyt uÅ¼yteczne, z wyjÄ…tkiem celÃ³w tego przykÅ‚adu. ZauwaÅ¼, Å¼e nie dodaliÅ›my Å¼adnych adnotacji typÃ³w do definicji. PoniewaÅ¼ nie ma adnotacji typÃ³w, moÅ¼emy wywoÅ‚aÄ‡ domkniÄ™cie z dowolnym typem, co zrobiliÅ›my tutaj z `String` za pierwszym razem. JeÅ›li nastÄ™pnie sprÃ³bujemy wywoÅ‚aÄ‡ `example_closure` z liczbÄ… caÅ‚kowitÄ…, otrzymamy bÅ‚Ä…d.\n\n<Listing number=\"13-3\" file-name=\"src/main.rs\" caption=\"PrÃ³ba wywoÅ‚ania domkniÄ™cia, ktÃ³rego typy sÄ… wywnioskowane, z dwoma rÃ³Å¼nymi typami\">\n\n```rust,ignore,does_not_compile\n# fn main() {\n    let example_closure = |x| x;\n\n    let s = example_closure(String::from(\"hello\"));\n    let n = example_closure(5);\n# }\n```\n\n</Listing>\n\nKompilator daje nam nastÄ™pujÄ…cy bÅ‚Ä…d:\n\n```console\n$ cargo run\n   Compiling closure-example v0.1.0 (file:///projects/closure-example)\nerror[E0308]: mismatched types\n --> src/main.rs:5:29\n  |\n5 |     let n = example_closure(5);\n  |             --------------- ^ expected `String`, found integer\n  |             |\n  |             arguments to this function are incorrect\n  |\nnote: expected because the closure was earlier called with an argument of type `String`\n --> src/main.rs:4:29\n  |\n4 |     let s = example_closure(String::from(\"hello\"));\n  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of type `String`\n  |             |\n  |             in this closure call\nnote: closure parameter defined here\n --> src/main.rs:2:28\n  |\n2 |     let example_closure = |x| x;\n  |                            ^\nhelp: try using a conversion method\n  |\n5 |     let n = example_closure(5.to_string());\n  |                              ++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `closure-example` (bin \"closure-example\") due to 1 previous error\n```\n\nZa pierwszym razem, gdy wywoÅ‚ujemy `example_closure` z wartoÅ›ciÄ… `String`, kompilator wywnioskowuje typ `x` i typ zwracany domkniÄ™cia jako `String`. Te typy sÄ… nastÄ™pnie zablokowane w domkniÄ™ciu w `example_closure`, i otrzymujemy bÅ‚Ä…d typu, gdy nastÄ™pnym razem prÃ³bujemy uÅ¼yÄ‡ innego typu z tym samym domkniÄ™ciem.\n\n### Przechwytywanie referencji lub przenoszenie wÅ‚asnoÅ›ci\n\nDomkniÄ™cia mogÄ… przechwytywaÄ‡ wartoÅ›ci ze swojego Å›rodowiska na trzy sposoby, ktÃ³re bezpoÅ›rednio odpowiadajÄ… trzem sposobom, w jakie funkcja moÅ¼e przyjÄ…Ä‡ parametr: poÅ¼yczanie niezmienne, poÅ¼yczanie zmienne i przejmowanie wÅ‚asnoÅ›ci. DomkniÄ™cie zdecyduje, ktÃ³rego z nich uÅ¼yÄ‡, w zaleÅ¼noÅ›ci od tego, co ciaÅ‚o funkcji robi z przechwyconymi wartoÅ›ciami.\n\nW Listing 13-4 definiujemy domkniÄ™cie, ktÃ³re przechwytuje niezmiennÄ… referencjÄ™ do wektora o nazwie `list`, poniewaÅ¼ potrzebuje jedynie niezmiennej referencji, aby wydrukowaÄ‡ wartoÅ›Ä‡.\n\n<Listing number=\"13-4\" file-name=\"src/main.rs\" caption=\"Definiowanie i wywoÅ‚ywanie domkniÄ™cia, ktÃ³re przechwytuje niezmiennÄ… referencjÄ™\">\n\n```rust\nfn main() {\n    let list = vec![1, 2, 3];\n    println!(\"Przed zdefiniowaniem domkniÄ™cia: {list:?}\");\n\n    let only_borrows = || println!(\"Z domkniÄ™cia: {list:?}\");\n\n    println!(\"Przed wywoÅ‚aniem domkniÄ™cia: {list:?}\");\n    only_borrows();\n    println!(\"Po wywoÅ‚aniu domkniÄ™cia: {list:?}\");\n}\n```\n\n</Listing>\n\nTen przykÅ‚ad ilustruje rÃ³wnieÅ¼, Å¼e zmienna moÅ¼e byÄ‡ zwiÄ…zana z definicjÄ… domkniÄ™cia, a pÃ³Åºniej moÅ¼emy wywoÅ‚aÄ‡ domkniÄ™cie, uÅ¼ywajÄ…c nazwy zmiennej i nawiasÃ³w, tak jakby nazwa zmiennej byÅ‚a nazwÄ… funkcji.\n\nPoniewaÅ¼ moÅ¼emy mieÄ‡ jednoczeÅ›nie wiele niezmiennych referencji do `list`, `list` jest nadal dostÄ™pny z kodu przed definicjÄ… domkniÄ™cia, po definicji domkniÄ™cia, ale przed wywoÅ‚aniem domkniÄ™cia, i po wywoÅ‚aniu domkniÄ™cia. Ten kod kompiluje siÄ™, uruchamia i drukuje:\n\n```console\n$ cargo run\n   Compiling closure-example v0.1.0 (file:///projects/closure-example)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s\n     Running `target/debug/closure-example`\nPrzed zdefiniowaniem domkniÄ™cia: [1, 2, 3]\nPrzed wywoÅ‚aniem domkniÄ™cia: [1, 2, 3]\nZ domkniÄ™cia: [1, 2, 3]\nPo wywoÅ‚aniu domkniÄ™cia: [1, 2, 3]\n```\n\nNastÄ™pnie, w Listing 13-5, zmieniamy ciaÅ‚o domkniÄ™cia tak, aby dodawaÅ‚o element do wektora `list`. DomkniÄ™cie teraz przechwytuje zmiennÄ… referencjÄ™.\n\n<Listing number=\"13-5\" file-name=\"src/main.rs\" caption=\"Definiowanie i wywoÅ‚ywanie domkniÄ™cia, ktÃ³re przechwytuje zmiennÄ… referencjÄ™\">\n\n```rust\nfn main() {\n    let mut list = vec![1, 2, 3];\n    println!(\"Przed zdefiniowaniem domkniÄ™cia: {list:?}\");\n\n    let mut borrows_mutably = || list.push(7);\n\n    borrows_mutably();\n    println!(\"Po wywoÅ‚aniu domkniÄ™cia: {list:?}\");\n}\n```\n\n</Listing>\n\nTen kod kompiluje siÄ™, uruchamia i drukuje:\n\n```console\n$ cargo run\n   Compiling closure-example v0.1.0 (file:///projects/closure-example)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s\n     Running `target/debug/closure-example`\nPrzed zdefiniowaniem domkniÄ™cia: [1, 2, 3]\nPo wywoÅ‚aniu domkniÄ™cia: [1, 2, 3, 7]\n```\n\nZauwaÅ¼, Å¼e nie ma juÅ¼ `println!` miÄ™dzy definicjÄ… a wywoÅ‚aniem domkniÄ™cia `borrows_mutably`: Kiedy `borrows_mutably` jest zdefiniowane, przechwytuje zmiennÄ… referencjÄ™ do `list`. Nie uÅ¼ywamy domkniÄ™cia ponownie po jego wywoÅ‚aniu, wiÄ™c zmienna poÅ¼yczka siÄ™ koÅ„czy. MiÄ™dzy definicjÄ… domkniÄ™cia a wywoÅ‚aniem domkniÄ™cia, niezmienna poÅ¼yczka do wydrukowania nie jest dozwolona, poniewaÅ¼ Å¼adne inne poÅ¼yczki nie sÄ… dozwolone, gdy istnieje zmienna poÅ¼yczka. SprÃ³buj dodaÄ‡ tam `println!`, aby zobaczyÄ‡, jaki komunikat o bÅ‚Ä™dzie otrzymasz!\n\nJeÅ›li chcesz wymusiÄ‡ na domkniÄ™ciu przejÄ™cie wÅ‚asnoÅ›ci wartoÅ›ci, ktÃ³rych uÅ¼ywa w Å›rodowisku, mimo Å¼e ciaÅ‚o domkniÄ™cia nie potrzebuje Å›ciÅ›le wÅ‚asnoÅ›ci, moÅ¼esz uÅ¼yÄ‡ sÅ‚owa kluczowego `move` przed listÄ… parametrÃ³w.\n\nTa technika jest najbardziej uÅ¼yteczna, gdy przekazujemy domkniÄ™cie do nowego wÄ…tku, aby przenieÅ›Ä‡ dane, tak aby nowy wÄ…tek byÅ‚ ich wÅ‚aÅ›cicielem. SzczegÃ³Å‚owo omÃ³wimy wÄ…tki i dlaczego warto ich uÅ¼ywaÄ‡ w Rozdziale 16, kiedy bÄ™dziemy mÃ³wiÄ‡ o wspÃ³Å‚bieÅ¼noÅ›ci, ale na razie przyjrzyjmy siÄ™ krÃ³tko tworzeniu nowego wÄ…tku za pomocÄ… domkniÄ™cia, ktÃ³re wymaga sÅ‚owa kluczowego `move`. Listing 13-6 pokazuje Listing 13-4 zmodyfikowany tak, aby drukowaÅ‚ wektor w nowym wÄ…tku, a nie w wÄ…tku gÅ‚Ã³wnym.\n\n<Listing number=\"13-6\" file-name=\"src/main.rs\" caption=\"UÅ¼ywanie `move` do wymuszenia na domkniÄ™ciu dla wÄ…tku przejÄ™cia wÅ‚asnoÅ›ci `list`\">\n\n```rust\nuse std::thread;\n\nfn main() {\n    let list = vec![1, 2, 3];\n    println!(\"Przed zdefiniowaniem domkniÄ™cia: {list:?}\");\n\n    thread::spawn(move || println!(\"Z wÄ…tku: {list:?}\"))\n        .join()\n        .unwrap();\n}\n```\n\n</Listing>\n\nTworzymy nowy wÄ…tek, przekazujÄ…c mu domkniÄ™cie do uruchomienia jako argument. CiaÅ‚o domkniÄ™cia wypisuje listÄ™. W Listing 13-4 domkniÄ™cie przechwytywaÅ‚o `list` tylko za pomocÄ… niezmiennej referencji, poniewaÅ¼ to jest minimalny dostÄ™p do `list` potrzebny do jego wydrukowania. W tym przykÅ‚adzie, mimo Å¼e ciaÅ‚o domkniÄ™cia nadal potrzebuje tylko niezmiennej referencji, musimy okreÅ›liÄ‡, Å¼e `list` powinno zostaÄ‡ przeniesione do domkniÄ™cia, umieszczajÄ…c sÅ‚owo kluczowe `move` na poczÄ…tku definicji domkniÄ™cia. Gdyby wÄ…tek gÅ‚Ã³wny wykonywaÅ‚ wiÄ™cej operacji przed wywoÅ‚aniem `join` na nowym wÄ…tku, nowy wÄ…tek mÃ³gÅ‚by zakoÅ„czyÄ‡ siÄ™ przed zakoÅ„czeniem reszty wÄ…tku gÅ‚Ã³wnego, lub wÄ…tek gÅ‚Ã³wny mÃ³gÅ‚by zakoÅ„czyÄ‡ siÄ™ pierwszy. Gdyby wÄ…tek gÅ‚Ã³wny zachowaÅ‚ wÅ‚asnoÅ›Ä‡ `list`, ale zakoÅ„czyÅ‚ siÄ™ przed nowym wÄ…tkiem i upuÅ›ciÅ‚ `list`, niezmienna referencja w wÄ…tku byÅ‚aby niewaÅ¼na. Dlatego kompilator wymaga przeniesienia `list` do domkniÄ™cia przekazanego nowemu wÄ…tkowi, aby referencja byÅ‚a waÅ¼na. SprÃ³buj usunÄ…Ä‡ sÅ‚owo kluczowe `move` lub uÅ¼yÄ‡ `list` w wÄ…tku gÅ‚Ã³wnym po zdefiniowaniu domkniÄ™cia, aby zobaczyÄ‡, jakie bÅ‚Ä™dy kompilatora otrzymasz!\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"storing-closures-using-generic-parameters-and-the-fn-traits\"></a>\n<a id=\"limitations-of-the-cacher-implementation\"></a>\n<a id=\"moving-captured-values-out-of-the-closure-and-the-fn-traits\"></a>\n<a id=\"moving-captured-values-out-of-closures-and-the-fn-traits\"></a>\n\n### Przenoszenie przechwyconych wartoÅ›ci poza domkniÄ™cia\n\nGdy domkniÄ™cie przechwyci referencjÄ™ lub wÅ‚asnoÅ›Ä‡ wartoÅ›ci ze Å›rodowiska, w ktÃ³rym jest zdefiniowane (wpÅ‚ywajÄ…c tym samym na to, co, jeÅ›li w ogÃ³le, jest przenoszone _do_ domkniÄ™cia), kod w ciele domkniÄ™cia okreÅ›la, co dzieje siÄ™ z referencjami lub wartoÅ›ciami, gdy domkniÄ™cie jest pÃ³Åºniej oceniane (wpÅ‚ywajÄ…c tym samym na to, co, jeÅ›li w ogÃ³le, jest przenoszone _z_ domkniÄ™cia).\n\nCiaÅ‚o domkniÄ™cia moÅ¼e wykonaÄ‡ dowolne z nastÄ™pujÄ…cych czynnoÅ›ci: przenieÅ›Ä‡ przechwyconÄ… wartoÅ›Ä‡ poza domkniÄ™cie, zmutowaÄ‡ przechwyconÄ… wartoÅ›Ä‡, ani nie przenieÅ›Ä‡, ani nie zmutowaÄ‡ wartoÅ›ci, lub w ogÃ³le nic nie przechwyciÄ‡ ze Å›rodowiska.\n\nSposÃ³b, w jaki domkniÄ™cie przechwytuje i obsÅ‚uguje wartoÅ›ci ze Å›rodowiska, wpÅ‚ywa na to, ktÃ³re cechy domkniÄ™cie implementuje, a cechy to sposÃ³b, w jaki funkcje i struktury mogÄ… okreÅ›laÄ‡, jakich rodzajÃ³w domkniÄ™Ä‡ mogÄ… uÅ¼ywaÄ‡. DomkniÄ™cia automatycznie zaimplementujÄ… jednÄ…, dwie lub wszystkie trzy z tych cech `Fn`, w sposÃ³b addytywny, w zaleÅ¼noÅ›ci od tego, jak ciaÅ‚o domkniÄ™cia obsÅ‚uguje wartoÅ›ci:\n\n* `FnOnce` dotyczy domkniÄ™Ä‡, ktÃ³re moÅ¼na wywoÅ‚aÄ‡ raz. Wszystkie domkniÄ™cia implementujÄ… co najmniej tÄ™ cechÄ™, poniewaÅ¼ wszystkie domkniÄ™cia moÅ¼na wywoÅ‚aÄ‡. DomkniÄ™cie, ktÃ³re przenosi przechwycone wartoÅ›ci ze swojego ciaÅ‚a, zaimplementuje tylko `FnOnce` i Å¼adnych innych cech `Fn`, poniewaÅ¼ moÅ¼na je wywoÅ‚aÄ‡ tylko raz.\n* `FnMut` dotyczy domkniÄ™Ä‡, ktÃ³re nie przenoszÄ… przechwyconych wartoÅ›ci ze swojego ciaÅ‚a, ale mogÄ… mutowaÄ‡ przechwycone wartoÅ›ci. Te domkniÄ™cia moÅ¼na wywoÅ‚aÄ‡ wiÄ™cej niÅ¼ raz.\n* `Fn` dotyczy domkniÄ™Ä‡, ktÃ³re nie przenoszÄ… przechwyconych wartoÅ›ci ze swojego ciaÅ‚a i nie mutujÄ… przechwyconych wartoÅ›ci, a takÅ¼e domkniÄ™Ä‡, ktÃ³re nic nie przechwytujÄ… ze swojego Å›rodowiska. Te domkniÄ™cia moÅ¼na wywoÅ‚aÄ‡ wiÄ™cej niÅ¼ raz bez mutowania ich Å›rodowiska, co jest waÅ¼ne w przypadkach takich jak wielokrotne wywoÅ‚ywanie domkniÄ™cia wspÃ³Å‚bieÅ¼nie.\n\nPrzyjrzyjmy siÄ™ definicji metody `unwrap_or_else` na `Option<T>`, ktÃ³rej uÅ¼yliÅ›my w Listing 13-1:\n\n```rust,ignore\nimpl<T> Option<T> {\n    pub fn unwrap_or_else<F>(self, f: F) -> T\n    where\n        F: FnOnce() -> T\n    {\n        match self {\n            Some(x) => x,\n            None => f(),\n        }\n    }\n}\n```\n\nPamiÄ™taj, Å¼e `T` to typ ogÃ³lny reprezentujÄ…cy typ wartoÅ›ci w wariancie `Some` `Option`. Ten typ `T` jest rÃ³wnieÅ¼ typem zwracanym przez funkcjÄ™ `unwrap_or_else`: kod, ktÃ³ry wywoÅ‚uje `unwrap_or_else` na `Option<String>`, na przykÅ‚ad, otrzyma `String`.\n\nNastÄ™pnie, zauwaÅ¼, Å¼e funkcja `unwrap_or_else` ma dodatkowy generyczny parametr typu `F`. Typ `F` to typ parametru o nazwie `f`, czyli domkniÄ™cia, ktÃ³re dostarczamy podczas wywoÅ‚ywania `unwrap_or_else`.\n\nOgraniczenie cechy okreÅ›lone dla typu generycznego `F` to `FnOnce() -> T`, co oznacza, Å¼e `F` musi byÄ‡ wywoÅ‚ywalne raz, nie przyjmowaÄ‡ Å¼adnych argumentÃ³w i zwracaÄ‡ `T`. UÅ¼ycie `FnOnce` w ograniczeniu cechy wyraÅ¼a ograniczenie, Å¼e `unwrap_or_else` nie wywoÅ‚a `f` wiÄ™cej niÅ¼ raz. W ciele `unwrap_or_else` widzimy, Å¼e jeÅ›li `Option` jest `Some`, `f` nie zostanie wywoÅ‚ane. JeÅ›li `Option` jest `None`, `f` zostanie wywoÅ‚ane raz. PoniewaÅ¼ wszystkie domkniÄ™cia implementujÄ… `FnOnce`, `unwrap_or_else` akceptuje wszystkie trzy rodzaje domkniÄ™Ä‡ i jest tak elastyczne, jak to tylko moÅ¼liwe.\n\n> Uwaga: JeÅ›li to, co chcemy zrobiÄ‡, nie wymaga przechwytywania wartoÅ›ci ze Å›rodowiska, moÅ¼emy uÅ¼yÄ‡ nazwy funkcji zamiast domkniÄ™cia tam, gdzie potrzebujemy czegoÅ›, co implementuje jednÄ… z cech `Fn`. Na przykÅ‚ad, na wartoÅ›ci `Option<Vec<T>>` moglibyÅ›my wywoÅ‚aÄ‡ `unwrap_or_else(Vec::new)`, aby otrzymaÄ‡ nowy, pusty wektor, jeÅ›li wartoÅ›Ä‡ to `None`. Kompilator automatycznie implementuje dowolnÄ… z cech `Fn`, ktÃ³ra jest odpowiednia dla definicji funkcji.\n\nTeraz przyjrzyjmy siÄ™ metodzie `sort_by_key` ze standardowej biblioteki, zdefiniowanej dla wycinkÃ³w, aby zobaczyÄ‡, jak rÃ³Å¼ni siÄ™ ona od `unwrap_or_else` i dlaczego `sort_by_key` uÅ¼ywa `FnMut` zamiast `FnOnce` dla ograniczenia cechy. DomkniÄ™cie otrzymuje jeden argument w postaci referencji do bieÅ¼Ä…cego elementu w rozpatrywanym wycinku i zwraca wartoÅ›Ä‡ typu `K`, ktÃ³rÄ… moÅ¼na posortowaÄ‡. Ta funkcja jest przydatna, gdy chcesz posortowaÄ‡ wycinek wedÅ‚ug okreÅ›lonego atrybutu kaÅ¼dego elementu. W Listing 13-7 mamy listÄ™ instancji `Rectangle` i uÅ¼ywamy `sort_by_key` do uporzÄ…dkowania ich wedÅ‚ug atrybutu `width` od najmniejszego do najwiÄ™kszego.\n\n<Listing number=\"13-7\" file-name=\"src/main.rs\" caption=\"UÅ¼ywanie `sort_by_key` do porzÄ…dkowania prostokÄ…tÃ³w wedÅ‚ug szerokoÅ›ci\">\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let mut list = [\n        Rectangle { width: 10, height: 1 },\n        Rectangle { width: 3, height: 5 },\n        Rectangle { width: 7, height: 12 },\n    ];\n\n    list.sort_by_key(|r| r.width);\n    println!(\"{list:#?}\");\n}\n```\n\n</Listing>\n\nTen kod drukuje:\n\n```console\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s\n     Running `target/debug/rectangles`\n[\n    Rectangle {\n        width: 3,\n        height: 5,\n    },\n    Rectangle {\n        width: 7,\n        height: 12,\n    },\n    Rectangle {\n        width: 10,\n        height: 1,\n    },\n]\n```\n\nPowodem, dla ktÃ³rego `sort_by_key` jest zdefiniowany tak, aby przyjmowaÄ‡ domkniÄ™cie `FnMut`, jest to, Å¼e wywoÅ‚uje ono domkniÄ™cie wielokrotnie: raz dla kaÅ¼dego elementu w wycinku. DomkniÄ™cie `|r| r.width` nie przechwytuje, nie mutuje ani nie przenosi niczego ze swojego Å›rodowiska, wiÄ™c speÅ‚nia wymagania ograniczenia cechy.\n\nNatomiast Listing 13-8 przedstawia przykÅ‚ad domkniÄ™cia, ktÃ³re implementuje tylko cechÄ™ `FnOnce`, poniewaÅ¼ przenosi wartoÅ›Ä‡ ze Å›rodowiska. Kompilator nie pozwoli nam uÅ¼yÄ‡ tego domkniÄ™cia z `sort_by_key`.\n\n<Listing number=\"13-8\" file-name=\"src/main.rs\" caption=\"PrÃ³ba uÅ¼ycia domkniÄ™cia `FnOnce` z `sort_by_key`\">\n\n```rust,ignore,does_not_compile\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let mut list = [\n        Rectangle { width: 10, height: 1 },\n        Rectangle { width: 3, height: 5 },\n        Rectangle { width: 7, height: 12 },\n    ];\n\n    let mut sort_operations = vec![];\n    let value = String::from(\"closure called\");\n\n    list.sort_by_key(|r| {\n        sort_operations.push(value);\n        r.width\n    });\n    println!(\"{list:#?}\");\n}\n```\n\n</Listing>\n\nTo jest wymyÅ›lny, skomplikowany sposÃ³b (ktÃ³ry nie dziaÅ‚a) na prÃ³bÄ™ zliczenia, ile razy `sort_by_key` wywoÅ‚uje domkniÄ™cie podczas sortowania `list`. Ten kod prÃ³buje to zrobiÄ‡, wpychajÄ…c `value` â€“ `String` ze Å›rodowiska domkniÄ™cia â€“ do wektora `sort_operations`. DomkniÄ™cie przechwytuje `value`, a nastÄ™pnie przenosi `value` poza domkniÄ™cie, przekazujÄ…c wÅ‚asnoÅ›Ä‡ `value` do wektora `sort_operations`. To domkniÄ™cie moÅ¼na wywoÅ‚aÄ‡ raz; prÃ³ba wywoÅ‚ania go po raz drugi nie zadziaÅ‚a, poniewaÅ¼ `value` nie byÅ‚oby juÅ¼ w Å›rodowisku, aby ponownie wpychaÄ‡ je do `sort_operations`! Dlatego to domkniÄ™cie implementuje tylko `FnOnce`. Kiedy prÃ³bujemy skompilowaÄ‡ ten kod, otrzymujemy nastÄ™pujÄ…cy bÅ‚Ä…d, Å¼e `value` nie moÅ¼e zostaÄ‡ przeniesione poza domkniÄ™cie, poniewaÅ¼ domkniÄ™cie musi implementowaÄ‡ `FnMut`:\n\n```console\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\nerror[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure\n  --> src/main.rs:18:30\n   |\n15 |     let value = String::from(\"closure called\");\n   |         -----   ------------------------------ move occurs because `value` has type `String`, which does not implement the `Copy` trait\n   |         |\n   |         captured outer variable\n16 |\n17 |     list.sort_by_key(|r| {\n   |                      --- captured by this `FnMut` closure\n18 |         sort_operations.push(value);\n   |                              ^^^^^ `value` is moved here\n   |\nhelp: consider cloning the value if the performance cost is acceptable\n   |\n18 |         sort_operations.push(value.clone());\n   |                                   ++++++++\n\nFor more information about this error, try `rustc --explain E0507`.\nerror: could not compile `rectangles` (bin \"rectangles\") due to 1 previous error\n```\n\nBÅ‚Ä…d wskazuje na liniÄ™ w ciele domkniÄ™cia, ktÃ³ra przenosi `value` poza Å›rodowisko. Aby to naprawiÄ‡, musimy zmieniÄ‡ ciaÅ‚o domkniÄ™cia tak, aby nie przenosiÅ‚o wartoÅ›ci poza Å›rodowisko. Utrzymywanie licznika w Å›rodowisku i inkrementowanie jego wartoÅ›ci w ciele domkniÄ™cia jest prostszym sposobem na zliczanie, ile razy domkniÄ™cie jest wywoÅ‚ywane. DomkniÄ™cie w Listing 13-9 dziaÅ‚a z `sort_by_key`, poniewaÅ¼ przechwytuje tylko zmiennÄ… referencjÄ™ do licznika `num_sort_operations` i dlatego moÅ¼e byÄ‡ wywoÅ‚ywane wiÄ™cej niÅ¼ raz.\n\n<Listing number=\"13-9\" file-name=\"src/main.rs\" caption=\"UÅ¼ywanie domkniÄ™cia `FnMut` z `sort_by_key` jest dozwolone.\">\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let mut list = [\n        Rectangle { width: 10, height: 1 },\n        Rectangle { width: 3, height: 5 },\n        Rectangle { width: 7, height: 12 },\n    ];\n\n    let mut num_sort_operations = 0;\n    list.sort_by_key(|r| {\n        num_sort_operations += 1;\n        r.width\n    });\n    println!(\"{list:#?}, posortowane w {num_sort_operations} operacjach\");\n}\n```\n\n</Listing>\n\nCechy `Fn` sÄ… waÅ¼ne podczas definiowania lub uÅ¼ywania funkcji lub typÃ³w, ktÃ³re wykorzystujÄ… domkniÄ™cia. W nastÄ™pnej sekcji omÃ³wimy iteratory. Wiele metod iteratora przyjmuje argumenty domkniÄ™cia, wiÄ™c pamiÄ™taj o tych szczegÃ³Å‚ach domkniÄ™Ä‡, kontynuujÄ…c!\n\n[unwrap-or-else]: ../std/option/enum.Option.html#method.unwrap_or_else",
        "chapter_title": "DomkniÄ™cia"
    },
    {
        "file_path": "ch13-02-iterators.md",
        "content": "## Przetwarzanie serii elementÃ³w za pomocÄ… iteratorÃ³w\n\nWzorzec iteratora pozwala na wykonywanie okreÅ›lonego zadania na sekwencji elementÃ³w po kolei. Iterator jest odpowiedzialny za logikÄ™ iterowania po kaÅ¼dym elemencie i okreÅ›lanie, kiedy sekwencja siÄ™ zakoÅ„czyÅ‚a. Kiedy uÅ¼ywasz iteratorÃ³w, nie musisz samodzielnie ponownie implementowaÄ‡ tej logiki.\n\nW Rust iteratory sÄ… _lenistwe_, co oznacza, Å¼e nie majÄ… Å¼adnego efektu, dopÃ³ki nie wywoÅ‚asz metod, ktÃ³re zuÅ¼ywajÄ… iterator. Na przykÅ‚ad, kod w Listing 13-10 tworzy iterator po elementach w wektorze `v1`, wywoÅ‚ujÄ…c metodÄ™ `iter` zdefiniowanÄ… dla `Vec<T>`. Sam ten kod nie robi nic uÅ¼ytecznego.\n\n<Listing number=\"13-10\" file-name=\"src/main.rs\" caption=\"Tworzenie iteratora\">\n\n```rust\n# fn main() {\n    let v1 = vec![1, 2, 3];\n\n    let v1_iter = v1.iter();\n# }\n```\n\n</Listing>\n\nIterator jest przechowywany w zmiennej `v1_iter`. Po utworzeniu iteratora moÅ¼emy go uÅ¼ywaÄ‡ na rÃ³Å¼ne sposoby. W Listing 3-5 iterowaliÅ›my po tablicy za pomocÄ… pÄ™tli `for`, aby wykonaÄ‡ jakiÅ› kod na kaÅ¼dym z jej elementÃ³w. Pod spodem, to niejawnie utworzyÅ‚o, a nastÄ™pnie zuÅ¼yÅ‚o iterator, ale pomijaliÅ›my dokÅ‚adne dziaÅ‚anie tego mechanizmu aÅ¼ do teraz.\n\nW przykÅ‚adzie z Listing 13-11 oddzielamy tworzenie iteratora od uÅ¼ywania iteratora w pÄ™tli `for`. Kiedy pÄ™tla `for` jest wywoÅ‚ywana z uÅ¼yciem iteratora w `v1_iter`, kaÅ¼dy element iteratora jest uÅ¼ywany w jednej iteracji pÄ™tli, ktÃ³ra wypisuje kaÅ¼dÄ… wartoÅ›Ä‡.\n\n<Listing number=\"13-11\" file-name=\"src/main.rs\" caption=\"UÅ¼ywanie iteratora w pÄ™tli `for`\">\n\n```rust\n# fn main() {\n    let v1 = vec![1, 2, 3];\n\n    let v1_iter = v1.iter();\n\n    for val in v1_iter {\n        println!(\"Otrzymano: {val}\");\n    }\n# }\n```\n\n</Listing>\n\nW jÄ™zykach, ktÃ³re nie majÄ… iteratorÃ³w dostarczanych przez ich standardowe biblioteki, prawdopodobnie napisaÅ‚byÅ› tÄ™ samÄ… funkcjonalnoÅ›Ä‡, rozpoczynajÄ…c zmiennÄ… od indeksu 0, uÅ¼ywajÄ…c tej zmiennej do indeksowania wektora w celu uzyskania wartoÅ›ci i zwiÄ™kszajÄ…c wartoÅ›Ä‡ zmiennej w pÄ™tli, dopÃ³ki nie osiÄ…gnÄ™Å‚aby caÅ‚kowitej liczby elementÃ³w w wektorze.\n\nIteratory obsÅ‚ugujÄ… caÅ‚Ä… tÄ™ logikÄ™ za Ciebie, zmniejszajÄ…c iloÅ›Ä‡ powtarzajÄ…cego siÄ™ kodu, ktÃ³ry mÃ³gÅ‚byÅ› potencjalnie zepsuÄ‡. Iteratory dajÄ… wiÄ™kszÄ… elastycznoÅ›Ä‡ w uÅ¼ywaniu tej samej logiki z wieloma rÃ³Å¼nymi rodzajami sekwencji, a nie tylko ze strukturami danych, do ktÃ³rych moÅ¼na indeksowaÄ‡, takimi jak wektory. Przyjrzyjmy siÄ™, jak to robiÄ… iteratory.\n\n### Cecha `Iterator` i metoda `next`\n\nWszystkie iteratory implementujÄ… cechÄ™ o nazwie `Iterator`, ktÃ³ra jest zdefiniowana w standardowej bibliotece. Definicja cechy wyglÄ…da nastÄ™pujÄ…co:\n\n```rust\npub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n\n    // metody z domyÅ›lnymi implementacjami pominiÄ™te\n}\n```\n\nZauwaÅ¼, Å¼e ta definicja uÅ¼ywa nowej skÅ‚adni: `type Item` i `Self::Item`, ktÃ³re definiujÄ… typ skojarzony z tÄ… cechÄ…. SzczegÃ³Å‚owo omÃ³wimy typy skojarzone w Rozdziale 20. Na razie wystarczy wiedzieÄ‡, Å¼e ten kod mÃ³wi, Å¼e implementacja cechy `Iterator` wymaga rÃ³wnieÅ¼ zdefiniowania typu `Item`, a ten typ `Item` jest uÅ¼ywany w typie zwracanym przez metodÄ™ `next`. Innymi sÅ‚owy, typ `Item` bÄ™dzie typem zwracanym przez iterator.\n\nCecha `Iterator` wymaga od implementatorÃ³w zdefiniowania tylko jednej metody: metody `next`, ktÃ³ra zwraca po jednym elemencie iteratora na raz, opakowanym w `Some`, a po zakoÅ„czeniu iteracji zwraca `None`.\n\nMoÅ¼emy wywoÅ‚ywaÄ‡ metodÄ™ `next` bezpoÅ›rednio na iteratorach; Listing 13-12 pokazuje, jakie wartoÅ›ci sÄ… zwracane z wielokrotnych wywoÅ‚aÅ„ `next` na iteratorze utworzonym z wektora.\n\n<Listing number=\"13-12\" file-name=\"src/lib.rs\" caption=\"WywoÅ‚ywanie metody `next` na iteratorze\">\n\n```rust,noplayground\n# #[cfg(test)]\n# mod tests {\n    #[test]\n    fn iterator_demonstration() {\n        let v1 = vec![1, 2, 3];\n\n        let mut v1_iter = v1.iter();\n\n        assert_eq!(v1_iter.next(), Some(&1));\n        assert_eq!(v1_iter.next(), Some(&2));\n        assert_eq!(v1_iter.next(), Some(&3));\n        assert_eq!(v1_iter.next(), None);\n    }\n# }\n```\n\n</Listing>\n\nZauwaÅ¼, Å¼e musieliÅ›my uczyniÄ‡ `v1_iter` zmiennym: wywoÅ‚anie metody `next` na iteratorze zmienia wewnÄ™trzny stan, ktÃ³rego iterator uÅ¼ywa do Å›ledzenia swojej pozycji w sekwencji. Innymi sÅ‚owy, ten kod _zuÅ¼ywa_, czyli wykorzystuje, iterator. KaÅ¼de wywoÅ‚anie `next` pobiera element z iteratora. Nie musieliÅ›my uczyniÄ‡ `v1_iter` zmiennym, gdy uÅ¼ywaliÅ›my pÄ™tli `for`, poniewaÅ¼ pÄ™tla przejmowaÅ‚a wÅ‚asnoÅ›Ä‡ `v1_iter` i czyniÅ‚a go zmiennym za kulisami.\n\nZauwaÅ¼ rÃ³wnieÅ¼, Å¼e wartoÅ›ci, ktÃ³re otrzymujemy z wywoÅ‚aÅ„ `next`, to niezmienne referencje do wartoÅ›ci w wektorze. Metoda `iter` produkuje iterator po niezmiennych referencjach. JeÅ›li chcemy stworzyÄ‡ iterator, ktÃ³ry przejmuje wÅ‚asnoÅ›Ä‡ `v1` i zwraca posiadane wartoÅ›ci, moÅ¼emy zamiast `iter` wywoÅ‚aÄ‡ `into_iter`. Podobnie, jeÅ›li chcemy iterowaÄ‡ po zmiennych referencjach, moÅ¼emy zamiast `iter` wywoÅ‚aÄ‡ `iter_mut`.\n\n### Metody, ktÃ³re zuÅ¼ywajÄ… iterator\n\nCecha `Iterator` ma szereg rÃ³Å¼nych metod z domyÅ›lnymi implementacjami dostarczonymi przez standardowÄ… bibliotekÄ™; o tych metodach moÅ¼esz dowiedzieÄ‡ siÄ™, przeglÄ…dajÄ…c dokumentacjÄ™ API standardowej biblioteki dla cechy `Iterator`. NiektÃ³re z tych metod wywoÅ‚ujÄ… metodÄ™ `next` w swojej definicji, dlatego jesteÅ› zobowiÄ…zany do zaimplementowania metody `next` przy implementacji cechy `Iterator`.\n\nMetody, ktÃ³re wywoÅ‚ujÄ… `next`, nazywane sÄ… _konsumujÄ…cymi adapterami_, poniewaÅ¼ ich wywoÅ‚anie zuÅ¼ywa iterator. Jednym z przykÅ‚adÃ³w jest metoda `sum`, ktÃ³ra przejmuje wÅ‚asnoÅ›Ä‡ iteratora i iteruje przez elementy, wielokrotnie wywoÅ‚ujÄ…c `next`, zuÅ¼ywajÄ…c tym samym iterator. Podczas iteracji dodaje kaÅ¼dy element do bieÅ¼Ä…cej sumy i zwraca sumÄ™ po zakoÅ„czeniu iteracji. Listing 13-13 zawiera test ilustrujÄ…cy uÅ¼ycie metody `sum`.\n\n<Listing number=\"13-13\" file-name=\"src/lib.rs\" caption=\"WywoÅ‚ywanie metody `sum` w celu uzyskania sumy wszystkich elementÃ³w w iteratorze\">\n\n```rust,noplayground\n# #[cfg(test)]\n# mod tests {\n    #[test]\n    fn iterator_sum() {\n        let v1 = vec![1, 2, 3];\n\n        let v1_iter = v1.iter();\n\n        let total: i32 = v1_iter.sum();\n\n        assert_eq!(total, 6);\n    }\n# }\n```\n\n</Listing>\n\nNie moÅ¼emy uÅ¼yÄ‡ `v1_iter` po wywoÅ‚aniu `sum`, poniewaÅ¼ `sum` przejmuje wÅ‚asnoÅ›Ä‡ iteratora, na ktÃ³rym jest wywoÅ‚ywana.\n\n### Metody, ktÃ³re produkujÄ… inne iteratory\n\n_Adaptery iteratora_ to metody zdefiniowane na cesze `Iterator`, ktÃ³re nie zuÅ¼ywajÄ… iteratora. Zamiast tego produkujÄ… one inne iteratory, zmieniajÄ…c jakiÅ› aspekt oryginalnego iteratora.\n\nListing 13-14 pokazuje przykÅ‚ad wywoÅ‚ania metody adaptera iteratora `map`, ktÃ³ra przyjmuje domkniÄ™cie do wywoÅ‚ania na kaÅ¼dym elemencie w trakcie iteracji. Metoda `map` zwraca nowy iterator, ktÃ³ry produkuje zmodyfikowane elementy. DomkniÄ™cie tutaj tworzy nowy iterator, w ktÃ³rym kaÅ¼dy element z wektora zostanie zwiÄ™kszony o 1.\n\n<Listing number=\"13-14\" file-name=\"src/main.rs\" caption=\"WywoÅ‚anie adaptera iteratora `map` w celu utworzenia nowego iteratora\">\n\n```rust,not_desired_behavior\n# fn main() {\n    let v1: Vec<i32> = vec![1, 2, 3];\n\n    v1.iter().map(|x| x + 1);\n# }\n```\n\n</Listing>\n\nJednak ten kod generuje ostrzeÅ¼enie:\n\n```console\n$ cargo run\n   Compiling iterators v0.1.0 (file:///projects/iterators)\nwarning: unused `Map` that must be used\n --> src/main.rs:4:5\n  |\n4 |     v1.iter().map(|x| x + 1);\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: iterators are lazy and do nothing unless consumed\n  = note: `#[warn(unused_must_use)]` on by default\nhelp: use `let _ = ...` to ignore the resulting value\n  |\n4 |     let _ = v1.iter().map(|x| x + 1);\n  |     +++++++\n\nwarning: `iterators` (bin \"iterators\") generated 1 warning\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.47s\n     Running `target/debug/iterators`\n```\n\nKod w Listing 13-14 nic nie robi; okreÅ›lone przez nas domkniÄ™cie nigdy nie jest wywoÅ‚ywane. OstrzeÅ¼enie przypomina nam, dlaczego: adaptery iteratorÃ³w sÄ… leniwe, i musimy tutaj skonsumowaÄ‡ iterator.\n\nAby naprawiÄ‡ to ostrzeÅ¼enie i skonsumowaÄ‡ iterator, uÅ¼yjemy metody `collect`, ktÃ³rej uÅ¼yliÅ›my z `env::args` w Listing 12-1. Ta metoda zuÅ¼ywa iterator i zbiera wynikowe wartoÅ›ci do typu danych kolekcji.\n\nW Listing 13-15 zbieramy wyniki iteracji po iteratorze zwrÃ³conym z wywoÅ‚ania `map` do wektora. Ten wektor bÄ™dzie zawieraÅ‚ kaÅ¼dy element z oryginalnego wektora, zwiÄ™kszony o 1.\n\n<Listing number=\"13-15\" file-name=\"src/main.rs\" caption=\"WywoÅ‚ywanie metody `map` w celu utworzenia nowego iteratora, a nastÄ™pnie wywoÅ‚ywanie metody `collect` w celu zuÅ¼ycia nowego iteratora i utworzenia wektora\">\n\n```rust\n# fn main() {\n    let v1: Vec<i32> = vec![1, 2, 3];\n\n    let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();\n\n    assert_eq!(v2, vec![2, 3, 4]);\n# }\n```\n\n</Listing>\n\nPoniewaÅ¼ `map` przyjmuje domkniÄ™cie, moÅ¼emy okreÅ›liÄ‡ dowolnÄ… operacjÄ™, ktÃ³rÄ… chcemy wykonaÄ‡ na kaÅ¼dym elemencie. Jest to doskonaÅ‚y przykÅ‚ad tego, jak domkniÄ™cia pozwalajÄ… dostosowaÄ‡ pewne zachowanie, jednoczeÅ›nie ponownie wykorzystujÄ…c zachowanie iteracji, ktÃ³re zapewnia cecha `Iterator`.\n\nMoÅ¼na Å‚Ä…czyÄ‡ wiele wywoÅ‚aÅ„ adapterÃ³w iteratora, aby wykonywaÄ‡ zÅ‚oÅ¼one dziaÅ‚ania w czytelny sposÃ³b. PoniewaÅ¼ jednak wszystkie iteratory sÄ… leniwe, naleÅ¼y wywoÅ‚aÄ‡ jednÄ… z metod adaptera konsumujÄ…cego, aby uzyskaÄ‡ wyniki z wywoÅ‚aÅ„ adapterÃ³w iteratora.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"using-closures-that-capture-their-environment\"></a>\n\n### DomkniÄ™cia, ktÃ³re przechwytujÄ… swoje Å›rodowisko\n\nWiele adapterÃ³w iteratora przyjmuje domkniÄ™cia jako argumenty, a czÄ™sto domkniÄ™cia, ktÃ³re bÄ™dziemy okreÅ›laÄ‡ jako argumenty dla adapterÃ³w iteratora, bÄ™dÄ… domkniÄ™ciami, ktÃ³re przechwytujÄ… ich Å›rodowisko.\n\nW tym przykÅ‚adzie uÅ¼yjemy metody `filter`, ktÃ³ra przyjmuje domkniÄ™cie. DomkniÄ™cie pobiera element z iteratora i zwraca `bool`. JeÅ›li domkniÄ™cie zwraca `true`, wartoÅ›Ä‡ zostanie wÅ‚Ä…czona do iteracji wyprodukowanej przez `filter`. JeÅ›li domkniÄ™cie zwraca `false`, wartoÅ›Ä‡ nie zostanie wÅ‚Ä…czona.\n\nW Listing 13-16 uÅ¼ywamy `filter` z domkniÄ™ciem, ktÃ³re przechwytuje zmiennÄ… `shoe_size` ze swojego Å›rodowiska, aby iterowaÄ‡ po kolekcji instancji struktury `Shoe`. ZwrÃ³ci tylko buty o okreÅ›lonym rozmiarze.\n\n<Listing number=\"13-16\" file-name=\"src/lib.rs\" caption=\"UÅ¼ycie metody `filter` z domkniÄ™ciem, ktÃ³re przechwytuje `shoe_size`\">\n\n```rust,noplayground\n#[derive(PartialEq, Debug)]\nstruct Shoe {\n    size: u32,\n    style: String,\n}\n\nfn shoes_in_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {\n    shoes.into_iter().filter(|s| s.size == shoe_size).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn filters_by_size() {\n        let shoes = vec![\n            Shoe {\n                size: 10,\n                style: String::from(\"sneaker\"),\n            },\n            Shoe {\n                size: 13,\n                style: String::from(\"sandal\"),\n            },\n            Shoe {\n                size: 10,\n                style: String::from(\"boot\"),\n            },\n        ];\n\n        let in_my_size = shoes_in_size(shoes, 10);\n\n        assert_eq!(\n            in_my_size,\n            vec![\n                Shoe {\n                    size: 10,\n                    style: String::from(\"sneaker\")\n                },\n                Shoe {\n                    size: 10,\n                    style: String::from(\"boot\")\n                },\n            ]\n        );\n    }\n}\n```\n\n</Listing>\n\nFunkcja `shoes_in_size` przejmuje wÅ‚asnoÅ›Ä‡ wektora butÃ³w i rozmiaru buta jako parametry. Zwraca wektor zawierajÄ…cy tylko buty o okreÅ›lonym rozmiarze.\n\nW ciele `shoes_in_size` wywoÅ‚ujemy `into_iter`, aby stworzyÄ‡ iterator, ktÃ³ry przejmuje wÅ‚asnoÅ›Ä‡ wektora. NastÄ™pnie wywoÅ‚ujemy `filter`, aby dostosowaÄ‡ ten iterator do nowego iteratora, ktÃ³ry zawiera tylko elementy, dla ktÃ³rych domkniÄ™cie zwraca `true`.\n\nDomkniÄ™cie przechwytuje parametr `shoe_size` ze Å›rodowiska i porÃ³wnuje wartoÅ›Ä‡ z rozmiarem kaÅ¼dego buta, zachowujÄ…c tylko buty o okreÅ›lonym rozmiarze. Na koniec wywoÅ‚anie `collect` zbiera wartoÅ›ci zwrÃ³cone przez dostosowany iterator do wektora, ktÃ³ry jest zwracany przez funkcjÄ™.\n\nTest pokazuje, Å¼e po wywoÅ‚aniu `shoes_in_size` otrzymujemy z powrotem tylko buty, ktÃ³re majÄ… ten sam rozmiar, co okreÅ›lona przez nas wartoÅ›Ä‡.",
        "chapter_title": "Przetwarzanie serii elementÃ³w za pomocÄ… iteratorÃ³w"
    },
    {
        "file_path": "ch13-03-improving-our-io-project.md",
        "content": "## Udoskonalanie naszego projektu I/O\n\nDziÄ™ki tej nowej wiedzy o iteratorach moÅ¼emy ulepszyÄ‡ projekt I/O z RozdziaÅ‚u 12, wykorzystujÄ…c iteratory, aby uczyniÄ‡ kod bardziej czytelnym i zwiÄ™zÅ‚ym. Przyjrzyjmy siÄ™, jak iteratory mogÄ… ulepszyÄ‡ naszÄ… implementacjÄ™ funkcji `Config::build` i funkcji `search`.\n\n### Usuwanie `clone` za pomocÄ… iteratora\n\nW Listing 12-6 dodaliÅ›my kod, ktÃ³ry przyjmowaÅ‚ wycinek wartoÅ›ci `String` i tworzyÅ‚ instancjÄ™ struktury `Config` poprzez indeksowanie do wycinka i klonowanie wartoÅ›ci, co pozwalaÅ‚o strukturze `Config` na posiadanie tych wartoÅ›ci. W Listing 13-17 odtworzyliÅ›my implementacjÄ™ funkcji `Config::build` takÄ…, jaka byÅ‚a w Listing 12-23.\n\n<Listing number=\"13-17\" file-name=\"src/main.rs\" caption=\"Reprodukcja funkcji `Config::build` z Listing 12-23\">\n\n```rust,ignore\n# use std::env;\n# use std::error::Error;\n# use std::fs;\n# use std::process;\n# \n# use minigrep::{search, search_case_insensitive};\n# \n# fn main() {\n#     let args: Vec<String> = env::args().collect();\n# \n#     let config = Config::build(&args).unwrap_or_else(|err| {\n#         println!(\"Problem parsing arguments: {err}\");\n#         process::exit(1);\n#     });\n# \n#     if let Err(e) = run(config) {\n#         println!(\"Application error: {e}\");\n#         process::exit(1);\n#     }\n# }\n# \n# pub struct Config {\n#     pub query: String,\n#     pub file_path: String,\n#     pub ignore_case: bool,\n# }\n# \nimpl Config {\n    fn build(args: &[String]) -> Result<Config, &'static str> {\n        if args.len() < 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        let ignore_case = env::var(\"IGNORE_CASE\").is_ok();\n\n        Ok(Config {\n            query,\n            file_path,\n            ignore_case,\n        })\n    }\n}\n# \n# fn run(config: Config) -> Result<(), Box<dyn Error>> {\n#     let contents = fs::read_to_string(config.file_path)?;\n# \n#     let results = if config.ignore_case {\n#         search_case_insensitive(&config.query, &contents)\n#     } else {\n#         search(&config.query, &contents)\n#     };\n# \n#     for line in results {\n#         println!(\"{line}\");\n#     }\n# \n#     Ok(())\n# }\n```\n\n</Listing>\n\nWÃ³wczas powiedzieliÅ›my, Å¼eby nie martwiÄ‡ siÄ™ nieefektywnymi wywoÅ‚aniami `clone`, poniewaÅ¼ usuniemy je w przyszÅ‚oÅ›ci. CÃ³Å¼, ten czas nadszedÅ‚!\n\nPotrzebowaliÅ›my `clone` tutaj, poniewaÅ¼ mamy wycinek z elementami `String` w parametrze `args`, ale funkcja `build` nie jest wÅ‚aÅ›cicielem `args`. Aby zwrÃ³ciÄ‡ wÅ‚asnoÅ›Ä‡ instancji `Config`, musieliÅ›my sklonowaÄ‡ wartoÅ›ci z pÃ³l `query` i `file_path` `Config`, tak aby instancja `Config` mogÅ‚a posiadaÄ‡ swoje wartoÅ›ci.\n\nDziÄ™ki naszej nowej wiedzy o iteratorach moÅ¼emy zmieniÄ‡ funkcjÄ™ `build`, aby przyjmowaÅ‚a wÅ‚asnoÅ›Ä‡ iteratora jako swÃ³j argument, zamiast poÅ¼yczaÄ‡ wycinek. UÅ¼yjemy funkcjonalnoÅ›ci iteratora zamiast kodu, ktÃ³ry sprawdza dÅ‚ugoÅ›Ä‡ wycinka i indeksuje do okreÅ›lonych miejsc. To wyjaÅ›ni, co robi funkcja `Config::build`, poniewaÅ¼ iterator bÄ™dzie miaÅ‚ dostÄ™p do wartoÅ›ci.\n\nGdy `Config::build` przejmie wÅ‚asnoÅ›Ä‡ iteratora i przestanie uÅ¼ywaÄ‡ operacji indeksowania, ktÃ³re poÅ¼yczajÄ…, moÅ¼emy przenieÅ›Ä‡ wartoÅ›ci `String` z iteratora do `Config` zamiast wywoÅ‚ywaÄ‡ `clone` i tworzyÄ‡ nowÄ… alokacjÄ™.\n\n#### BezpoÅ›rednie uÅ¼ywanie zwrÃ³conego iteratora\n\nOtwÃ³rz plik _src/main.rs_ swojego projektu I/O, ktÃ³ry powinien wyglÄ…daÄ‡ nastÄ™pujÄ…co:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust,ignore\n# use std::env;\n# use std::error::Error;\n# use std::fs;\n# use std::process;\n# \n# use minigrep::{search, search_case_insensitive};\n# \nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let config = Config::build(&args).unwrap_or_else(|err| {\n        eprintln!(\"Problem parsing arguments: {err}\");\n        process::exit(1);\n    });\n\n    // --snip--\n# \n#     if let Err(e) = run(config) {\n#         eprintln!(\"Application error: {e}\");\n#         process::exit(1);\n#     }\n}\n# \n# pub struct Config {\n#     pub query: String,\n#     pub file_path: String,\n#     pub ignore_case: bool,\n# }\n# \n# impl Config {\n#     fn build(args: &[String]) -> Result<Config, &'static str> {\n#         if args.len() < 3 {\n#             return Err(\"not enough arguments\");\n#         }\n# \n#         let query = args[1].clone();\n#         let file_path = args[2].clone();\n# \n#         let ignore_case = env::var(\"IGNORE_CASE\").is_ok();\n# \n#         Ok(Config {\n#             query,\n#             file_path,\n#             ignore_case,\n#         })\n#     }\n# }\n# \n# fn run(config: Config) -> Result<(), Box<dyn Error>> {\n#     let contents = fs::read_to_string(config.file_path)?;\n# \n#     let results = if config.ignore_case {\n#         search_case_insensitive(&config.query, &contents)\n#     } else {\n#         search(&config.query, &contents)\n#     };\n# \n#     for line in results {\n#         println!(\"{line}\");\n#     }\n# \n#     Ok(())\n# }\n```\n\nNajpierw zmienimy poczÄ…tek funkcji `main` z Listing 12-24 na kod z Listing 13-18, ktÃ³ry tym razem uÅ¼ywa iteratora. To nie skompiluje siÄ™, dopÃ³ki nie zaktualizujemy rÃ³wnieÅ¼ `Config::build`.\n\n<Listing number=\"13-18\" file-name=\"src/main.rs\" caption=\"Przekazywanie wartoÅ›ci zwracanej przez `env::args` do `Config::build`\">\n\n```rust,ignore,does_not_compile\n# use std::env;\n# use std::error::Error;\n# use std::fs;\n# use std::process;\n# \n# use minigrep::{search, search_case_insensitive};\n# \nfn main() {\n    let config = Config::build(env::args()).unwrap_or_else(|err| {\n        eprintln!(\"Problem z parsowaniem argumentÃ³w: {err}\");\n        process::exit(1);\n    });\n\n    // --snip--\n# \n#     if let Err(e) = run(config) {\n#         eprintln!(\"BÅ‚Ä…d aplikacji: {e}\");\n#         process::exit(1);\n#     }\n}\n# \n# pub struct Config {\n#     pub query: String,\n#     pub file_path: String,\n#     pub ignore_case: bool,\n# }\n# \n# impl Config {\n#     fn build(args: &[String]) -> Result<Config, &'static str> {\n#         if args.len() < 3 {\n#             return Err(\"za maÅ‚o argumentÃ³w\");\n#         }\n# \n#         let query = args[1].clone();\n#         let file_path = args[2].clone();\n# \n#         let ignore_case = env::var(\"IGNORE_CASE\").is_ok();\n# \n#         Ok(Config {\n#             query,\n#             file_path,\n#             ignore_case,\n#         })\n#     }\n# }\n# \n# fn run(config: Config) -> Result<(), Box<dyn Error>> {\n#     let contents = fs::read_to_string(config.file_path)?;\n# \n#     let results = if config.ignore_case {\n#         search_case_insensitive(&config.query, &contents)\n#     } else {\n#         search(&config.query, &contents)\n#     };\n# \n#     for line in results {\n#         println!(\"{line}\");\n#     }\n# \n#     Ok(())\n# }\n```\n\n</Listing>\n\nFunkcja `env::args` zwraca iterator! Zamiast zbieraÄ‡ wartoÅ›ci iteratora do wektora, a nastÄ™pnie przekazywaÄ‡ wycinek do `Config::build`, teraz przekazujemy wÅ‚asnoÅ›Ä‡ iteratora zwrÃ³conego przez `env::args` bezpoÅ›rednio do `Config::build`.\n\nNastÄ™pnie musimy zaktualizowaÄ‡ definicjÄ™ `Config::build`. ZmieÅ„my sygnaturÄ™ `Config::build` tak, aby wyglÄ…daÅ‚a jak w Listing 13-19. To nadal siÄ™ nie skompiluje, poniewaÅ¼ musimy zaktualizowaÄ‡ ciaÅ‚o funkcji.\n\n<Listing number=\"13-19\" file-name=\"src/main.rs\" caption=\"Aktualizacja sygnatury `Config::build` w celu oczekiwania iteratora\">\n\n```rust,ignore,does_not_compile\n# use std::env;\n# use std::error::Error;\n# use std::fs;\n# use std::process;\n# \n# use minigrep::{search, search_case_insensitive};\n# \n# fn main() {\n#     let config = Config::build(env::args()).unwrap_or_else(|err| {\n#         eprintln!(\"Problem z parsowaniem argumentÃ³w: {err}\");\n#         process::exit(1);\n#     });\n# \n#     if let Err(e) = run(config) {\n#         eprintln!(\"BÅ‚Ä…d aplikacji: {e}\");\n#         process::exit(1);\n#     }\n# }\n# \n# pub struct Config {\n#     pub query: String,\n#     pub file_path: String,\n#     pub ignore_case: bool,\n# }\n# \nimpl Config {\n    fn build(\n        mut args: impl Iterator<Item = String>,\n    ) -> Result<Config, &'static str> {\n        // --snip--\n#         if args.len() < 3 {\n#             return Err(\"za maÅ‚o argumentÃ³w\");\n#         }\n# \n#         let query = args[1].clone();\n#         let file_path = args[2].clone();\n# \n#         let ignore_case = env::var(\"IGNORE_CASE\").is_ok();\n# \n#         Ok(Config {\n#             query,\n#             file_path,\n#             ignore_case,\n#         })\n#     }\n# }\n# \n# fn run(config: Config) -> Result<(), Box<dyn Error>> {\n#     let contents = fs::read_to_string(config.file_path)?;\n# \n#     let results = if config.ignore_case {\n#         search_case_insensitive(&config.query, &contents)\n#     } else {\n#         search(&config.query, &contents)\n#     };\n# \n#     for line in results {\n#         println!(\"{line}\");\n#     }\n# \n#     Ok(())\n# }\n```\n\n</Listing>\n\nDokumentacja standardowej biblioteki dla funkcji `env::args` pokazuje, Å¼e typ iteratora, ktÃ³ry zwraca, to `std::env::Args`, a ten typ implementuje cechÄ™ `Iterator` i zwraca wartoÅ›ci `String`.\n\nZaktualizowaliÅ›my sygnaturÄ™ funkcji `Config::build` tak, aby parametr `args` miaÅ‚ typ generyczny z ograniczeniami cech `impl Iterator<Item = String>` zamiast `&[String]`. To uÅ¼ycie skÅ‚adni `impl Trait`, ktÃ³rÄ… omÃ³wiliÅ›my w sekcji [â€UÅ¼ywanie cech jako parametrÃ³wâ€][impl-trait]<!-- ignore --> w Rozdziale 10, oznacza, Å¼e `args` moÅ¼e byÄ‡ dowolnym typem, ktÃ³ry implementuje cechÄ™ `Iterator` i zwraca elementy `String`.\n\nPoniewaÅ¼ przejmujemy wÅ‚asnoÅ›Ä‡ `args` i bÄ™dziemy modyfikowaÄ‡ `args` poprzez iteracjÄ™ po nim, moÅ¼emy dodaÄ‡ sÅ‚owo kluczowe `mut` do specyfikacji parametru `args`, aby uczyniÄ‡ go zmiennym.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"using-iterator-trait-methods-instead-of-indexing\"></a>\n\n#### UÅ¼ywanie metod cech `Iterator`\n\nNastÄ™pnie poprawimy ciaÅ‚o `Config::build`. PoniewaÅ¼ `args` implementuje cechÄ™ `Iterator`, wiemy, Å¼e moÅ¼emy na nim wywoÅ‚aÄ‡ metodÄ™ `next`! Listing 13-20 aktualizuje kod z Listing 12-23, aby uÅ¼ywaÅ‚ metody `next`.\n\n<Listing number=\"13-20\" file-name=\"src/main.rs\" caption=\"Zmiana ciaÅ‚a `Config::build` w celu uÅ¼ycia metod iteratora\">\n\n```rust,ignore,noplayground\n# use std::env;\n# use std::error::Error;\n# use std::fs;\n# use std::process;\n# \n# use minigrep::{search, search_case_insensitive};\n# \n# fn main() {\n#     let config = Config::build(env::args()).unwrap_or_else(|err| {\n#         eprintln!(\"Problem z parsowaniem argumentÃ³w: {err}\");\n#         process::exit(1);\n#     });\n# \n#     if let Err(e) = run(config) {\n#         eprintln!(\"BÅ‚Ä…d aplikacji: {e}\");\n#         process::exit(1);\n#     }\n# }\n# \n# pub struct Config {\n#     pub query: String,\n#     pub file_path: String,\n#     pub ignore_case: bool,\n# }\n# \nimpl Config {\n    fn build(\n        mut args: impl Iterator<Item = String>,\n    ) -> Result<Config, &'static str> {\n        args.next();\n\n        let query = match args.next() {\n            Some(arg) => arg,\n            None => return Err(\"Nie otrzymano ciÄ…gu zapytania\"),\n        };\n\n        let file_path = match args.next() {\n            Some(arg) => arg,\n            None => return Err(\"Nie otrzymano Å›cieÅ¼ki pliku\"),\n        };\n\n        let ignore_case = env::var(\"IGNORE_CASE\").is_ok();\n\n        Ok(Config {\n            query,\n            file_path,\n            ignore_case,\n        })\n    }\n}\n# \n# fn run(config: Config) -> Result<(), Box<dyn Error>> {\n#     let contents = fs::read_to_string(config.file_path)?;\n# \n#     let results = if config.ignore_case {\n#         search_case_insensitive(&config.query, &contents)\n#     } else {\n#         search(&config.query, &contents)\n#     };\n# \n#     for line in results {\n#         println!(\"{line}\");\n#     }\n# \n#     Ok(())\n# }\n```\n\n</Listing>\n\nPamiÄ™taj, Å¼e pierwsza wartoÅ›Ä‡ zwracana przez `env::args` to nazwa programu. Chcemy jÄ… zignorowaÄ‡ i przejÅ›Ä‡ do nastÄ™pnej wartoÅ›ci, wiÄ™c najpierw wywoÅ‚ujemy `next` i nic nie robimy z wartoÅ›ciÄ… zwracanÄ…. NastÄ™pnie wywoÅ‚ujemy `next`, aby uzyskaÄ‡ wartoÅ›Ä‡, ktÃ³rÄ… chcemy umieÅ›ciÄ‡ w polu `query` struktury `Config`. JeÅ›li `next` zwraca `Some`, uÅ¼ywamy `match`, aby wyodrÄ™bniÄ‡ wartoÅ›Ä‡. JeÅ›li zwraca `None`, oznacza to, Å¼e nie podano wystarczajÄ…cej liczby argumentÃ³w, i zwracamy `Err`. To samo robimy dla wartoÅ›ci `file_path`.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"making-code-clearer-with-iterator-adapters\"></a>\n\n### Upraszczanie kodu za pomocÄ… adapterÃ³w iteratorÃ³w\n\nMoÅ¼emy rÃ³wnieÅ¼ wykorzystaÄ‡ iteratory w funkcji `search` w naszym projekcie I/O, ktÃ³ra jest tutaj odtworzona w Listing 13-21 w takiej postaci, w jakiej byÅ‚a w Listing 12-19.\n\n<Listing number=\"13-21\" file-name=\"src/lib.rs\" caption=\"Implementacja funkcji `search` z Listing 12-19\">\n\n```rust,ignore\npub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n    let mut results = Vec::new();\n\n    for line in contents.lines() {\n        if line.contains(query) {\n            results.push(line);\n        }\n    }\n\n    results\n}\n# \n# #[cfg(test)]\n# mod tests {\n#     use super::*;\n# \n#     #[test]\n#     fn one_result() {\n#         let query = \"duct\";\n#         let contents = \"\\\n# Rust:\n# safe, fast, productive.\n# Pick three.\";\n# \n#         assert_eq!(vec![\"safe, fast, productive.\"], search(query, contents));\n#     }\n# }\n```\n\n</Listing>\n\nMoÅ¼emy napisaÄ‡ ten kod w bardziej zwiÄ™zÅ‚y sposÃ³b, uÅ¼ywajÄ…c metod adaptera iteratora. Pozwala to rÃ³wnieÅ¼ uniknÄ…Ä‡ posiadania zmiennego, poÅ›redniego wektora `results`. Styl programowania funkcyjnego preferuje minimalizowanie iloÅ›ci zmiennego stanu, aby kod byÅ‚ bardziej czytelny. UsuniÄ™cie zmiennego stanu moÅ¼e umoÅ¼liwiÄ‡ przyszÅ‚e ulepszenie, aby wyszukiwanie odbywaÅ‚o siÄ™ rÃ³wnolegle, poniewaÅ¼ nie musielibyÅ›my zarzÄ…dzaÄ‡ wspÃ³Å‚bieÅ¼nym dostÄ™pem do wektora `results`. Listing 13-22 pokazuje tÄ™ zmianÄ™.\n\n<Listing number=\"13-22\" file-name=\"src/lib.rs\" caption=\"UÅ¼ywanie metod adaptera iteratora w implementacji funkcji `search`\">\n\n```rust,ignore\npub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n    contents\n        .lines()\n        .filter(|line| line.contains(query))\n        .collect()\n}\n# \n# pub fn search_case_insensitive<'a>(\n#     query: &str,\n#     contents: &'a str,\n# ) -> Vec<&'a str> {\n#     let query = query.to_lowercase();\n#     let mut results = Vec::new();\n# \n#     for line in contents.lines() {\n#         if line.to_lowercase().contains(&query) {\n#             results.push(line);\n#         }\n#     }\n# \n#     results\n# }\n# \n# #[cfg(test)]\n# mod tests {\n#     use super::*;\n# \n#     #[test]\n#     fn case_sensitive() {\n#         let query = \"duct\";\n#         let contents = \"\\\n# Rust:\n# safe, fast, productive.\n# Pick three.\n# Duct tape.\";\n# \n#         assert_eq!(vec![\"safe, fast, productive.\"], search(query, contents));\n#     }\n# \n#     #[test]\n#     fn case_insensitive() {\n#         let query = \"rUsT\";\n#         let contents = \"\\\n# Rust:\n# safe, fast, productive.\n# Pick three.\n# Trust me.\";\n# \n#         assert_eq!(\n#             vec![\"Rust:\", \"Trust me.\"],\n#             search_case_insensitive(query, contents)\n#         );\n#     }\n# }\n```\n\n</Listing>\n\nPamiÄ™taj, Å¼e celem funkcji `search` jest zwrÃ³cenie wszystkich wierszy w `contents`, ktÃ³re zawierajÄ… `query`. Podobnie jak w przykÅ‚adzie `filter` w Listing 13-16, ten kod uÅ¼ywa adaptera `filter` do zachowania tylko tych wierszy, dla ktÃ³rych `line.contains(query)` zwraca `true`. NastÄ™pnie zbieramy pasujÄ…ce wiersze do innego wektora za pomocÄ… `collect`. O wiele proÅ›ciej! ZachÄ™camy do wprowadzenia tej samej zmiany, aby uÅ¼ywaÄ‡ metod iteratora rÃ³wnieÅ¼ w funkcji `search_case_insensitive`.\n\nDla dalszego ulepszenia, zwrÃ³Ä‡ iterator z funkcji `search` poprzez usuniÄ™cie wywoÅ‚ania `collect` i zmianÄ™ typu zwracanego na `impl Iterator<Item = &'a str>`, tak aby funkcja staÅ‚a siÄ™ adapterem iteratora. ZauwaÅ¼, Å¼e bÄ™dziesz musiaÅ‚ rÃ³wnieÅ¼ zaktualizowaÄ‡ testy! Przeszukaj duÅ¼y plik za pomocÄ… narzÄ™dzia `minigrep` przed i po wprowadzeniu tej zmiany, aby zaobserwowaÄ‡ rÃ³Å¼nicÄ™ w zachowaniu. Przed tÄ… zmianÄ… program nie wyÅ›wietli Å¼adnych wynikÃ³w, dopÃ³ki nie zbierze wszystkich wynikÃ³w, ale po zmianie wyniki bÄ™dÄ… wyÅ›wietlane w miarÄ™ znajdowania kaÅ¼dej pasujÄ…cej linii, poniewaÅ¼ pÄ™tla `for` w funkcji `run` bÄ™dzie mogÅ‚a wykorzystaÄ‡ lenistwo iteratora.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"choosing-between-loops-or-iterators\"></a>\n\n### WybÃ³r miÄ™dzy pÄ™tlami a iteratorami\n\nNastÄ™pne logiczne pytanie brzmi, jaki styl powinieneÅ› wybraÄ‡ w swoim kodzie i dlaczego: oryginalnÄ… implementacjÄ™ z Listing 13-21, czy wersjÄ™ uÅ¼ywajÄ…cÄ… iteratorÃ³w z Listing 13-22 (zakÅ‚adajÄ…c, Å¼e zbieramy wszystkie wyniki przed ich zwrÃ³ceniem, a nie zwracamy iteratora). WiÄ™kszoÅ›Ä‡ programistÃ³w Rusta preferuje styl iteratorÃ³w. Na poczÄ…tku jest to trochÄ™ trudniejsze do opanowania, ale gdy juÅ¼ poczujesz siÄ™ z rÃ³Å¼nymi adapterami iteratorÃ³w i tym, co robiÄ…, iteratory mogÄ… byÄ‡ Å‚atwiejsze do zrozumienia. Zamiast bawiÄ‡ siÄ™ rÃ³Å¼nymi elementami pÄ™tli i budowaÄ‡ nowe wektory, kod skupia siÄ™ na ogÃ³lnym celu pÄ™tli. Abstrakcjonizuje to niektÃ³re z typowych kodÃ³w, dziÄ™ki czemu Å‚atwiej jest dostrzec koncepcje unikalne dla tego kodu, takie jak warunek filtrowania, ktÃ³ry musi speÅ‚niÄ‡ kaÅ¼dy element w iteratorze.\n\nAle czy te dwie implementacje sÄ… naprawdÄ™ rÃ³wnowaÅ¼ne? Intuicyjne zaÅ‚oÅ¼enie moÅ¼e byÄ‡ takie, Å¼e pÄ™tla niÅ¼szego poziomu bÄ™dzie szybsza. Porozmawiajmy o wydajnoÅ›ci.\n\n[impl-trait]: ch10-02-traits.html#traits-as-parameters",
        "chapter_title": "Udoskonalanie naszego projektu I/O"
    },
    {
        "file_path": "ch13-04-performance.md",
        "content": "<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"comparing-performance-loops-vs-iterators\"></a>\n\n## WydajnoÅ›Ä‡ w pÄ™tlach vs. iteratorach\n\nAby zdecydowaÄ‡, czy uÅ¼yÄ‡ pÄ™tli, czy iteratorÃ³w, musisz wiedzieÄ‡, ktÃ³ra implementacja jest szybsza: wersja funkcji `search` z jawnÄ… pÄ™tlÄ… `for` czy wersja z iteratorami.\n\nPrzeprowadziliÅ›my benchmark, Å‚adujÄ…c caÅ‚Ä… zawartoÅ›Ä‡ _PrzygÃ³d Sherlocka Holmesa_ Sir Arthura Conana Doyle'a do `String` i szukajÄ…c sÅ‚owa _the_ w zawartoÅ›ci. Oto wyniki benchmarku dla wersji `search` uÅ¼ywajÄ…cej pÄ™tli `for` i wersji uÅ¼ywajÄ…cej iteratorÃ³w:\n\n```text\ntest bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)\ntest bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)\n```\n\nObie implementacje majÄ… podobnÄ… wydajnoÅ›Ä‡! Nie bÄ™dziemy tutaj wyjaÅ›niaÄ‡ kodu benchmarku, poniewaÅ¼ nie chodzi o udowodnienie, Å¼e obie wersje sÄ… rÃ³wnowaÅ¼ne, ale o ogÃ³lne rozeznanie, jak te dwie implementacje wypadajÄ… pod wzglÄ™dem wydajnoÅ›ci.\n\nAby uzyskaÄ‡ bardziej kompleksowy benchmark, powinieneÅ› sprawdziÄ‡ uÅ¼ycie rÃ³Å¼nych tekstÃ³w o rÃ³Å¼nych rozmiarach jako `contents`, rÃ³Å¼nych sÅ‚Ã³w i sÅ‚Ã³w o rÃ³Å¼nej dÅ‚ugoÅ›ci jako `query` oraz wszelkiego rodzaju innych wariacji. Chodzi o to: iteratory, choÄ‡ sÄ… abstrakcjÄ… wysokiego poziomu, sÄ… kompilowane do mniej wiÄ™cej tego samego kodu, co gdybyÅ› sam napisaÅ‚ kod niÅ¼szego poziomu. Iteratory to jedna z _abstrakcji zerokosztowych_ Rusta, co oznacza, Å¼e uÅ¼ycie abstrakcji nie narzuca Å¼adnego dodatkowego narzutu czasowego. Jest to analogiczne do tego, jak Bjarne Stroustrup, oryginalny projektant i implementator C++, definiuje zerowy narzut w swoim przemÃ³wieniu inauguracyjnym ETAPS z 2012 roku â€Foundations of C++â€:\n\n> OgÃ³lnie rzecz biorÄ…c, implementacje C++ przestrzegajÄ… zasady zerowego narzutu: Czego nie uÅ¼ywasz, za to nie pÅ‚acisz. A dalej: Czego uÅ¼ywasz, nie mÃ³gÅ‚byÅ› napisaÄ‡ rÄ™cznie lepiej.\n\nW wielu przypadkach kod Rusta uÅ¼ywajÄ…cy iteratorÃ³w kompiluje siÄ™ do tego samego assemblera, co kod napisany rÄ™cznie. Stosowane sÄ… optymalizacje, takie jak rozwiniÄ™cie pÄ™tli i eliminacja sprawdzania zakresÃ³w przy dostÄ™pie do tablic, co sprawia, Å¼e wynikowy kod jest niezwykle wydajny. Teraz, gdy to wiesz, moÅ¼esz bez obaw uÅ¼ywaÄ‡ iteratorÃ³w i domkniÄ™Ä‡! SprawiajÄ…, Å¼e kod wydaje siÄ™ byÄ‡ na wyÅ¼szym poziomie, ale nie narzucajÄ… kary za wydajnoÅ›Ä‡ w czasie dziaÅ‚ania.\n\n## Podsumowanie\n\nDomkniÄ™cia i iteratory to cechy Rusta inspirowane ideami programowania funkcyjnego. PrzyczyniajÄ… siÄ™ one do zdolnoÅ›ci Rusta do wyraÅºnego wyraÅ¼ania idei wysokiego poziomu z niskopoziomowÄ… wydajnoÅ›ciÄ…. Implementacje domkniÄ™Ä‡ i iteratorÃ³w sÄ… takie, Å¼e wydajnoÅ›Ä‡ w czasie dziaÅ‚ania nie jest naruszana. Jest to czÄ™Å›Ä‡ celu Rusta, jakim jest dÄ…Å¼enie do zapewnienia abstrakcji zerokosztowych.\n\nTeraz, gdy ulepszyliÅ›my ekspresywnoÅ›Ä‡ naszego projektu I/O, przyjrzyjmy siÄ™ kilku innym funkcjom `cargo`, ktÃ³re pomogÄ… nam udostÄ™pniÄ‡ projekt Å›wiatu.\n",
        "chapter_title": "WydajnoÅ›Ä‡ w pÄ™tlach vs. iteratorach"
    },
    {
        "file_path": "ch14-00-more-about-cargo.md",
        "content": "# WiÄ™cej o Cargo i Crates.io\n\nDo tej pory uÅ¼ywaliÅ›my tylko najbardziej podstawowych funkcji Cargo do budowania, uruchamiania i testowania naszego kodu, ale potrafi ono znacznie wiÄ™cej. W tym rozdziale omÃ³wimy niektÃ³re z jego innych, bardziej zaawansowanych funkcji, aby pokazaÄ‡, jak:\n\n- DostosowaÄ‡ kompilacjÄ™ za pomocÄ… profili wydania.\n- PublikowaÄ‡ biblioteki na [crates.io](https://crates.io/)<!-- ignore -->.\n- OrganizowaÄ‡ duÅ¼e projekty za pomocÄ… obszarÃ³w roboczych.\n- InstalowaÄ‡ pliki binarne z [crates.io](https://crates.io/)<!-- ignore -->.\n- RozszerzaÄ‡ Cargo za pomocÄ… niestandardowych poleceÅ„.\n\nCargo potrafi jeszcze wiÄ™cej niÅ¼ funkcjonalnoÅ›Ä‡, ktÃ³rÄ… omÃ³wimy w tym rozdziale, wiÄ™c aby uzyskaÄ‡ peÅ‚ne wyjaÅ›nienie wszystkich jego funkcji, zobacz [jego dokumentacjÄ™](https://doc.rust-lang.org/cargo/).\n",
        "chapter_title": "WiÄ™cej o Cargo i Crates.io"
    },
    {
        "file_path": "ch14-01-release-profiles.md",
        "content": "## Dostosowywanie kompilacji za pomocÄ… profili wydania\n\nW Rust _profile wydania_ to predefiniowane, dostosowywalne profile z rÃ³Å¼nymi konfiguracjami, ktÃ³re pozwalajÄ… programistom na wiÄ™kszÄ… kontrolÄ™ nad rÃ³Å¼nymi opcjami kompilacji kodu. KaÅ¼dy profil jest konfigurowany niezaleÅ¼nie od innych.\n\nCargo ma dwa gÅ‚Ã³wne profile: profil `dev`, ktÃ³rego Cargo uÅ¼ywa podczas uruchamiania `cargo build`, oraz profil `release`, ktÃ³rego Cargo uÅ¼ywa podczas uruchamiania `cargo build --release`. Profil `dev` jest zdefiniowany z dobrymi wartoÅ›ciami domyÅ›lnymi do tworzenia oprogramowania, a profil `release` ma dobre wartoÅ›ci domyÅ›lne dla kompilacji wydania.\n\nTe nazwy profili mogÄ… byÄ‡ znane z danych wyjÅ›ciowych Twoich kompilacji:\n\n<!-- manual-regeneration\nanywhere, run:\ncargo build\ncargo build --release\nand ensure output below is accurate\n-->\n\n```console\n$ cargo build\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s\n$ cargo build --release\n    Finished `release` profile [optimized] target(s) in 0.32s\n```\n\n`dev` i `release` to rÃ³Å¼ne profile uÅ¼ywane przez kompilator.\n\nCargo ma domyÅ›lne ustawienia dla kaÅ¼dego z profili, ktÃ³re sÄ… stosowane, gdy nie dodaÅ‚eÅ› jawnie Å¼adnych sekcji `[profile.*]` do pliku _Cargo.toml_ projektu. DodajÄ…c sekcje `[profile.*]` dla dowolnego profilu, ktÃ³ry chcesz dostosowaÄ‡, nadpisujesz dowolny podzbiÃ³r domyÅ›lnych ustawieÅ„. Na przykÅ‚ad, oto domyÅ›lne wartoÅ›ci ustawienia `opt-level` dla profili `dev` i `release`:\n\n<span class=\"filename\">Nazwa pliku: Cargo.toml</span>\n\n```toml\n[profile.dev]\nopt-level = 0\n\n[profile.release]\nopt-level = 3\n```\n\nUstawienie `opt-level` kontroluje liczbÄ™ optymalizacji, ktÃ³re Rust zastosuje do Twojego kodu, w zakresie od 0 do 3. Zastosowanie wiÄ™kszej liczby optymalizacji wydÅ‚uÅ¼a czas kompilacji, wiÄ™c jeÅ›li jesteÅ› w fazie rozwoju i czÄ™sto kompilujesz swÃ³j kod, bÄ™dziesz chciaÅ‚ mniej optymalizacji, aby kompilowaÄ‡ szybciej, nawet jeÅ›li wynikowy kod bÄ™dzie dziaÅ‚aÅ‚ wolniej. DomyÅ›lny `opt-level` dla `dev` wynosi zatem `0`. Kiedy jesteÅ› gotowy do wydania swojego kodu, najlepiej poÅ›wiÄ™ciÄ‡ wiÄ™cej czasu na kompilacjÄ™. Skompilujesz w trybie wydania tylko raz, ale bÄ™dziesz uruchamiaÄ‡ skompilowany program wiele razy, wiÄ™c tryb wydania wymienia dÅ‚uÅ¼szy czas kompilacji na szybszy kod. Dlatego domyÅ›lny `opt-level` dla profilu `release` wynosi `3`.\n\nMoÅ¼esz nadpisaÄ‡ domyÅ›lne ustawienie, dodajÄ…c dla niego innÄ… wartoÅ›Ä‡ w _Cargo.toml_. Na przykÅ‚ad, jeÅ›li chcemy uÅ¼yÄ‡ poziomu optymalizacji 1 w profilu deweloperskim, moÅ¼emy dodaÄ‡ te dwie linie do pliku _Cargo.toml_ naszego projektu:\n\n<span class=\"filename\">Nazwa pliku: Cargo.toml</span>\n\n```toml\n[profile.dev]\nopt-level = 1\n```\n\nTen kod nadpisuje domyÅ›lne ustawienie `0`. Teraz, gdy uruchomimy `cargo build`, Cargo uÅ¼yje domyÅ›lnych ustawieÅ„ dla profilu `dev` plus nasze dostosowanie `opt-level`. PoniewaÅ¼ ustawiliÅ›my `opt-level` na `1`, Cargo zastosuje wiÄ™cej optymalizacji niÅ¼ domyÅ›lnie, ale nie tak wiele, jak w kompilacji wydania.\n\nAby uzyskaÄ‡ peÅ‚nÄ… listÄ™ opcji konfiguracji i wartoÅ›ci domyÅ›lnych dla kaÅ¼dego profilu, zobacz [dokumentacjÄ™ Cargo](https://doc.rust-lang.org/cargo/reference/profiles.html).\n",
        "chapter_title": "Dostosowywanie kompilacji za pomocÄ… profili wydania"
    },
    {
        "file_path": "ch14-02-publishing-to-crates-io.md",
        "content": "## Publikowanie pakietu na Crates.io\n\nKorzystaliÅ›my juÅ¼ z pakietÃ³w z [crates.io](https://crates.io/)<!-- ignore --> jako zaleÅ¼noÅ›ci w naszych projektach, ale moÅ¼esz rÃ³wnieÅ¼ udostÄ™pniaÄ‡ swÃ³j kod innym osobom, publikujÄ…c wÅ‚asne pakiety. Rejestr pakietÃ³w [crates.io](https://crates.io/)<!-- ignore --> dystrybuuje kod ÅºrÃ³dÅ‚owy Twoich pakietÃ³w, wiÄ™c hostuje gÅ‚Ã³wnie kod open source.\n\nRust i Cargo posiadajÄ… funkcje, ktÃ³re uÅ‚atwiajÄ… innym osobom odnalezienie i uÅ¼ycie opublikowanego pakietu. NastÄ™pnie omÃ³wimy niektÃ³re z tych funkcji, a potem wyjaÅ›nimy, jak opublikowaÄ‡ pakiet.\n\n### Tworzenie uÅ¼ytecznych komentarzy dokumentacji\n\nDokÅ‚adne udokumentowanie Twoich pakietÃ³w pomoÅ¼e innym uÅ¼ytkownikom zrozumieÄ‡, jak i kiedy ich uÅ¼ywaÄ‡, dlatego warto poÅ›wiÄ™ciÄ‡ czas na napisanie dokumentacji. W Rozdziale 3 omÃ³wiliÅ›my, jak komentowaÄ‡ kod w Rust za pomocÄ… dwÃ³ch ukoÅ›nikÃ³w, `//`. Rust ma rÃ³wnieÅ¼ szczegÃ³lny rodzaj komentarza do dokumentacji, znany wygodnie jako _komentarz dokumentacji_, ktÃ³ry wygeneruje dokumentacjÄ™ HTML. HTML wyÅ›wietla zawartoÅ›Ä‡ komentarzy dokumentacji dla publicznych elementÃ³w API przeznaczonych dla programistÃ³w zainteresowanych sposobem _uÅ¼ycia_ Twojego pakietu, w przeciwieÅ„stwie do sposobu _implementacji_ Twojego pakietu.\n\nKomentarze dokumentacji uÅ¼ywajÄ… trzech ukoÅ›nikÃ³w, `///`, zamiast dwÃ³ch i obsÅ‚ugujÄ… notacjÄ™ Markdown do formatowania tekstu. UmieÅ›Ä‡ komentarze dokumentacji tuÅ¼ przed elementem, ktÃ³ry dokumentujÄ…. Listing 14-1 pokazuje komentarze dokumentacji dla funkcji `add_one` w pakiecie o nazwie `my_crate`.\n\n<Listing number=\"14-1\" file-name=\"src/lib.rs\" caption=\"Komentarz dokumentacji dla funkcji\">\n\n```rust,ignore\n/// Dodaje jeden do podanej liczby.\n///\n/// # PrzykÅ‚ady\n///\n/// ```\n/// let arg = 5;\n/// let answer = my_crate::add_one(arg);\n///\n/// assert_eq!(6, answer);\n/// ```\npub fn add_one(x: i32) -> i32 {\n    x + 1\n}\n```\n\n</Listing>\n\nTutaj podajemy opis tego, co robi funkcja `add_one`, rozpoczynamy sekcjÄ™ z nagÅ‚Ã³wkiem `PrzykÅ‚ady`, a nastÄ™pnie podajemy kod, ktÃ³ry demonstruje, jak uÅ¼ywaÄ‡ funkcji `add_one`. MoÅ¼emy wygenerowaÄ‡ dokumentacjÄ™ HTML z tego komentarza dokumentacji, uruchamiajÄ…c `cargo doc`. To polecenie uruchamia narzÄ™dzie `rustdoc` dystrybuowane z Rustem i umieszcza wygenerowanÄ… dokumentacjÄ™ HTML w katalogu _target/doc_.\n\nDla wygody, uruchomienie `cargo doc --open` zbuduje HTML dla dokumentacji twojego bieÅ¼Ä…cego pakietu (a takÅ¼e dokumentacjÄ™ dla wszystkich zaleÅ¼noÅ›ci twojego pakietu) i otworzy wynik w przeglÄ…darce internetowej. PrzejdÅº do funkcji `add_one` i zobaczysz, jak tekst z komentarzy dokumentacji jest renderowany, jak pokazano na Rysunku 14-1.\n\n<img alt=\"Wyrenderowana dokumentacja HTML dla funkcji `add_one` pakietu `my_crate`\" src=\"img/trpl14-01.png\" class=\"center\" />\n\n<span class=\"caption\">Rysunek 14-1: Dokumentacja HTML dla funkcji `add_one`</span>\n\n#### CzÄ™sto uÅ¼ywane sekcje\n\nUÅ¼yliÅ›my nagÅ‚Ã³wka Markdown `# PrzykÅ‚ady` w Listing 14-1, aby stworzyÄ‡ sekcjÄ™ w HTML z tytuÅ‚em â€PrzykÅ‚adyâ€. Oto inne sekcje, ktÃ³re autorzy pakietÃ³w czÄ™sto uÅ¼ywajÄ… w swojej dokumentacji:\n\n- **Panics**: SÄ… to scenariusze, w ktÃ³rych dokumentowana funkcja moÅ¼e wywoÅ‚aÄ‡ panikÄ™. Osoby wywoÅ‚ujÄ…ce funkcjÄ™, ktÃ³re nie chcÄ…, aby ich programy panikowaÅ‚y, powinny upewniÄ‡ siÄ™, Å¼e nie wywoÅ‚ujÄ… funkcji w tych sytuacjach.\n- **Errors**: JeÅ›li funkcja zwraca `Result`, opisanie rodzajÃ³w bÅ‚Ä™dÃ³w, ktÃ³re mogÄ… wystÄ…piÄ‡, i warunkÃ³w, ktÃ³re mogÄ… spowodowaÄ‡ zwrÃ³cenie tych bÅ‚Ä™dÃ³w, moÅ¼e byÄ‡ pomocne dla osÃ³b wywoÅ‚ujÄ…cych, aby mogÅ‚y napisaÄ‡ kod do obsÅ‚ugi rÃ³Å¼nych rodzajÃ³w bÅ‚Ä™dÃ³w na rÃ³Å¼ne sposoby.\n- **Safety**: JeÅ›li wywoÅ‚anie funkcji jest `unsafe` (niebezpieczne) (omawiamy niebezpieczeÅ„stwo w Rozdziale 20), powinna istnieÄ‡ sekcja wyjaÅ›niajÄ…ca, dlaczego funkcja jest niebezpieczna i omawiajÄ…ca niezmienniki, ktÃ³rych funkcja oczekuje od osÃ³b wywoÅ‚ujÄ…cych.\n\nWiÄ™kszoÅ›Ä‡ komentarzy dokumentacyjnych nie potrzebuje wszystkich tych sekcji, ale jest to dobra lista kontrolna, ktÃ³ra przypomina o aspektach Twojego kodu, ktÃ³rymi uÅ¼ytkownicy bÄ™dÄ… zainteresowani.\n\n#### Komentarze dokumentacji jako testy\n\nDodawanie blokÃ³w kodu przykÅ‚adu w komentarzach dokumentacji moÅ¼e pomÃ³c zademonstrowaÄ‡, jak uÅ¼ywaÄ‡ Twojej biblioteki i ma dodatkowy bonus: uruchomienie `cargo test` uruchomi przykÅ‚ady kodu z Twojej dokumentacji jako testy! Nic nie jest lepsze niÅ¼ dokumentacja z przykÅ‚adami. Ale nic nie jest gorsze niÅ¼ przykÅ‚ady, ktÃ³re nie dziaÅ‚ajÄ…, poniewaÅ¼ kod zmieniÅ‚ siÄ™ od czasu napisania dokumentacji. JeÅ›li uruchomimy `cargo test` z dokumentacjÄ… dla funkcji `add_one` z Listing 14-1, zobaczymy sekcjÄ™ w wynikach testÃ³w, ktÃ³ra wyglÄ…da tak:\n\n<!-- manual-regeneration\ncd listings/ch14-more-about-cargo/listing-14-01/\ncargo test\ncopy just the doc-tests section below\n-->\n\n```text\n   Doc-tests my_crate\n\nrunning 1 test\ntest src/lib.rs - add_one (linia 5) ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s\n```\n\nTeraz, jeÅ›li zmienimy funkcjÄ™ lub przykÅ‚ad tak, Å¼e `assert_eq!` w przykÅ‚adzie wywoÅ‚a panikÄ™, i ponownie uruchomimy `cargo test`, zobaczymy, Å¼e testy dokumentacji wykryjÄ…, Å¼e przykÅ‚ad i kod sÄ… niezsynchronizowane!\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"commenting-contained-items\"></a>\n\n#### Komentarze do zawartych elementÃ³w\n\nStyl komentarza dokumentacji `//!` dodaje dokumentacjÄ™ do elementu, ktÃ³ry *zawiera* komentarze, a nie do elementÃ³w *nastÄ™pujÄ…cych po* komentarzach. Zazwyczaj uÅ¼ywamy tych komentarzy dokumentacji wewnÄ…trz pliku gÅ‚Ã³wnego pakietu (_src/lib.rs_ zgodnie z konwencjÄ…) lub wewnÄ…trz moduÅ‚u, aby udokumentowaÄ‡ pakiet lub moduÅ‚ jako caÅ‚oÅ›Ä‡.\n\nNa przykÅ‚ad, aby dodaÄ‡ dokumentacjÄ™ opisujÄ…cÄ… cel pakietu `my_crate`, ktÃ³ry zawiera funkcjÄ™ `add_one`, dodajemy komentarze dokumentacji, ktÃ³re zaczynajÄ… siÄ™ od `//!` na poczÄ…tku pliku _src/lib.rs_, jak pokazano w Listing 14-2.\n\n<Listing number=\"14-2\" file-name=\"src/lib.rs\" caption=\"Dokumentacja dla pakietu `my_crate` jako caÅ‚oÅ›ci\">\n\n```rust,ignore\n//! # MÃ³j Pakiet\n//!\n//! `my_crate` to zbiÃ³r narzÄ™dzi uÅ‚atwiajÄ…cych wykonywanie pewnych\n//! obliczeÅ„.\n\n/// Dodaje jeden do podanej liczby.\n// --snip--\n# ///\n# /// # PrzykÅ‚ady\n# ///\n# /// ```\n# /// let arg = 5;\n# /// let answer = my_crate::add_one(arg);\n# ///\n# /// assert_eq!(6, answer);\n# /// ```\n# pub fn add_one(x: i32) -> i32 {\n#     x + 1\n# }\n```\n\n</Listing>\n\nZauwaÅ¼, Å¼e po ostatniej linii zaczynajÄ…cej siÄ™ od `//!` nie ma Å¼adnego kodu. PoniewaÅ¼ rozpoczÄ™liÅ›my komentarze od `//!` zamiast `///`, dokumentujemy element, ktÃ³ry zawiera ten komentarz, a nie element, ktÃ³ry nastÄ™puje po tym komentarzu. W tym przypadku elementem jest plik _src/lib.rs_, ktÃ³ry jest korzeniem pakietu. Te komentarze opisujÄ… caÅ‚y pakiet.\n\nKiedy uruchomimy `cargo doc --open`, te komentarze zostanÄ… wyÅ›wietlone na stronie gÅ‚Ã³wnej dokumentacji `my_crate` powyÅ¼ej listy publicznych elementÃ³w w pakiecie, jak pokazano na Rysunku 14-2.\n\nKomentarze dokumentacyjne wewnÄ…trz elementÃ³w sÄ… szczegÃ³lnie przydatne do opisywania pakietÃ³w i moduÅ‚Ã³w. UÅ¼ywaj ich do wyjaÅ›niania ogÃ³lnego celu kontenera, aby pomÃ³c uÅ¼ytkownikom zrozumieÄ‡ organizacjÄ™ pakietu.\n\n<img alt=\"Wyrenderowana dokumentacja HTML z komentarzem dla caÅ‚ego pakietu `art`\" src=\"img/trpl14-02.png\" class=\"center\" />\n\n<span class=\"caption\">Rysunek 14-2: Wyrenderowana dokumentacja dla `my_crate`, zawierajÄ…ca komentarz opisujÄ…cy caÅ‚y pakiet</span>\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"exporting-a-convenient-public-api-with-pub-use\"></a>\n\n### Eksportowanie wygodnego publicznego API\n\nStruktura publicznego API jest kluczowÄ… kwestiÄ… podczas publikowania pakietu. Osoby korzystajÄ…ce z twojego pakietu sÄ… mniej zaznajomione z jego strukturÄ… niÅ¼ ty i mogÄ… mieÄ‡ trudnoÅ›ci ze znalezieniem elementÃ³w, ktÃ³rych chcÄ… uÅ¼yÄ‡, jeÅ›li twÃ³j pakiet ma duÅ¼Ä… hierarchiÄ™ moduÅ‚Ã³w.\n\nW Rozdziale 7 omÃ³wiliÅ›my, jak uczyniÄ‡ elementy publicznymi za pomocÄ… sÅ‚owa kluczowego `pub` oraz jak wprowadziÄ‡ elementy do zakresu za pomocÄ… sÅ‚owa kluczowego `use`. Jednak struktura, ktÃ³ra ma sens dla Ciebie podczas tworzenia pakietu, moÅ¼e nie byÄ‡ zbyt wygodna dla Twoich uÅ¼ytkownikÃ³w. MoÅ¼esz chcieÄ‡ zorganizowaÄ‡ swoje struktury w hierarchii zawierajÄ…cej wiele poziomÃ³w, ale wtedy osoby, ktÃ³re chcÄ… uÅ¼yÄ‡ typu zdefiniowanego gÅ‚Ä™boko w hierarchii, mogÄ… mieÄ‡ trudnoÅ›ci z odkryciem, Å¼e taki typ istnieje. MogÄ… rÃ³wnieÅ¼ byÄ‡ zirytowane koniecznoÅ›ciÄ… wpisywania `use my_crate::some_module::another_module::UsefulType;` zamiast `use my_crate::UsefulType;`.\n\nDobrÄ… wiadomoÅ›ciÄ… jest to, Å¼e jeÅ›li struktura _nie_ jest wygodna do uÅ¼ycia z innej biblioteki, nie musisz zmieniaÄ‡ swojej wewnÄ™trznej organizacji: zamiast tego moÅ¼esz ponownie eksportowaÄ‡ elementy, aby stworzyÄ‡ publicznÄ… strukturÄ™, ktÃ³ra rÃ³Å¼ni siÄ™ od Twojej prywatnej struktury, uÅ¼ywajÄ…c `pub use`. *Ponowne eksportowanie* pobiera publiczny element w jednym miejscu i udostÄ™pnia go publicznie w innym miejscu, tak jakby byÅ‚ zdefiniowany w tym innym miejscu.\n\nNa przykÅ‚ad, powiedzmy, Å¼e stworzyliÅ›my bibliotekÄ™ o nazwie `art` do modelowania pojÄ™Ä‡ artystycznych. W tej bibliotece znajdujÄ… siÄ™ dwa moduÅ‚y: moduÅ‚ `kinds` zawierajÄ…cy dwa wyliczenia o nazwach `PrimaryColor` i `SecondaryColor` oraz moduÅ‚ `utils` zawierajÄ…cy funkcjÄ™ o nazwie `mix`, jak pokazano w Listing 14-3.\n\n<Listing number=\"14-3\" file-name=\"src/lib.rs\" caption=\"Biblioteka `art` z elementami zorganizowanymi w moduÅ‚y `kinds` i `utils`\">\n\n```rust,noplayground,test_harness\n//! # Sztuka\n//!\n//! Biblioteka do modelowania koncepcji artystycznych.\n\npub mod kinds {\n    /// Kolory podstawowe wedÅ‚ug modelu kolorÃ³w RYB.\n    pub enum PrimaryColor {\n        Red,\n        Yellow,\n        Blue,\n    }\n\n    /// Kolory wtÃ³rne wedÅ‚ug modelu kolorÃ³w RYB.\n    pub enum SecondaryColor {\n        Orange,\n        Green,\n        Purple,\n    }\n}\n\npub mod utils {\n    use crate::kinds::*;\n\n    /// ÅÄ…czy dwa kolory podstawowe w rÃ³wnych proporcjach, aby stworzyÄ‡\n    /// kolor wtÃ³rny.\n    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {\n        // --snip--\n#         unimplemented!();\n    }\n}\n```\n\n</Listing>\n\nRysunek 14-3 pokazuje, jak wyglÄ…daÅ‚aby strona gÅ‚Ã³wna dokumentacji dla tego pakietu wygenerowana przez `cargo doc`.\n\n<img alt=\"Wyrenderowana dokumentacja dla pakietu `art`, ktÃ³ra zawiera listÄ™ moduÅ‚Ã³w `kinds` i `utils`\" src=\"img/trpl14-03.png\" class=\"center\" />\n\n<span class=\"caption\">Rysunek 14-3: Strona gÅ‚Ã³wna dokumentacji dla `art`, ktÃ³ra zawiera listÄ™ moduÅ‚Ã³w `kinds` i `utils`</span>\n\nZauwaÅ¼, Å¼e typy `PrimaryColor` i `SecondaryColor` nie sÄ… wymienione na stronie gÅ‚Ã³wnej, podobnie jak funkcja `mix`. Musimy kliknÄ…Ä‡ `kinds` i `utils`, aby je zobaczyÄ‡.\n\nInny pakiet, ktÃ³ry zaleÅ¼y od tej biblioteki, potrzebowaÅ‚by instrukcji `use`, ktÃ³re wprowadzajÄ… elementy z `art` do zakresu, okreÅ›lajÄ…c strukturÄ™ moduÅ‚u, ktÃ³ra jest aktualnie zdefiniowana. Listing 14-4 pokazuje przykÅ‚ad pakietu, ktÃ³ry uÅ¼ywa elementÃ³w `PrimaryColor` i `mix` z pakietu `art`.\n\n<Listing number=\"14-4\" file-name=\"src/main.rs\" caption=\"Pakiet uÅ¼ywajÄ…cy elementÃ³w pakietu `art` z wyeksportowanÄ… strukturÄ… wewnÄ™trznÄ…\">\n\n```rust,ignore\nuse art::kinds::PrimaryColor;\nuse art::utils::mix;\n\nfn main() {\n    let red = PrimaryColor::Red;\n    let yellow = PrimaryColor::Yellow;\n    mix(red, yellow);\n}\n```\n\n</Listing>\n\nAutor kodu w Listing 14-4, ktÃ³ry uÅ¼ywa pakietu `art`, musiaÅ‚ dowiedzieÄ‡ siÄ™, Å¼e `PrimaryColor` znajduje siÄ™ w module `kinds`, a `mix` w module `utils`. Struktura moduÅ‚Ã³w pakietu `art` jest bardziej istotna dla programistÃ³w pracujÄ…cych nad pakietem `art` niÅ¼ dla tych, ktÃ³rzy go uÅ¼ywajÄ…. WewnÄ™trzna struktura nie zawiera Å¼adnych uÅ¼ytecznych informacji dla kogoÅ› prÃ³bujÄ…cego zrozumieÄ‡, jak uÅ¼ywaÄ‡ pakietu `art`, ale raczej powoduje zamieszanie, poniewaÅ¼ programiÅ›ci, ktÃ³rzy go uÅ¼ywajÄ…, muszÄ… dowiedzieÄ‡ siÄ™, gdzie szukaÄ‡ i muszÄ… okreÅ›laÄ‡ nazwy moduÅ‚Ã³w w instrukcjach `use`.\n\nAby usunÄ…Ä‡ wewnÄ™trznÄ… organizacjÄ™ z publicznego API, moÅ¼emy zmodyfikowaÄ‡ kod pakietu `art` w Listing 14-3, aby dodaÄ‡ instrukcje `pub use` do ponownego eksportu elementÃ³w na najwyÅ¼szym poziomie, jak pokazano w Listing 14-5.\n\n<Listing number=\"14-5\" file-name=\"src/lib.rs\" caption=\"Dodawanie instrukcji `pub use` do ponownego eksportu elementÃ³w\">\n\n```rust,ignore\n//! # Sztuka\n//!\n//! Biblioteka do modelowania koncepcji artystycznych.\n\npub use self::kinds::PrimaryColor;\npub use self::kinds::SecondaryColor;\npub use self::utils::mix;\n\npub mod kinds {\n    // --snip--\n#     /// Kolory podstawowe wedÅ‚ug modelu kolorÃ³w RYB.\n#     pub enum PrimaryColor {\n#         Red,\n#         Yellow,\n#         Blue,\n#     }\n# \n#     /// Kolory wtÃ³rne wedÅ‚ug modelu kolorÃ³w RYB.\n#     pub enum SecondaryColor {\n#         Orange,\n#         Green,\n#         Purple,\n#     }\n}\n\npub mod utils {\n    // --snip--\n#     use crate::kinds::*;\n# \n#     /// ÅÄ…czy dwa kolory podstawowe w rÃ³wnych proporcjach, aby stworzyÄ‡\n#     /// kolor wtÃ³rny.\n#     pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {\n#         SecondaryColor::Orange\n#     }\n}\n```\n\n</Listing>\n\nDokumentacja API wygenerowana przez `cargo doc` dla tego pakietu bÄ™dzie teraz listowaÄ‡ i linkowaÄ‡ ponowne eksporty na stronie gÅ‚Ã³wnej, jak pokazano na Rysunku 14-4, uÅ‚atwiajÄ…c znalezienie typÃ³w `PrimaryColor` i `SecondaryColor` oraz funkcji `mix`.\n\n<img alt=\"Wyrenderowana dokumentacja dla pakietu `art` z ponownymi eksportami na stronie gÅ‚Ã³wnej\" src=\"img/trpl14-04.png\" class=\"center\" />\n\n<span class=\"caption\">Rysunek 14-4: Strona gÅ‚Ã³wna dokumentacji dla `art`, ktÃ³ra zawiera listÄ™ ponownych eksportÃ³w</span>\n\nUÅ¼ytkownicy pakietu `art` nadal mogÄ… przeglÄ…daÄ‡ i uÅ¼ywaÄ‡ wewnÄ™trznej struktury z Listing 14-3, jak zademonstrowano w Listing 14-4, lub mogÄ… uÅ¼ywaÄ‡ bardziej wygodnej struktury z Listing 14-5, jak pokazano w Listing 14-6.\n\n<Listing number=\"14-6\" file-name=\"src/main.rs\" caption=\"Program uÅ¼ywajÄ…cy ponownie wyeksportowanych elementÃ³w z pakietu `art`\">\n\n```rust,ignore\nuse art::PrimaryColor;\nuse art::mix;\n\nfn main() {\n    // --snip--\n#     let red = PrimaryColor::Red;\n#     let yellow = PrimaryColor::Yellow;\n#     mix(red, yellow);\n}\n```\n\n</Listing>\n\nW przypadkach, gdy istnieje wiele zagnieÅ¼dÅ¼onych moduÅ‚Ã³w, ponowne eksportowanie typÃ³w na najwyÅ¼szym poziomie za pomocÄ… `pub use` moÅ¼e znacznie wpÅ‚ynÄ…Ä‡ na doÅ›wiadczenie osÃ³b korzystajÄ…cych z pakietu. Innym czÄ™stym zastosowaniem `pub use` jest ponowne eksportowanie definicji zaleÅ¼noÅ›ci w bieÅ¼Ä…cym pakiecie, aby definicje tego pakietu staÅ‚y siÄ™ czÄ™Å›ciÄ… publicznego API Twojego pakietu.\n\nTworzenie uÅ¼ytecznej struktury publicznego API to bardziej sztuka niÅ¼ nauka, a Ty moÅ¼esz iterowaÄ‡, aby znaleÅºÄ‡ API, ktÃ³re najlepiej pasuje do Twoich uÅ¼ytkownikÃ³w. WybÃ³r `pub use` daje Ci elastycznoÅ›Ä‡ w wewnÄ™trznej strukturze pakietu i oddziela tÄ™ wewnÄ™trznÄ… strukturÄ™ od tego, co prezentujesz uÅ¼ytkownikom. Przyjrzyj siÄ™ kodowi niektÃ³rych zainstalowanych pakietÃ³w, aby sprawdziÄ‡, czy ich wewnÄ™trzna struktura rÃ³Å¼ni siÄ™ od ich publicznego API.\n\n### Konfigurowanie konta Crates.io\n\nZanim bÄ™dziesz mÃ³gÅ‚ publikowaÄ‡ jakiekolwiek pakiety, musisz utworzyÄ‡ konto na [crates.io](https://crates.io/)<!-- ignore --> i uzyskaÄ‡ token API. Aby to zrobiÄ‡, odwiedÅº stronÄ™ gÅ‚Ã³wnÄ… [crates.io](https://crates.io/)<!-- ignore --> i zaloguj siÄ™ za pomocÄ… konta GitHub. (Konto GitHub jest obecnie wymagane, ale witryna moÅ¼e w przyszÅ‚oÅ›ci obsÅ‚ugiwaÄ‡ inne sposoby tworzenia konta.) Po zalogowaniu odwiedÅº ustawienia swojego konta pod adresem [https://crates.io/me/](https://crates.io/me/)<!-- ignore --> i pobierz swÃ³j klucz API. NastÄ™pnie uruchom polecenie `cargo login` i wklej swÃ³j klucz API po wyÅ›wietleniu monitu, w nastÄ™pujÄ…cy sposÃ³b:\n\n```console\n$ cargo login\nabcdefghijklmnopqrstuvwxyz012345\n```\n\nTo polecenie poinformuje Cargo o Twoim tokenie API i zapisze go lokalnie w _~/.cargo/credentials.toml_. ZauwaÅ¼, Å¼e ten token jest tajny: nie udostÄ™pniaj go nikomu. JeÅ›li z jakiegoÅ› powodu go udostÄ™pnisz, powinieneÅ› go uniewaÅ¼niÄ‡ i wygenerowaÄ‡ nowy token na [crates.io](https://crates.io/)<!-- ignore -->.\n\n### Dodawanie metadanych do nowego pakietu\n\nPowiedzmy, Å¼e masz pakiet, ktÃ³ry chcesz opublikowaÄ‡. Przed publikacjÄ… musisz dodaÄ‡ kilka metadanych w sekcji `[package]` pliku _Cargo.toml_ pakietu.\n\nTwÃ³j pakiet bÄ™dzie potrzebowaÅ‚ unikalnej nazwy. Podczas pracy nad pakietem lokalnie, moÅ¼esz nazwaÄ‡ pakiet jak chcesz. Jednak nazwy pakietÃ³w na [crates.io](https://crates.io/)<!-- ignore --> sÄ… przydzielane na zasadzie â€kto pierwszy, ten lepszyâ€. Gdy nazwa pakietu zostanie zajÄ™ta, nikt inny nie moÅ¼e opublikowaÄ‡ pakietu o tej nazwie. Przed prÃ³bÄ… publikacji pakietu, wyszukaj nazwÄ™, ktÃ³rej chcesz uÅ¼yÄ‡. JeÅ›li nazwa zostaÅ‚a uÅ¼yta, bÄ™dziesz musiaÅ‚ znaleÅºÄ‡ innÄ… nazwÄ™ i edytowaÄ‡ pole `name` w pliku _Cargo.toml_ w sekcji `[package]`, aby uÅ¼yÄ‡ nowej nazwy do publikacji, w nastÄ™pujÄ…cy sposÃ³b:\n\n<span class=\"filename\">Nazwa pliku: Cargo.toml</span>\n\n```toml\n[package]\nname = \"guessing_game\"\n```\n\nNawet jeÅ›li wybraÅ‚eÅ› unikalnÄ… nazwÄ™, kiedy uruchomisz `cargo publish`, aby opublikowaÄ‡ pakiet w tym momencie, otrzymasz ostrzeÅ¼enie, a nastÄ™pnie bÅ‚Ä…d:\n\n<!-- manual-regeneration\nCreate a new package with an unregistered name, making no further modifications\n  to the generated package, so it is missing the description and license fields.\ncargo publish\ncopy just the relevant lines below\n-->\n\n```console\n$ cargo publish\n    Aktualizowanie indeksu crates.io\nwarning: manifest nie ma opisu, licencji, pliku licencyjnego, dokumentacji, strony gÅ‚Ã³wnej lub repozytorium.\nZobacz https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata aby uzyskaÄ‡ wiÄ™cej informacji.\n--snip--\nerror: nie udaÅ‚o siÄ™ opublikowaÄ‡ w rejestrze pod adresem https://crates.io\n\nSpowodowane przez:\n  zdalny serwer odpowiedziaÅ‚ bÅ‚Ä™dem (status 400 Bad Request): brakujÄ…ce lub puste pola metadanych: description, license. Zobacz https://doc.rust-lang.org/cargo/reference/manifest.html, aby uzyskaÄ‡ wiÄ™cej informacji na temat konfiguracji tych pÃ³l\n```\n\nProwadzi to do bÅ‚Ä™du, poniewaÅ¼ brakuje Ci pewnych kluczowych informacji: opis i licencja sÄ… wymagane, aby ludzie wiedzieli, co robi TwÃ³j pakiet i na jakich warunkach mogÄ… go uÅ¼ywaÄ‡. W _Cargo.toml_ dodaj opis skÅ‚adajÄ…cy siÄ™ z jednego lub dwÃ³ch zdaÅ„, poniewaÅ¼ bÄ™dzie on wyÅ›wietlany wraz z Twoim pakietem w wynikach wyszukiwania. Dla pola `license` musisz podaÄ‡ _wartoÅ›Ä‡ identyfikatora licencji_. [Software Package Data Exchange (SPDX) Fundacji Linuksa][spdx] wymienia identyfikatory, ktÃ³rych moÅ¼esz uÅ¼yÄ‡ dla tej wartoÅ›ci. Na przykÅ‚ad, aby okreÅ›liÄ‡, Å¼e licencjonowaÅ‚eÅ› swÃ³j pakiet za pomocÄ… licencji MIT, dodaj identyfikator `MIT`:\n\n<span class=\"filename\">Nazwa pliku: Cargo.toml</span>\n\n```toml\n[package]\nname = \"guessing_game\"\nlicense = \"MIT\"\n```\n\nJeÅ›li chcesz uÅ¼yÄ‡ licencji, ktÃ³ra nie pojawia siÄ™ w SPDX, musisz umieÅ›ciÄ‡ tekst tej licencji w pliku, doÅ‚Ä…czyÄ‡ ten plik do swojego projektu, a nastÄ™pnie uÅ¼yÄ‡ `license-file`, aby okreÅ›liÄ‡ nazwÄ™ tego pliku zamiast uÅ¼ywania klucza `license`.\n\nPorady dotyczÄ…ce wyboru odpowiedniej licencji dla Twojego projektu wykraczajÄ… poza zakres tej ksiÄ…Å¼ki. Wiele osÃ³b w spoÅ‚ecznoÅ›ci Rusta licencjonuje swoje projekty w ten sam sposÃ³b co Rust, uÅ¼ywajÄ…c podwÃ³jnej licencji `MIT OR Apache-2.0`. Ta praktyka pokazuje, Å¼e moÅ¼esz rÃ³wnieÅ¼ okreÅ›liÄ‡ wiele identyfikatorÃ³w licencji oddzielonych `OR`, aby mieÄ‡ wiele licencji dla swojego projektu.\n\nPo dodaniu unikalnej nazwy, wersji, opisu i licencji, plik _Cargo.toml_ dla projektu gotowego do publikacji moÅ¼e wyglÄ…daÄ‡ nastÄ™pujÄ…co:\n\n<span class=\"filename\">Nazwa pliku: Cargo.toml</span>\n\n```toml\n[package]\nname = \"guessing_game\"\nversion = \"0.1.0\"\nedition = \"2024\"\ndescription = \"Ciekawa gra, w ktÃ³rej zgadujesz liczbÄ™ wybranÄ… przez komputer.\"\nlicense = \"MIT OR Apache-2.0\"\n\n[dependencies]\n```\n\n[Dokumentacja Cargo](https://doc.rust-lang.org/cargo/) opisuje inne metadane, ktÃ³re moÅ¼na okreÅ›liÄ‡, aby inni mogli Å‚atwiej odkryÄ‡ i uÅ¼ywaÄ‡ Twojego pakietu.\n\n### Publikowanie na Crates.io\n\nTeraz, gdy utworzyÅ‚eÅ› konto, zapisaÅ‚eÅ› swÃ³j token API, wybraÅ‚eÅ› nazwÄ™ dla swojego pakietu i okreÅ›liÅ‚eÅ› wymagane metadane, jesteÅ› gotowy do publikacji! Publikowanie pakietu przesyÅ‚a konkretnÄ… wersjÄ™ do [crates.io](https://crates.io/)<!-- ignore -->, aby inni mogli z niej korzystaÄ‡.\n\nBÄ…dÅº ostroÅ¼ny, poniewaÅ¼ publikacja jest _trwaÅ‚a_. Wersja nigdy nie moÅ¼e zostaÄ‡ nadpisana, a kod nie moÅ¼e zostaÄ‡ usuniÄ™ty, z wyjÄ…tkiem pewnych okolicznoÅ›ci. Jednym z gÅ‚Ã³wnych celÃ³w Crates.io jest peÅ‚nienie funkcji staÅ‚ego archiwum kodu, tak aby kompilacje wszystkich projektÃ³w, ktÃ³re zaleÅ¼Ä… od pakietÃ³w z [crates.io](https://crates.io/)<!-- ignore -->, nadal dziaÅ‚aÅ‚y. Dopuszczenie usuwania wersji uniemoÅ¼liwiÅ‚oby osiÄ…gniÄ™cie tego celu. Nie ma jednak limitu liczby wersji pakietÃ³w, ktÃ³re moÅ¼esz opublikowaÄ‡.\n\nUruchom ponownie polecenie `cargo publish`. Powinno siÄ™ teraz udaÄ‡:\n\n<!-- manual-regeneration\ngo to some valid crate, publish a new version\ncargo publish\ncopy just the relevant lines below\n-->\n\n```console\n$ cargo publish\n    Aktualizowanie indeksu crates.io\n   Pakowanie guessing_game v0.1.0 (file:///projects/guessing_game)\n    Spakowano 6 plikÃ³w, 1.2KiB (895.0B skompresowanych)\n   Weryfikowanie guessing_game v0.1.0 (file:///projects/guessing_game)\n   Kompilowanie guessing_game v0.1.0\n(file:///projects/guessing_game/target/package/guessing_game-0.1.0)\n    ZakoÅ„czono `dev` profil [unoptimized + debuginfo] cel(e) w 0.19s\n   PrzesyÅ‚anie guessing_game v0.1.0 (file:///projects/guessing_game)\n    PrzesÅ‚ano guessing_game v0.1.0 do rejestru `crates-io`\nnote: oczekiwanie na dostÄ™pnoÅ›Ä‡ `guessing_game v0.1.0` w rejestrze\n`crates-io`. MoÅ¼esz nacisnÄ…Ä‡ ctrl-c, aby pominÄ…Ä‡ oczekiwanie; pakiet powinien byÄ‡ dostÄ™pny wkrÃ³tce.\n   Opublikowano guessing_game v0.1.0 w rejestrze `crates-io`\n```\n\nGratulacje! UdostÄ™pniÅ‚eÅ› swÃ³j kod spoÅ‚ecznoÅ›ci Rusta, a kaÅ¼dy moÅ¼e Å‚atwo dodaÄ‡ TwÃ³j pakiet jako zaleÅ¼noÅ›Ä‡ swojego projektu.\n\n### Publikowanie nowej wersji istniejÄ…cego pakietu\n\nKiedy wprowadzisz zmiany w swoim pakiecie i bÄ™dziesz gotowy do wydania nowej wersji, zmieniasz wartoÅ›Ä‡ `version` okreÅ›lonÄ… w pliku _Cargo.toml_ i publikujesz ponownie. UÅ¼yj [zasad Semantycznego Wersjonowania][semver], aby zdecydowaÄ‡, jaki jest odpowiedni numer nastÄ™pnej wersji, w oparciu o rodzaj wprowadzonych zmian. NastÄ™pnie uruchom `cargo publish`, aby przesÅ‚aÄ‡ nowÄ… wersjÄ™.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"removing-versions-from-cratesio-with-cargo-yank\"></a>\n<a id=\"deprecating-versions-from-cratesio-with-cargo-yank\"></a>\n\n### Wycofywanie wersji z Crates.io\n\nChociaÅ¼ nie moÅ¼esz usuwaÄ‡ poprzednich wersji pakietu, moÅ¼esz uniemoÅ¼liwiÄ‡ przyszÅ‚ym projektom dodawanie ich jako nowych zaleÅ¼noÅ›ci. Jest to przydatne, gdy wersja pakietu jest zepsuta z jakiegoÅ› powodu. W takich sytuacjach Cargo obsÅ‚uguje wycofanie wersji pakietu.\n\n_Wycofanie_ wersji zapobiega zaleÅ¼noÅ›ciom nowych projektÃ³w od tej wersji, jednoczeÅ›nie umoÅ¼liwiajÄ…c wszystkim istniejÄ…cym projektom, ktÃ³re sÄ… od niej zaleÅ¼ne, dalsze dziaÅ‚anie. Zasadniczo, wycofanie oznacza, Å¼e wszystkie projekty z plikiem _Cargo.lock_ nie zostanÄ… zepsute, a Å¼adne przyszÅ‚e pliki _Cargo.lock_ nie bÄ™dÄ… uÅ¼ywaÄ‡ wycofanej wersji.\n\nAby wycofaÄ‡ wersjÄ™ pakietu, w katalogu pakietu, ktÃ³ry wczeÅ›niej opublikowaÅ‚eÅ›, uruchom `cargo yank` i okreÅ›l, ktÃ³rÄ… wersjÄ™ chcesz wycofaÄ‡. Na przykÅ‚ad, jeÅ›li opublikowaliÅ›my pakiet o nazwie `guessing_game` w wersji 1.0.1 i chcemy go wycofaÄ‡, uruchomimy nastÄ™pujÄ…ce polecenie w katalogu projektu `guessing_game`:\n\n<!-- manual-regeneration:\ncargo yank carol-test --version 2.1.0\ncargo yank carol-test --version 2.1.0 --undo\n-->\n\n```console\n$ cargo yank --vers 1.0.1\n    Aktualizowanie indeksu crates.io\n        WycofujÄ™ guessing_game@1.0.1\n```\n\nDodajÄ…c `--undo` do polecenia, moÅ¼esz rÃ³wnieÅ¼ cofnÄ…Ä‡ wycofanie i ponownie zezwoliÄ‡ projektom na zaleÅ¼noÅ›Ä‡ od danej wersji:\n\n```console\n$ cargo yank --vers 1.0.1 --undo\n    Aktualizowanie indeksu crates.io\n      Przywracam guessing_game@1.0.1\n```\n\nWycofanie _nie_ usuwa Å¼adnego kodu. Nie moÅ¼e na przykÅ‚ad usunÄ…Ä‡ przypadkowo przesÅ‚anych sekretÃ³w. JeÅ›li tak siÄ™ stanie, musisz natychmiast zresetowaÄ‡ te sekrety.\n\n[spdx]: https://spdx.org/licenses/\n[semver]: https://semver.org/",
        "chapter_title": "Publikowanie pakietu na Crates.io"
    },
    {
        "file_path": "ch14-03-cargo-workspaces.md",
        "content": "## Obszary robocze Cargo\n\nW Rozdziale 12 zbudowaliÅ›my pakiet, ktÃ³ry zawieraÅ‚ binarny crate i biblioteczny crate. W miarÄ™ rozwoju projektu moÅ¼e siÄ™ okazaÄ‡, Å¼e biblioteczny crate staje siÄ™ coraz wiÄ™kszy i chcesz podzieliÄ‡ swÃ³j pakiet na wiele bibliotecznych crate'Ã³w. Cargo oferuje funkcjÄ™ o nazwie _workspaces_ (obszary robocze), ktÃ³ra moÅ¼e pomÃ³c w zarzÄ…dzaniu wieloma powiÄ…zanymi pakietami, ktÃ³re sÄ… rozwijane rÃ³wnoczeÅ›nie.\n\n### Tworzenie obszaru roboczego\n\n_Obszar roboczy_ to zestaw pakietÃ³w, ktÃ³re wspÃ³Å‚dzielÄ… ten sam plik _Cargo.lock_ i katalog wyjÅ›ciowy. StwÃ³rzmy projekt z wykorzystaniem obszaru roboczego â€” uÅ¼yjemy trywialnego kodu, abyÅ›my mogli skupiÄ‡ siÄ™ na strukturze obszaru roboczego. Istnieje wiele sposobÃ³w na strukturÄ™ obszaru roboczego, wiÄ™c pokaÅ¼emy tylko jeden powszechny. BÄ™dziemy mieÄ‡ obszar roboczy zawierajÄ…cy binarny pakiet i dwie biblioteki. Binarny pakiet, ktÃ³ry zapewni gÅ‚Ã³wnÄ… funkcjonalnoÅ›Ä‡, bÄ™dzie zaleÅ¼aÅ‚ od dwÃ³ch bibliotek. Jedna biblioteka zapewni funkcjÄ™ `add_one`, a druga biblioteka funkcjÄ™ `add_two`. Te trzy pakiety bÄ™dÄ… czÄ™Å›ciÄ… tego samego obszaru roboczego. Zaczniemy od utworzenia nowego katalogu dla obszaru roboczego:\n\n```console\n$ mkdir add\n$ cd add\n```\n\nNastÄ™pnie, w katalogu _add_, tworzymy plik _Cargo.toml_, ktÃ³ry skonfiguruje caÅ‚y obszar roboczy. Ten plik nie bÄ™dzie miaÅ‚ sekcji `[package]`. Zamiast tego, zacznie siÄ™ od sekcji `[workspace]`, ktÃ³ra pozwoli nam dodawaÄ‡ czÅ‚onkÃ³w do obszaru roboczego. Zwracamy rÃ³wnieÅ¼ uwagÄ™ na uÅ¼ycie najnowszej i najlepszej wersji algorytmu resolvera Cargo w naszym obszarze roboczym, ustawiajÄ…c wartoÅ›Ä‡ `resolver` na `\"3\"`:\n\n<span class=\"filename\">Nazwa pliku: Cargo.toml</span>\n\n```toml\n[workspace]\nresolver = \"3\"\n```\n\nNastÄ™pnie utworzymy binarny pakiet `adder` poprzez uruchomienie `cargo new` w katalogu _add_:\n\n<!-- manual-regeneration\ncd listings/ch14-more-about-cargo/output-only-01-adder-crate/add\nremove `members = [\"adder\"]` from Cargo.toml\nrm -rf adder\ncargo new adder\ncopy output below\n-->\n\n```console\n$ cargo new adder\n     Utworzono pakiet binarny (aplikacja) `adder`\n      Dodawanie `adder` jako czÅ‚onka obszaru roboczego pod `file:///projects/add`\n```\n\nUruchomienie `cargo new` wewnÄ…trz obszaru roboczego automatycznie dodaje nowo utworzony pakiet do klucza `members` w definicji `[workspace]` w pliku _Cargo.toml_ obszaru roboczego, w nastÄ™pujÄ…cy sposÃ³b:\n\n```toml\n[workspace]\nresolver = \"3\"\nmembers = [\"adder\"]\n```\n\nW tym momencie moÅ¼emy zbudowaÄ‡ obszar roboczy, uruchamiajÄ…c `cargo build`. Pliki w katalogu _add_ powinny wyglÄ…daÄ‡ nastÄ™pujÄ…co:\n\n```text\nâ”œâ”€â”€ Cargo.lock\nâ”œâ”€â”€ Cargo.toml\nâ”œâ”€â”€ adder\nâ”‚   â”œâ”€â”€ Cargo.toml\nâ”‚   â””â”€â”€ src\nâ”‚       â””â”€â”€ main.rs\nâ””â”€â”€ target\n```\n\nObszar roboczy posiada jeden katalog _target_ na najwyÅ¼szym poziomie, do ktÃ³rego zostanÄ… umieszczone skompilowane artefakty; pakiet `adder` nie ma wÅ‚asnego katalogu _target_. Nawet gdybyÅ›my uruchomili `cargo build` z wnÄ™trza katalogu _adder_, skompilowane artefakty nadal znalazÅ‚yby siÄ™ w _add/target_, a nie _add/adder/target_. Cargo strukturyzuje katalog _target_ w obszarze roboczym w ten sposÃ³b, poniewaÅ¼ pakiety w obszarze roboczym majÄ… od siebie zaleÅ¼eÄ‡. Gdyby kaÅ¼dy pakiet miaÅ‚ wÅ‚asny katalog _target_, kaÅ¼dy pakiet musiaÅ‚by rekompilowaÄ‡ kaÅ¼dy z pozostaÅ‚ych pakietÃ³w w obszarze roboczym, aby umieÅ›ciÄ‡ artefakty w swoim wÅ‚asnym katalogu _target_. DziÄ™ki wspÃ³Å‚dzieleniu jednego katalogu _target_ pakiety mogÄ… uniknÄ…Ä‡ niepotrzebnej ponownej kompilacji.\n\n### Tworzenie drugiego pakietu w obszarze roboczym\n\nNastÄ™pnie stwÃ³rzmy kolejny pakiet czÅ‚onkowski w obszarze roboczym i nazwijmy go `add_one`. Wygeneruj nowy pakiet biblioteczny o nazwie `add_one`:\n\n<!-- manual-regeneration\ncd listings/ch14-more-about-cargo/output-only-02-add-one/add\nremove `\"add_one\"` from `members` list in Cargo.toml\nrm -rf add_one\ncargo new add_one --lib\ncopy output below\n-->\n\n```console\n$ cargo new add_one --lib\n     Utworzono bibliotekÄ™ `add_one`\n      Dodawanie `add_one` jako czÅ‚onka obszaru roboczego pod `file:///projects/add`\n```\n\nPlik _Cargo.toml_ na najwyÅ¼szym poziomie bÄ™dzie teraz zawieraÅ‚ Å›cieÅ¼kÄ™ _add_one_ na liÅ›cie `members`:\n\n<span class=\"filename\">Nazwa pliku: Cargo.toml</span>\n\n```toml\n[workspace]\nresolver = \"3\"\nmembers = [\"adder\", \"add_one\"]\n```\n\nTwÃ³j katalog _add_ powinien teraz zawieraÄ‡ nastÄ™pujÄ…ce katalogi i pliki:\n\n```text\nâ”œâ”€â”€ Cargo.lock\nâ”œâ”€â”€ Cargo.toml\nâ”œâ”€â”€ add_one\nâ”‚   â”œâ”€â”€ Cargo.toml\nâ”‚   â””â”€â”€ src\nâ”‚       â””â”€â”€ lib.rs\nâ”œâ”€â”€ adder\nâ”‚   â”œâ”€â”€ Cargo.toml\nâ”‚   â””â”€â”€ src\nâ”‚       â””â”€â”€ main.rs\nâ””â”€â”€ target\n```\n\nW pliku _add_one/src/lib.rs_ dodajmy funkcjÄ™ `add_one`:\n\n<span class=\"filename\">Nazwa pliku: add_one/src/lib.rs</span>\n\n```rust,noplayground\npub fn add_one(x: i32) -> i32 {\n    x + 1\n}\n```\n\nTeraz pakiet `adder` z naszym plikiem binarnym moÅ¼e zaleÅ¼eÄ‡ od pakietu `add_one`, ktÃ³ry zawiera naszÄ… bibliotekÄ™. Najpierw bÄ™dziemy musieli dodaÄ‡ zaleÅ¼noÅ›Ä‡ Å›cieÅ¼kowÄ… do `add_one` do pliku _adder/Cargo.toml_.\n\n<span class=\"filename\">Nazwa pliku: adder/Cargo.toml</span>\n\n```toml\n[dependencies]\nadd_one = { path = \"../add_one\" }\n```\n\nCargo nie zakÅ‚ada, Å¼e pakiety w obszarze roboczym bÄ™dÄ… od siebie zaleÅ¼eÄ‡, wiÄ™c musimy jawnie okreÅ›liÄ‡ relacje zaleÅ¼noÅ›ci.\n\nNastÄ™pnie, uÅ¼yjmy funkcji `add_one` (z pakietu `add_one`) w pakiecie `adder`. OtwÃ³rz plik _adder/src/main.rs_ i zmieÅ„ funkcjÄ™ `main`, aby wywoÅ‚ywaÅ‚a funkcjÄ™ `add_one`, jak w Listing 14-7.\n\n<Listing number=\"14-7\" file-name=\"adder/src/main.rs\" caption=\"UÅ¼ywanie biblioteki `add_one` z pakietu `adder`\">\n\n```rust,ignore\nfn main() {\n    let num = 10;\n    println!(\"Witaj, Å›wiecie! {num} plus jeden to {}!\", add_one::add_one(num));\n}\n```\n\n</Listing>\n\nZbudujmy obszar roboczy, uruchamiajÄ…c `cargo build` w katalogu _add_ na najwyÅ¼szym poziomie!\n\n<!-- manual-regeneration\ncd listings/ch14-more-about-cargo/listing-14-07/add\ncargo build\ncopy output below; the output updating script doesn't handle subdirectories in paths properly\n-->\n\n```console\n$ cargo build\n   Kompilowanie add_one v0.1.0 (file:///projects/add/add_one)\n   Kompilowanie adder v0.1.0 (file:///projects/add/adder)\n    ZakoÅ„czono `dev` profil [unoptimized + debuginfo] cel(e) w 0.22s\n```\n\nAby uruchomiÄ‡ binarny pakiet z katalogu _add_, moÅ¼emy okreÅ›liÄ‡, ktÃ³ry pakiet w obszarze roboczym chcemy uruchomiÄ‡, uÅ¼ywajÄ…c argumentu `-p` i nazwy pakietu z `cargo run`:\n\n<!-- manual-regeneration\ncd listings/ch14-more-about-cargo/listing-14-07/add\ncargo run -p adder\ncopy output below; the output updating script doesn't handle subdirectories in paths properly\n-->\n\n```console\n$ cargo run -p adder\n    ZakoÅ„czono `dev` profil [unoptimized + debuginfo] cel(e) w 0.00s\n     Uruchamianie `target/debug/adder`\nWitaj, Å›wiecie! 10 plus jeden to 11!\n```\n\nTo uruchamia kod z _adder/src/main.rs_, ktÃ³ry zaleÅ¼y od pakietu `add_one`.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"depending-on-an-external-package-in-a-workspace\"></a>\n\n### ZaleÅ¼noÅ›Ä‡ od zewnÄ™trznego pakietu\n\nZauwaÅ¼, Å¼e obszar roboczy ma tylko jeden plik _Cargo.lock_ na najwyÅ¼szym poziomie, zamiast mieÄ‡ plik _Cargo.lock_ w katalogu kaÅ¼dego pakietu. To zapewnia, Å¼e wszystkie pakiety uÅ¼ywajÄ… tej samej wersji wszystkich zaleÅ¼noÅ›ci. JeÅ›li dodamy pakiet `rand` do plikÃ³w _adder/Cargo.toml_ i _add_one/Cargo.toml_, Cargo rozwiÄ…Å¼e oba do jednej wersji `rand` i zapisze to w jednym pliku _Cargo.lock_. Sprawienie, by wszystkie pakiety w obszarze roboczym uÅ¼ywaÅ‚y tych samych zaleÅ¼noÅ›ci, oznacza, Å¼e pakiety zawsze bÄ™dÄ… ze sobÄ… kompatybilne. Dodajmy pakiet `rand` do sekcji `[dependencies]` w pliku _add_one/Cargo.toml_, abyÅ›my mogli uÅ¼ywaÄ‡ pakietu `rand` w pakiecie `add_one`:\n\n<!-- When updating the version of `rand` used, also update the version of\n`rand` used in these files so they all match:\n* ch02-00-guessing-game-tutorial.md\n* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md\n-->\n\n<span class=\"filename\">Nazwa pliku: add_one/Cargo.toml</span>\n\n```toml\n[dependencies]\nrand = \"0.8.5\"\n```\n\nMoÅ¼emy teraz dodaÄ‡ `use rand;` do pliku _add_one/src/lib.rs_, a zbudowanie caÅ‚ego obszaru roboczego przez uruchomienie `cargo build` w katalogu _add_ spowoduje zaimportowanie i skompilowanie pakietu `rand`. Otrzymamy jedno ostrzeÅ¼enie, poniewaÅ¼ nie odwoÅ‚ujemy siÄ™ do `rand`, ktÃ³re wprowadziliÅ›my do zakresu:\n\n<!-- manual-regeneration\ncd listings/ch14-more-about-cargo/no-listing-03-workspace-with-external-dependency/add\ncargo build\ncopy output below; the output updating script doesn't handle subdirectories in paths properly\n-->\n\n```console\n$ cargo build\n    Aktualizowanie indeksu crates.io\n  Pobrano rand v0.8.5\n   --snip--\n   Kompilowanie rand v0.8.5\n   Kompilowanie add_one v0.1.0 (file:///projects/add/add_one)\nwarning: nieuÅ¼ywany import: `rand`\n --> add_one/src/lib.rs:1:5\n  |\n1 | use rand;\n  |     ^^^^\n  |\n  = note: `#[warn(unused_imports)]` domyÅ›lnie wÅ‚Ä…czone\n\nwarning: `add_one` (lib) wygenerowaÅ‚ 1 ostrzeÅ¼enie (uruchom `cargo fix --lib -p add_one`, aby zastosowaÄ‡ 1 sugestiÄ™)\n   Kompilowanie adder v0.1.0 (file:///projects/add/adder)\n    ZakoÅ„czono `dev` profil [unoptimized + debuginfo] cel(e) w 0.95s\n```\n\nPlik _Cargo.lock_ na najwyÅ¼szym poziomie zawiera teraz informacje o zaleÅ¼noÅ›ci `add_one` od `rand`. JednakÅ¼e, mimo Å¼e `rand` jest uÅ¼ywane gdzieÅ› w obszarze roboczym, nie moÅ¼emy go uÅ¼ywaÄ‡ w innych pakietach w obszarze roboczym, chyba Å¼e dodamy `rand` rÃ³wnieÅ¼ do ich plikÃ³w _Cargo.toml_. Na przykÅ‚ad, jeÅ›li dodamy `use rand;` do pliku _adder/src/main.rs_ dla pakietu `adder`, otrzymamy bÅ‚Ä…d:\n\n<!-- manual-regeneration\ncd listings/ch14-more-about-cargo/output-only-03-use-rand/add\ncargo build\ncopy output below; the output updating script doesn't handle subdirectories in paths properly\n-->\n\n```console\n$ cargo build\n  --snip--\n   Kompilowanie adder v0.1.0 (file:///projects/add/adder)\nerror[E0432]: nierozwiÄ…zany import `rand`\n --> adder/src/main.rs:2:5\n  |\n2 | use rand;\n  |     ^^^^ brak zewnÄ™trznego pakietu `rand`\n```\n\nAby to naprawiÄ‡, edytuj plik _Cargo.toml_ pakietu `adder` i wskaÅ¼, Å¼e `rand` jest rÃ³wnieÅ¼ jego zaleÅ¼noÅ›ciÄ…. Budowanie pakietu `adder` doda `rand` do listy zaleÅ¼noÅ›ci dla `adder` w _Cargo.lock_, ale nie zostanÄ… pobrane Å¼adne dodatkowe kopie `rand`. Cargo zapewni, Å¼e kaÅ¼dy pakiet w obszarze roboczym uÅ¼ywajÄ…cy pakietu `rand` bÄ™dzie uÅ¼ywaÅ‚ tej samej wersji, o ile okreÅ›lÄ… kompatybilne wersje `rand`, oszczÄ™dzajÄ…c nam miejsce i zapewniajÄ…c, Å¼e pakiety w obszarze roboczym bÄ™dÄ… ze sobÄ… kompatybilne.\n\nJeÅ›li pakiety w obszarze roboczym okreÅ›lajÄ… niekompatybilne wersje tej samej zaleÅ¼noÅ›ci, Cargo rozwiÄ…Å¼e kaÅ¼dÄ… z nich, ale nadal bÄ™dzie staraÅ‚o siÄ™ rozwiÄ…zaÄ‡ jak najmniej wersji.\n\n### Dodawanie testu do obszaru roboczego\n\nDla kolejnego ulepszenia, dodajmy test funkcji `add_one::add_one` w pakiecie `add_one`:\n\n<span class=\"filename\">Nazwa pliku: add_one/src/lib.rs</span>\n\n```rust,noplayground\npub fn add_one(x: i32) -> i32 {\n    x + 1\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_works() {\n        assert_eq!(3, add_one(2));\n    }\n}\n```\n\nTeraz uruchom `cargo test` w katalogu _add_ najwyÅ¼szego poziomu. Uruchomienie `cargo test` w tak skonstruowanym obszarze roboczym uruchomi testy dla wszystkich pakietÃ³w w obszarze roboczym:\n\n<!-- manual-regeneration\ncd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add\ncargo test\ncopy output below; the output updating script doesn't handle subdirectories in\npaths properly\n-->\n\n```console\n$ cargo test\n   Kompilowanie add_one v0.1.0 (file:///projects/add/add_one)\n   Kompilowanie adder v0.1.0 (file:///projects/add/adder)\n    ZakoÅ„czono `test` profil [unoptimized + debuginfo] cel(e) w 0.20s\n     Uruchamianie unittests src/lib.rs (target/debug/deps/add_one-93c49ee75dc46543)\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Uruchamianie unittests src/main.rs (target/debug/deps/adder-3a47283c568d2b6a)\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests add_one\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n```\n\nPierwsza sekcja wyjÅ›cia pokazuje, Å¼e test `it_works` w pakiecie `add_one` przeszedÅ‚. NastÄ™pna sekcja pokazuje, Å¼e w pakiecie `adder` nie znaleziono Å¼adnych testÃ³w, a nastÄ™pnie ostatnia sekcja pokazuje, Å¼e w pakiecie `add_one` nie znaleziono Å¼adnych testÃ³w dokumentacji.\n\nMoÅ¼emy rÃ³wnieÅ¼ uruchomiÄ‡ testy dla jednego konkretnego pakietu w obszarze roboczym z katalogu najwyÅ¼szego poziomu, uÅ¼ywajÄ…c flagi `-p` i okreÅ›lajÄ…c nazwÄ™ pakietu, ktÃ³ry chcemy przetestowaÄ‡:\n\n<!-- manual-regeneration\ncd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add\ncargo test -p add_one\ncopy output below; the output updating script doesn't handle subdirectories in paths properly\n-->\n\n```console\n$ cargo test -p add_one\n    ZakoÅ„czono `test` profil [unoptimized + debuginfo] cel(e) w 0.00s\n     Uruchamianie unittests src/lib.rs (target/debug/deps/add_one-93c49ee75dc46543)\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests add_one\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n```\n\nTo wyjÅ›cie pokazuje, Å¼e `cargo test` uruchomiÅ‚ tylko testy dla pakietu `add_one` i nie uruchomiÅ‚ testÃ³w pakietu `adder`.\n\nJeÅ›li opublikujesz pakiety w obszarze roboczym na [crates.io](https://crates.io/)<!-- ignore -->, kaÅ¼dy pakiet w obszarze roboczym bÄ™dzie musiaÅ‚ zostaÄ‡ opublikowany osobno. Podobnie jak `cargo test`, moÅ¼emy opublikowaÄ‡ konkretny pakiet w naszym obszarze roboczym, uÅ¼ywajÄ…c flagi `-p` i okreÅ›lajÄ…c nazwÄ™ pakietu, ktÃ³ry chcemy opublikowaÄ‡.\n\nDodatkowo, sprÃ³buj dodaÄ‡ pakiet `add_two` do tego obszaru roboczego w podobny sposÃ³b jak pakiet `add_one`!\n\nW miarÄ™ wzrostu projektu rozwaÅ¼ uÅ¼ycie obszaru roboczego: pozwala on na pracÄ™ z mniejszymi, Å‚atwiejszymi do zrozumienia komponentami niÅ¼ jedna duÅ¼a bryÅ‚a kodu. Ponadto, utrzymywanie pakietÃ³w w obszarze roboczym moÅ¼e uÅ‚atwiÄ‡ koordynacjÄ™ miÄ™dzy pakietami, jeÅ›li czÄ™sto sÄ… zmieniane w tym samym czasie.",
        "chapter_title": "Obszary robocze Cargo"
    },
    {
        "file_path": "ch14-04-installing-binaries.md",
        "content": "<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"installing-binaries-from-cratesio-with-cargo-install\"></a>\n\n## Instalowanie binariÃ³w za pomocÄ… `cargo install`\n\nPolecenie `cargo install` pozwala instalowaÄ‡ i uÅ¼ywaÄ‡ lokalnie binarne pakiety. Nie ma ono na celu zastÄ…pienia pakietÃ³w systemowych; ma byÄ‡ wygodnym sposobem dla programistÃ³w Rust na instalowanie narzÄ™dzi, ktÃ³re inni udostÄ™pnili na [crates.io](https://crates.io/)<!-- ignore -->. ZauwaÅ¼, Å¼e moÅ¼esz instalowaÄ‡ tylko pakiety, ktÃ³re majÄ… binarne cele. _Cel binarny_ to uruchamialny program, ktÃ³ry jest tworzony, jeÅ›li pakiet ma plik _src/main.rs_ lub inny plik okreÅ›lony jako binarny, w przeciwieÅ„stwie do celu bibliotecznego, ktÃ³ry nie jest uruchamialny sam w sobie, ale nadaje siÄ™ do wÅ‚Ä…czenia do innych programÃ³w. Zazwyczaj pakiety majÄ… w pliku README informacje o tym, czy dany pakiet jest bibliotekÄ…, ma cel binarny, czy jedno i drugie.\n\nWszystkie pliki binarne zainstalowane za pomocÄ… `cargo install` sÄ… przechowywane w folderze _bin_ katalogu instalacyjnego. JeÅ›li zainstalowaÅ‚eÅ› Rust za pomocÄ… _rustup.rs_ i nie masz Å¼adnych niestandardowych konfiguracji, ten katalog bÄ™dzie *$HOME/.cargo/bin*. Upewnij siÄ™, Å¼e ten katalog znajduje siÄ™ w Twojej zmiennej `$PATH`, aby mÃ³c uruchamiaÄ‡ programy zainstalowane za pomocÄ… `cargo install`.\n\nNa przykÅ‚ad, w Rozdziale 12 wspomnieliÅ›my, Å¼e istnieje implementacja narzÄ™dzia `grep` w Rust o nazwie `ripgrep` do przeszukiwania plikÃ³w. Aby zainstalowaÄ‡ `ripgrep`, moÅ¼emy uruchomiÄ‡ nastÄ™pujÄ…ce polecenie:\n\n<!-- manual-regeneration\ncargo install something you don't have, copy relevant output below\n-->\n\n```console\n$ cargo install ripgrep\n    Aktualizowanie indeksu crates.io\n  Pobrano ripgrep v14.1.1\n  Pobrano 1 pakiet (213.6 KB) w 0.40s\n  Instalowanie ripgrep v14.1.1\n--snip--\n   Kompilowanie grep v0.3.2\n    ZakoÅ„czono `release` profil [optimized + debuginfo] cel(e) w 6.73s\n  Instalowanie ~/.cargo/bin/rg\n   Zainstalowano pakiet `ripgrep v14.1.1` (wykonywalny `rg`)\n```\n\nDruga od koÅ„ca linia wyjÅ›cia pokazuje lokalizacjÄ™ i nazwÄ™ zainstalowanego pliku binarnego, ktÃ³rym w przypadku `ripgrep` jest `rg`. DopÃ³ki katalog instalacyjny znajduje siÄ™ w Twoim `$PATH`, jak wspomniano wczeÅ›niej, moÅ¼esz uruchomiÄ‡ `rg --help` i zaczÄ…Ä‡ uÅ¼ywaÄ‡ szybszego, bardziej â€rustyâ€ narzÄ™dzia do przeszukiwania plikÃ³w!\n",
        "chapter_title": "Instalowanie binariÃ³w za pomocÄ… cargo install"
    },
    {
        "file_path": "ch14-05-extending-cargo.md",
        "content": "## Rozszerzanie Cargo o niestandardowe polecenia\n\nCargo zostaÅ‚o zaprojektowane tak, aby moÅ¼na byÅ‚o je rozszerzaÄ‡ o nowe podpolecenia bez koniecznoÅ›ci modyfikowania. JeÅ›li plik binarny w Twojej `$PATH` ma nazwÄ™ `cargo-coÅ›`, moÅ¼esz uruchomiÄ‡ go tak, jakby byÅ‚ podpoleceniem Cargo, uruchamiajÄ…c `cargo coÅ›`. Niestandardowe polecenia tego typu sÄ… rÃ³wnieÅ¼ wyÅ›wietlane po uruchomieniu `cargo --list`. MoÅ¼liwoÅ›Ä‡ uÅ¼ycia `cargo install` do instalowania rozszerzeÅ„, a nastÄ™pnie uruchamiania ich tak samo jak wbudowanych narzÄ™dzi Cargo, jest bardzo wygodnÄ… zaletÄ… projektu Cargo!\n\n## Podsumowanie\n\nUdostÄ™pnianie kodu za pomocÄ… Cargo i [crates.io](https://crates.io/)<!-- ignore --> jest czÄ™Å›ciÄ… tego, co sprawia, Å¼e ekosystem Rusta jest uÅ¼yteczny do wielu rÃ³Å¼nych zadaÅ„. Standardowa biblioteka Rusta jest maÅ‚a i stabilna, ale pakiety sÄ… Å‚atwe do udostÄ™pniania, uÅ¼ywania i ulepszania w innym tempie niÅ¼ jÄ™zyk. Nie krÄ™puj siÄ™ udostÄ™pniaÄ‡ kodu, ktÃ³ry jest dla Ciebie uÅ¼yteczny, na [crates.io](https://crates.io/)<!-- ignore -->; prawdopodobnie bÄ™dzie on uÅ¼yteczny rÃ³wnieÅ¼ dla kogoÅ› innego!\n",
        "chapter_title": "Rozszerzanie Cargo o niestandardowe polecenia"
    },
    {
        "file_path": "ch15-00-smart-pointers.md",
        "content": "# Inteligentne wskaÅºniki\n\nWskaÅºnik to ogÃ³lne pojÄ™cie dla zmiennej, ktÃ³ra zawiera adres w pamiÄ™ci. Ten adres odwoÅ‚uje siÄ™ do, czyli â€wskazuje naâ€, inne dane. NajczÄ™stszym rodzajem wskaÅºnika w Rust jest referencja, o ktÃ³rej uczyÅ‚eÅ› siÄ™ w Rozdziale 4. Referencje sÄ… wskazywane symbolem `&` i poÅ¼yczajÄ… wartoÅ›Ä‡, na ktÃ³rÄ… wskazujÄ…. Nie majÄ… Å¼adnych specjalnych moÅ¼liwoÅ›ci poza odwoÅ‚ywaniem siÄ™ do danych i nie majÄ… Å¼adnych narzutÃ³w.\n\n_Inteligentne wskaÅºniki_ natomiast to struktury danych, ktÃ³re zachowujÄ… siÄ™ jak wskaÅºnik, ale majÄ… rÃ³wnieÅ¼ dodatkowe metadane i moÅ¼liwoÅ›ci. Koncepcja inteligentnych wskaÅºnikÃ³w nie jest unikalna dla Rusta: inteligentne wskaÅºniki powstaÅ‚y w C++ i istniejÄ… rÃ³wnieÅ¼ w innych jÄ™zykach. Rust posiada rÃ³Å¼norodne inteligentne wskaÅºniki zdefiniowane w standardowej bibliotece, ktÃ³re zapewniajÄ… funkcjonalnoÅ›Ä‡ wykraczajÄ…cÄ… poza tÄ™ zapewnianÄ… przez referencje. Aby zbadaÄ‡ ogÃ³lne pojÄ™cie, przyjrzymy siÄ™ kilku rÃ³Å¼nym przykÅ‚adom inteligentnych wskaÅºnikÃ³w, w tym typowi inteligentnego wskaÅºnika z _licznikiem referencji_. Ten wskaÅºnik umoÅ¼liwia posiadanie wielu wÅ‚aÅ›cicieli danych poprzez Å›ledzenie liczby wÅ‚aÅ›cicieli i, gdy nie ma juÅ¼ wÅ‚aÅ›cicieli, oczyszczanie danych.\n\nW Rust, z jego koncepcjÄ… wÅ‚asnoÅ›ci i poÅ¼yczania, istnieje dodatkowa rÃ³Å¼nica miÄ™dzy referencjami a inteligentnymi wskaÅºnikami: podczas gdy referencje tylko poÅ¼yczajÄ… dane, w wielu przypadkach inteligentne wskaÅºniki _posiadajÄ…_ dane, na ktÃ³re wskazujÄ….\n\nInteligentne wskaÅºniki sÄ… zazwyczaj implementowane za pomocÄ… struktur. W przeciwieÅ„stwie do zwykÅ‚ej struktury, inteligentne wskaÅºniki implementujÄ… cechy `Deref` i `Drop`. Cecha `Deref` pozwala instancji struktury inteligentnego wskaÅºnika zachowywaÄ‡ siÄ™ jak referencja, dziÄ™ki czemu moÅ¼na pisaÄ‡ kod, ktÃ³ry dziaÅ‚a zarÃ³wno z referencjami, jak i inteligentnymi wskaÅºnikami. Cecha `Drop` pozwala dostosowaÄ‡ kod, ktÃ³ry jest uruchamiany, gdy instancja inteligentnego wskaÅºnika wychodzi poza zakres. W tym rozdziale omÃ³wimy obie te cechy i zademonstrujemy, dlaczego sÄ… one waÅ¼ne dla inteligentnych wskaÅºnikÃ³w.\n\nBiorÄ…c pod uwagÄ™, Å¼e wzorzec inteligentnego wskaÅºnika jest ogÃ³lnym wzorcem projektowym czÄ™sto uÅ¼ywanym w Rust, ten rozdziaÅ‚ nie obejmie kaÅ¼dego istniejÄ…cego inteligentnego wskaÅºnika. Wiele bibliotek ma wÅ‚asne inteligentne wskaÅºniki, a nawet moÅ¼esz napisaÄ‡ wÅ‚asny. OmÃ³wimy najbardziej popularne inteligentne wskaÅºniki w standardowej bibliotece:\n\n- `Box<T>`, do alokowania wartoÅ›ci na stercie\n- `Rc<T>`, typ zliczajÄ…cy referencje, ktÃ³ry umoÅ¼liwia wielokrotne posiadanie\n- `Ref<T>` i `RefMut<T>`, dostÄ™pne przez `RefCell<T>`, typ, ktÃ³ry wymusza zasady poÅ¼yczania w czasie dziaÅ‚ania zamiast w czasie kompilacji\n\nPonadto omÃ³wimy wzorzec _wewnÄ™trznej zmiennoÅ›ci_, w ktÃ³rym niezmienny typ udostÄ™pnia API do mutowania wartoÅ›ci wewnÄ™trznej. OmÃ³wimy rÃ³wnieÅ¼ cykle referencji: jak mogÄ… prowadziÄ‡ do wyciekÃ³w pamiÄ™ci i jak im zapobiegaÄ‡.\n\nZaczynajmy!",
        "chapter_title": "Inteligentne wskaÅºniki"
    },
    {
        "file_path": "ch15-02-deref.md",
        "content": "<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"treating-smart-pointers-like-regular-references-with-the-deref-trait\"></a>\n<a id=\"treating-smart-pointers-like-regular-references-with-deref\"></a>\n\n## Traktowanie inteligentnych wskaÅºnikÃ³w jak zwykÅ‚ych referencji\n\nImplementacja cechy `Deref` pozwala dostosowaÄ‡ zachowanie _operatora dereferencji_ `*` (nie myliÄ‡ z operatorem mnoÅ¼enia ani glob). ImplementujÄ…c `Deref` w taki sposÃ³b, Å¼e inteligentny wskaÅºnik moÅ¼e byÄ‡ traktowany jak zwykÅ‚a referencja, moÅ¼esz pisaÄ‡ kod, ktÃ³ry dziaÅ‚a na referencjach i uÅ¼ywaÄ‡ tego kodu rÃ³wnieÅ¼ z inteligentnymi wskaÅºnikami.\n\nNajpierw przyjrzyjmy siÄ™, jak operator dereferencji dziaÅ‚a ze zwykÅ‚ymi referencjami. NastÄ™pnie sprÃ³bujemy zdefiniowaÄ‡ niestandardowy typ, ktÃ³ry zachowuje siÄ™ jak `Box<T>` i zobaczymy, dlaczego operator dereferencji nie dziaÅ‚a jak referencja na naszym nowo zdefiniowanym typie. Zbadamy, jak implementacja cechy `Deref` umoÅ¼liwia inteligentnym wskaÅºnikom dziaÅ‚anie w sposÃ³b podobny do referencji. NastÄ™pnie przyjrzymy siÄ™ funkcji Rust deref coercion i temu, jak pozwala nam ona pracowaÄ‡ zarÃ³wno z referencjami, jak i inteligentnymi wskaÅºnikami.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"following-the-pointer-to-the-value-with-the-dereference-operator\"></a>\n<a id=\"following-the-pointer-to-the-value\"></a>\n\n### PodÄ…Å¼anie za referencjÄ… do wartoÅ›ci za pomocÄ… operatora dereferencji\n\nZwykÅ‚a referencja jest typem wskaÅºnika, a jeden ze sposobÃ³w myÅ›lenia o wskaÅºniku to strzaÅ‚ka do wartoÅ›ci przechowywanej gdzie indziej. W Listing 15-6 tworzymy referencjÄ™ do wartoÅ›ci `i32`, a nastÄ™pnie uÅ¼ywamy operatora dereferencji, aby podÄ…Å¼yÄ‡ za referencjÄ… do wartoÅ›ci.\n\n<Listing number=\"15-6\" file-name=\"src/main.rs\" caption=\"UÅ¼ywanie operatora dereferencji do podÄ…Å¼ania za referencjÄ… do wartoÅ›ci `i32`\">\n\n```rust\nfn main() {\n    let x = 5;\n    let y = &x;\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n```\n\n</Listing>\n\nZmienna `x` przechowuje wartoÅ›Ä‡ `i32` rÃ³wnÄ… `5`. Ustawiamy `y` na referencjÄ™ do `x`. MoÅ¼emy potwierdziÄ‡, Å¼e `x` jest rÃ³wne `5`. Jednak jeÅ›li chcemy sprawdziÄ‡ wartoÅ›Ä‡ w `y`, musimy uÅ¼yÄ‡ `*y`, aby podÄ…Å¼yÄ‡ za referencjÄ… do wartoÅ›ci, na ktÃ³rÄ… wskazuje (stÄ…d _dereferencja_), tak aby kompilator mÃ³gÅ‚ porÃ³wnaÄ‡ rzeczywistÄ… wartoÅ›Ä‡. Po dereferencji `y` mamy dostÄ™p do wartoÅ›ci caÅ‚kowitej, na ktÃ³rÄ… wskazuje `y`, ktÃ³rÄ… moÅ¼emy porÃ³wnaÄ‡ z `5`.\n\nGdybyÅ›my sprÃ³bowali napisaÄ‡ `assert_eq!(5, y);` zamiast tego, otrzymalibyÅ›my nastÄ™pujÄ…cy bÅ‚Ä…d kompilacji:\n\n```console\n$ cargo run\n   Compiling deref-example v0.1.0 (file:///projects/deref-example)\nerror[E0277]: nie moÅ¼na porÃ³wnaÄ‡ `{integer}` z `&{integer}`\n --> src/main.rs:6:5\n  |\n6 |     assert_eq!(5, y);\n  |     ^^^^^^^^^^^^^^^^ brak implementacji dla `{integer} == &{integer}`\n  |\n  = help: cecha `PartialEq<&{integer}>` nie jest zaimplementowana dla `{integer}`\n  = note: ten bÅ‚Ä…d pochodzi z makra `assert_eq` (w kompilacjach Nightly, uruchom z -Z macro-backtrace, aby uzyskaÄ‡ wiÄ™cej informacji)\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: nie udaÅ‚o siÄ™ skompilowaÄ‡ `deref-example` (bin \"deref-example\") z powodu 1 poprzedniego bÅ‚Ä™du\n```\n\nPorÃ³wnywanie liczby i referencji do liczby jest niedozwolone, poniewaÅ¼ sÄ… to rÃ³Å¼ne typy. Musimy uÅ¼yÄ‡ operatora dereferencji, aby podÄ…Å¼yÄ‡ za referencjÄ… do wartoÅ›ci, na ktÃ³rÄ… wskazuje.\n\n### UÅ¼ywanie `Box<T>` jak referencji\n\nMoÅ¼emy przepisaÄ‡ kod z Listing 15-6, aby uÅ¼ywaÅ‚ `Box<T>` zamiast referencji; operator dereferencji uÅ¼yty na `Box<T>` w Listing 15-7 dziaÅ‚a tak samo, jak operator dereferencji uÅ¼yty na referencji w Listing 15-6.\n\n<Listing number=\"15-7\" file-name=\"src/main.rs\" caption=\"UÅ¼ywanie operatora dereferencji na `Box<i32>`\">\n\n```rust\nfn main() {\n    let x = 5;\n    let y = Box::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n```\n\n</Listing>\n\nGÅ‚Ã³wna rÃ³Å¼nica miÄ™dzy Listing 15-7 a Listing 15-6 polega na tym, Å¼e tutaj ustawiamy `y` jako instancjÄ™ pudeÅ‚ka wskazujÄ…cego na skopiowanÄ… wartoÅ›Ä‡ `x`, a nie referencjÄ™ wskazujÄ…cÄ… na wartoÅ›Ä‡ `x`. W ostatniej asercji moÅ¼emy uÅ¼yÄ‡ operatora dereferencji, aby podÄ…Å¼yÄ‡ za wskaÅºnikiem pudeÅ‚ka w ten sam sposÃ³b, w jaki robiliÅ›my to, gdy `y` byÅ‚a referencjÄ…. NastÄ™pnie zbadamy, co jest specjalnego w `Box<T>`, co pozwala nam uÅ¼ywaÄ‡ operatora dereferencji, definiujÄ…c nasz wÅ‚asny typ pudeÅ‚ka.\n\n### Definiowanie naszego wÅ‚asnego inteligentnego wskaÅºnika\n\nZbudujmy typ opakowujÄ…cy podobny do typu `Box<T>` dostarczanego przez standardowÄ… bibliotekÄ™, aby doÅ›wiadczyÄ‡, jak typy inteligentnych wskaÅºnikÃ³w domyÅ›lnie zachowujÄ… siÄ™ inaczej niÅ¼ referencje. NastÄ™pnie przyjrzymy siÄ™, jak dodaÄ‡ moÅ¼liwoÅ›Ä‡ uÅ¼ycia operatora dereferencji.\n\n> Uwaga: Istnieje jedna duÅ¼a rÃ³Å¼nica miÄ™dzy typem `MyBox<T>`, ktÃ³ry zaraz zbudujemy, a prawdziwym `Box<T>`: nasza wersja nie bÄ™dzie przechowywaÄ‡ swoich danych na stercie. W tym przykÅ‚adzie skupiamy siÄ™ na `Deref`, wiÄ™c to, gdzie dane sÄ… faktycznie przechowywane, jest mniej waÅ¼ne niÅ¼ zachowanie podobne do wskaÅºnika.\n\nTyp `Box<T>` jest ostatecznie zdefiniowany jako struktura tuplowa z jednym elementem, wiÄ™c Listing 15-8 definiuje typ `MyBox<T>` w ten sam sposÃ³b. Zdefiniujemy rÃ³wnieÅ¼ funkcjÄ™ `new` pasujÄ…cÄ… do funkcji `new` zdefiniowanej w `Box<T>`.\n\n<Listing number=\"15-8\" file-name=\"src/main.rs\" caption=\"Definiowanie typu `MyBox<T>`\">\n\n```rust\nstruct MyBox<T>(T);\n\nimpl<T> MyBox<T> {\n    fn new(x: T) -> MyBox<T> {\n        MyBox(x)\n    }\n}\n# \n# fn main() {}\n```\n\n</Listing>\n\nDefiniujemy strukturÄ™ o nazwie `MyBox` i deklarujemy parametr generyczny `T`, poniewaÅ¼ chcemy, aby nasz typ przechowywaÅ‚ wartoÅ›ci dowolnego typu. Typ `MyBox` jest strukturÄ… tuplowÄ… z jednym elementem typu `T`. Funkcja `MyBox::new` przyjmuje jeden parametr typu `T` i zwraca instancjÄ™ `MyBox`, ktÃ³ra przechowuje przekazanÄ… wartoÅ›Ä‡.\n\nSprÃ³bujmy dodaÄ‡ funkcjÄ™ `main` z Listing 15-7 do Listing 15-8 i zmieniÄ‡ jÄ… tak, aby uÅ¼ywaÅ‚a zdefiniowanego przez nas typu `MyBox<T>` zamiast `Box<T>`. Kod w Listing 15-9 nie skompiluje siÄ™, poniewaÅ¼ Rust nie wie, jak dereferencyjnie traktowaÄ‡ `MyBox`.\n\n<Listing number=\"15-9\" file-name=\"src/main.rs\" caption=\"PrÃ³ba uÅ¼ycia `MyBox<T>` w ten sam sposÃ³b, w jaki uÅ¼yliÅ›my referencji i `Box<T>`\">\n\n```rust,ignore,does_not_compile\n# struct MyBox<T>(T);\n# \n# impl<T> MyBox<T> {\n#     fn new(x: T) -> MyBox<T> {\n#         MyBox(x)\n#     }\n# }\n# \nfn main() {\n    let x = 5;\n    let y = MyBox::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n```\n\n</Listing>\n\nOto wynikowy bÅ‚Ä…d kompilacji:\n\n```console\n$ cargo run\n   Compiling deref-example v0.1.0 (file:///projects/deref-example)\nerror[E0614]: type `MyBox<{integer}>` cannot be dereferenced\n  --> src/main.rs:14:19\n   |\n14 |     assert_eq!(5, *y);\n   |                   ^^ nie moÅ¼na dereferencyjnie traktowaÄ‡\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: nie udaÅ‚o siÄ™ skompilowaÄ‡ `deref-example` (bin \"deref-example\") z powodu 1 poprzedniego bÅ‚Ä™du\n```\n\nNasz typ `MyBox<T>` nie moÅ¼e zostaÄ‡ dereferencjonowany, poniewaÅ¼ nie zaimplementowaliÅ›my tej moÅ¼liwoÅ›ci dla naszego typu. Aby umoÅ¼liwiÄ‡ dereferencjonowanie za pomocÄ… operatora `*`, implementujemy cechÄ™ `Deref`.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"treating-a-type-like-a-reference-by-implementing-the-deref-trait\"></a>\n\n### Implementacja cechy `Deref`\n\nJak omÃ³wiono w sekcji [â€Implementacja cechy dla typuâ€][impl-trait]<!-- ignore --> w Rozdziale 10, aby zaimplementowaÄ‡ cechÄ™, musimy dostarczyÄ‡ implementacje dla wymaganych metod cechy. Cecha `Deref`, dostarczana przez standardowÄ… bibliotekÄ™, wymaga od nas zaimplementowania jednej metody o nazwie `deref`, ktÃ³ra poÅ¼ycza `self` i zwraca referencjÄ™ do wewnÄ™trznych danych. Listing 15-10 zawiera implementacjÄ™ `Deref` do dodania do definicji `MyBox<T>`.\n\n<Listing number=\"15-10\" file-name=\"src/main.rs\" caption=\"Implementacja `Deref` dla `MyBox<T>`\">\n\n```rust\nuse std::ops::Deref;\n\nimpl<T> Deref for MyBox<T> {\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n# \n# struct MyBox<T>(T);\n# \n# impl<T> MyBox<T> {\n#     fn new(x: T) -> MyBox<T> {\n#         MyBox(x)\n#     }\n# }\n# \n# fn main() {\n#     let x = 5;\n#     let y = MyBox::new(x);\n# \n#     assert_eq!(5, x);\n#     assert_eq!(5, *y);\n# }\n```\n\n</Listing>\n\nSkÅ‚adnia `type Target = T;` definiuje typ skojarzony dla cechy `Deref`. Typy skojarzone to nieco inny sposÃ³b deklarowania parametru generycznego, ale na razie nie musisz siÄ™ nimi martwiÄ‡; omÃ³wimy je bardziej szczegÃ³Å‚owo w Rozdziale 20.\n\nWypeÅ‚niamy ciaÅ‚o metody `deref` za pomocÄ… `&self.0`, tak aby `deref` zwracaÅ‚o referencjÄ™ do wartoÅ›ci, do ktÃ³rej chcemy uzyskaÄ‡ dostÄ™p za pomocÄ… operatora `*`; przypomnij sobie z sekcji [â€Tworzenie rÃ³Å¼nych typÃ³w za pomocÄ… struktur tuplowychâ€][tuple-structs]<!-- ignore --> w Rozdziale 5, Å¼e `.0` uzyskuje dostÄ™p do pierwszej wartoÅ›ci w strukturze tuplowej. Funkcja `main` w Listing 15-9, ktÃ³ra wywoÅ‚uje `*` na wartoÅ›ci `MyBox<T>`, teraz siÄ™ kompiluje, a asercje przechodzÄ…!\n\nBez cechy `Deref` kompilator moÅ¼e dereferencyjnie traktowaÄ‡ tylko referencje `&`. Metoda `deref` daje kompilatorowi moÅ¼liwoÅ›Ä‡ wziÄ™cia wartoÅ›ci dowolnego typu, ktÃ³ry implementuje `Deref`, i wywoÅ‚ania metody `deref`, aby uzyskaÄ‡ referencjÄ™, ktÃ³rÄ… wie, jak dereferencyjnie traktowaÄ‡.\n\nKiedy wpisaliÅ›my `*y` w Listing 15-9, za kulisami Rust faktycznie uruchomiÅ‚ ten kod:\n\n```rust,ignore\n*(y.deref())\n```\n\nRust zastÄ™puje operator `*` wywoÅ‚aniem metody `deref`, a nastÄ™pnie prostym dereferencjonowaniem, tak abyÅ›my nie musieli zastanawiaÄ‡ siÄ™, czy potrzebujemy wywoÅ‚ywaÄ‡ metodÄ™ `deref`, czy nie. Ta funkcja Rusta pozwala nam pisaÄ‡ kod, ktÃ³ry dziaÅ‚a identycznie, niezaleÅ¼nie od tego, czy mamy zwykÅ‚Ä… referencjÄ™, czy typ implementujÄ…cy `Deref`.\n\nPowÃ³d, dla ktÃ³rego metoda `deref` zwraca referencjÄ™ do wartoÅ›ci, a zwykÅ‚a dereferencja poza nawiasami w `*(y.deref())` jest nadal konieczna, ma zwiÄ…zek z systemem wÅ‚asnoÅ›ci. Gdyby metoda `deref` zwracaÅ‚a wartoÅ›Ä‡ bezpoÅ›rednio zamiast referencji do wartoÅ›ci, wartoÅ›Ä‡ zostaÅ‚aby przeniesiona z `self`. Nie chcemy przejmowaÄ‡ wÅ‚asnoÅ›ci wewnÄ™trznej wartoÅ›ci w `MyBox<T>` w tym przypadku ani w wiÄ™kszoÅ›ci przypadkÃ³w, gdy uÅ¼ywamy operatora dereferencji.\n\nZauwaÅ¼, Å¼e operator `*` jest zastÄ™powany wywoÅ‚aniem metody `deref`, a nastÄ™pnie wywoÅ‚aniem operatora `*` tylko raz, za kaÅ¼dym razem, gdy uÅ¼ywamy `*` w naszym kodzie. PoniewaÅ¼ podstawianie operatora `*` nie rekursuje w nieskoÅ„czonoÅ›Ä‡, otrzymujemy dane typu `i32`, co pasuje do `5` w `assert_eq!` w Listing 15-9.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"implicit-deref-coercions-with-functions-and-methods\"></a>\n<a id=\"using-deref-coercions-in-functions-and-methods\"></a>\n\n### UÅ¼ywanie koercji Deref w funkcjach i metodach\n\n_Koercja Deref_ konwertuje referencjÄ™ do typu, ktÃ³ry implementuje cechÄ™ `Deref`, na referencjÄ™ do innego typu. Na przykÅ‚ad, koercja Deref moÅ¼e przekonwertowaÄ‡ `&String` na `&str`, poniewaÅ¼ `String` implementuje cechÄ™ `Deref` w taki sposÃ³b, Å¼e zwraca `&str`. Koercja Deref jest udogodnieniem, ktÃ³re Rust wykonuje na argumentach funkcji i metod, i dziaÅ‚a tylko na typach, ktÃ³re implementujÄ… cechÄ™ `Deref`. Dzieje siÄ™ to automatycznie, gdy przekazujemy referencjÄ™ do wartoÅ›ci konkretnego typu jako argument do funkcji lub metody, ktÃ³ra nie pasuje do typu parametru w definicji funkcji lub metody. Sekwencja wywoÅ‚aÅ„ metody `deref` konwertuje dostarczony przez nas typ na typ, ktÃ³rego potrzebuje parametr.\n\nKoercja Deref zostaÅ‚a dodana do Rusta, aby programiÅ›ci piszÄ…cy wywoÅ‚ania funkcji i metod nie musieli dodawaÄ‡ tak wielu jawnych referencji i dereferencji za pomocÄ… `&` i `*`. Funkcja koercji Deref pozwala nam rÃ³wnieÅ¼ pisaÄ‡ wiÄ™cej kodu, ktÃ³ry moÅ¼e dziaÅ‚aÄ‡ zarÃ³wno z referencjami, jak i inteligentnymi wskaÅºnikami.\n\nAby zobaczyÄ‡ koercjÄ™ Deref w dziaÅ‚aniu, uÅ¼yjmy typu `MyBox<T>`, ktÃ³ry zdefiniowaliÅ›my w Listing 15-8, a takÅ¼e implementacji `Deref`, ktÃ³rÄ… dodaliÅ›my w Listing 15-10. Listing 15-11 pokazuje definicjÄ™ funkcji, ktÃ³ra ma parametr wycinka ciÄ…gu znakÃ³w.\n\n<Listing number=\"15-11\" file-name=\"src/main.rs\" caption=\"Funkcja `hello`, ktÃ³ra ma parametr `name` typu `&str`\">\n\n```rust\nfn hello(name: &str) {\n    println!(\"Witaj, {name}!\");\n}\n# \n# fn main() {}\n```\n\n</Listing>\n\nMoÅ¼emy wywoÅ‚aÄ‡ funkcjÄ™ `hello` z wycinkiem ciÄ…gu znakÃ³w jako argumentem, na przykÅ‚ad `hello(\"Rust\");`. Koercja Deref umoÅ¼liwia wywoÅ‚anie `hello` z referencjÄ… do wartoÅ›ci typu `MyBox<String>`, jak pokazano w Listing 15-12.\n\n<Listing number=\"15-12\" file-name=\"src/main.rs\" caption=\"WywoÅ‚anie `hello` z referencjÄ… do wartoÅ›ci `MyBox<String>`, co dziaÅ‚a dziÄ™ki koercji dereferencyjnej\">\n\n```rust\n# use std::ops::Deref;\n# \n# impl<T> Deref for MyBox<T> {\n#     type Target = T;\n# \n#     fn deref(&self) -> &T {\n#         &self.0\n#     }\n# }\n# \n# struct MyBox<T>(T);\n# \n# impl<T> MyBox<T> {\n#     fn new(x: T) -> MyBox<T> {\n#         MyBox(x)\n#     }\n# }\n# \n# fn hello(name: &str) {\n#     println!(\"Witaj, {name}!\");\n# }\n# \nfn main() {\n    let m = MyBox::new(String::from(\"Rust\"));\n    hello(&m);\n}\n```\n\n</Listing>\n\nTutaj wywoÅ‚ujemy funkcjÄ™ `hello` z argumentem `&m`, ktÃ³ry jest referencjÄ… do wartoÅ›ci `MyBox<String>`. PoniewaÅ¼ zaimplementowaliÅ›my cechÄ™ `Deref` dla `MyBox<T>` w Listing 15-10, Rust moÅ¼e przeksztaÅ‚ciÄ‡ `&MyBox<String>` w `&String` poprzez wywoÅ‚anie `deref`. Standardowa biblioteka dostarcza implementacjÄ™ `Deref` dla `String`, ktÃ³ra zwraca wycinek ciÄ…gu znakÃ³w, i jest to w dokumentacji API dla `Deref`. Rust ponownie wywoÅ‚uje `deref`, aby przeksztaÅ‚ciÄ‡ `&String` w `&str`, co pasuje do definicji funkcji `hello`.\n\nGdyby Rust nie implementowaÅ‚ koercji dereferencyjnej, musielibyÅ›my napisaÄ‡ kod z Listing 15-13 zamiast kodu z Listing 15-12, aby wywoÅ‚aÄ‡ `hello` z wartoÅ›ciÄ… typu `&MyBox<String>`.\n\n<Listing number=\"15-13\" file-name=\"src/main.rs\" caption=\"Kod, ktÃ³ry musielibyÅ›my napisaÄ‡, gdyby Rust nie miaÅ‚ koercji dereferencyjnej\">\n\n```rust\n# use std::ops::Deref;\n# \n# impl<T> Deref for MyBox<T> {\n#     type Target = T;\n# \n#     fn deref(&self) -> &T {\n#         &self.0\n#     }\n# }\n# \n# struct MyBox<T>(T);\n# \n# impl<T> MyBox<T> {\n#     fn new(x: T) -> MyBox<T> {\n#         MyBox(x)\n#     }\n# }\n# \n# fn hello(name: &str) {\n#     println!(\"Witaj, {name}!\");\n# }\n# \nfn main() {\n    let m = MyBox::new(String::from(\"Rust\"));\n    hello(&(*m)[..]);\n}\n```\n\n</Listing>\n\n`(*m)` dereferencuje `MyBox<String>` do `String`. NastÄ™pnie `&` i `[..]` pobierajÄ… wycinek ciÄ…gu znakÃ³w z `String`, ktÃ³ry jest rÃ³wny caÅ‚emu ciÄ…gowi, aby pasowaÅ‚ do sygnatury `hello`. Ten kod bez koercji dereferencyjnych jest trudniejszy do odczytania, napisania i zrozumienia ze wszystkimi zaangaÅ¼owanymi symbolami. Koercja Deref pozwala Rustowi automatycznie obsÅ‚ugiwaÄ‡ te konwersje.\n\nKiedy cecha `Deref` jest zdefiniowana dla zaangaÅ¼owanych typÃ³w, Rust przeanalizuje typy i uÅ¼yje `Deref::deref` tyle razy, ile to konieczne, aby uzyskaÄ‡ referencjÄ™ pasujÄ…cÄ… do typu parametru. Liczba razy, jakÄ… naleÅ¼y wstawiÄ‡ `Deref::deref`, jest rozwiÄ…zywana w czasie kompilacji, wiÄ™c nie ma kary za wydajnoÅ›Ä‡ w czasie dziaÅ‚ania za korzystanie z koercji Deref!\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"how-deref-coercion-interacts-with-mutability\"></a>\n\n### ObsÅ‚uga koercji Deref ze zmiennymi referencjami\n\nPodobnie jak uÅ¼ywasz cechy `Deref` do nadpisywania operatora `*` na niezmiennych referencjach, moÅ¼esz uÅ¼yÄ‡ cechy `DerefMut` do nadpisywania operatora `*` na zmiennych referencjach.\n\nRust wykonuje koercjÄ™ dereferencyjnÄ…, gdy znajdzie typy i implementacje cech w trzech przypadkach:\n\n1. Z `&T` do `&U`, gdy `T: Deref<Target=U>`\n2. Z `&mut T` do `&mut U`, gdy `T: DerefMut<Target=U>`\n3. Z `&mut T` do `&U`, gdy `T: Deref<Target=U>`\n\nPierwsze dwa przypadki sÄ… takie same, z wyjÄ…tkiem tego, Å¼e drugi implementuje zmiennoÅ›Ä‡. Pierwszy przypadek mÃ³wi, Å¼e jeÅ›li masz `&T` i `T` implementuje `Deref` do pewnego typu `U`, moÅ¼esz w sposÃ³b przezroczysty uzyskaÄ‡ `&U`. Drugi przypadek mÃ³wi, Å¼e ta sama koercja dereferencyjna ma miejsce dla zmiennych referencji.\n\nTrzeci przypadek jest bardziej podstÄ™pny: Rust rÃ³wnieÅ¼ przeksztaÅ‚ci zmiennÄ… referencjÄ™ w niezmiennÄ…. Ale odwrotna operacja _nie_ jest moÅ¼liwa: niezmienne referencje nigdy nie zostanÄ… przeksztaÅ‚cone w zmienne referencje. Ze wzglÄ™du na zasady poÅ¼yczania, jeÅ›li masz zmiennÄ… referencjÄ™, ta zmienna referencja musi byÄ‡ jedynÄ… referencjÄ… do tych danych (w przeciwnym razie program nie skompilowaÅ‚by siÄ™). Konwersja jednej zmiennej referencji na jednÄ… niezmiennÄ… referencjÄ™ nigdy nie naruszy zasad poÅ¼yczania. Konwersja niezmiennej referencji na zmiennÄ… referencjÄ™ wymagaÅ‚aby, aby poczÄ…tkowa niezmienna referencja byÅ‚a jedynÄ… niezmiennÄ… referencjÄ… do tych danych, ale zasady poÅ¼yczania tego nie gwarantujÄ…. Dlatego Rust nie moÅ¼e przyjÄ…Ä‡ zaÅ‚oÅ¼enia, Å¼e konwersja niezmiennej referencji na zmiennÄ… referencjÄ™ jest moÅ¼liwa.\n\n[impl-trait]: ch10-02-traits.html#implementing-a-trait-on-a-type\n[tuple-structs]: ch05-01-defining-structs.html#creating-different-types-with-tuple-structs",
        "chapter_title": "Traktowanie inteligentnych wskaÅºnikÃ³w jak zwykÅ‚ych referencji"
    },
    {
        "file_path": "ch15-03-drop.md",
        "content": "## Uruchamianie kodu podczas czyszczenia za pomocÄ… cechy `Drop`\n\nDruga cecha waÅ¼na dla wzorca wskaÅºnika sprytnego to `Drop`, ktÃ³ra pozwala na\ndostosowanie tego, co dzieje siÄ™, gdy wartoÅ›Ä‡ ma wyjÅ›Ä‡ poza zakres. MoÅ¼esz\ndostarczyÄ‡ implementacjÄ™ cechy `Drop` dla dowolnego typu, a ten kod moÅ¼e\nzostaÄ‡ uÅ¼yty do zwolnienia zasobÃ³w, takich jak pliki lub poÅ‚Ä…czenia sieciowe.\n\nWprowadzamy `Drop` w kontekÅ›cie wskaÅºnikÃ³w sprytnych, poniewaÅ¼ funkcjonalnoÅ›Ä‡\ncechy `Drop` jest prawie zawsze uÅ¼ywana podczas implementacji wskaÅºnika\nsprytnego. Na przykÅ‚ad, gdy `Box<T>` zostanie usuniÄ™ty (`dropped`), zwolni\nprzestrzeÅ„ na stercie, na ktÃ³rÄ… wskazuje `Box`.\n\nW niektÃ³rych jÄ™zykach, dla niektÃ³rych typÃ³w, programista musi wywoÅ‚aÄ‡ kod,\naby zwolniÄ‡ pamiÄ™Ä‡ lub zasoby za kaÅ¼dym razem, gdy skoÅ„czy uÅ¼ywaÄ‡ instancji\ntych typÃ³w. PrzykÅ‚adami sÄ… uchwyty plikÃ³w, gniazda sieciowe i blokady. JeÅ›li\nprogramista zapomni, system moÅ¼e zostaÄ‡ przeciÄ…Å¼ony i ulec awarii. W Rust\nmoÅ¼na okreÅ›liÄ‡, Å¼e dany fragment kodu ma byÄ‡ uruchamiany za kaÅ¼dym razem, gdy\nwartoÅ›Ä‡ wyjdzie poza zakres, a kompilator wstawi ten kod automatycznie. W\nrezultacie nie musisz martwiÄ‡ siÄ™ o umieszczanie kodu czyszczÄ…cego wszÄ™dzie w\nprogramie, gdzie instancja okreÅ›lonego typu zostaje zakoÅ„czona â€“ nadal nie\nbÄ™dziesz miaÅ‚ wyciekÃ³w zasobÃ³w!\n\nKod do uruchomienia, gdy wartoÅ›Ä‡ wyjdzie poza zakres, okreÅ›lasz, implementujÄ…c\ncechÄ™ `Drop`. Cecha `Drop` wymaga zaimplementowania jednej metody o nazwie\n`drop`, ktÃ³ra przyjmuje mutowalnÄ… referencjÄ™ do `self`. Aby zobaczyÄ‡, kiedy Rust\nwywoÅ‚uje `drop`, zaimplementujmy na razie `drop` z instrukcjami `println!`.\n\nListing 15-14 przedstawia strukturÄ™ `CustomSmartPointer`, ktÃ³rej jedynÄ…\ndostosowanÄ… funkcjonalnoÅ›ciÄ… jest to, Å¼e wypisze `Dropping CustomSmartPointer!`,\ngdy instancja wyjdzie poza zakres, aby pokazaÄ‡, kiedy Rust uruchamia metodÄ™\n`drop`.\n\n<Listing number=\"15-14\" file-name=\"src/main.rs\" caption=\"Struktura `CustomSmartPointer` implementujÄ…ca cechÄ™ `Drop`, w ktÃ³rej umieÅ›cilibyÅ›my nasz kod czyszczÄ…cy\">\n\n```rust\nstruct CustomSmartPointer {\n    data: String,\n}\n\nimpl Drop for CustomSmartPointer {\n    fn drop(&mut self) {\n        println!(\"Dropping CustomSmartPointer with data `{}`!\", self.data);\n    }\n}\n\nfn main() {\n    let c = CustomSmartPointer {\n        data: String::from(\"my stuff\"),\n    };\n    let d = CustomSmartPointer {\n        data: String::from(\"other stuff\"),\n    };\n    println!(\"CustomSmartPointers created\");\n}\n```\n\n</Listing>\n\nCecha `Drop` jest uwzglÄ™dniona w preambule, wiÄ™c nie musimy jej importowaÄ‡.\nImplementujemy cechÄ™ `Drop` dla `CustomSmartPointer` i dostarczamy implementacjÄ™\nmetody `drop`, ktÃ³ra wywoÅ‚uje `println!`. TreÅ›Ä‡ metody `drop` to miejsce, w\nktÃ³rym umieÅ›ciÅ‚byÅ› dowolnÄ… logikÄ™, ktÃ³rÄ… chciaÅ‚byÅ› uruchomiÄ‡, gdy instancja\ntwojego typu wyjdzie poza zakres. Wypisujemy tutaj tekst, aby wizualnie\nzademonstrowaÄ‡, kiedy Rust wywoÅ‚a `drop`.\n\nW `main` tworzymy dwie instancje `CustomSmartPointer`, a nastÄ™pnie wypisujemy\n`CustomSmartPointers created`. Pod koniec `main`, nasze instancje\n`CustomSmartPointer` wyjdÄ… poza zakres, a Rust wywoÅ‚a kod, ktÃ³ry umieÅ›ciliÅ›my\nw metodzie `drop`, wypisujÄ…c naszÄ… koÅ„cowÄ… wiadomoÅ›Ä‡. ZauwaÅ¼, Å¼e nie musieliÅ›my\njawnie wywoÅ‚ywaÄ‡ metody `drop`.\n\nPo uruchomieniu tego programu zobaczymy nastÄ™pujÄ…cy wynik:\n\n```console\n$ cargo run\n   Compiling drop-example v0.1.0 (file:///projects/drop-example)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.60s\n     Running `target/debug/drop-example`\nCustomSmartPointers created\nDropping CustomSmartPointer with data `other stuff`!\nDropping CustomSmartPointer with data `my stuff`!\n```\n\nRust automatycznie wywoÅ‚aÅ‚ `drop` dla nas, gdy nasze instancje wyszÅ‚y poza\nzakres, uruchamiajÄ…c okreÅ›lony przez nas kod. Zmienne sÄ… usuwane w odwrotnej\nkolejnoÅ›ci ich tworzenia, wiÄ™c `d` zostaÅ‚o usuniÄ™te przed `c`. Celem tego\nprzykÅ‚adu jest zapewnienie wizualnego przewodnika po dziaÅ‚aniu metody `drop`;\nzazwyczaj okreÅ›liÅ‚byÅ› kod czyszczÄ…cy, ktÃ³ry twÃ³j typ musi uruchomiÄ‡, a nie\nkomunikat do wypisania.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"dropping-a-value-early-with-std-mem-drop\"></a>\n\nNiestety, wyÅ‚Ä…czenie automatycznej funkcjonalnoÅ›ci `drop` nie jest proste.\nWyÅ‚Ä…czanie `drop` zazwyczaj nie jest konieczne; caÅ‚y sens cechy `Drop` polega\nna tym, Å¼e jest obsÅ‚ugiwana automatycznie. Czasami jednak moÅ¼esz chcieÄ‡\nposprzÄ…taÄ‡ wartoÅ›Ä‡ wczeÅ›niej. Jednym z przykÅ‚adÃ³w jest uÅ¼ycie wskaÅºnikÃ³w\nsprytnych zarzÄ…dzajÄ…cych blokadami: MoÅ¼esz chcieÄ‡ wymusiÄ‡ wywoÅ‚anie metody\n`drop`, ktÃ³ra zwalnia blokadÄ™, tak aby inny kod w tym samym zakresie mÃ³gÅ‚\nnabyÄ‡ blokadÄ™. Rust nie pozwala na rÄ™czne wywoÅ‚anie metody `drop` cechy `Drop`;\nzamiast tego musisz wywoÅ‚aÄ‡ funkcjÄ™ `std::mem::drop` dostarczonÄ… przez\nbibliotekÄ™ standardowÄ…, jeÅ›li chcesz wymusiÄ‡ usuniÄ™cie wartoÅ›ci przed koÅ„cem\njej zakresu.\n\nPrÃ³ba rÄ™cznego wywoÅ‚ania metody `drop` cechy `Drop` poprzez modyfikacjÄ™ funkcji\n`main` z Listingu 15-14 nie zadziaÅ‚a, jak pokazano w Listingu 15-15.\n\n<Listing number=\"15-15\" file-name=\"src/main.rs\" caption=\"PrÃ³ba rÄ™cznego wywoÅ‚ania metody `drop` z cechy `Drop` w celu wczesnego posprzÄ…tania\">\n\n```rust,ignore,does_not_compile\n# struct CustomSmartPointer {\n#     data: String,\n# }\n# \n# impl Drop for CustomSmartPointer {\n#     fn drop(&mut self) {\n#         println!(\"Dropping CustomSmartPointer with data `{}`!\", self.data);\n#     }\n# }\n# \nfn main() {\n    let c = CustomSmartPointer {\n        data: String::from(\"some data\"),\n    };\n    println!(\"CustomSmartPointer created\");\n    c.drop();\n    println!(\"CustomSmartPointer dropped before the end of main\");\n}\n```\n\n</Listing>\n\nKiedy sprÃ³bujemy skompilowaÄ‡ ten kod, otrzymamy taki bÅ‚Ä…d:\n\n```console\n$ cargo run\n   Compiling drop-example v0.1.0 (file:///projects/drop-example)\nerror[E0040]: explicit use of destructor method\n  --> src/main.rs:16:7\n   |\n16 |     c.drop();\n   |       ^^^^ explicit destructor calls not allowed\n   |\nhelp: consider using `drop` function\n   |\n16 -     c.drop();\n16 +     drop(c);\n   |\n\nFor more information about this error, try `rustc --explain E0040`.\nerror: could not compile `drop-example` (bin \"drop-example\") due to 1 previous error\n```\n\nTen komunikat o bÅ‚Ä™dzie informuje, Å¼e nie wolno nam jawnie wywoÅ‚ywaÄ‡ `drop`.\nKomunikat o bÅ‚Ä™dzie uÅ¼ywa terminu _destruktor_, ktÃ³ry jest ogÃ³lnym terminem\nprogramistycznym dla funkcji, ktÃ³ra oczyszcza instancjÄ™. _Destruktor_ jest\nanalogiczny do _konstruktora_, ktÃ³ry tworzy instancjÄ™. Funkcja `drop` w Rust\njest jednym szczegÃ³lnym destruktorem.\n\nRust nie pozwala nam jawnie wywoÅ‚ywaÄ‡ `drop`, poniewaÅ¼ Rust nadal\nautomatycznie wywoÅ‚ywaÅ‚by `drop` na wartoÅ›ci na koÅ„cu `main`. SpowodowaÅ‚oby to\nbÅ‚Ä…d podwÃ³jnego zwolnienia pamiÄ™ci, poniewaÅ¼ Rust prÃ³bowaÅ‚by dwukrotnie\nposprzÄ…taÄ‡ tÄ™ samÄ… wartoÅ›Ä‡.\n\nNie moÅ¼emy wyÅ‚Ä…czyÄ‡ automatycznego wstawiania `drop`, gdy wartoÅ›Ä‡ wyjdzie poza\nzakres, i nie moÅ¼emy jawnie wywoÅ‚aÄ‡ metody `drop`. WiÄ™c, jeÅ›li potrzebujemy\nwymusiÄ‡ wczesne posprzÄ…tanie wartoÅ›ci, uÅ¼ywamy funkcji `std::mem::drop`.\n\nFunkcja `std::mem::drop` rÃ³Å¼ni siÄ™ od metody `drop` w cechy `Drop`. WywoÅ‚ujemy\njÄ…, przekazujÄ…c jako argument wartoÅ›Ä‡, ktÃ³rÄ… chcemy wymusiÄ‡ usuniÄ™cie.\nFunkcja znajduje siÄ™ w preambule, wiÄ™c moÅ¼emy zmodyfikowaÄ‡ `main` w Listingu\n15-15, aby wywoÅ‚aÄ‡ funkcjÄ™ `drop`, jak pokazano w Listingu 15-16.\n\n<Listing number=\"15-16\" file-name=\"src/main.rs\" caption=\"WywoÅ‚ywanie `std::mem::drop` w celu jawnego usuniÄ™cia wartoÅ›ci, zanim wyjdzie ona poza zakres\">\n\n```rust\n# struct CustomSmartPointer {\n#     data: String,\n# }\n# \n# impl Drop for CustomSmartPointer {\n#     fn drop(&mut self) {\n#         println!(\"Dropping CustomSmartPointer with data `{}`!\", self.data);\n#     }\n# }\n# \nfn main() {\n    let c = CustomSmartPointer {\n        data: String::from(\"some data\"),\n    };\n    println!(\"CustomSmartPointer created\");\n    drop(c);\n    println!(\"CustomSmartPointer dropped before the end of main\");\n}\n```\n\n</Listing>\n\nUruchomienie tego kodu wypisze nastÄ™pujÄ…ce:\n\n```console\n$ cargo run\n   Compiling drop-example v0.1.0 (file:///projects/drop-example)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s\n     Running `target/debug/drop-example`\nCustomSmartPointer created\nDropping CustomSmartPointer with data `some data`!\nCustomSmartPointer dropped before the end of main\n```\n\nTekst ``Dropping CustomSmartPointer with data `some data`!`` jest wypisany\npomiÄ™dzy tekstami `CustomSmartPointer created` i `CustomSmartPointer dropped\nbefore the end of main`, pokazujÄ…c, Å¼e kod metody `drop` jest wywoÅ‚ywany w celu\nusuniÄ™cia `c` w tym punkcie.\n\nKod okreÅ›lony w implementacji cechy `Drop` moÅ¼na wykorzystaÄ‡ na wiele sposobÃ³w,\naby czyszczenie byÅ‚o wygodne i bezpieczne: na przykÅ‚ad moÅ¼na go uÅ¼yÄ‡ do\nstworzenia wÅ‚asnego alokatora pamiÄ™ci! DziÄ™ki cechy `Drop` i systemowi wÅ‚asnoÅ›ci\nRust nie musisz pamiÄ™taÄ‡ o czyszczeniu, poniewaÅ¼ Rust robi to automatycznie.\n\nNie musisz teÅ¼ martwiÄ‡ siÄ™ problemami wynikajÄ…cymi z przypadkowego czyszczenia\nwartoÅ›ci nadal uÅ¼ywanych: System wÅ‚asnoÅ›ci, ktÃ³ry zapewnia, Å¼e referencje sÄ…\nzawsze prawidÅ‚owe, gwarantuje rÃ³wnieÅ¼, Å¼e `drop` zostanie wywoÅ‚any tylko raz,\ngdy wartoÅ›Ä‡ nie jest juÅ¼ uÅ¼ywana.\n\nTeraz, gdy przeanalizowaliÅ›my `Box<T>` i niektÃ³re cechy wskaÅºnikÃ³w sprytnych,\nprzyjrzyjmy siÄ™ kilku innym wskaÅºnikom sprytnym zdefiniowanym w bibliotece\nstandardowej.",
        "chapter_title": "Uruchamianie kodu podczas czyszczenia za pomocÄ… cechy `Drop`"
    },
    {
        "file_path": "ch15-04-rc.md",
        "content": "## `Rc<T>`, wskaÅºnik sprytny zliczajÄ…cy referencje\n\nW wiÄ™kszoÅ›ci przypadkÃ³w wÅ‚asnoÅ›Ä‡ jest jasna: dokÅ‚adnie wiesz, ktÃ³ra zmienna\nposiada danÄ… wartoÅ›Ä‡. IstniejÄ… jednak sytuacje, gdy pojedyncza wartoÅ›Ä‡ moÅ¼e\nmieÄ‡ wielu wÅ‚aÅ›cicieli. Na przykÅ‚ad, w strukturach danych grafowych, wiele\nkrawÄ™dzi moÅ¼e wskazywaÄ‡ na ten sam wÄ™zeÅ‚, a ten wÄ™zeÅ‚ jest koncepcyjnie\nwÅ‚asnoÅ›ciÄ… wszystkich krawÄ™dzi, ktÃ³re na niego wskazujÄ…. WÄ™zeÅ‚ nie powinien\nbyÄ‡ usuwany, chyba Å¼e nie ma Å¼adnych krawÄ™dzi wskazujÄ…cych na niego, a zatem\nnie ma wÅ‚aÅ›cicieli.\n\nMusisz jawnie wÅ‚Ä…czyÄ‡ wielokrotnÄ… wÅ‚asnoÅ›Ä‡, uÅ¼ywajÄ…c typu Rust `Rc<T>`, co\njest skrÃ³tem od _reference counting_ (zliczanie referencji). Typ `Rc<T>`\nÅ›ledzi liczbÄ™ referencji do wartoÅ›ci, aby okreÅ›liÄ‡, czy wartoÅ›Ä‡ jest nadal\nuÅ¼ywana. JeÅ›li do wartoÅ›ci istnieje zero referencji, wartoÅ›Ä‡ moÅ¼e zostaÄ‡\nusuniÄ™ta bez uniewaÅ¼niania Å¼adnych referencji.\n\nWyobraÅº sobie `Rc<T>` jako telewizor w pokoju rodzinnym. Kiedy jedna osoba\nwchodzi, Å¼eby oglÄ…daÄ‡ telewizor, wÅ‚Ä…cza go. Inni mogÄ… wejÅ›Ä‡ do pokoju i oglÄ…daÄ‡\ntelewizor. Kiedy ostatnia osoba opuszcza pokÃ³j, wyÅ‚Ä…cza telewizor, poniewaÅ¼\nnie jest juÅ¼ uÅ¼ywany. Gdyby ktoÅ› wyÅ‚Ä…czyÅ‚ telewizor, podczas gdy inni nadal\ngo oglÄ…dajÄ…, pozostali widzowie wywoÅ‚aliby zamieszanie!\n\nTypu `Rc<T>` uÅ¼ywamy, gdy chcemy alokowaÄ‡ dane na stercie, aby wiele czÄ™Å›ci\nnaszego programu mogÅ‚o je odczytywaÄ‡, a nie moÅ¼emy w czasie kompilacji\nokreÅ›liÄ‡, ktÃ³ra czÄ™Å›Ä‡ zakoÅ„czy uÅ¼ywanie danych jako ostatnia. GdybyÅ›my\nwiedzieli, ktÃ³ra czÄ™Å›Ä‡ zakoÅ„czy uÅ¼ywanie jako ostatnia, moglibyÅ›my po prostu\nuczyniÄ‡ tÄ™ czÄ™Å›Ä‡ wÅ‚aÅ›cicielem danych, a normalne zasady wÅ‚asnoÅ›ci egzekwowane\nw czasie kompilacji weszÅ‚yby w Å¼ycie.\n\nZauwaÅ¼, Å¼e `Rc<T>` jest przeznaczony wyÅ‚Ä…cznie do uÅ¼ytku w scenariuszach\njednowÄ…tkowych. Kiedy bÄ™dziemy omawiaÄ‡ wspÃ³Å‚bieÅ¼noÅ›Ä‡ w Rozdziale 16,\npokaÅ¼emy, jak realizowaÄ‡ zliczanie referencji w programach\nwielowÄ…tkowych.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"using-rct-to-share-data\"></a>\n\n### UdostÄ™pnianie danych\n\nWrÃ³Ä‡my do naszego przykÅ‚adu listy konsensusowej z Listingu 15-5. Przypomnijmy,\nÅ¼e zdefiniowaliÅ›my jÄ… za pomocÄ… `Box<T>`. Tym razem stworzymy dwie listy, ktÃ³re\nobie wspÃ³Å‚dzielÄ… wÅ‚asnoÅ›Ä‡ trzeciej listy. Koncepcyjnie wyglÄ…da to podobnie do\nRysunku 15-3.\n\n<img alt=\"A linked list with the label 'a' pointing to three elements. The first element contains the integer 5 and points to the second element. Th\ne second element contains the integer 10 and points to the third element. The third element contains the value 'Nil' that signifies the end of the l\nist; it does not point anywhere. A linked list with the label 'b' points to an element that contains the integer 3 and points to the first element o\nf list 'a'. A linked list with the label 'c' points to an element that contains the integer 4 and also points to the first element of list 'a' so th\nat the tails of lists 'b' and 'c' are both list 'a'.\" src=\"img/trpl15-03.svg\" class=\"center\" />\n\n<span class=\"caption\">Rysunek 15-3: Dwie listy, `b` i `c`, wspÃ³Å‚dzielÄ…ce wÅ‚asnoÅ›Ä‡\ntrzeciej listy, `a`</span>\n\nStworzymy listÄ™ `a`, ktÃ³ra bÄ™dzie zawieraÄ‡ `5`, a nastÄ™pnie `10`. NastÄ™pnie,\nstworzymy dwie kolejne listy: `b`, ktÃ³ra zaczyna siÄ™ od `3`, i `c`, ktÃ³ra\nzaczyna siÄ™ od `4`. Obie listy `b` i `c` bÄ™dÄ… kontynuowane do pierwszej listy `a`\nzawierajÄ…cej `5` i `10`. Innymi sÅ‚owy, obie listy bÄ™dÄ… wspÃ³Å‚dzieliÄ‡ pierwszÄ…\nlistÄ™ zawierajÄ…cÄ… `5` i `10`.\n\nPrÃ³ba zaimplementowania tego scenariusza przy uÅ¼yciu naszej definicji `List` z\n`Box<T>` nie zadziaÅ‚a, jak pokazano w Listingu 15-17.\n\n<Listing number=\"15-17\" file-name=\"src/main.rs\" caption=\"Demonstrowanie, Å¼e nie wolno nam mieÄ‡ dwÃ³ch list uÅ¼ywajÄ…cych `Box<T>`, ktÃ³re prÃ³bujÄ… wspÃ³Å‚dzieliÄ‡ wÅ‚asnoÅ›Ä‡ trzeciej listy\">\n\n```rust,ignore,does_not_compile\nenum List {\n    Cons(i32, Box<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));\n    let b = Cons(3, Box::new(a));\n    let c = Cons(4, Box::new(a));\n}\n```\n\n</Listing>\n\nKiedy skompilujemy ten kod, otrzymamy taki bÅ‚Ä…d:\n\n```console\n$ cargo run\n   Compiling cons-list v0.1.0 (file:///projects/cons-list)\nerror[E0382]: use of moved value: `a`\n  --> src/main.rs:11:30\n   |\n 9 |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));\n   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait\n10 |     let b = Cons(3, Box::new(a));\n   |                              - value moved here\n11 |     let c = Cons(4, Box::new(a));\n   |                              ^ value used here after move\n   |\nnote: if `List` implemented `Clone`, you could clone the value\n  --> src/main.rs:1:1\n   |\n 1 | enum List {\n   | ^^^^^^^^^ consider implementing `Clone` for this type\n...\n10 |     let b = Cons(3, Box::new(a));\n   |                              - you could clone this value\n\nFor more information about this error, try `rustc --explain E0382`.\nerror: could not compile `cons-list` (bin \"cons-list\") due to 1 previous error\n```\n\nWarianty `Cons` posiadajÄ… przechowywane dane, wiÄ™c kiedy tworzymy listÄ™ `b`, `a`\nzostaje przeniesione do `b`, a `b` staje siÄ™ wÅ‚aÅ›cicielem `a`. NastÄ™pnie, gdy\nprÃ³bujemy ponownie uÅ¼yÄ‡ `a` podczas tworzenia `c`, nie jest to dozwolone,\nponiewaÅ¼ `a` zostaÅ‚o przeniesione.\n\nMoglibyÅ›my zmieniÄ‡ definicjÄ™ `Cons`, aby przechowywaÅ‚a referencje, ale wtedy\nmusielibyÅ›my okreÅ›liÄ‡ parametry czasu Å¼ycia. OkreÅ›lajÄ…c parametry czasu Å¼ycia,\nokreÅ›lilibyÅ›my, Å¼e kaÅ¼dy element na liÅ›cie bÄ™dzie istniaÅ‚ co najmniej tak dÅ‚ugo\njak caÅ‚a lista. Tak jest w przypadku elementÃ³w i list w Listingu 15-17, ale\nnie w kaÅ¼dym scenariuszu.\n\nZamiast tego zmienimy naszÄ… definicjÄ™ `List`, aby uÅ¼ywaÄ‡ `Rc<T>` zamiast\n`Box<T>`, jak pokazano w Listingu 15-18. KaÅ¼dy wariant `Cons` bÄ™dzie teraz\nprzechowywaÅ‚ wartoÅ›Ä‡ i `Rc<T>` wskazujÄ…cy na `List`. Kiedy tworzymy `b`,\nzamiast przejmowaÄ‡ wÅ‚asnoÅ›Ä‡ `a`, sklonujemy `Rc<List>`, ktÃ³re `a` przechowuje,\npowiÄ…kszajÄ…c tym samym liczbÄ™ referencji z jednej do dwÃ³ch i pozwalajÄ…c `a` i `b`\nwspÃ³Å‚dzieliÄ‡ wÅ‚asnoÅ›Ä‡ danych w tym `Rc<List>`. Sklonujemy rÃ³wnieÅ¼ `a` podczas\ntworzenia `c`, zwiÄ™kszajÄ…c liczbÄ™ referencji z dwÃ³ch do trzech. Za kaÅ¼dym\nrazem, gdy wywoÅ‚amy `Rc::clone`, liczba referencji do danych w `Rc<List>`\nwzroÅ›nie, a dane nie zostanÄ… usuniÄ™te, chyba Å¼e bÄ™dzie do nich zero referencji.\n\n<Listing number=\"15-18\" file-name=\"src/main.rs\" caption=\"Definicja `List` uÅ¼ywajÄ…ca `Rc<T>`\">\n\n```rust\nenum List {\n    Cons(i32, Rc<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::rc::Rc;\n\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n    let b = Cons(3, Rc::clone(&a));\n    let c = Cons(4, Rc::clone(&a));\n}\n```\n\n</Listing>\n\nMusimy dodaÄ‡ instrukcjÄ™ `use`, aby wprowadziÄ‡ `Rc<T>` do zakresu, poniewaÅ¼ nie\nznajduje siÄ™ on w preambule. W funkcji `main` tworzymy listÄ™ zawierajÄ…cÄ… `5` i\n`10` i przechowujemy jÄ… w nowym `Rc<List>` w zmiennej `a`. NastÄ™pnie, gdy\ntworzymy `b` i `c`, wywoÅ‚ujemy funkcjÄ™ `Rc::clone` i przekazujemy referencjÄ™\ndo `Rc<List>` w `a` jako argument.\n\nMoglibyÅ›my wywoÅ‚aÄ‡ `a.clone()` zamiast `Rc::clone(&a)`, ale konwencjÄ… Rust jest\nuÅ¼ywanie `Rc::clone` w tym przypadku. Implementacja `Rc::clone` nie tworzy\ngÅ‚Ä™bokiej kopii wszystkich danych, jak robiÄ… to implementacje `clone` wiÄ™kszoÅ›ci\ntypÃ³w. WywoÅ‚anie `Rc::clone` tylko zwiÄ™ksza licznik referencji, co nie\nzabiera wiele czasu. GÅ‚Ä™bokie kopie danych mogÄ… zajmowaÄ‡ duÅ¼o czasu. UÅ¼ywajÄ…c\n`Rc::clone` do zliczania referencji, moÅ¼emy wizualnie rozrÃ³Å¼niÄ‡ klony\ntworzÄ…ce gÅ‚Ä™bokie kopie od klonÃ³w, ktÃ³re zwiÄ™kszajÄ… licznik referencji. SzukajÄ…c\nproblemÃ³w z wydajnoÅ›ciÄ… w kodzie, musimy braÄ‡ pod uwagÄ™ tylko klony tworzÄ…ce\ngÅ‚Ä™bokie kopie i moÅ¼emy ignorowaÄ‡ wywoÅ‚ania `Rc::clone`.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"cloning-an-rct-increases-the-reference-count\"></a>\n\n### Klonowanie w celu zwiÄ™kszenia licznika referencji\n\nZmieÅ„my nasz dziaÅ‚ajÄ…cy przykÅ‚ad z Listingu 15-18, abyÅ›my mogli zobaczyÄ‡,\njak zmieniajÄ… siÄ™ liczniki referencji, gdy tworzymy i usuwamy referencje do\n`Rc<List>` w `a`.\n\nW Listingu 15-19 zmienimy `main` tak, aby zawieraÅ‚ wewnÄ™trzny zakres wokÃ³Å‚\nlisty `c`; wtedy bÄ™dziemy mogli zobaczyÄ‡, jak zmienia siÄ™ licznik referencji,\ngdy `c` wyjdzie poza zakres.\n\n<Listing number=\"15-19\" file-name=\"src/main.rs\" caption=\"Wypisywanie licznika referencji\">\n\n```rust\n# enum List {\n#     Cons(i32, Rc<List>),\n#     Nil,\n# }\n# \n# use crate::List::{Cons, Nil};\n# use std::rc::Rc;\n# \n// --snip--\n\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n    println!(\"count after creating a = {}\", Rc::strong_count(&a));\n    let b = Cons(3, Rc::clone(&a));\n    println!(\"count after creating b = {}\", Rc::strong_count(&a));\n    {\n        let c = Cons(4, Rc::clone(&a));\n        println!(\"count after creating c = {}\", Rc::strong_count(&a));\n    }\n    println!(\"count after c goes out of scope = {}\", Rc::strong_count(&a));\n}\n```\n\n</Listing>\n\nW kaÅ¼dym punkcie programu, w ktÃ³rym zmienia siÄ™ licznik referencji, wypisujemy\nwartoÅ›Ä‡ licznika referencji, ktÃ³rÄ… uzyskujemy wywoÅ‚ujÄ…c funkcjÄ™\n`Rc::strong_count`. Funkcja ta nazywa siÄ™ `strong_count` (silne zliczanie)\nzamiast `count` (zliczanie), poniewaÅ¼ typ `Rc<T>` ma rÃ³wnieÅ¼ `weak_count`\n(sÅ‚abe zliczanie); do czego sÅ‚uÅ¼y `weak_count` zobaczymy w sekcji [â€Zapobieganie\ncyklom referencji za pomocÄ… `Weak<T>`â€][preventing-ref-cycles]<!-- ignore -->.\n\nTen kod wypisuje nastÄ™pujÄ…ce:\n\n```console\n$ cargo run\n   Compiling cons-list v0.1.0 (file:///projects/cons-list)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.45s\n     Running `target/debug/cons-list`\ncount after creating a = 1\ncount after creating b = 2\ncount after creating c = 3\ncount after c goes out of scope = 2\n```\n\nWidzimy, Å¼e `Rc<List>` w `a` ma poczÄ…tkowy licznik referencji rÃ³wny 1; nastÄ™pnie,\nza kaÅ¼dym razem, gdy wywoÅ‚ujemy `clone`, licznik zwiÄ™ksza siÄ™ o 1. Gdy `c`\nwyjdzie poza zakres, licznik zmniejsza siÄ™ o 1. Nie musimy wywoÅ‚ywaÄ‡ funkcji\nw celu zmniejszenia licznika referencji, tak jak musimy wywoÅ‚aÄ‡ `Rc::clone`\nw celu zwiÄ™kszenia licznika referencji: Implementacja cechy `Drop` automatycznie\nzmniejsza licznik referencji, gdy wartoÅ›Ä‡ `Rc<T>` wyjdzie poza zakres.\n\nCzego nie widzimy w tym przykÅ‚adzie, to to, Å¼e gdy `b`, a nastÄ™pnie `a` wyjdÄ…\npoza zakres na koÅ„cu `main`, licznik wynosi 0, a `Rc<List>` zostaje caÅ‚kowicie\nwyczyszczone. UÅ¼ycie `Rc<T>` pozwala jednej wartoÅ›ci mieÄ‡ wielu wÅ‚aÅ›cicieli, a\nlicznik zapewnia, Å¼e wartoÅ›Ä‡ pozostaje waÅ¼na tak dÅ‚ugo, jak dÅ‚ugo istnieje\nktÃ³rykolwiek z wÅ‚aÅ›cicieli.\n\nPoprzez niemutowalne referencje, `Rc<T>` pozwala na wspÃ³Å‚dzielenie danych\npomiÄ™dzy wieloma czÄ™Å›ciami programu wyÅ‚Ä…cznie do odczytu. Gdyby `Rc<T>`\npozwalaÅ‚o na posiadanie rÃ³wnieÅ¼ wielu mutowalnych referencji, mogÅ‚oby to\nnaruszyÄ‡ jednÄ… z zasad poÅ¼yczania omÃ³wionych w Rozdziale 4: Wiele mutowalnych\npoÅ¼yczeÅ„ do tego samego miejsca moÅ¼e prowadziÄ‡ do wyÅ›cigÃ³w danych i\nniekonsekwencji. Ale moÅ¼liwoÅ›Ä‡ modyfikacji danych jest bardzo przydatna! W\nnastÄ™pnej sekcji omÃ³wimy wzorzec mutowalnoÅ›ci wewnÄ™trznej i typ `RefCell<T>`,\nktÃ³rego moÅ¼na uÅ¼ywaÄ‡ w poÅ‚Ä…czeniu z `Rc<T>` do pracy z tym ograniczeniem\niemutowalnoÅ›ci.\n\n[preventing-ref-cycles]: ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt",
        "chapter_title": "`Rc<T>`, wskaÅºnik sprytny zliczajÄ…cy referencje"
    },
    {
        "file_path": "ch15-05-interior-mutability.md",
        "content": "## `RefCell<T>` i wzorzec mutowalnoÅ›ci wewnÄ™trznej\n\n_MutowalnoÅ›Ä‡ wewnÄ™trzna_ to wzorzec projektowy w Rust, ktÃ³ry pozwala na\nmodyfikowanie danych nawet wtedy, gdy istniejÄ… do nich niemutowalne referencje;\nzazwyczaj takie dziaÅ‚anie jest zabronione przez zasady poÅ¼yczania. Aby\nmodyfikowaÄ‡ dane, wzorzec ten uÅ¼ywa kodu `unsafe` wewnÄ…trz struktury danych,\naby naginaÄ‡ zwykÅ‚e zasady Rust dotyczÄ…ce mutowalnoÅ›ci i poÅ¼yczania. Kod\nniebezpieczny wskazuje kompilatorowi, Å¼e rÄ™cznie sprawdzamy zasady, zamiast\npolegaÄ‡ na tym, Å¼e kompilator sprawdzi je za nas; o kodzie niebezpiecznym\nbÄ™dziemy rozmawiaÄ‡ szerzej w Rozdziale 20.\n\nTypy uÅ¼ywajÄ…ce wzorca mutowalnoÅ›ci wewnÄ™trznej moÅ¼emy stosowaÄ‡ tylko wtedy,\ngdy jesteÅ›my pewni, Å¼e zasady poÅ¼yczania bÄ™dÄ… przestrzegane w czasie\nwykonania, mimo Å¼e kompilator nie moÅ¼e tego zagwarantowaÄ‡. Kod `unsafe` jest\nwtedy opakowany w bezpieczne API, a typ zewnÄ™trzny nadal pozostaje\niemutowalny.\n\nPrzyjrzyjmy siÄ™ tej koncepcji, badajÄ…c typ `RefCell<T>`, ktÃ³ry stosuje wzorzec\nmutowalnoÅ›ci wewnÄ™trznej.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"enforcing-borrowing-rules-at-runtime-with-refcellt\"></a>\n\n### Egzekwowanie zasad poÅ¼yczania w czasie wykonania\n\nW przeciwieÅ„stwie do `Rc<T>`, typ `RefCell<T>` reprezentuje pojedynczÄ… wÅ‚asnoÅ›Ä‡\ndanych, ktÃ³re przechowuje. Co zatem odrÃ³Å¼nia `RefCell<T>` od typu takiego jak\n`Box<T>`? Przypomnij sobie zasady poÅ¼yczania, ktÃ³rych nauczyÅ‚eÅ› siÄ™ w Rozdziale 4:\n\n- W dowolnym momencie moÅ¼esz mieÄ‡ _albo_ jednÄ… mutowalnÄ… referencjÄ™, _albo_ dowolnÄ…\n  liczbÄ™ niemutowalnych referencji (ale nie obie naraz).\n- Referencje muszÄ… byÄ‡ zawsze prawidÅ‚owe.\n\nW przypadku referencji i `Box<T>`, niezmienniki zasad poÅ¼yczania sÄ…\negzekwowane w czasie kompilacji. W przypadku `RefCell<T>` te niezmienniki sÄ…\negzekwowane _w czasie wykonania_. W przypadku referencji, jeÅ›li naruszysz te\nzasady, otrzymasz bÅ‚Ä…d kompilacji. W przypadku `RefCell<T>`, jeÅ›li naruszysz\nte zasady, TwÃ³j program zostanie przerwany (`panic`) i zakoÅ„czy dziaÅ‚anie.\n\nZaletami sprawdzania zasad poÅ¼yczania w czasie kompilacji sÄ… to, Å¼e bÅ‚Ä™dy\nzostanÄ… wykryte wczeÅ›niej w procesie rozwoju, a takÅ¼e brak wpÅ‚ywu na wydajnoÅ›Ä‡\nw czasie wykonania, poniewaÅ¼ caÅ‚a analiza jest zakoÅ„czona wczeÅ›niej. Z tych\npowodÃ³w sprawdzanie zasad poÅ¼yczania w czasie kompilacji jest najlepszym\nwyborem w wiÄ™kszoÅ›ci przypadkÃ³w, dlatego jest to domyÅ›lne zachowanie Rust.\n\nZaletÄ… sprawdzania zasad poÅ¼yczania w czasie wykonania jest to, Å¼e pozwala to\nna pewne scenariusze bezpieczne pod wzglÄ™dem pamiÄ™ci, ktÃ³re zostaÅ‚yby\nzabronione przez sprawdzenia w czasie kompilacji. Analiza statyczna, taka jak\nkompilator Rust, jest z natury konserwatywna. NiektÃ³re wÅ‚aÅ›ciwoÅ›ci kodu sÄ…\nniemoÅ¼liwe do wykrycia poprzez analizÄ™ kodu: NajsÅ‚ynniejszym przykÅ‚adem jest\nProblem Zatrzymania, ktÃ³ry wykracza poza zakres tej ksiÄ…Å¼ki, ale jest\nciekawym tematem do zbadania.\n\nPoniewaÅ¼ niektÃ³re analizy sÄ… niemoÅ¼liwe, jeÅ›li kompilator Rust nie moÅ¼e byÄ‡\npewien, Å¼e kod jest zgodny z zasadami wÅ‚asnoÅ›ci, moÅ¼e odrzuciÄ‡ poprawny\nprogram; w ten sposÃ³b jest konserwatywny. Gdyby Rust akceptowaÅ‚ niepoprawny\nprogram, uÅ¼ytkownicy nie mogliby ufaÄ‡ gwarancjom, jakie daje Rust. Jednak\njeÅ›li Rust odrzuci poprawny program, programista bÄ™dzie miaÅ‚ niedogodnoÅ›ci,\nale nic katastrofalnego nie moÅ¼e siÄ™ wydarzyÄ‡. Typ `RefCell<T>` jest uÅ¼yteczny,\ngdy jesteÅ› pewien, Å¼e TwÃ³j kod jest zgodny z zasadami poÅ¼yczania, ale\nkompilator nie jest w stanie tego zrozumieÄ‡ i zagwarantowaÄ‡.\n\nPodobnie jak `Rc<T>`, `RefCell<T>` jest przeznaczony wyÅ‚Ä…cznie do uÅ¼ytku w\nscenariuszach jednowÄ…tkowych i spowoduje bÅ‚Ä…d kompilacji, jeÅ›li sprÃ³bujesz go\nuÅ¼yÄ‡ w kontekÅ›cie wielowÄ…tkowym. O tym, jak uzyskaÄ‡ funkcjonalnoÅ›Ä‡ `RefCell<T>`\nw programie wielowÄ…tkowym, bÄ™dziemy rozmawiaÄ‡ w Rozdziale 16.\n\nOto podsumowanie powodÃ³w, dla ktÃ³rych warto wybraÄ‡ `Box<T>`, `Rc<T>` lub\n`RefCell<T>`:\n\n- `Rc<T>` umoÅ¼liwia wielu wÅ‚aÅ›cicieli tych samych danych; `Box<T>` i\n  `RefCell<T>` majÄ… pojedynczych wÅ‚aÅ›cicieli.\n- `Box<T>` pozwala na niemutowalne lub mutowalne poÅ¼yczenia sprawdzane w\n  czasie kompilacji; `Rc<T>` pozwala tylko na niemutowalne poÅ¼yczenia\n  sprawdzane w czasie kompilacji; `RefCell<T>` pozwala na niemutowalne lub\n  mutowalne poÅ¼yczenia sprawdzane w czasie wykonania.\n- PoniewaÅ¼ `RefCell<T>` pozwala na mutowalne poÅ¼yczenia sprawdzane w czasie\n  wykonania, moÅ¼esz modyfikowaÄ‡ wartoÅ›Ä‡ wewnÄ…trz `RefCell<T>`, nawet gdy\n  `RefCell<T>` jest niemutowalny.\n\nModyfikacja wartoÅ›ci wewnÄ…trz niemutowalnej wartoÅ›ci to wzorzec mutowalnoÅ›ci\nwewnÄ™trznej. Przyjrzyjmy siÄ™ sytuacji, w ktÃ³rej mutowalnoÅ›Ä‡ wewnÄ™trzna jest\nprzydatna i zbadajmy, jak jest to moÅ¼liwe.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"interior-mutability-a-mutable-borrow-to-an-immutable-value\"></a>\n\n### UÅ¼ycie mutowalnoÅ›ci wewnÄ™trznej\n\nKonsekwencjÄ… zasad poÅ¼yczania jest to, Å¼e gdy masz niemutowalnÄ… wartoÅ›Ä‡, nie\nmoÅ¼esz jej mutowalnie poÅ¼yczyÄ‡. Na przykÅ‚ad, ten kod siÄ™ nie skompiluje:\n\n```rust,ignore,does_not_compile\nfn main() {\n    let x = 5;\n    let y = &mut x;\n}\n```\n\nGdybyÅ› sprÃ³bowaÅ‚ skompilowaÄ‡ ten kod, otrzymaÅ‚byÅ› nastÄ™pujÄ…cy bÅ‚Ä…d:\n\n```console\n$ cargo run\n   Compiling borrowing v0.1.0 (file:///projects/borrowing)\nerror[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n --> src/main.rs:3:13\n  |\n3 |     let y = &mut x;\n  |             ^^^^^^ cannot borrow as mutable\n  |\nhelp: consider changing this to be mutable\n  |\n2 |     let mut x = 5;\n  |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `borrowing` (bin \"borrowing\") due to 1 previous error\n```\n\nIstniejÄ… jednak sytuacje, w ktÃ³rych byÅ‚oby przydatne, aby wartoÅ›Ä‡ mogÅ‚a\nmodyfikowaÄ‡ siÄ™ w swoich metodach, ale wydawaÅ‚a siÄ™ niemutowalna dla innego\nkodu. Kod poza metodami wartoÅ›ci nie mÃ³gÅ‚by modyfikowaÄ‡ wartoÅ›ci. UÅ¼ycie\n`RefCell<T>` jest jednym ze sposobÃ³w na uzyskanie zdolnoÅ›ci do mutowalnoÅ›ci\nwewnÄ™trznej, ale `RefCell<T>` nie omija caÅ‚kowicie zasad poÅ¼yczania: Sprawdzanie\npoÅ¼yczania w kompilatorze pozwala na tÄ™ mutowalnoÅ›Ä‡ wewnÄ™trznÄ…, a zasady\npoÅ¼yczania sÄ… sprawdzane w czasie wykonania. JeÅ›li naruszysz zasady,\notrzymasz `panic!` zamiast bÅ‚Ä™du kompilacji.\n\nPrzejdÅºmy przez praktyczny przykÅ‚ad, w ktÃ³rym moÅ¼emy uÅ¼yÄ‡ `RefCell<T>` do\nmodyfikacji niemutowalnej wartoÅ›ci i zobaczyÄ‡, dlaczego jest to przydatne.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"a-use-case-for-interior-mutability-mock-objects\"></a>\n\n#### Testowanie z obiektami mockowymi\n\nCzasami podczas testowania programista uÅ¼ywa jednego typu zamiast innego, aby\nobserwowaÄ‡ okreÅ›lone zachowanie i upewniÄ‡ siÄ™, Å¼e jest ono poprawnie\nzaimplementowane. Ten zastÄ™pczy typ nazywa siÄ™ _dublerem testowym_. PomyÅ›l o nim\nw sensie dublera kaskaderskiego w filmie, gdzie osoba wchodzi i zastÄ™puje\naktora, aby wykonaÄ‡ szczegÃ³lnie trudnÄ… scenÄ™. Dublery testowe zastÄ™pujÄ… inne\ntypy, gdy przeprowadzamy testy. _Obiekty mockowe_ to specyficzne typy\ndublerÃ³w testowych, ktÃ³re rejestrujÄ…, co dzieje siÄ™ podczas testu, aby moÅ¼na\nbyÅ‚o stwierdziÄ‡, Å¼e podjÄ™to prawidÅ‚owe dziaÅ‚ania.\n\nRust nie ma obiektÃ³w w tym samym sensie, co inne jÄ™zyki, i Rust nie ma funkcji\nobiektÃ³w mockowych wbudowanych w bibliotekÄ™ standardowÄ…, jak to robiÄ… niektÃ³re\ninne jÄ™zyki. MoÅ¼esz jednak z pewnoÅ›ciÄ… stworzyÄ‡ strukturÄ™, ktÃ³ra bÄ™dzie\nsÅ‚uÅ¼yÄ‡ tym samym celom, co obiekt mockowy.\n\nOto scenariusz, ktÃ³ry przetestujemy: stworzymy bibliotekÄ™, ktÃ³ra Å›ledzi\nwartoÅ›Ä‡ w stosunku do wartoÅ›ci maksymalnej i wysyÅ‚a wiadomoÅ›ci w zaleÅ¼noÅ›ci od\ntego, jak blisko wartoÅ›ci maksymalnej jest obecna wartoÅ›Ä‡. Ta biblioteka mogÅ‚aby\nbyÄ‡ uÅ¼ywana na przykÅ‚ad do Å›ledzenia limitu uÅ¼ytkownika na liczbÄ™ wywoÅ‚aÅ„ API,\nktÃ³re sÄ… dozwolone.\n\nNasza biblioteka bÄ™dzie zapewniaÄ‡ jedynie funkcjonalnoÅ›Ä‡ Å›ledzenia, jak blisko\nwartoÅ›ci maksymalnej jest wartoÅ›Ä‡ i jakie wiadomoÅ›ci powinny byÄ‡ wysyÅ‚ane w\ndanych momentach. Aplikacje korzystajÄ…ce z naszej biblioteki bÄ™dÄ… musiaÅ‚y\ndostarczyÄ‡ mechanizm wysyÅ‚ania wiadomoÅ›ci: Aplikacja moÅ¼e pokazaÄ‡ wiadomoÅ›Ä‡\nuÅ¼ytkownikowi bezpoÅ›rednio, wysÅ‚aÄ‡ e-mail, wysÅ‚aÄ‡ wiadomoÅ›Ä‡ tekstowÄ… lub zrobiÄ‡\ncokolwiek innego. Biblioteka nie musi znaÄ‡ tych szczegÃ³Å‚Ã³w. Potrzebuje tylko\nczegoÅ›, co implementuje cechÄ™, ktÃ³rÄ… dostarczymy, nazwanÄ… `Messenger`. Listing\n15-20 pokazuje kod biblioteki.\n\n<Listing number=\"15-20\" file-name=\"src/lib.rs\" caption=\"Biblioteka do Å›ledzenia, jak blisko wartoÅ›Ä‡ jest wartoÅ›ci maksymalnej i ostrzegania, gdy wartoÅ›Ä‡ osiÄ…ga pewne poziomy\">\n\n```rust,noplayground\npub trait Messenger {\n    fn send(&self, msg: &str);\n}\n\npub struct LimitTracker<'a, T: Messenger> {\n    messenger: &'a T,\n    value: usize,\n    max: usize,\n}\n\nimpl<'a, T> LimitTracker<'a, T>\nwhere\n    T: Messenger,\n{\n    pub fn new(messenger: &'a T, max: usize) -> LimitTracker<'a, T> {\n        LimitTracker {\n            messenger,\n            value: 0,\n            max,\n        }\n    }\n\n    pub fn set_value(&mut self, value: usize) {\n        self.value = value;\n\n        let percentage_of_max = self.value as f64 / self.max as f64;\n\n        if percentage_of_max >= 1.0 {\n            self.messenger.send(\"Error: You are over your quota!\");\n        } else if percentage_of_max >= 0.9 {\n            self.messenger\n                .send(\"Urgent warning: You've used up over 90% of your quota!\");\n        } else if percentage_of_max >= 0.75 {\n            self.messenger\n                .send(\"Warning: You've used up over 75% of your quota!\");\n        }\n    }\n}\n```\n\n</Listing>\n\nJednÄ… waÅ¼nÄ… czÄ™Å›ciÄ… tego kodu jest to, Å¼e cecha `Messenger` ma jednÄ… metodÄ™\no nazwie `send`, ktÃ³ra przyjmuje niemutowalnÄ… referencjÄ™ do `self` i tekst\nwiadomoÅ›ci. Ta cecha jest interfejsem, ktÃ³ry nasz obiekt mockowy musi\nimplementowaÄ‡, aby mock mÃ³gÅ‚ byÄ‡ uÅ¼ywany w ten sam sposÃ³b, co prawdziwy obiekt.\nDruga waÅ¼na czÄ™Å›Ä‡ to to, Å¼e chcemy przetestowaÄ‡ zachowanie metody `set_value`\nw `LimitTracker`. MoÅ¼emy zmieniÄ‡ to, co przekazujemy jako parametr `value`,\nale `set_value` nie zwraca niczego, na czym moglibyÅ›my oprzeÄ‡ asercje. Chcemy\nbyÄ‡ w stanie powiedzieÄ‡, Å¼e jeÅ›li utworzymy `LimitTracker` z czymÅ›, co\nimplementuje cechÄ™ `Messenger` i okreÅ›lonÄ… wartoÅ›ciÄ… dla `max`, to messenger\notrzymuje polecenie wysÅ‚ania odpowiednich wiadomoÅ›ci, gdy przekazujemy\nrÃ³Å¼ne liczby dla `value`.\n\nPotrzebujemy obiektu mockowego, ktÃ³ry zamiast wysyÅ‚aÄ‡ e-mail lub wiadomoÅ›Ä‡\ntekstowÄ… po wywoÅ‚aniu `send`, bÄ™dzie jedynie Å›ledziÅ‚ wiadomoÅ›ci, ktÃ³re mu\nkazano wysÅ‚aÄ‡. MoÅ¼emy utworzyÄ‡ nowÄ… instancjÄ™ obiektu mockowego, stworzyÄ‡\n`LimitTracker` uÅ¼ywajÄ…cy obiektu mockowego, wywoÅ‚aÄ‡ metodÄ™ `set_value` w\n`LimitTracker`, a nastÄ™pnie sprawdziÄ‡, czy obiekt mockowy zawiera wiadomoÅ›ci,\nktÃ³rych oczekujemy. Listing 15-21 pokazuje prÃ³bÄ™ zaimplementowania obiektu\nmockowego, ktÃ³ry ma to robiÄ‡, ale sprawdzajÄ…cy poÅ¼yczki na to nie zezwala.\n\n<Listing number=\"15-21\" file-name=\"src/lib.rs\" caption=\"PrÃ³ba zaimplementowania `MockMessenger`, ktÃ³ra nie jest dozwolona przez sprawdzajÄ…cego poÅ¼yczki\">\n\n```rust,ignore,does_not_compile\n# pub trait Messenger {\n#     fn send(&self, msg: &str);\n# }\n# \n# pub struct LimitTracker<'a, T: Messenger> {\n#     messenger: &'a T,\n#     value: usize,\n#     max: usize,\n# }\n# \n# impl<'a, T> LimitTracker<'a, T>\n# where\n#     T: Messenger,\n# {\n#     pub fn new(messenger: &'a T, max: usize) -> LimitTracker<'a, T> {\n#         LimitTracker {\n#             messenger,\n#             value: 0,\n#             max,\n#         }\n#     }\n# \n#     pub fn set_value(&mut self, value: usize) {\n#         self.value = value;\n# \n#         let percentage_of_max = self.value as f64 / self.max as f64;\n# \n#         if percentage_of_max >= 1.0 {\n#             self.messenger.send(\"Error: You are over your quota!\");\n#         } else if percentage_of_max >= 0.9 {\n#             self.messenger\n#                 .send(\"Urgent warning: You've used up over 90% of your quota!\");\n#         } else if percentage_of_max >= 0.75 {\n#             self.messenger\n#                 .send(\"Warning: You've used up over 75% of your quota!\");\n#         }\n#     }\n# }\n# \n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    struct MockMessenger {\n        sent_messages: Vec<String>,\n    }\n\n    impl MockMessenger {\n        fn new() -> MockMessenger {\n            MockMessenger {\n                sent_messages: vec![],\n            }\n        }\n    }\n\n    impl Messenger for MockMessenger {\n        fn send(&self, message: &str) {\n            self.sent_messages.push(String::from(message));\n        }\n    }\n\n    #[test]\n    fn it_sends_an_over_75_percent_warning_message() {\n        let mock_messenger = MockMessenger::new();\n        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);\n\n        limit_tracker.set_value(80);\n\n        assert_eq!(mock_messenger.sent_messages.len(), 1);\n    }\n}\n```\n\n</Listing>\n\nTen kod testowy definiuje strukturÄ™ `MockMessenger`, ktÃ³ra ma pole\n`sent_messages` z wektorem wartoÅ›ci `String`, aby Å›ledziÄ‡ wiadomoÅ›ci, ktÃ³re ma\nwysyÅ‚aÄ‡. Definiujemy rÃ³wnieÅ¼ skojarzonÄ… funkcjÄ™ `new`, aby uÅ‚atwiÄ‡ tworzenie\nnowych wartoÅ›ci `MockMessenger`, ktÃ³re zaczynajÄ… siÄ™ od pustej listy wiadomoÅ›ci.\nNastÄ™pnie implementujemy cechÄ™ `Messenger` dla `MockMessenger`, aby mÃ³c\nprzekazaÄ‡ `MockMessenger` do `LimitTracker`. W definicji metody `send`\npobieramy wiadomoÅ›Ä‡ przekazanÄ… jako parametr i przechowujemy jÄ… na liÅ›cie\n`sent_messages` `MockMessenger`.\n\nW teÅ›cie sprawdzamy, co dzieje siÄ™, gdy `LimitTracker` otrzymuje polecenie\nustawienia `value` na wartoÅ›Ä‡ wiÄ™kszÄ… niÅ¼ 75 procent wartoÅ›ci `max`. Najpierw\ntworzymy nowy `MockMessenger`, ktÃ³ry rozpocznie siÄ™ od pustej listy wiadomoÅ›ci.\nNastÄ™pnie tworzymy nowy `LimitTracker` i przekazujemy mu referencjÄ™ do nowego\nobiektu `MockMessenger` oraz wartoÅ›Ä‡ `max` rÃ³wnÄ… `100`. WywoÅ‚ujemy metodÄ™\n`set_value` w `LimitTracker` z wartoÅ›ciÄ… `80`, co stanowi ponad 75 procent z\n100. NastÄ™pnie twierdzimy, Å¼e lista wiadomoÅ›ci Å›ledzonych przez\n`MockMessenger` powinna teraz zawieraÄ‡ jednÄ… wiadomoÅ›Ä‡.\n\nJest jednak jeden problem z tym testem, jak pokazano tutaj:\n\n```console\n$ cargo test\n   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)\nerror[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&` reference\n  --> src/lib.rs:58:13\n   |\n58 |             self.sent_messages.push(String::from(message));\n   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n   |\nhelp: consider changing this to be a mutable reference in the `impl` method and the `trait` definition\n   |\n 2 ~     fn send(&mut self, msg: &str);\n 3 | }\n...\n56 |     impl Messenger for MockMessenger {\n57 ~         fn send(&mut self, message: &str) {\n   |\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `limit-tracker` (lib test) due to 1 previous error\n```\n\nNie moÅ¼emy modyfikowaÄ‡ `MockMessenger`, aby Å›ledziÅ‚ wiadomoÅ›ci, poniewaÅ¼\nmetoda `send` przyjmuje niemutowalnÄ… referencjÄ™ do `self`. Nie moÅ¼emy rÃ³wnieÅ¼\nskorzystaÄ‡ z sugestii komunikatu o bÅ‚Ä™dzie, aby uÅ¼yÄ‡ `&mut self` zarÃ³wno w\nmetodzie `impl`, jak i w definicji cechy. Nie chcemy zmieniaÄ‡ cechy `Messenger`\nwyÅ‚Ä…cznie dla celÃ³w testowania. Zamiast tego musimy znaleÅºÄ‡ sposÃ³b, aby nasz\nkod testowy dziaÅ‚aÅ‚ poprawnie z naszym istniejÄ…cym projektem.\n\nTo sytuacja, w ktÃ³rej mutowalnoÅ›Ä‡ wewnÄ™trzna moÅ¼e pomÃ³c! BÄ™dziemy\nprzechowywaÄ‡ `sent_messages` wewnÄ…trz `RefCell<T>`, a nastÄ™pnie metoda `send`\nbÄ™dzie mogÅ‚a modyfikowaÄ‡ `sent_messages` w celu przechowywania widzianych przez\nnas wiadomoÅ›ci. Listing 15-22 pokazuje, jak to wyglÄ…da.\n\n<Listing number=\"15-22\" file-name=\"src/lib.rs\" caption=\"UÅ¼ycie `RefCell<T>` do mutowania wewnÄ™trznej wartoÅ›ci, podczas gdy wartoÅ›Ä‡ zewnÄ™trzna jest uwaÅ¼ana za niemutowalnÄ…\">\n\n```rust,noplayground\n# pub trait Messenger {\n#     fn send(&self, msg: &str);\n# }\n# \n# pub struct LimitTracker<'a, T: Messenger> {\n#     messenger: &'a T,\n#     value: usize,\n#     max: usize,\n# }\n# \n# impl<'a, T> LimitTracker<'a, T>\n# where\n#     T: Messenger,\n# {\n#     pub fn new(messenger: &'a T, max: usize) -> LimitTracker<'a, T> {\n#         LimitTracker {\n#             messenger,\n#             value: 0,\n#             max,\n#         }\n#     }\n# \n#     pub fn set_value(&mut self, value: usize) {\n#         self.value = value;\n# \n#         let percentage_of_max = self.value as f64 / self.max as f64;\n# \n#         if percentage_of_max >= 1.0 {\n#             self.messenger.send(\"Error: You are over your quota!\");\n#         } else if percentage_of_max >= 0.9 {\n#             self.messenger\n#                 .send(\"Urgent warning: You've used up over 90% of your quota!\");\n#         } else if percentage_of_max >= 0.75 {\n#             self.messenger\n#                 .send(\"Warning: You've used up over 75% of your quota!\");\n#         }\n#     }\n# }\n# \n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::cell::RefCell;\n\n    struct MockMessenger {\n        sent_messages: RefCell<Vec<String>>,\n    }\n\n    impl MockMessenger {\n        fn new() -> MockMessenger {\n            MockMessenger {\n                sent_messages: RefCell::new(vec![]),\n            }\n        }\n    }\n\n    impl Messenger for MockMessenger {\n        fn send(&self, message: &str) {\n            self.sent_messages.borrow_mut().push(String::from(message));\n        }\n    }\n\n    #[test]\n    fn it_sends_an_over_75_percent_warning_message() {\n        // --snip--\n#         let mock_messenger = MockMessenger::new();\n#         let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);\n# \n#         limit_tracker.set_value(80);\n\n        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);\n    }\n}\n```\n\n</Listing>\n\nPole `sent_messages` jest teraz typu `RefCell<Vec<String>>` zamiast\n`Vec<String>`. W funkcji `new` tworzymy nowÄ… instancjÄ™ `RefCell<Vec<String>>`\nwokÃ³Å‚ pustego wektora.\n\nDla implementacji metody `send` pierwszy parametr nadal jest niemutowalnym\npoÅ¼yczeniem `self`, co odpowiada definicji cechy. WywoÅ‚ujemy `borrow_mut` na\n`RefCell<Vec<String>>` w `self.sent_messages`, aby uzyskaÄ‡ mutowalnÄ… referencjÄ™\ndo wartoÅ›ci wewnÄ…trz `RefCell<Vec<String>>`, ktÃ³ra jest wektorem. NastÄ™pnie\nmoÅ¼emy wywoÅ‚aÄ‡ `push` na mutowalnej referencji do wektora, aby Å›ledziÄ‡ wiadomoÅ›ci\nwysÅ‚ane podczas testu.\n\nOstatnia zmiana, jakÄ… musimy wprowadziÄ‡, dotyczy asercji: aby sprawdziÄ‡, ile\nelementÃ³w jest w wewnÄ™trznym wektorze, wywoÅ‚ujemy `borrow` na\n`RefCell<Vec<String>>`, aby uzyskaÄ‡ niemutowalnÄ… referencjÄ™ do wektora.\n\nTeraz, gdy widziaÅ‚eÅ›, jak uÅ¼ywaÄ‡ `RefCell<T>`, zagÅ‚Ä™bmy siÄ™ w to, jak to dziaÅ‚a!\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"keeping-track-of-borrows-at-runtime-with-refcellt\"></a>\n\n#### Åšledzenie poÅ¼yczeÅ„ w czasie wykonania\n\nPodczas tworzenia niemutowalnych i mutowalnych referencji uÅ¼ywamy odpowiednio\nskÅ‚adni `&` i `&mut`. W przypadku `RefCell<T>` uÅ¼ywamy metod `borrow` i\n`borrow_mut`, ktÃ³re sÄ… czÄ™Å›ciÄ… bezpiecznego API naleÅ¼Ä…cego do `RefCell<T>`. Metoda\n`borrow` zwraca typ wskaÅºnika sprytnego `Ref<T>`, a `borrow_mut` zwraca typ\nwskaÅºnika sprytnego `RefMut<T>`. Oba typy implementujÄ… `Deref`, wiÄ™c moÅ¼emy je\ntraktowaÄ‡ jak zwykÅ‚e referencje.\n\n`RefCell<T>` Å›ledzi, ile wskaÅºnikÃ³w sprytnych `Ref<T>` i `RefMut<T>` jest\naktywnie uÅ¼ywanych. Za kaÅ¼dym razem, gdy wywoÅ‚ujemy `borrow`, `RefCell<T>`\nzwiÄ™ksza licznik aktywnych niemutowalnych poÅ¼yczeÅ„. Gdy wartoÅ›Ä‡ `Ref<T>` wyjdzie\npoza zakres, licznik niemutowalnych poÅ¼yczeÅ„ zmniejsza siÄ™ o 1. Podobnie jak\nzasady poÅ¼yczania w czasie kompilacji, `RefCell<T>` pozwala nam na wiele\nniemutowalnych poÅ¼yczeÅ„ lub jedno mutowalne poÅ¼yczenie w dowolnym momencie.\n\nJeÅ›li sprÃ³bujemy naruszyÄ‡ te zasady, zamiast otrzymania bÅ‚Ä™du kompilacji, jak\nmiaÅ‚oby to miejsce w przypadku referencji, implementacja `RefCell<T>` spowoduje\npanikÄ™ w czasie wykonania. Listing 15-23 pokazuje modyfikacjÄ™ implementacji\n`send` z Listingu 15-22. Celowo prÃ³bujemy stworzyÄ‡ dwa mutowalne poÅ¼yczenia\naktywne w tym samym zakresie, aby zilustrowaÄ‡, Å¼e `RefCell<T>` zapobiega temu\nw czasie wykonania.\n\n<Listing number=\"15-23\" file-name=\"src/lib.rs\" caption=\"Tworzenie dwÃ³ch mutowalnych referencji w tym samym zakresie, aby zobaczyÄ‡, Å¼e `RefCell<T>` spowoduje panikÄ™\">\n\n```rust,ignore,panics\n# pub trait Messenger {\n#     fn send(&self, msg: &str);\n# }\n# \n# pub struct LimitTracker<'a, T: Messenger> {\n#     messenger: &'a T,\n#     value: usize,\n#     max: usize,\n# }\n# \n# impl<'a, T> LimitTracker<'a, T>\n# where\n#     T: Messenger,\n# {\n#     pub fn new(messenger: &'a T, max: usize) -> LimitTracker<'a, T> {\n#         LimitTracker {\n#             messenger,\n#             value: 0,\n#             max,\n#         }\n#     }\n# \n#     pub fn set_value(&mut self, value: usize) {\n#         self.value = value;\n# \n#         let percentage_of_max = self.value as f64 / self.max as f64;\n# \n#         if percentage_of_max >= 1.0 {\n#             self.messenger.send(\"Error: You are over your quota!\");\n#         } else if percentage_of_max >= 0.9 {\n#             self.messenger\n#                 .send(\"Urgent warning: You've used up over 90% of your quota!\");\n#         } else if percentage_of_max >= 0.75 {\n#             self.messenger\n#                 .send(\"Warning: You've used up over 75% of your quota!\");\n#         }\n#     }\n# }\n# \n# #[cfg(test)]\n# mod tests {\n#     use super::*;\n#     use std::cell::RefCell;\n# \n#     struct MockMessenger {\n#         sent_messages: RefCell<Vec<String>>,\n#     }\n# \n#     impl MockMessenger {\n#         fn new() -> MockMessenger {\n#             MockMessenger {\n#                 sent_messages: RefCell::new(vec![]),\n#             }\n#         }\n#     }\n# \n    impl Messenger for MockMessenger {\n        fn send(&self, message: &str) {\n            let mut one_borrow = self.sent_messages.borrow_mut();\n            let mut two_borrow = self.sent_messages.borrow_mut();\n\n            one_borrow.push(String::from(message));\n            two_borrow.push(String::from(message));\n        }\n    }\n# \n#     #[test]\n#     fn it_sends_an_over_75_percent_warning_message() {\n#         let mock_messenger = MockMessenger::new();\n#         let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);\n# \n#         limit_tracker.set_value(80);\n# \n#         assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);\n#     }\n# }\n```\n\n</Listing>\n\nTworzymy zmiennÄ… `one_borrow` dla wskaÅºnika sprytnego `RefMut<T>` zwrÃ³conego\nprzez `borrow_mut`. NastÄ™pnie tworzymy kolejne mutowalne poÅ¼yczenie w ten sam\nsposÃ³b w zmiennej `two_borrow`. Tworzy to dwie mutowalne referencje w tym samym\nzakresie, co jest niedozwolone. Kiedy uruchomimy testy dla naszej biblioteki,\nkod z Listingu 15-23 skompiluje siÄ™ bez bÅ‚Ä™dÃ³w, ale test siÄ™ nie powiedzie:\n\n```console\n$ cargo test\n   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s\n     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)\n\nrunning 1 test\ntest tests::it_sends_an_over_75_percent_warning_message ... FAILED\n\nfailures:\n\n---- tests::it_sends_an_over_75_percent_warning_message stdout ----\n\nthread 'tests::it_sends_an_over_75_percent_warning_message' panicked at src/lib.rs:60:53:\nRefCell already borrowed\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::it_sends_an_over_75_percent_warning_message\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n```\n\nZauwaÅ¼, Å¼e kod spowodowaÅ‚ panikÄ™ z komunikatem `already borrowed:\nBorrowMutError`. W ten sposÃ³b `RefCell<T>` obsÅ‚uguje naruszenia zasad\npoÅ¼yczania w czasie wykonania.\n\nDecyzja o wychwytywaniu bÅ‚Ä™dÃ³w poÅ¼yczania w czasie wykonania, a nie w czasie\nkompilacji, jak to zrobiliÅ›my tutaj, oznacza, Å¼e potencjalnie moÅ¼esz\nznajdowaÄ‡ bÅ‚Ä™dy w swoim kodzie pÃ³Åºniej w procesie rozwoju: byÄ‡ moÅ¼e dopiero po\nwdroÅ¼eniu kodu do produkcji. Ponadto, TwÃ³j kod poniesie niewielkÄ… karÄ™\nwydajnoÅ›ciowÄ… w czasie wykonania w wyniku Å›ledzenia poÅ¼yczeÅ„ w czasie\nwykonania, a nie w czasie kompilacji. JednakÅ¼e, uÅ¼ycie `RefCell<T>` umoÅ¼liwia\nnapisanie obiektu mockowego, ktÃ³ry moÅ¼e modyfikowaÄ‡ siÄ™, aby Å›ledziÄ‡\nwiadomoÅ›ci, ktÃ³re widziaÅ‚, podczas gdy uÅ¼ywasz go w kontekÅ›cie, w ktÃ³rym\ndozwolone sÄ… tylko niemutowalne wartoÅ›ci. MoÅ¼esz uÅ¼ywaÄ‡ `RefCell<T>` pomimo\njego kompromisÃ³w, aby uzyskaÄ‡ wiÄ™kszÄ… funkcjonalnoÅ›Ä‡ niÅ¼ zapewniajÄ… zwykÅ‚e\nreferencje.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"having-multiple-owners-of-mutable-data-by-combining-rc-t-and-ref-cell-t\"></a>\n<a id=\"allowing-multiple-owners-of-mutable-data-with-rct-and-refcellt\"></a>\n\n### Zezwalanie na wielu wÅ‚aÅ›cicieli mutowalnych danych\n\nCzÄ™stym sposobem uÅ¼ycia `RefCell<T>` jest poÅ‚Ä…czenie go z `Rc<T>`. Przypomnijmy,\nÅ¼e `Rc<T>` pozwala na posiadanie wielu wÅ‚aÅ›cicieli danych, ale daje dostÄ™p do\ntych danych tylko w trybie niemutowalnym. JeÅ›li masz `Rc<T>`, ktÃ³ry zawiera\n`RefCell<T>`, moÅ¼esz uzyskaÄ‡ wartoÅ›Ä‡, ktÃ³ra moÅ¼e mieÄ‡ wielu wÅ‚aÅ›cicieli _i_ ktÃ³rÄ…\nmoÅ¼esz modyfikowaÄ‡!\n\nNa przykÅ‚ad, przypomnij sobie przykÅ‚ad listy konsensusowej z Listingu 15-18,\nw ktÃ³rym uÅ¼yliÅ›my `Rc<T>`, aby umoÅ¼liwiÄ‡ wielu listom wspÃ³Å‚dzielenie wÅ‚asnoÅ›ci\ninnej listy. PoniewaÅ¼ `Rc<T>` przechowuje tylko niemutowalne wartoÅ›ci, nie moÅ¼emy\nzmieniÄ‡ Å¼adnej z wartoÅ›ci na liÅ›cie po ich utworzeniu. Dodajmy `RefCell<T>`,\naby mÃ³c zmieniaÄ‡ wartoÅ›ci na listach. Listing 15-24 pokazuje, Å¼e uÅ¼ywajÄ…c\n`RefCell<T>` w definicji `Cons`, moÅ¼emy modyfikowaÄ‡ wartoÅ›Ä‡ przechowywanÄ… we\nwszystkich listach.\n\n<Listing number=\"15-24\" file-name=\"src/main.rs\" caption=\"UÅ¼ycie `Rc<RefCell<i32>>` do stworzenia mutowalnej `List`\">\n\n```rust\n#[derive(Debug)]\nenum List {\n    Cons(Rc<RefCell<i32>>, Rc<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nfn main() {\n    let value = Rc::new(RefCell::new(5));\n\n    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));\n\n    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));\n    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));\n\n    *value.borrow_mut() += 10;\n\n    println!(\"a after = {a:?}\");\n    println!(\"b after = {b:?}\");\n    println!(\"c after = {c:?}\");\n}\n```\n\n</Listing>\n\nTworzymy wartoÅ›Ä‡, ktÃ³ra jest instancjÄ… `Rc<RefCell<i32>>` i przechowujemy jÄ…\nw zmiennej o nazwie `value`, abyÅ›my mogli uzyskaÄ‡ do niej bezpoÅ›redni dostÄ™p\npÃ³Åºniej. NastÄ™pnie tworzymy `List` w `a` z wariantem `Cons`, ktÃ³ry przechowuje\n`value`. Musimy sklonowaÄ‡ `value`, aby zarÃ³wno `a`, jak i `value` posiadaÅ‚y\nwÅ‚asnoÅ›Ä‡ wewnÄ™trznej wartoÅ›ci `5`, zamiast przenosiÄ‡ wÅ‚asnoÅ›Ä‡ z `value` do `a`\nlub aby `a` poÅ¼yczaÅ‚o z `value`.\n\nOpakowujemy listÄ™ `a` w `Rc<T>`, aby po utworzeniu list `b` i `c` obie mogÅ‚y\nodnosiÄ‡ siÄ™ do `a`, co zrobiliÅ›my w Listingu 15-18.\n\nPo utworzeniu list w `a`, `b` i `c`, chcemy dodaÄ‡ 10 do wartoÅ›ci w `value`. Robimy\nto, wywoÅ‚ujÄ…c `borrow_mut` na `value`, co wykorzystuje funkcjÄ™ automatycznego\nrozpoÅ¼yczania, ktÃ³rÄ… omÃ³wiliÅ›my w [â€Gdzie jest operator `->`?â€][wheres-the---operator]<!-- ignore -->\nw Rozdziale 5, aby rozpoÅ¼yczyÄ‡ `Rc<T>` do wewnÄ™trznej wartoÅ›ci `RefCell<T>`. Metoda\n`borrow_mut` zwraca wskaÅºnik sprytny `RefMut<T>`, a my uÅ¼ywamy na nim operatora\nrozpoÅ¼yczania i zmieniamy wewnÄ™trznÄ… wartoÅ›Ä‡.\n\nKiedy wypiszemy `a`, `b` i `c`, widzimy, Å¼e wszystkie majÄ… zmodyfikowanÄ…\nwartoÅ›Ä‡ `15` zamiast `5`:\n\n```console\n$ cargo run\n   Compiling cons-list v0.1.0 (file:///projects/cons-list)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.63s\n     Running `target/debug/cons-list`\na after = Cons(RefCell { value: 15 }, Nil)\nb after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))\nc after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))\n```\n\nTa technika jest caÅ‚kiem sprytna! UÅ¼ywajÄ…c `RefCell<T>`, mamy zewnÄ™trznie\nniemutowalnÄ… wartoÅ›Ä‡ `List`. Ale moÅ¼emy uÅ¼yÄ‡ metod `RefCell<T>`, ktÃ³re zapewniajÄ…\ndostÄ™p do jego wewnÄ™trznej mutowalnoÅ›ci, dziÄ™ki czemu moÅ¼emy modyfikowaÄ‡ nasze\ndane, gdy tego potrzebujemy. Sprawdzenia zasad poÅ¼yczania w czasie wykonania\nchroniÄ… nas przed wyÅ›cigami danych, a czasami warto poÅ›wiÄ™ciÄ‡ trochÄ™ szybkoÅ›ci\ndla tej elastycznoÅ›ci w naszych strukturach danych. ZauwaÅ¼, Å¼e `RefCell<T>`\nnie dziaÅ‚a w kodzie wielowÄ…tkowym! `Mutex<T>` to wersja `RefCell<T>` bezpieczna\nwielowÄ…tkowo, a o `Mutex<T>` bÄ™dziemy rozmawiaÄ‡ w Rozdziale 16.\n\n[wheres-the---operator]: ch05-03-method-syntax.html#wheres-the---operator",
        "chapter_title": "`RefCell<T>` i wzorzec mutowalnoÅ›ci wewnÄ™trznej"
    },
    {
        "file_path": "ch15-06-reference-cycles.md",
        "content": "## Cykle referencji mogÄ… prowadziÄ‡ do wyciekÃ³w pamiÄ™ci\n\nGwarancje bezpieczeÅ„stwa pamiÄ™ci w Rust sprawiajÄ…, Å¼e trudno, ale nie jest\nniemoÅ¼liwe, przypadkowe tworzenie pamiÄ™ci, ktÃ³ra nigdy nie jest zwalniana (znane\njako _wyciek pamiÄ™ci_). CaÅ‚kowite zapobieganie wyciekom pamiÄ™ci nie jest jednÄ…\nz gwarancji Rust, co oznacza, Å¼e wycieki pamiÄ™ci sÄ… bezpieczne w Rust. MoÅ¼emy\nzobaczyÄ‡, Å¼e Rust dopuszcza wycieki pamiÄ™ci, uÅ¼ywajÄ…c `Rc<T>` i `RefCell<T>`:\nMoÅ¼liwe jest tworzenie referencji, w ktÃ³rych elementy odwoÅ‚ujÄ… siÄ™ do siebie\nw cyklu. Tworzy to wycieki pamiÄ™ci, poniewaÅ¼ licznik referencji kaÅ¼dego\nelementu w cyklu nigdy nie osiÄ…gnie 0, a wartoÅ›ci nigdy nie zostanÄ… usuniÄ™te.\n\n### Tworzenie cyklu referencji\n\nPrzyjrzyjmy siÄ™, jak moÅ¼e powstaÄ‡ cykl referencji i jak mu zapobiec, zaczynajÄ…c\nod definicji enum `List` i metody `tail` w Listingu 15-25.\n\n<Listing number=\"15-25\" file-name=\"src/main.rs\" caption=\"Definicja listy konsensusowej, ktÃ³ra przechowuje `RefCell<T>`, abyÅ›my mogli modyfikowaÄ‡ to, do czego odwoÅ‚uje siÄ™ wariant `Cons`\">\n\n```rust\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nenum List {\n    Cons(i32, RefCell<Rc<List>>),\n    Nil,\n}\n\nimpl List {\n    fn tail(&self) -> Option<&RefCell<Rc<List>>> {\n        match self {\n            Cons(_, item) => Some(item),\n            Nil => None,\n        }\n    }\n}\n# \n# fn main() {}\n```\n\n</Listing>\n\nUÅ¼ywamy kolejnej wariacji definicji `List` z Listingu 15-5. Drugi element\nwariantu `Cons` to teraz `RefCell<Rc<List>>`, co oznacza, Å¼e zamiast moÅ¼liwoÅ›ci\nmodyfikacji wartoÅ›ci `i32`, jak to robiliÅ›my w Listingu 15-24, chcemy\nmodyfikowaÄ‡ wartoÅ›Ä‡ `List`, na ktÃ³rÄ… wskazuje wariant `Cons`. Dodajemy rÃ³wnieÅ¼\nmetodÄ™ `tail`, aby uÅ‚atwiÄ‡ nam dostÄ™p do drugiego elementu, jeÅ›li mamy wariant\n`Cons`.\n\nW Listingu 15-26 dodajemy funkcjÄ™ `main`, ktÃ³ra uÅ¼ywa definicji z Listingu\n15-25. Ten kod tworzy listÄ™ w `a` i listÄ™ w `b`, ktÃ³ra wskazuje na listÄ™ w `a`.\nNastÄ™pnie modyfikuje listÄ™ w `a`, aby wskazywaÅ‚a na `b`, tworzÄ…c cykl\nreferencji. Po drodze znajdujÄ… siÄ™ instrukcje `println!`, aby pokazaÄ‡, jakie\nsÄ… liczniki referencji w rÃ³Å¼nych punktach tego procesu.\n\n<Listing number=\"15-26\" file-name=\"src/main.rs\" caption=\"Tworzenie cyklu referencji dwÃ³ch wartoÅ›ci `List` wskazujÄ…cych na siebie nawzajem\">\n\n```rust\n# use crate::List::{Cons, Nil};\n# use std::cell::RefCell;\n# use std::rc::Rc;\n# \n# #[derive(Debug)]\n# enum List {\n#     Cons(i32, RefCell<Rc<List>>),\n#     Nil,\n# }\n# \n# impl List {\n#     fn tail(&self) -> Option<&RefCell<Rc<List>>> {\n#         match self {\n#             Cons(_, item) => Some(item),\n#             Nil => None,\n#         }\n#     }\n# }\n# \nfn main() {\n    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));\n\n    println!(\"a initial rc count = {}\", Rc::strong_count(&a));\n    println!(\"a next item = {:?}\", a.tail());\n\n    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));\n\n    println!(\"a rc count after b creation = {}\", Rc::strong_count(&a));\n    println!(\"b initial rc count = {}\", Rc::strong_count(&b));\n    println!(\"b next item = {:?}\", b.tail());\n\n    if let Some(link) = a.tail() {\n        *link.borrow_mut() = Rc::clone(&b);\n    }\n\n    println!(\"b rc count after changing a = {}\", Rc::strong_count(&b));\n    println!(\"a rc count after changing a = {}\", Rc::strong_count(&a));\n\n    // Uncomment the next line to see that we have a cycle;\n    // it will overflow the stack.\n    // println!(\"a next item = {:?}\", a.tail());\n}\n```\n\n</Listing>\n\nTworzymy instancjÄ™ `Rc<List>` przechowujÄ…cÄ… wartoÅ›Ä‡ `List` w zmiennej `a` z\npoczÄ…tkowÄ… listÄ… `5, Nil`. NastÄ™pnie tworzymy instancjÄ™ `Rc<List>` przechowujÄ…cÄ…\ninna wartoÅ›Ä‡ `List` w zmiennej `b`, ktÃ³ra zawiera wartoÅ›Ä‡ `10` i wskazuje na\nlistÄ™ w `a`.\n\nModyfikujemy `a` tak, aby wskazywaÅ‚a na `b` zamiast `Nil`, tworzÄ…c cykl.\nRobimy to, uÅ¼ywajÄ…c metody `tail` do uzyskania referencji do\n`RefCell<Rc<List>>` w `a`, ktÃ³rÄ… umieszczamy w zmiennej `link`. NastÄ™pnie\nuÅ¼ywamy metody `borrow_mut` w `RefCell<Rc<List>>`, aby zmieniÄ‡ wewnÄ™trznÄ…\nwartoÅ›Ä‡ z `Rc<List>`, ktÃ³ra przechowuje wartoÅ›Ä‡ `Nil`, na `Rc<List>` w `b`.\n\nPo uruchomieniu tego kodu, z pominiÄ™ciem ostatniego `println!` na razie,\notrzymamy nastÄ™pujÄ…cy wynik:\n\n```console\n$ cargo run\n   Compiling cons-list v0.1.0 (file:///projects/cons-list)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.53s\n     Running `target/debug/cons-list`\na initial rc count = 1\na next item = Some(RefCell { value: Nil })\na rc count after b creation = 2\nb initial rc count = 1\nb next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })\nb rc count after changing a = 2\na rc count after changing a = 2\n```\n\nLicznik referencji instancji `Rc<List>` zarÃ³wno w `a`, jak i `b` wynosi 2 po\nzmianie listy w `a` na wskazujÄ…cÄ… na `b`. Na koÅ„cu `main` Rust usuwa zmiennÄ…\n`b`, co zmniejsza licznik referencji instancji `Rc<List>` z `b` z 2 do 1.\nPamiÄ™Ä‡, ktÃ³rÄ… `Rc<List>` ma na stercie, nie zostanie w tym momencie usuniÄ™ta,\nponiewaÅ¼ jej licznik referencji wynosi 1, a nie 0. NastÄ™pnie Rust usuwa `a`, co\nzmniejsza licznik referencji instancji `Rc<List>` z `a` rÃ³wnieÅ¼ z 2 do 1.\nPamiÄ™Ä‡ tej instancji rÃ³wnieÅ¼ nie moÅ¼e zostaÄ‡ usuniÄ™ta, poniewaÅ¼ inna instancja\n`Rc<List>` nadal siÄ™ do niej odwoÅ‚uje. PamiÄ™Ä‡ alokowana na listÄ™ pozostanie\nniezebrana na zawsze. Aby zwizualizowaÄ‡ ten cykl referencji, stworzyliÅ›my\ndiagram na Rysunku 15-4.\n\n<img alt=\"A rectangle labeled 'a' that points to a rectangle containing the integer 5. A rectangle labeled 'b' that points to a rectangle containing the integer 10. The rectangle containing 5 points to the rectangle containing 10, and the rectangle containing 10 points back to the rectangle containing 5, creating a cycle.\" src=\"img/trpl15-04.svg\" class=\"center\" />\n\n<span class=\"caption\">Rysunek 15-4: Cykl referencji list `a` i `b`\nwskazujÄ…cych na siebie nawzajem</span>\n\nJeÅ›li odkomentujesz ostatniÄ… instrukcjÄ™ `println!` i uruchomisz program, Rust\nsprÃ³buje wypisaÄ‡ ten cykl, w ktÃ³rym `a` wskazuje na `b`, `b` na `a` i tak dalej,\naÅ¼ do przepeÅ‚nienia stosu.\n\nW porÃ³wnaniu do rzeczywistego programu, konsekwencje tworzenia cyklu referencji\nw tym przykÅ‚adzie nie sÄ… bardzo powaÅ¼ne: zaraz po utworzeniu cyklu referencji\nprogram siÄ™ koÅ„czy. JednakÅ¼e, jeÅ›li bardziej zÅ‚oÅ¼ony program alokowaÅ‚by duÅ¼o\npamiÄ™ci w cyklu i utrzymywaÅ‚ jÄ… przez dÅ‚ugi czas, program zuÅ¼ywaÅ‚by wiÄ™cej\npamiÄ™ci niÅ¼ potrzebowaÅ‚ i mÃ³gÅ‚by przeciÄ…Å¼yÄ‡ system, powodujÄ…c wyczerpanie\ndostÄ™pnej pamiÄ™ci.\n\nTworzenie cykli referencji nie jest Å‚atwe, ale teÅ¼ nie niemoÅ¼liwe. JeÅ›li masz\nwartoÅ›ci `RefCell<T>`, ktÃ³re zawierajÄ… wartoÅ›ci `Rc<T>` lub podobne zagnieÅ¼dÅ¼one\npoÅ‚Ä…czenia typÃ³w z mutowalnoÅ›ciÄ… wewnÄ™trznÄ… i zliczaniem referencji, musisz\nzapewniÄ‡, Å¼e nie tworzysz cykli; nie moÅ¼esz polegaÄ‡ na Rust w ich\nwykrywaniu. Tworzenie cyklu referencji byÅ‚oby bÅ‚Ä™dem logicznym w twoim\nprogramie, ktÃ³ry powinieneÅ› minimalizowaÄ‡ za pomocÄ… automatycznych testÃ³w,\nprzeglÄ…dÃ³w kodu i innych praktyk rozwoju oprogramowania.\n\nInnym rozwiÄ…zaniem pozwalajÄ…cym uniknÄ…Ä‡ cykli referencji jest reorganizacja\nstruktur danych tak, aby niektÃ³re referencje wyraÅ¼aÅ‚y wÅ‚asnoÅ›Ä‡, a inne nie.\nW rezultacie moÅ¼esz mieÄ‡ cykle skÅ‚adajÄ…ce siÄ™ z relacji wÅ‚asnoÅ›ci i relacji\nbraku wÅ‚asnoÅ›ci, a tylko relacje wÅ‚asnoÅ›ci wpÅ‚ywajÄ… na to, czy wartoÅ›Ä‡ moÅ¼e\nzostaÄ‡ usuniÄ™ta. W Listingu 15-25 zawsze chcemy, aby warianty `Cons` posiadaÅ‚y\nswojÄ… listÄ™, wiÄ™c reorganizacja struktury danych nie jest moÅ¼liwa.\nPrzyjrzyjmy siÄ™ przykÅ‚adowi uÅ¼ywajÄ…cemu grafÃ³w skÅ‚adajÄ…cych siÄ™ z wÄ™zÅ‚Ã³w\nrodzicielskich i wÄ™zÅ‚Ã³w potomnych, aby zobaczyÄ‡, kiedy relacje braku wÅ‚asnoÅ›ci\nsÄ… odpowiednim sposobem na zapobieganie cyklom referencji.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"preventing-reference-cycles-turning-an-rct-into-a-weakt\"></a>\n\n### Zapobieganie cyklom referencji za pomocÄ… `Weak<T>`\n\nDo tej pory wykazaliÅ›my, Å¼e wywoÅ‚anie `Rc::clone` zwiÄ™ksza `strong_count`\ninstancji `Rc<T>`, a instancja `Rc<T>` jest usuwana tylko, jeÅ›li jej\n`strong_count` wynosi 0. MoÅ¼esz rÃ³wnieÅ¼ utworzyÄ‡ sÅ‚abÄ… referencjÄ™ do wartoÅ›ci\nw instancji `Rc<T>`, wywoÅ‚ujÄ…c `Rc::downgrade` i przekazujÄ…c referencjÄ™ do\n`Rc<T>`. *Silne referencje* to sposÃ³b na wspÃ³Å‚dzielenie wÅ‚asnoÅ›ci instancji\n`Rc<T>`. *SÅ‚abe referencje* nie wyraÅ¼ajÄ… relacji wÅ‚asnoÅ›ci, a ich licznik nie\nwpÅ‚ywa na to, kiedy instancja `Rc<T>` jest usuwana. Nie spowodujÄ… one cyklu\nreferencji, poniewaÅ¼ kaÅ¼dy cykl zawierajÄ…cy sÅ‚abe referencje zostanie przerwany,\ngdy silny licznik referencji wartoÅ›ci w nim zaangaÅ¼owanych osiÄ…gnie 0.\n\nKiedy wywoÅ‚ujesz `Rc::downgrade`, otrzymujesz wskaÅºnik sprytny typu `Weak<T>`.\nZamiast zwiÄ™kszaÄ‡ `strong_count` w instancji `Rc<T>` o 1, wywoÅ‚anie\n`Rc::downgrade` zwiÄ™ksza `weak_count` o 1. Typ `Rc<T>` uÅ¼ywa `weak_count` do\nÅ›ledzenia liczby istniejÄ…cych referencji `Weak<T>`, podobnie jak `strong_count`.\nRÃ³Å¼nica polega na tym, Å¼e `weak_count` nie musi wynosiÄ‡ 0, aby instancja `Rc<T>`\nzostaÅ‚a usuniÄ™ta.\n\nPoniewaÅ¼ wartoÅ›Ä‡, do ktÃ³rej odwoÅ‚uje siÄ™ `Weak<T>`, mogÅ‚a zostaÄ‡ usuniÄ™ta, aby\ncoÅ› zrobiÄ‡ z wartoÅ›ciÄ…, na ktÃ³rÄ… wskazuje `Weak<T>`, musisz upewniÄ‡ siÄ™, Å¼e\nwartoÅ›Ä‡ nadal istnieje. ZrÃ³b to, wywoÅ‚ujÄ…c metodÄ™ `upgrade` na instancji\n`Weak<T>`, ktÃ³ra zwrÃ³ci `Option<Rc<T>>`. Otrzymasz wynik `Some`, jeÅ›li wartoÅ›Ä‡\n`Rc<T>` nie zostaÅ‚a jeszcze usuniÄ™ta, i wynik `None`, jeÅ›li wartoÅ›Ä‡ `Rc<T>`\nzostaÅ‚a usuniÄ™ta. PoniewaÅ¼ `upgrade` zwraca `Option<Rc<T>>`, Rust zapewni,\nÅ¼e przypadki `Some` i `None` zostanÄ… obsÅ‚uÅ¼one, i nie bÄ™dzie nieprawidÅ‚owego\nwskaÅºnika.\n\nJako przykÅ‚ad, zamiast uÅ¼ywaÄ‡ listy, ktÃ³rej elementy wiedzÄ… tylko o nastÄ™pnym\nelemencie, stworzymy drzewo, ktÃ³rego elementy wiedzÄ… o swoich elementach\npotocznych _i_ swoich elementach nadrzÄ™dnych.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"creating-a-tree-data-structure-a-node-with-child-nodes\"></a>\n\n#### Tworzenie struktury danych drzewa\n\nNa poczÄ…tek zbudujemy drzewo z wÄ™zÅ‚ami, ktÃ³re wiedzÄ… o swoich wÄ™zÅ‚ach\npotocznych. Stworzymy strukturÄ™ o nazwie `Node`, ktÃ³ra bÄ™dzie zawieraÅ‚a wÅ‚asnÄ…\nwartoÅ›Ä‡ `i32`, a takÅ¼e referencje do swoich potomnych wÄ™zÅ‚Ã³w `Node`:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    children: RefCell<Vec<Rc<Node>>>,\n}\n# \n# fn main() {\n#     let leaf = Rc::new(Node {\n#         value: 3,\n#         children: RefCell::new(vec![]),\n#     });\n# \n#     let branch = Rc::new(Node {\n#         value: 5,\n#         children: RefCell::new(vec![Rc::clone(&leaf)]),\n#     });\n# }\n```\n\nChcemy, aby `Node` byÅ‚ wÅ‚aÅ›cicielem swoich dzieci, i chcemy wspÃ³Å‚dzieliÄ‡ tÄ™\nwÅ‚asnoÅ›Ä‡ ze zmiennymi, abyÅ›my mogli bezpoÅ›rednio uzyskiwaÄ‡ dostÄ™p do kaÅ¼dego\n`Node` w drzewie. Aby to zrobiÄ‡, definiujemy elementy `Vec<T>` jako wartoÅ›ci\ntypu `Rc<Node>`. Chcemy rÃ³wnieÅ¼ modyfikowaÄ‡, ktÃ³re wÄ™zÅ‚y sÄ… dzieÄ‡mi innego\nwÄ™zÅ‚a, wiÄ™c mamy `RefCell<T>` w `children` wokÃ³Å‚ `Vec<Rc<Node>>`.\n\nNastÄ™pnie uÅ¼yjemy naszej definicji struktury i stworzymy jednÄ… instancjÄ™\n`Node` o nazwie `leaf` z wartoÅ›ciÄ… `3` i bez dzieci, oraz innÄ… instancjÄ™ o\nnazwie `branch` z wartoÅ›ciÄ… `5` i `leaf` jako jedno z jej dzieci, jak pokazano\nw Listingu 15-27.\n\n<Listing number=\"15-27\" file-name=\"src/main.rs\" caption=\"Tworzenie wÄ™zÅ‚a `leaf` bez dzieci i wÄ™zÅ‚a `branch` z `leaf` jako jednym z jego dzieci\">\n\n```rust\n# use std::cell::RefCell;\n# use std::rc::Rc;\n# \n# #[derive(Debug)]\n# struct Node {\n#     value: i32,\n#     children: RefCell<Vec<Rc<Node>>>,\n# }\n# \nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        children: RefCell::new(vec![]),\n    });\n\n    let branch = Rc::new(Node {\n        value: 5,\n        children: RefCell::new(vec![Rc::clone(&leaf)]),\n    });\n}\n```\n\n</Listing>\n\nKlonujemy `Rc<Node>` z `leaf` i przechowujemy go w `branch`, co oznacza, Å¼e\n`Node` z `leaf` ma teraz dwÃ³ch wÅ‚aÅ›cicieli: `leaf` i `branch`. MoÅ¼emy przejÅ›Ä‡\nod `branch` do `leaf` poprzez `branch.children`, ale nie ma sposobu, aby\nprzejÅ›Ä‡ od `leaf` do `branch`. Powodem jest to, Å¼e `leaf` nie ma referencji do\n`branch` i nie wie, Å¼e sÄ… ze sobÄ… powiÄ…zane. Chcemy, aby `leaf` wiedziaÅ‚o,\nÅ¼e `branch` jest jego rodzicem. Zrobimy to w nastÄ™pnym kroku.\n\n#### Dodawanie referencji od dziecka do jego rodzica\n\nAby wÄ™zeÅ‚ potomny byÅ‚ Å›wiadomy swojego rodzica, musimy dodaÄ‡ pole `parent` do\ndefinicji naszej struktury `Node`. Problem polega na podjÄ™ciu decyzji, jaki\ntyp powinno mieÄ‡ `parent`. Wiemy, Å¼e nie moÅ¼e zawieraÄ‡ `Rc<T>`, poniewaÅ¼\nstworzyÅ‚oby to cykl referencji, w ktÃ³rym `leaf.parent` wskazywaÅ‚oby na `branch`,\na `branch.children` na `leaf`, co spowodowaÅ‚oby, Å¼e ich wartoÅ›ci\n`strong_count` nigdy nie byÅ‚yby rÃ³wne 0.\n\nRozwaÅ¼ajÄ…c relacje w inny sposÃ³b, wÄ™zeÅ‚ rodzicielski powinien byÄ‡ wÅ‚aÅ›cicielem\nswoich dzieci: JeÅ›li wÄ™zeÅ‚ rodzicielski zostanie usuniÄ™ty, jego wÄ™zÅ‚y potomne\nrÃ³wnieÅ¼ powinny zostaÄ‡ usuniÄ™te. Jednak dziecko nie powinno byÄ‡ wÅ‚aÅ›cicielem\nswojego rodzica: JeÅ›li usuniemy wÄ™zeÅ‚ potomny, rodzic powinien nadal istnieÄ‡.\nTo przypadek dla sÅ‚abych referencji!\n\nTak wiÄ™c, zamiast `Rc<T>`, typ `parent` bÄ™dzie uÅ¼ywaÅ‚ `Weak<T>`, a konkretnie\n`RefCell<Weak<Node>>`. Teraz definicja naszej struktury `Node` wyglÄ…da\ntak:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust\nuse std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell<Weak<Node>>,\n    children: RefCell<Vec<Rc<Node>>>,\n}\n# \n# fn main() {\n#     let leaf = Rc::new(Node {\n#         value: 3,\n#         parent: RefCell::new(Weak::new()),\n#         children: RefCell::new(vec![]),\n#     });\n# \n#     println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n# \n#     let branch = Rc::new(Node {\n#         value: 5,\n#         parent: RefCell::new(Weak::new()),\n#         children: RefCell::new(vec![Rc::clone(&leaf)]),\n#     });\n# \n#     *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n# \n#     println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n# }\n```\n\nWÄ™zeÅ‚ bÄ™dzie mÃ³gÅ‚ odwoÅ‚ywaÄ‡ siÄ™ do swojego wÄ™zÅ‚a rodzicielskiego, ale nie\nposiada swojego rodzica. W Listingu 15-28 aktualizujemy `main`, aby uÅ¼ywaÅ‚ tej\nnowej definicji, tak aby wÄ™zeÅ‚ `leaf` miaÅ‚ sposÃ³b odwoÅ‚ywania siÄ™ do swojego\nrodzica, `branch`.\n\n<Listing number=\"15-28\" file-name=\"src/main.rs\" caption=\"WÄ™zeÅ‚ `leaf` ze sÅ‚abÄ… referencjÄ… do swojego wÄ™zÅ‚a rodzicielskiego, `branch`\">\n\n```rust\n# use std::cell::RefCell;\n# use std::rc::{Rc, Weak};\n# \n# #[derive(Debug)]\n# struct Node {\n#     value: i32,\n#     parent: RefCell<Weak<Node>>,\n#     children: RefCell<Vec<Rc<Node>>>,\n# }\n# \nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n\n    let branch = Rc::new(Node {\n        value: 5,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![Rc::clone(&leaf)]),\n    });\n\n    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n}\n```\n\n</Listing>\n\nTworzenie wÄ™zÅ‚a `leaf` wyglÄ…da podobnie do Listingu 15-27, z wyjÄ…tkiem pola\n`parent`: `leaf` zaczyna bez rodzica, wiÄ™c tworzymy nowÄ…, pustÄ… instancjÄ™\nreferencji `Weak<Node>`.\n\nW tym momencie, gdy prÃ³bujemy uzyskaÄ‡ referencjÄ™ do rodzica `leaf` za pomocÄ…\nmetody `upgrade`, otrzymujemy wartoÅ›Ä‡ `None`. Widzimy to w wynikach pierwszej\ninstrukcji `println!`:\n\n```text\nleaf parent = None\n```\n\nKiedy tworzymy wÄ™zeÅ‚ `branch`, bÄ™dzie on rÃ³wnieÅ¼ miaÅ‚ nowÄ… referencjÄ™ `Weak<Node>`\nw polu `parent`, poniewaÅ¼ `branch` nie ma wÄ™zÅ‚a rodzicielskiego. Nadal mamy\n`leaf` jako jedno z dzieci `branch`. Gdy juÅ¼ mamy instancjÄ™ `Node` w `branch`,\nmoÅ¼emy zmodyfikowaÄ‡ `leaf`, aby nadaÄ‡ mu referencjÄ™ `Weak<Node>` do jego rodzica.\nUÅ¼ywamy metody `borrow_mut` w `RefCell<Weak<Node>>` w polu `parent` wÄ™zÅ‚a `leaf`,\na nastÄ™pnie uÅ¼ywamy funkcji `Rc::downgrade` do stworzenia referencji `Weak<Node>`\ndo `branch` z `Rc<Node>` w `branch`.\n\nKiedy ponownie wypiszemy rodzica `leaf`, tym razem otrzymamy wariant `Some`\nprzechowujÄ…cy `branch`: Teraz `leaf` moÅ¼e uzyskaÄ‡ dostÄ™p do swojego rodzica!\nGdy wypiszemy `leaf`, unikamy rÃ³wnieÅ¼ cyklu, ktÃ³ry ostatecznie zakoÅ„czyÅ‚ siÄ™\nprzepeÅ‚nieniem stosu, jak to miaÅ‚o miejsce w Listingu 15-26; referencje\n`Weak<Node>` sÄ… wypisywane jako `(Weak)`:\n\n```text\nleaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },\nchildren: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },\nchildren: RefCell { value: [] } }] } })\n```\n\nBrak nieskoÅ„czonego wyniku wskazuje, Å¼e ten kod nie stworzyÅ‚ cyklu referencji.\nMoÅ¼emy to rÃ³wnieÅ¼ stwierdziÄ‡, patrzÄ…c na wartoÅ›ci, ktÃ³re otrzymujemy po\nwywoÅ‚aniu `Rc::strong_count` i `Rc::weak_count`.\n\n#### Wizualizacja zmian w `strong_count` i `weak_count`\n\nSpÃ³jrzmy, jak zmieniajÄ… siÄ™ wartoÅ›ci `strong_count` i `weak_count` instancji\n`Rc<Node>`, tworzÄ…c nowy wewnÄ™trzny zakres i przenoszÄ…c tworzenie `branch` do\ntego zakresu. W ten sposÃ³b moÅ¼emy zobaczyÄ‡, co dzieje siÄ™, gdy `branch` jest\ntworzone, a nastÄ™pnie usuwane, gdy wyjdzie poza zakres. Modyfikacje pokazano\nw Listingu 15-29.\n\n<Listing number=\"15-29\" file-name=\"src/main.rs\" caption=\"Tworzenie `branch` w wewnÄ™trznym zakresie i badanie licznikÃ³w silnych i sÅ‚abych referencji\">\n\n```rust\n# use std::cell::RefCell;\n# use std::rc::{Rc, Weak};\n# \n# #[derive(Debug)]\n# struct Node {\n#     value: i32,\n#     parent: RefCell<Weak<Node>>,\n#     children: RefCell<Vec<Rc<Node>>>,\n# }\n# \nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(&leaf),\n        Rc::weak_count(&leaf),\n    );\n\n    {\n        let branch = Rc::new(Node {\n            value: 5,\n            parent: RefCell::new(Weak::new()),\n            children: RefCell::new(vec![Rc::clone(&leaf)]),\n        });\n\n        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n\n        println!(\n            \"branch strong = {}, weak = {}\",\n            Rc::strong_count(&branch),\n            Rc::weak_count(&branch),\n        );\n\n        println!(\n            \"leaf strong = {}, weak = {}\",\n            Rc::strong_count(&leaf),\n            Rc::weak_count(&leaf),\n        );\n    }\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(&leaf),\n        Rc::weak_count(&leaf),\n    );\n}\n```\n\n</Listing>\n\nPo utworzeniu `leaf`, jego `Rc<Node>` ma silny licznik rÃ³wny 1 i sÅ‚aby licznik\nrÃ³wny 0. W wewnÄ™trznym zakresie tworzymy `branch` i kojarzymy go z `leaf`, po\nczym, gdy wypiszemy liczniki, `Rc<Node>` w `branch` bÄ™dzie miaÅ‚o silny licznik\nrÃ³wny 1 i sÅ‚aby licznik rÃ³wny 1 (dla `leaf.parent` wskazujÄ…cego na `branch` za\npomocÄ… `Weak<Node>`). Kiedy wypiszemy liczniki w `leaf`, zobaczymy, Å¼e bÄ™dzie\nmiaÅ‚o silny licznik rÃ³wny 2, poniewaÅ¼ `branch` ma teraz klon `Rc<Node>` z `leaf`\nprzechowywany w `branch.children`, ale nadal bÄ™dzie miaÅ‚o sÅ‚aby licznik rÃ³wny\n0.\n\nKiedy wewnÄ™trzny zakres siÄ™ koÅ„czy, `branch` wychodzi poza zakres, a silny\nlicznik `Rc<Node>` zmniejsza siÄ™ do 0, wiÄ™c jego `Node` zostaje usuniÄ™ty.\nSÅ‚aby licznik rÃ³wny 1 z `leaf.parent` nie ma wpÅ‚ywu na to, czy `Node` jest\nusuwany, wiÄ™c nie mamy wyciekÃ³w pamiÄ™ci!\n\nJeÅ›li sprÃ³bujemy uzyskaÄ‡ dostÄ™p do rodzica `leaf` po zakoÅ„czeniu zakresu,\nponownie otrzymamy `None`. Na koÅ„cu programu `Rc<Node>` w `leaf` ma silny\nlicznik rÃ³wny 1 i sÅ‚aby licznik rÃ³wny 0, poniewaÅ¼ zmienna `leaf` jest teraz\nponownie jedynÄ… referencjÄ… do `Rc<Node>`.\n\nWszystkie logiki zarzÄ…dzajÄ…ce licznikami i usuwaniem wartoÅ›ci sÄ… wbudowane w\n`Rc<T>` i `Weak<T>` oraz ich implementacje cechy `Drop`. OkreÅ›lajÄ…c, Å¼e\nrelacja od dziecka do rodzica powinna byÄ‡ referencjÄ… `Weak<T>` w definicji\n`Node`, jesteÅ› w stanie sprawiÄ‡, Å¼e wÄ™zÅ‚y rodzicielskie wskazujÄ… na wÄ™zÅ‚y\npotoczne i vice versa bez tworzenia cyklu referencji i wyciekÃ³w pamiÄ™ci.\n\n## Podsumowanie\n\nTen rozdziaÅ‚ omÃ³wiÅ‚, jak uÅ¼ywaÄ‡ wskaÅºnikÃ³w sprytnych, aby uzyskaÄ‡ rÃ³Å¼ne\ngwarancje i kompromisy w porÃ³wnaniu do tych, ktÃ³re Rust domyÅ›lnie zapewnia ze\nzwykÅ‚ymi referencjami. Typ `Box<T>` ma znany rozmiar i wskazuje na dane\nalokowane na stercie. Typ `Rc<T>` Å›ledzi liczbÄ™ referencji do danych na stercie,\ntak aby dane mogÅ‚y mieÄ‡ wielu wÅ‚aÅ›cicieli. Typ `RefCell<T>` ze swojÄ…\nmutowalnoÅ›ciÄ… wewnÄ™trznÄ… daje nam typ, ktÃ³rego moÅ¼emy uÅ¼ywaÄ‡, gdy potrzebujemy\nnimutowalnego typu, ale musimy zmieniÄ‡ wewnÄ™trznÄ… wartoÅ›Ä‡ tego typu; egzekwuje\non rÃ³wnieÅ¼ zasady poÅ¼yczania w czasie wykonania zamiast w czasie kompilacji.\n\nOmÃ³wiono rÃ³wnieÅ¼ cechy `Deref` i `Drop`, ktÃ³re umoÅ¼liwiajÄ… wiele funkcjonalnoÅ›ci\nwskaÅºnikÃ³w sprytnych. ZbadaliÅ›my cykle referencji, ktÃ³re mogÄ… powodowaÄ‡ wycieki\npamiÄ™ci, i jak im zapobiegaÄ‡ za pomocÄ… `Weak<T>`.\n\nJeÅ›li ten rozdziaÅ‚ wzbudziÅ‚ Twoje zainteresowanie i chcesz zaimplementowaÄ‡\nwÅ‚asne wskaÅºniki sprytne, zajrzyj do [â€The Rustonomiconâ€][nomicon] po wiÄ™cej\nprzydatnych informacji.\n\nNastÄ™pnie bÄ™dziemy rozmawiaÄ‡ o wspÃ³Å‚bieÅ¼noÅ›ci w Rust. Nauczysz siÄ™ nawet kilku\nnowych wskaÅºnikÃ³w sprytnych.\n\n[nomicon]: ../nomicon/index.html",
        "chapter_title": "Cykle referencji mogÄ… prowadziÄ‡ do wyciekÃ³w pamiÄ™ci"
    },
    {
        "file_path": "ch16-00-concurrency.md",
        "content": "# Bezpieczna wspÃ³Å‚bieÅ¼noÅ›Ä‡\n\nBezpieczne i efektywne zarzÄ…dzanie programowaniem wspÃ³Å‚bieÅ¼nym to kolejny z\ngÅ‚Ã³wnych celÃ³w Rust. _Programowanie wspÃ³Å‚bieÅ¼ne_, w ktÃ³rym rÃ³Å¼ne czÄ™Å›ci programu\nwykonujÄ… siÄ™ niezaleÅ¼nie, oraz _programowanie rÃ³wnolegÅ‚e_, w ktÃ³rym rÃ³Å¼ne czÄ™Å›ci\nprogramu wykonujÄ… siÄ™ w tym samym czasie, stajÄ… siÄ™ coraz waÅ¼niejsze, poniewaÅ¼\ncoraz wiÄ™cej komputerÃ³w wykorzystuje swoje wieloprocesorowe moÅ¼liwoÅ›ci.\nHistorycznie programowanie w tych kontekstach byÅ‚o trudne i podatne na bÅ‚Ä™dy.\nRust ma nadziejÄ™ to zmieniÄ‡.\n\nPoczÄ…tkowo zespÃ³Å‚ Rust uwaÅ¼aÅ‚, Å¼e zapewnienie bezpieczeÅ„stwa pamiÄ™ci i\nzapobieganie problemom wspÃ³Å‚bieÅ¼noÅ›ci to dwa oddzielne wyzwania do rozwiÄ…zania\nrÃ³Å¼nymi metodami. Z czasem zespÃ³Å‚ odkryÅ‚, Å¼e systemy wÅ‚asnoÅ›ci i typÃ³w to\npotÄ™Å¼ny zestaw narzÄ™dzi pomagajÄ…cych zarzÄ…dzaÄ‡ zarÃ³wno bezpieczeÅ„stwem pamiÄ™ci,\njak i problemami wspÃ³Å‚bieÅ¼noÅ›ci! DziÄ™ki wykorzystaniu wÅ‚asnoÅ›ci i sprawdzania\ntypÃ³w, wiele bÅ‚Ä™dÃ³w wspÃ³Å‚bieÅ¼noÅ›ci w Rust to bÅ‚Ä™dy kompilacji, a nie bÅ‚Ä™dy\nczasu wykonania. Dlatego, zamiast zmuszaÄ‡ CiÄ™ do spÄ™dzania wielu godzin na\nprÃ³bach odtworzenia dokÅ‚adnych okolicznoÅ›ci, w ktÃ³rych wystÄ™puje bÅ‚Ä…d\nwspÃ³Å‚bieÅ¼noÅ›ci w czasie wykonania, niepoprawny kod odmÃ³wi kompilacji i\nwyÅ›wietli bÅ‚Ä…d wyjaÅ›niajÄ…cy problem. W rezultacie moÅ¼esz naprawiÄ‡ swÃ³j kod\npodczas pracy nad nim, a nie potencjalnie po jego wdroÅ¼eniu do produkcji.\nNazwaliÅ›my ten aspekt Rust _bezpiecznÄ… wspÃ³Å‚bieÅ¼noÅ›ciÄ…_. Bezpieczna\nwspÃ³Å‚bieÅ¼noÅ›Ä‡ pozwala pisaÄ‡ kod wolny od subtelnych bÅ‚Ä™dÃ³w i Å‚atwy do\nrefaktoryzacji bez wprowadzania nowych bÅ‚Ä™dÃ³w.\n\n> Uwaga: Dla uproszczenia bÄ™dziemy odnosiÄ‡ siÄ™ do wielu problemÃ³w jako\n> _wspÃ³Å‚bieÅ¼nych_, zamiast byÄ‡ bardziej precyzyjnym, mÃ³wiÄ…c _wspÃ³Å‚bieÅ¼nych i/lub\n> rÃ³wnolegÅ‚ych_. W tym rozdziale proszÄ™ mentalnie zastÄ™powaÄ‡ _wspÃ³Å‚bieÅ¼nych\n> i/lub rÃ³wnolegÅ‚ych_ za kaÅ¼dym razem, gdy uÅ¼ywamy _wspÃ³Å‚bieÅ¼nych_. W nastÄ™pnym\n> rozdziale, gdzie rozrÃ³Å¼nienie ma wiÄ™ksze znaczenie, bÄ™dziemy bardziej\n> precyzyjni.\n\nWiele jÄ™zykÃ³w jest dogmatycznych w kwestii rozwiÄ…zaÅ„, ktÃ³re oferujÄ… do\nobsÅ‚ugi problemÃ³w wspÃ³Å‚bieÅ¼noÅ›ci. Na przykÅ‚ad, Erlang ma eleganckÄ…\nfunkcjonalnoÅ›Ä‡ dla wspÃ³Å‚bieÅ¼noÅ›ci opartej na przekazywaniu wiadomoÅ›ci, ale\nma tylko niejasne sposoby udostÄ™pniania stanu miÄ™dzy wÄ…tkami. ObsÅ‚ugiwanie\ntylko podzbioru moÅ¼liwych rozwiÄ…zaÅ„ jest rozsÄ…dnÄ… strategiÄ… dla jÄ™zykÃ³w\nwyÅ¼szego poziomu, poniewaÅ¼ jÄ™zyk wyÅ¼szego poziomu obiecuje korzyÅ›ci z\noddawania czÄ™Å›ci kontroli w zamian za abstrakcje. Jednak od jÄ™zykÃ³w niÅ¼szego\npoziomu oczekuje siÄ™, Å¼e zapewniÄ… rozwiÄ…zanie o najlepszej wydajnoÅ›ci w kaÅ¼dej\ndanej sytuacji i bÄ™dÄ… miaÅ‚y mniej abstrakcji nad sprzÄ™tem. Dlatego Rust\noferuje rÃ³Å¼norodne narzÄ™dzia do modelowania problemÃ³w w sposÃ³b odpowiedni dla\ntwojej sytuacji i wymagaÅ„.\n\nOto tematy, ktÃ³re omÃ³wimy w tym rozdziale:\n\n- Jak tworzyÄ‡ wÄ…tki do jednoczesnego uruchamiania wielu fragmentÃ³w kodu\n- WspÃ³Å‚bieÅ¼noÅ›Ä‡ oparta na _przekazywaniu wiadomoÅ›ci_, gdzie kanaÅ‚y wysyÅ‚ajÄ…\n  wiadomoÅ›ci miÄ™dzy wÄ…tkami\n- WspÃ³Å‚bieÅ¼noÅ›Ä‡ oparta na _wspÃ³Å‚dzielonym stanie_, gdzie wiele wÄ…tkÃ³w ma\n  dostÄ™p do pewnej czÄ™Å›ci danych\n- Cechy `Sync` i `Send`, ktÃ³re rozszerzajÄ… gwarancje wspÃ³Å‚bieÅ¼noÅ›ci Rust na\n  typy zdefiniowane przez uÅ¼ytkownika, a takÅ¼e na typy dostarczane przez\n  bibliotekÄ™ standardowÄ…",
        "chapter_title": "Bezpieczna wspÃ³Å‚bieÅ¼noÅ›Ä‡"
    },
    {
        "file_path": "ch16-01-threads.md",
        "content": "## UÅ¼ywanie wÄ…tkÃ³w do jednoczesnego uruchamiania kodu\n\nW wiÄ™kszoÅ›ci obecnych systemÃ³w operacyjnych kod wykonywanego programu dziaÅ‚a w\n_procesie_, a system operacyjny zarzÄ…dza wieloma procesami jednoczeÅ›nie.\nWewnÄ…trz programu moÅ¼esz mieÄ‡ rÃ³wnieÅ¼ niezaleÅ¼ne czÄ™Å›ci, ktÃ³re dziaÅ‚ajÄ…\njednoczeÅ›nie. Funkcje, ktÃ³re uruchamiajÄ… te niezaleÅ¼ne czÄ™Å›ci, nazywane sÄ…\n_wÄ…tkami_. Na przykÅ‚ad, serwer webowy moÅ¼e mieÄ‡ wiele wÄ…tkÃ³w, aby mÃ³gÅ‚\njednoczeÅ›nie odpowiadaÄ‡ na wiÄ™cej niÅ¼ jedno Å¼Ä…danie.\n\nPodzielenie obliczeÅ„ w programie na wiele wÄ…tkÃ³w w celu jednoczesnego\nuruchamiania wielu zadaÅ„ moÅ¼e poprawiÄ‡ wydajnoÅ›Ä‡, ale takÅ¼e zwiÄ™ksza\nzÅ‚oÅ¼onoÅ›Ä‡. PoniewaÅ¼ wÄ…tki mogÄ… dziaÅ‚aÄ‡ jednoczeÅ›nie, nie ma inherentnej\ngwarancji co do kolejnoÅ›ci, w jakiej bÄ™dÄ… dziaÅ‚aÄ‡ czÄ™Å›ci kodu na rÃ³Å¼nych\nwÄ…tkach. MoÅ¼e to prowadziÄ‡ do problemÃ³w, takich jak:\n\n- WyÅ›cigi danych, w ktÃ³rych wÄ…tki uzyskujÄ… dostÄ™p do danych lub zasobÃ³w w\n  niekonsekwentnej kolejnoÅ›ci\n- Zakleszczenia, w ktÃ³rych dwa wÄ…tki czekajÄ… na siebie nawzajem, uniemoÅ¼liwiajÄ…c\n  kontynuowanie obu wÄ…tkÃ³w\n- BÅ‚Ä™dy, ktÃ³re wystÄ™pujÄ… tylko w okreÅ›lonych sytuacjach i sÄ… trudne do\n  niezawodnego odtworzenia i naprawy\n\nRust prÃ³buje zÅ‚agodziÄ‡ negatywne skutki uÅ¼ywania wÄ…tkÃ³w, ale programowanie w\nkontekÅ›cie wielowÄ…tkowym nadal wymaga starannego przemyÅ›lenia i innej\nstruktury kodu niÅ¼ w programach dziaÅ‚ajÄ…cych w pojedynczym wÄ…tku.\n\nJÄ™zyki programowania implementujÄ… wÄ…tki na kilka rÃ³Å¼nych sposobÃ³w, a wiele\nsystemÃ³w operacyjnych zapewnia API, ktÃ³re jÄ™zyk programowania moÅ¼e wywoÅ‚ywaÄ‡\nw celu tworzenia nowych wÄ…tkÃ³w. Biblioteka standardowa Rust uÅ¼ywa modelu\nimplementacji wÄ…tkÃ³w _1:1_, w ktÃ³rym program uÅ¼ywa jednego wÄ…tku systemu\noperacyjnego na jeden wÄ…tek jÄ™zykowy. IstniejÄ… crate'y, ktÃ³re implementujÄ…\ninne modele wÄ…tkowania, ktÃ³re dokonujÄ… innych kompromisÃ³w w stosunku do modelu\n1:1. (System asynchroniczny Rust, ktÃ³ry zobaczymy w nastÄ™pnym rozdziale,\nzapewnia rÃ³wnieÅ¼ inne podejÅ›cie do wspÃ³Å‚bieÅ¼noÅ›ci.)\n\n### Tworzenie nowego wÄ…tku za pomocÄ… `spawn`\n\nAby utworzyÄ‡ nowy wÄ…tek, wywoÅ‚ujemy funkcjÄ™ `thread::spawn` i przekazujemy jej\ndomkniÄ™cie (o domkniÄ™ciach mÃ³wiliÅ›my w Rozdziale 13) zawierajÄ…ce kod, ktÃ³ry\nchcemy uruchomiÄ‡ w nowym wÄ…tku. PrzykÅ‚ad w Listingu 16-1 wypisuje tekst z\ngÅ‚Ã³wnego wÄ…tku i inny tekst z nowego wÄ…tku.\n\n<Listing number=\"16-1\" file-name=\"src/main.rs\" caption=\"Tworzenie nowego wÄ…tku do wypisania jednej rzeczy, podczas gdy gÅ‚Ã³wny wÄ…tek wypisuje coÅ› innego\">\n\n```rust\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {i} from the spawned thread!\");\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    for i in 1..5 {\n        println!(\"hi number {i} from the main thread!\");\n        thread::sleep(Duration::from_millis(1));\n    }\n}\n```\n\n</Listing>\n\nZauwaÅ¼, Å¼e gdy gÅ‚Ã³wny wÄ…tek programu Rust zakoÅ„czy dziaÅ‚anie, wszystkie\nutworzone wÄ…tki zostajÄ… wyÅ‚Ä…czone, niezaleÅ¼nie od tego, czy zakoÅ„czyÅ‚y\ndziaÅ‚anie. Wynik tego programu moÅ¼e byÄ‡ za kaÅ¼dym razem nieco inny, ale bÄ™dzie\nwyglÄ…daÅ‚ podobnie do nastÄ™pujÄ…cego:\n\n<!-- Not extracting output because changes to this output aren't significant;\nthe changes are likely to be due to the threads running differently rather than\nchanges in the compiler -->\n\n```text\nhi number 1 from the main thread!\nhi number 1 from the spawned thread!\nhi number 2 from the main thread!\nhi number 2 from the spawned thread!\nhi number 3 from the main thread!\nhi number 3 from the spawned thread!\nhi number 4 from the main thread!\nhi number 4 from the spawned thread!\nhi number 5 from the spawned thread!\n```\n\nWywoÅ‚ania `thread::sleep` zmuszajÄ… wÄ…tek do zatrzymania jego wykonania na krÃ³tki\nokres, pozwalajÄ…c na uruchomienie innego wÄ…tku. WÄ…tki prawdopodobnie bÄ™dÄ…\ndziaÅ‚aÄ‡ naprzemiennie, ale nie jest to gwarantowane: ZaleÅ¼y to od tego, jak\nsystem operacyjny planuje wÄ…tki. W tym uruchomieniu gÅ‚Ã³wny wÄ…tek wypisaÅ‚ siÄ™\njako pierwszy, mimo Å¼e instrukcja `print` z utworzonego wÄ…tku pojawia siÄ™\npierwsza w kodzie. I chociaÅ¼ kazaliÅ›my utworzonemu wÄ…tkowi wypisywaÄ‡, dopÃ³ki `i`\nnie bÄ™dzie rÃ³wne `9`, doszedÅ‚ tylko do `5`, zanim gÅ‚Ã³wny wÄ…tek siÄ™\nwyÅ‚Ä…czyÅ‚.\n\nJeÅ›li uruchomisz ten kod i zobaczysz tylko wynik z gÅ‚Ã³wnego wÄ…tku, lub nie\nzobaczysz Å¼adnych nakÅ‚adek, sprÃ³buj zwiÄ™kszyÄ‡ liczby w zakresach, aby stworzyÄ‡\nwiÄ™cej moÅ¼liwoÅ›ci dla systemu operacyjnego do przeÅ‚Ä…czania miÄ™dzy wÄ…tkami.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"waiting-for-all-threads-to-finish-using-join-handles\"></a>\n\n### Czekanie na zakoÅ„czenie wszystkich wÄ…tkÃ³w\n\nKod z Listingu 16-1 nie tylko zatrzymuje utworzony wÄ…tek przedwczeÅ›nie w\nw wiÄ™kszoÅ›ci przypadkÃ³w z powodu zakoÅ„czenia gÅ‚Ã³wnego wÄ…tku, ale poniewaÅ¼ nie\nma gwarancji co do kolejnoÅ›ci, w jakiej wÄ…tki dziaÅ‚ajÄ…, nie moÅ¼emy rÃ³wnieÅ¼\nzagwarantowaÄ‡, Å¼e utworzony wÄ…tek w ogÃ³le siÄ™ uruchomi!\n\nProblem przedwczesnego zakoÅ„czenia lub braku uruchomienia utworzonego wÄ…tku\nmoÅ¼emy naprawiÄ‡, zapisujÄ…c wartoÅ›Ä‡ zwracanÄ… przez `thread::spawn` w zmiennej.\nTypem zwracanym przez `thread::spawn` jest `JoinHandle<T>`. `JoinHandle<T>`\njest wartoÅ›ciÄ… wÅ‚asnoÅ›ciowÄ…, ktÃ³ra po wywoÅ‚aniu na niej metody `join` bÄ™dzie\nczekaÅ‚a na zakoÅ„czenie swojego wÄ…tku. Listing 16-2 pokazuje, jak uÅ¼yÄ‡\n`JoinHandle<T>` z utworzonego w Listingu 16-1 wÄ…tku i jak wywoÅ‚aÄ‡ `join`, aby\nupewniÄ‡ siÄ™, Å¼e utworzony wÄ…tek zakoÅ„czy siÄ™ przed zakoÅ„czeniem `main`.\n\n<Listing number=\"16-2\" file-name=\"src/main.rs\" caption=\"Zapisywanie `JoinHandle<T>` z `thread::spawn` w celu zagwarantowania, Å¼e wÄ…tek zostanie uruchomiony do koÅ„ca\">\n\n```rust\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let handle = thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {i} from the spawned thread!\");\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    for i in 1..5 {\n        println!(\"hi number {i} from the main thread!\");\n        thread::sleep(Duration::from_millis(1));\n    }\n\n    handle.join().unwrap();\n}\n```\n\n</Listing>\n\nWywoÅ‚anie `join` na uchwycie blokuje aktualnie dziaÅ‚ajÄ…cy wÄ…tek, uniemoÅ¼liwiajÄ…c\nmu wykonywanie pracy lub zakoÅ„czenie, dopÃ³ki wÄ…tek reprezentowany przez uchwyt\nsiÄ™ nie zakoÅ„czy. _Blokowanie_ wÄ…tku oznacza, Å¼e wÄ…tek jest uniemoÅ¼liwiony\nwykonanie pracy lub wyjÅ›cia. PoniewaÅ¼ umieÅ›ciliÅ›my wywoÅ‚anie `join` po pÄ™tli\n`for` gÅ‚Ã³wnego wÄ…tku, uruchomienie Listingu 16-2 powinno wygenerowaÄ‡ wynik\npodobny do tego:\n\n<!-- Not extracting output because changes to this output aren't significant;\nthe changes are likely to be due to the threads running differently rather than\nchanges in the compiler -->\n\n```text\nhi number 1 from the main thread!\nhi number 2 from the main thread!\nhi number 1 from the spawned thread!\nhi number 3 from the main thread!\nhi number 2 from the spawned thread!\nhi number 4 from the main thread!\nhi number 3 from the spawned thread!\nhi number 4 from the spawned thread!\nhi number 5 from the spawned thread!\nhi number 6 from the spawned thread!\nhi number 7 from the spawned thread!\nhi number 8 from the spawned thread!\nhi number 9 from the spawned thread!\n```\n\nDwa wÄ…tki nadal dziaÅ‚ajÄ… naprzemiennie, ale gÅ‚Ã³wny wÄ…tek czeka z powodu wywoÅ‚ania\n`handle.join()` i nie koÅ„czy dziaÅ‚ania, dopÃ³ki utworzony wÄ…tek siÄ™ nie\nzakoÅ„czy.\n\nAle zobaczmy, co siÄ™ stanie, gdy zamiast tego przeniesiemy `handle.join()` przed\npÄ™tlÄ™ `for` w `main`, tak:\n\n<Listing file-name=\"src/main.rs\">\n\n```rust\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let handle = thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {i} from the spawned thread!\");\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    handle.join().unwrap();\n\n    for i in 1..5 {\n        println!(\"hi number {i} from the main thread!\");\n        thread::sleep(Duration::from_millis(1));\n    }\n}\n```\n\n</Listing>\n\nGÅ‚Ã³wny wÄ…tek poczeka na zakoÅ„czenie utworzonego wÄ…tku, a nastÄ™pnie uruchomi\nswojÄ… pÄ™tlÄ™ `for`, wiÄ™c wyniki nie bÄ™dÄ… juÅ¼ przeplatane, jak pokazano\ntutaj:\n\n<!-- Not extracting output because changes to this output aren't significant;\nthe changes are likely to be due to the threads running differently rather than\nchanges in the compiler -->\n\n```text\nhi number 1 from the spawned thread!\nhi number 2 from the spawned thread!\nhi number 3 from the spawned thread!\nhi number 4 from the spawned thread!\nhi number 5 from the spawned thread!\nhi number 6 from the spawned thread!\nhi number 7 from the spawned thread!\nhi number 8 from the spawned thread!\nhi number 9 from the spawned thread!\nhi number 1 from the main thread!\nhi number 2 from the main thread!\nhi number 3 from the main thread!\nhi number 4 from the main thread!\n```\n\nMaÅ‚e detale, takie jak miejsce wywoÅ‚ania `join`, mogÄ… wpÅ‚ywaÄ‡ na to, czy wÄ…tki\ndziaÅ‚ajÄ… jednoczeÅ›nie.\n\n### UÅ¼ywanie domkniÄ™Ä‡ `move` z wÄ…tkami\n\nCzÄ™sto bÄ™dziemy uÅ¼ywaÄ‡ sÅ‚owa kluczowego `move` z domkniÄ™ciami przekazywanymi do\n`thread::spawn`, poniewaÅ¼ domkniÄ™cie przejmie wtedy wÅ‚asnoÅ›Ä‡ wartoÅ›ci, ktÃ³rych\nuÅ¼ywa ze Å›rodowiska, przenoszÄ…c w ten sposÃ³b wÅ‚asnoÅ›Ä‡ tych wartoÅ›ci z jednego\nwÄ…tku do drugiego. W sekcji [â€Przechwytywanie referencji lub przenoszenie\nwÅ‚asnoÅ›ciâ€][capture]<!-- ignore --> w Rozdziale 13 omÃ³wiliÅ›my `move` w kontekÅ›cie\ndomkniÄ™Ä‡. Teraz skupimy siÄ™ bardziej na interakcji miÄ™dzy `move` a\n`thread::spawn`.\n\nZauwaÅ¼ w Listingu 16-1, Å¼e domkniÄ™cie, ktÃ³re przekazujemy do `thread::spawn`,\nnie przyjmuje Å¼adnych argumentÃ³w: Nie uÅ¼ywamy Å¼adnych danych z gÅ‚Ã³wnego wÄ…tku\nw kodzie utworzonego wÄ…tku. Aby uÅ¼yÄ‡ danych z gÅ‚Ã³wnego wÄ…tku w utworzonym\nwÄ…tku, domkniÄ™cie utworzonego wÄ…tku musi przechwyciÄ‡ wartoÅ›ci, ktÃ³rych\npotrzebuje. Listing 16-3 pokazuje prÃ³bÄ™ utworzenia wektora w gÅ‚Ã³wnym wÄ…tku i\nuÅ¼ycia go w utworzonym wÄ…tku. Jednak to jeszcze nie zadziaÅ‚a, jak zobaczysz za\nchwilÄ™.\n\n<Listing number=\"16-3\" file-name=\"src/main.rs\" caption=\"PrÃ³ba uÅ¼ycia wektora utworzonego przez gÅ‚Ã³wny wÄ…tek w innym wÄ…tku\">\n\n```rust,ignore,does_not_compile\nuse std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];\n\n    let handle = thread::spawn(|| {\n        println!(\"Here's a vector: {v:?}\");\n    });\n\n    handle.join().unwrap();\n}\n```\n\n</Listing>\n\nDomkniÄ™cie uÅ¼ywa `v`, wiÄ™c przechwyci `v` i uczyni je czÄ™Å›ciÄ… Å›rodowiska\ndomkniÄ™cia. PoniewaÅ¼ `thread::spawn` uruchamia to domkniÄ™cie w nowym wÄ…tku,\npowinniÅ›my mieÄ‡ dostÄ™p do `v` w tym nowym wÄ…tku. Ale kiedy kompilujemy ten\nprzykÅ‚ad, otrzymujemy nastÄ™pujÄ…cy bÅ‚Ä…d:\n\n```console\n$ cargo run\n   Compiling threads v0.1.0 (file:///projects/threads)\nerror[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function\n --> src/main.rs:6:32\n  |\n6 |     let handle = thread::spawn(|| {\n  |                                ^^ may outlive borrowed value `v`\n7 |         println!(\"Here's a vector: {v:?}\");\n  |                                     - `v` is borrowed here\n  |\nnote: function requires argument type to outlive `'static`\n --> src/main.rs:6:18\n  |\n6 |       let handle = thread::spawn(|| {\n  |  __________________^\n7 | |         println!(\"Here's a vector: {v:?}\");\n8 | |     });\n  | |______^\nhelp: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword\n  |\n6 |     let handle = thread::spawn(move || {\n  |                                ++++\n\nFor more information about this error, try `rustc --explain E0373`.\nerror: could not compile `threads` (bin \"threads\") due to 1 previous error\n```\n\nRust _wnioskuje_, jak przechwyciÄ‡ `v`, a poniewaÅ¼ `println!` potrzebuje tylko\nreferencji do `v`, domkniÄ™cie prÃ³buje poÅ¼yczyÄ‡ `v`. Jest jednak problem: Rust\nnie jest w stanie okreÅ›liÄ‡, jak dÅ‚ugo bÄ™dzie dziaÅ‚aÄ‡ utworzony wÄ…tek, wiÄ™c nie\nwie, czy referencja do `v` zawsze bÄ™dzie waÅ¼na.\n\nListing 16-4 przedstawia scenariusz, w ktÃ³rym referencja do `v` z wiÄ™kszym\nprawdopodobieÅ„stwem nie bÄ™dzie waÅ¼na.\n\n<Listing number=\"16-4\" file-name=\"src/main.rs\" caption=\"WÄ…tek z domkniÄ™ciem, ktÃ³re prÃ³buje przechwyciÄ‡ referencjÄ™ do `v` z gÅ‚Ã³wnego wÄ…tku, ktÃ³ry usuwa `v`\">\n\n```rust,ignore,does_not_compile\nuse std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];\n\n    let handle = thread::spawn(|| {\n        println!(\"Here's a vector: {v:?}\");\n    });\n\n    drop(v); // oh no!\n\n    handle.join().unwrap();\n}\n```\n\n</Listing>\n\nGdyby Rust pozwoliÅ‚ nam uruchomiÄ‡ ten kod, istniaÅ‚aby moÅ¼liwoÅ›Ä‡, Å¼e utworzony\nwÄ…tek zostaÅ‚by natychmiast przeniesiony do tÅ‚a bez uruchomienia. Utworzony\nwÄ…tek ma w Å›rodku referencjÄ™ do `v`, ale gÅ‚Ã³wny wÄ…tek natychmiast usuwa `v`\nuÅ¼ywajÄ…c funkcji `drop`, ktÃ³rÄ… omÃ³wiliÅ›my w Rozdziale 15. Wtedy, gdy\nutworzony wÄ…tek zacznie siÄ™ wykonywaÄ‡, `v` nie jest juÅ¼ waÅ¼ne, wiÄ™c referencja\ndo niego rÃ³wnieÅ¼ jest niewaÅ¼na. Och nie!\n\nAby naprawiÄ‡ bÅ‚Ä…d kompilacji w Listingu 16-3, moÅ¼emy skorzystaÄ‡ z porady z\nkomunikatu o bÅ‚Ä™dzie:\n\n<!-- manual-regeneration\nafter automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part\n-->\n\n```text\nhelp: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword\n  |\n6 |     let handle = thread::spawn(move || {\n  |                                ++++\n```\n\nDodajÄ…c sÅ‚owo kluczowe `move` przed domkniÄ™ciem, zmuszamy domkniÄ™cie do\nprzejÄ™cia wÅ‚asnoÅ›ci wartoÅ›ci, ktÃ³rych uÅ¼ywa, zamiast pozwalaÄ‡ Rustowi\nwnioskowaÄ‡, Å¼e powinno ono poÅ¼yczyÄ‡ te wartoÅ›ci. Modyfikacja Listingu 16-3\nprzedstawiona w Listingu 16-5 skompiluje siÄ™ i zadziaÅ‚a zgodnie z naszym\nzamierzeniem.\n\n<Listing number=\"16-5\" file-name=\"src/main.rs\" caption=\"UÅ¼ycie sÅ‚owa kluczowego `move`, aby zmusiÄ‡ domkniÄ™cie do przejÄ™cia wÅ‚asnoÅ›ci uÅ¼ywanych wartoÅ›ci\">\n\n```rust\nuse std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];\n\n    let handle = thread::spawn(move || {\n        println!(\"Here's a vector: {v:?}\");\n    });\n\n    handle.join().unwrap();\n}\n```\n\n</Listing>\n\nMoÅ¼emy byÄ‡ kuszeni, aby sprÃ³bowaÄ‡ tego samego, aby naprawiÄ‡ kod z Listingu\n16-4, gdzie gÅ‚Ã³wny wÄ…tek wywoÅ‚aÅ‚ `drop` za pomocÄ… domkniÄ™cia `move`. JednakÅ¼e,\nta poprawka nie zadziaÅ‚a, poniewaÅ¼ to, co Listing 16-4 prÃ³buje zrobiÄ‡, jest\nniedozwolone z innego powodu. GdybyÅ›my dodali `move` do domkniÄ™cia,\nprzenieÅ›libyÅ›my `v` do Å›rodowiska domkniÄ™cia i nie moglibyÅ›my juÅ¼ wywoÅ‚ywaÄ‡ na\n`v` `drop` w gÅ‚Ã³wnym wÄ…tku. Zamiast tego otrzymalibyÅ›my bÅ‚Ä…d kompilacji:\n\n```console\n$ cargo run\n   Compiling threads v0.1.0 (file:///projects/threads)\nerror[E0382]: use of moved value: `v`\n  --> src/main.rs:10:10\n   |\n 4 |     let v = vec![1, 2, 3];\n   |         - move occurs because `v` has type `Vec<i32>`, which does not implement the `Copy` trait\n 5 |\n 6 |     let handle = thread::spawn(move || {\n   |                                ------- value moved into closure here\n 7 |         println!(\"Here's a vector: {v:?}\");\n   |                                     - variable moved due to use in closure\n...\n10 |     drop(v); // oh no!\n   |          ^ value used here after move\n   |\nhelp: consider cloning the value before moving it into the closure\n   |\n 6 ~     let value = v.clone();\n 7 ~     let handle = thread::spawn(move || {\n 8 ~         println!(\"Here's a vector: {value:?}\");\n   |\n\nFor more information about this error, try `rustc --explain E0382`.\nerror: could not compile `threads` (bin \"threads\") due to 1 previous error\n```\n\nZasady wÅ‚asnoÅ›ci Rust znÃ³w nas uratowaÅ‚y! OtrzymaliÅ›my bÅ‚Ä…d z kodu w Listingu\n16-3, poniewaÅ¼ Rust byÅ‚ konserwatywny i tylko poÅ¼yczaÅ‚ `v` dla wÄ…tku, co\noznaczaÅ‚o, Å¼e gÅ‚Ã³wny wÄ…tek teoretycznie mÃ³gÅ‚by uniewaÅ¼niÄ‡ referencjÄ™\nutworzonego wÄ…tku. MÃ³wiÄ…c Rustowi, aby przeniÃ³sÅ‚ wÅ‚asnoÅ›Ä‡ `v` do utworzonego\nwÄ…tku, gwarantujemy Rustowi, Å¼e gÅ‚Ã³wny wÄ…tek nie bÄ™dzie juÅ¼ uÅ¼ywaÅ‚ `v`. JeÅ›li\nzmienimy Listing 16-4 w ten sam sposÃ³b, naruszamy wtedy zasady wÅ‚asnoÅ›ci,\ngdy prÃ³bujemy uÅ¼yÄ‡ `v` w gÅ‚Ã³wnym wÄ…tku. SÅ‚owo kluczowe `move` nadpisuje\nkonserwatywnÄ… domyÅ›lnÄ… poÅ¼yczkÄ™ Rust; nie pozwala nam naruszaÄ‡ zasad\nwÅ‚asnoÅ›ci.\n\nTeraz, gdy omÃ³wiliÅ›my, czym sÄ… wÄ…tki i metody dostarczane przez API wÄ…tkÃ³w,\nprzyjrzyjmy siÄ™ kilku sytuacjom, w ktÃ³rych moÅ¼emy uÅ¼ywaÄ‡ wÄ…tkÃ³w.\n\n[capture]: ch13-01-closures.html#capturing-references-or-moving-ownership",
        "chapter_title": "UÅ¼ywanie wÄ…tkÃ³w do jednoczesnego uruchamiania kodu"
    },
    {
        "file_path": "ch16-02-message-passing.md",
        "content": "<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"using-message-passing-to-transfer-data-between-threads\"></a>\n\n## PrzesyÅ‚anie danych miÄ™dzy wÄ…tkami za pomocÄ… przekazywania wiadomoÅ›ci\n\nJednym z coraz popularniejszych podejÅ›Ä‡ do zapewnienia bezpiecznej\nwspÃ³Å‚bieÅ¼noÅ›ci jest przekazywanie wiadomoÅ›ci, gdzie wÄ…tki lub aktorzy\nkomunikujÄ… siÄ™, wysyÅ‚ajÄ…c sobie wiadomoÅ›ci zawierajÄ…ce dane. Oto idea w haÅ›le z\n[dokumentacji jÄ™zyka Go](https://golang.org/doc/effective_go.html#concurrency):\nâ€Nie komunikuj siÄ™ poprzez wspÃ³Å‚dzielenie pamiÄ™ci; zamiast tego wspÃ³Å‚dziel\npamiÄ™Ä‡ poprzez komunikacjÄ™.â€\n\nAby zrealizowaÄ‡ wspÃ³Å‚bieÅ¼noÅ›Ä‡ opartÄ… na przekazywaniu wiadomoÅ›ci, biblioteka\nstandardowa Rust dostarcza implementacjÄ™ kanaÅ‚Ã³w. _KanaÅ‚_ to ogÃ³lna koncepcja\nprogramistyczna, za pomocÄ… ktÃ³rej dane sÄ… przesyÅ‚ane z jednego wÄ…tku do\ndrugiego.\n\nMoÅ¼esz wyobraziÄ‡ sobie kanaÅ‚ w programowaniu jako kierunkowy kanaÅ‚ wodny, taki\njak strumieÅ„ lub rzeka. JeÅ›li wrzucisz coÅ›, na przykÅ‚ad gumowÄ… kaczkÄ™, do rzeki,\nbÄ™dzie ona pÅ‚ynÄ™Å‚a w dÃ³Å‚ rzeki aÅ¼ do koÅ„ca szlaku wodnego.\n\nKanaÅ‚ ma dwie poÅ‚Ã³wki: nadajnik i odbiornik. PoÅ‚Ã³wka nadajnika to miejsce\nw gÃ³rze rzeki, gdzie wrzucasz gumowÄ… kaczkÄ™, a poÅ‚Ã³wka odbiornika to miejsce,\ngdzie gumowa kaczka dociera w dÃ³Å‚ rzeki. Jedna czÄ™Å›Ä‡ twojego kodu wywoÅ‚uje\nmetody na nadajniku z danymi, ktÃ³re chcesz wysÅ‚aÄ‡, a inna czÄ™Å›Ä‡ sprawdza koniec\nodbiorczy pod kÄ…tem nadchodzÄ…cych wiadomoÅ›ci. KanaÅ‚ jest uwaÅ¼any za _zamkniÄ™ty_,\njeÅ›li ktÃ³rakolwiek z poÅ‚Ã³wek â€“ nadajnik lub odbiornik â€“ zostanie usuniÄ™ta.\n\nTutaj stworzymy program, ktÃ³ry bÄ™dzie miaÅ‚ jeden wÄ…tek do generowania wartoÅ›ci\ni wysyÅ‚ania ich przez kanaÅ‚, oraz inny wÄ…tek, ktÃ³ry bÄ™dzie odbieraÅ‚ te wartoÅ›ci\ni wypisywaÅ‚ je. BÄ™dziemy przesyÅ‚aÄ‡ proste wartoÅ›ci miÄ™dzy wÄ…tkami za pomocÄ…\nkanaÅ‚u, aby zilustrowaÄ‡ tÄ™ funkcjÄ™. Gdy juÅ¼ zapoznasz siÄ™ z tÄ… technikÄ…,\nbÄ™dziesz mÃ³gÅ‚ uÅ¼ywaÄ‡ kanaÅ‚Ã³w dla dowolnych wÄ…tkÃ³w, ktÃ³re muszÄ… siÄ™ ze sobÄ…\nkomunikowaÄ‡, np. w systemie czatu lub w systemie, gdzie wiele wÄ…tkÃ³w wykonuje\nczÄ™Å›ci obliczeÅ„ i wysyÅ‚a je do jednego wÄ…tku, ktÃ³ry agreguje wyniki.\n\nNajpierw, w Listingu 16-6, stworzymy kanaÅ‚, ale nic z nim nie zrobimy. ZauwaÅ¼,\nÅ¼e to jeszcze siÄ™ nie skompiluje, poniewaÅ¼ Rust nie potrafi okreÅ›liÄ‡, jakiego\ntypu wartoÅ›ci chcemy przesyÅ‚aÄ‡ przez kanaÅ‚.\n\n<Listing number=\"16-6\" file-name=\"src/main.rs\" caption=\"Tworzenie kanaÅ‚u i przypisywanie dwÃ³ch poÅ‚Ã³wek do `tx` i `rx`\">\n\n```rust,ignore,does_not_compile\nuse std::sync::mpsc;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n}\n```\n\n</Listing>\n\nTworzymy nowy kanaÅ‚ za pomocÄ… funkcji `mpsc::channel`; `mpsc` oznacza\n_multiple producer, single consumer_ (wielu producentÃ³w, jeden konsument). W\nskrÃ³cie, sposÃ³b, w jaki biblioteka standardowa Rust implementuje kanaÅ‚y,\noznacza, Å¼e kanaÅ‚ moÅ¼e mieÄ‡ wiele koÅ„cÃ³w _wysyÅ‚ajÄ…cych_, ktÃ³re produkujÄ…\nwartoÅ›ci, ale tylko jeden koniec _odbierajÄ…cy_, ktÃ³ry te wartoÅ›ci konsumuje.\nWyobraÅº sobie wiele strumieni spÅ‚ywajÄ…cych do jednej duÅ¼ej rzeki: Wszystko,\nco zostanie wysÅ‚ane w dÃ³Å‚ ktÃ³regokolwiek ze strumieni, znajdzie siÄ™ w jednej\nrzece na koÅ„cu. Na razie zaczniemy od jednego producenta, ale dodamy wielu\nproducentÃ³w, gdy ten przykÅ‚ad zadziaÅ‚a.\n\nFunkcja `mpsc::channel` zwraca krotkÄ™, ktÃ³rej pierwszy element to koniec\nwysyÅ‚ajÄ…cy â€“ nadajnik â€“ a drugi element to koniec odbierajÄ…cy â€“ odbiornik.\nSkrÃ³ty `tx` i `rx` sÄ… tradycyjnie uÅ¼ywane w wielu dziedzinach odpowiednio dla\n_transmitter_ (nadajnik) i _receiver_ (odbiornik), wiÄ™c tak nazywamy nasze\nzmienne, aby wskazaÄ‡ kaÅ¼dy koniec. UÅ¼ywamy instrukcji `let` ze wzorcem,\nktÃ³ry dekomponuje krotki; o uÅ¼yciu wzorcÃ³w w instrukcjach `let` i\ndekompozycji bÄ™dziemy rozmawiaÄ‡ w Rozdziale 19. Na razie wiedz, Å¼e uÅ¼ycie\ninstrukcji `let` w ten sposÃ³b jest wygodnym podejÅ›ciem do wyodrÄ™bniania\nelementÃ³w krotki zwracanej przez `mpsc::channel`.\n\nPrzenieÅ›my koniec nadawczy do utworzonego wÄ…tku i niech wyÅ›le jeden ciÄ…g\nznakÃ³w, tak aby utworzony wÄ…tek komunikowaÅ‚ siÄ™ z gÅ‚Ã³wnym wÄ…tkiem, jak\npokazano w Listingu 16-7. To jest jak wrzucenie gumowej kaczki do rzeki w\ngÃ³rnym biegu lub wysÅ‚anie wiadomoÅ›ci na czacie z jednego wÄ…tku do drugiego.\n\n<Listing number=\"16-7\" file-name=\"src/main.rs\" caption='Przenoszenie `tx` do utworzonego wÄ…tku i wysyÅ‚anie `\"hi\"`'>\n\n```rust\nuse std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from(\"hi\");\n        tx.send(val).unwrap();\n    });\n}\n```\n\n</Listing>\n\nPonownie uÅ¼ywamy `thread::spawn` do utworzenia nowego wÄ…tku, a nastÄ™pnie\nuÅ¼ywamy `move` do przeniesienia `tx` do domkniÄ™cia, tak aby utworzony wÄ…tek\nbyÅ‚ wÅ‚aÅ›cicielem `tx`. Utworzony wÄ…tek musi byÄ‡ wÅ‚aÅ›cicielem nadajnika, aby\nmÃ³c wysyÅ‚aÄ‡ wiadomoÅ›ci przez kanaÅ‚.\n\nNadajnik ma metodÄ™ `send`, ktÃ³ra przyjmuje wartoÅ›Ä‡, ktÃ³rÄ… chcemy wysÅ‚aÄ‡.\nMetoda `send` zwraca typ `Result<T, E>`, wiÄ™c jeÅ›li odbiornik zostaÅ‚ juÅ¼\nusuniÄ™ty i nie ma dokÄ…d wysÅ‚aÄ‡ wartoÅ›ci, operacja wysyÅ‚ania zwrÃ³ci bÅ‚Ä…d.\nW tym przykÅ‚adzie wywoÅ‚ujemy `unwrap`, aby spowodowaÄ‡ panikÄ™ w przypadku bÅ‚Ä™du.\nAle w prawdziwej aplikacji obsÅ‚uÅ¼ylibyÅ›my to poprawnie: WrÃ³Ä‡ do RozdziaÅ‚u 9,\naby przejrzeÄ‡ strategie wÅ‚aÅ›ciwej obsÅ‚ugi bÅ‚Ä™dÃ³w.\n\nW Listingu 16-8 pobierzemy wartoÅ›Ä‡ z odbiornika w gÅ‚Ã³wnym wÄ…tku. To jest jak\npobieranie gumowej kaczki z wody na koÅ„cu rzeki lub odbieranie wiadomoÅ›ci na\nczacie.\n\n<Listing number=\"16-8\" file-name=\"src/main.rs\" caption='Odbieranie wartoÅ›ci `\"hi\"` w gÅ‚Ã³wnym wÄ…tku i jej wypisywanie'>\n\n```rust\nuse std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from(\"hi\");\n        tx.send(val).unwrap();\n    });\n\n    let received = rx.recv().unwrap();\n    println!(\"Got: {received}\");\n}\n```\n\n</Listing>\n\nOdbiornik ma dwie przydatne metody: `recv` i `try_recv`. UÅ¼ywamy `recv`,\nskrÃ³tu od _receive_ (odbierz), ktÃ³ra zablokuje wykonanie gÅ‚Ã³wnego wÄ…tku i\npoczeka, aÅ¼ wartoÅ›Ä‡ zostanie wysÅ‚ana przez kanaÅ‚. Gdy tylko wartoÅ›Ä‡ zostanie\nwysÅ‚ana, `recv` zwrÃ³ci jÄ… w `Result<T, E>`. Gdy nadajnik zostanie zamkniÄ™ty,\n`recv` zwrÃ³ci bÅ‚Ä…d, sygnalizujÄ…c, Å¼e nie nadejdÄ… juÅ¼ wiÄ™cej wartoÅ›ci.\n\nMetoda `try_recv` nie blokuje, ale zamiast tego natychmiast zwraca `Result<T,\nE>`: wartoÅ›Ä‡ `Ok` zawierajÄ…cÄ… wiadomoÅ›Ä‡, jeÅ›li jest dostÄ™pna, oraz wartoÅ›Ä‡\n`Err`, jeÅ›li tym razem nie ma Å¼adnych wiadomoÅ›ci. UÅ¼ycie `try_recv` jest\nprzydatne, jeÅ›li ten wÄ…tek ma innÄ… pracÄ™ do wykonania podczas oczekiwania na\nwiadomoÅ›ci: MoglibyÅ›my napisaÄ‡ pÄ™tlÄ™, ktÃ³ra co jakiÅ› czas wywoÅ‚uje `try_recv`,\nobchodzi wiadomoÅ›Ä‡, jeÅ›li jest dostÄ™pna, a w przeciwnym razie wykonuje innÄ…\npracÄ™ przez jakiÅ› czas, zanim ponownie sprawdzi.\n\nW tym przykÅ‚adzie dla uproszczenia uÅ¼yliÅ›my `recv`; gÅ‚Ã³wny wÄ…tek nie ma innej\npracy do wykonania poza czekaniem na wiadomoÅ›ci, wiÄ™c blokowanie gÅ‚Ã³wnego\nwÄ…tku jest odpowiednie.\n\nPo uruchomieniu kodu z Listingu 16-8 zobaczymy wartoÅ›Ä‡ wypisanÄ… z gÅ‚Ã³wnego\nwÄ…tku:\n\n<!-- Not extracting output because changes to this output aren't significant;\nthe changes are likely to be due to the threads running differently rather than\nchanges in the compiler -->\n\n```text\nGot: hi\n```\n\nIdealnie!\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"channels-and-ownership-transference\"></a>\n\n### Przenoszenie wÅ‚asnoÅ›ci przez kanaÅ‚y\n\nZasady wÅ‚asnoÅ›ci odgrywajÄ… kluczowÄ… rolÄ™ w przesyÅ‚aniu wiadomoÅ›ci, poniewaÅ¼\npomagajÄ… pisaÄ‡ bezpieczny, wspÃ³Å‚bieÅ¼ny kod. Zapobieganie bÅ‚Ä™dom w programowaniu\nwspÃ³Å‚bieÅ¼nym to zaleta myÅ›lenia o wÅ‚asnoÅ›ci w caÅ‚ym programie Rust. PrzeprowadÅºmy\neksperyment, aby pokazaÄ‡, jak kanaÅ‚y i wÅ‚asnoÅ›Ä‡ wspÃ³Å‚pracujÄ…, aby zapobiegaÄ‡\nproblemom: SprÃ³bujemy uÅ¼yÄ‡ wartoÅ›ci `val` w utworzonym wÄ…tku _po_ tym, jak\nwysÅ‚aliÅ›my jÄ… przez kanaÅ‚. SprÃ³buj skompilowaÄ‡ kod z Listingu 16-9, aby\nzobaczyÄ‡, dlaczego ten kod jest niedozwolony.\n\n<Listing number=\"16-9\" file-name=\"src/main.rs\" caption=\"PrÃ³ba uÅ¼ycia `val` po wysÅ‚aniu go przez kanaÅ‚\">\n\n```rust,ignore,does_not_compile\nuse std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from(\"hi\");\n        tx.send(val).unwrap();\n        println!(\"val is {val}\");\n    });\n\n    let received = rx.recv().unwrap();\n    println!(\"Got: {received}\");\n}\n```\n\n</Listing>\n\nTutaj prÃ³bujemy wypisaÄ‡ `val` po tym, jak wysÅ‚aliÅ›my go przez kanaÅ‚ za pomocÄ…\n`tx.send`. Zezwolenie na to byÅ‚oby zÅ‚ym pomysÅ‚em: Gdy wartoÅ›Ä‡ zostanie\nwysÅ‚ana do innego wÄ…tku, ten wÄ…tek mÃ³gÅ‚by jÄ… zmodyfikowaÄ‡ lub usunÄ…Ä‡, zanim\nponownie sprÃ³bujemy jej uÅ¼yÄ‡. Potencjalnie modyfikacje innego wÄ…tku mogÅ‚yby\nspowodowaÄ‡ bÅ‚Ä™dy lub nieoczekiwane rezultaty z powodu niespÃ³jnych lub\nnieistniejÄ…cych danych. Jednak Rust zgÅ‚asza bÅ‚Ä…d, jeÅ›li sprÃ³bujemy\nskompilowaÄ‡ kod z Listingu 16-9:\n\n```console\n$ cargo run\n   Compiling message-passing v0.1.0 (file:///projects/message-passing)\nerror[E0382]: borrow of moved value: `val`\n  --> src/main.rs:10:27\n   |\n 8 |         let val = String::from(\"hi\");\n   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait\n 9 |         tx.send(val).unwrap();\n   |                 --- value moved here\n10 |         println!(\"val is {val}\");\n   |                           ^^^ value borrowed here after move\n   |\n   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0382`.\nerror: could not compile `message-passing` (bin \"message-passing\") due to 1 previous error\n```\n\nNasz bÅ‚Ä…d wspÃ³Å‚bieÅ¼noÅ›ci spowodowaÅ‚ bÅ‚Ä…d kompilacji. Funkcja `send` przejmuje\nwÅ‚asnoÅ›Ä‡ swojego parametru, a po przeniesieniu wartoÅ›ci odbiornik przejmuje jej\nwÅ‚asnoÅ›Ä‡. To uniemoÅ¼liwia nam przypadkowe ponowne uÅ¼ycie wartoÅ›ci po jej\nwysÅ‚aniu; system wÅ‚asnoÅ›ci sprawdza, czy wszystko jest w porzÄ…dku.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"sending-multiple-values-and-seeing-the-receiver-waiting\"></a>\n\n### WysyÅ‚anie wielu wartoÅ›ci\n\nKod z Listingu 16-8 skompilowaÅ‚ siÄ™ i zadziaÅ‚aÅ‚, ale nie pokazaÅ‚ nam jasno, Å¼e\ndwa oddzielne wÄ…tki komunikowaÅ‚y siÄ™ ze sobÄ… przez kanaÅ‚.\n\nW Listingu 16-10 wprowadziliÅ›my pewne modyfikacje, ktÃ³re udowodniÄ…, Å¼e kod z\nListingu 16-8 dziaÅ‚a wspÃ³Å‚bieÅ¼nie: utworzony wÄ…tek bÄ™dzie teraz wysyÅ‚aÅ‚ wiele\nwiadomoÅ›ci i pauzowaÅ‚ na sekundÄ™ miÄ™dzy kaÅ¼dÄ… wiadomoÅ›ciÄ….\n\n<Listing number=\"16-10\" file-name=\"src/main.rs\" caption=\"WysyÅ‚anie wielu wiadomoÅ›ci i pauzowanie miÄ™dzy kaÅ¼dÄ… z nich\">\n\n```rust,noplayground\nuse std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"hi\"),\n            String::from(\"from\"),\n            String::from(\"the\"),\n            String::from(\"thread\"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {\n        println!(\"Got: {received}\");\n    }\n}\n```\n\n</Listing>\n\nTym razem utworzony wÄ…tek ma wektor ciÄ…gÃ³w, ktÃ³re chcemy wysÅ‚aÄ‡ do gÅ‚Ã³wnego\nwÄ…tku. Iterujemy po nich, wysyÅ‚ajÄ…c kaÅ¼dy z osobna i pauzujÄ…c miÄ™dzy kaÅ¼dym,\nwywoÅ‚ujÄ…c funkcjÄ™ `thread::sleep` z wartoÅ›ciÄ… `Duration` wynoszÄ…cÄ… jednÄ… sekundÄ™.\n\nW gÅ‚Ã³wnym wÄ…tku nie wywoÅ‚ujemy juÅ¼ jawnie funkcji `recv`: Zamiast tego\ntraktujemy `rx` jako iterator. Dla kaÅ¼dej otrzymanej wartoÅ›ci wypisujemy jÄ….\nGdy kanaÅ‚ zostanie zamkniÄ™ty, iteracja siÄ™ zakoÅ„czy.\n\nPodczas uruchamiania kodu z Listingu 16-10 powinieneÅ› zobaczyÄ‡ nastÄ™pujÄ…cy\nwynik z jednominutowÄ… przerwÄ… miÄ™dzy kaÅ¼dÄ… liniÄ…:\n\n<!-- Not extracting output because changes to this output aren't significant;\nthe changes are likely to be due to the threads running differently rather than\nchanges in the compiler -->\n\n```text\nGot: hi\nGot: from\nGot: the\nGot: thread\n```\n\nPoniewaÅ¼ nie mamy Å¼adnego kodu, ktÃ³ry pauzuje lub opÃ³Åºnia w pÄ™tli `for` w\ngÅ‚Ã³wnym wÄ…tku, moÅ¼emy stwierdziÄ‡, Å¼e gÅ‚Ã³wny wÄ…tek czeka na odebranie wartoÅ›ci\nz utworzonego wÄ…tku.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"creating-multiple-producers-by-cloning-the-transmitter\"></a>\n\n### Tworzenie wielu producentÃ³w\n\nWczeÅ›niej wspomnieliÅ›my, Å¼e `mpsc` to skrÃ³t od _multiple producer, single\nconsumer_ (wiele producentÃ³w, jeden konsument). Wykorzystajmy `mpsc` i\nrozszerzmy kod z Listingu 16-10, aby utworzyÄ‡ wiele wÄ…tkÃ³w, ktÃ³re wszystkie\nwysyÅ‚ajÄ… wartoÅ›ci do tego samego odbiornika. MoÅ¼emy to zrobiÄ‡, klonujÄ…c\nnadajnik, jak pokazano w Listingu 16-11.\n\n<Listing number=\"16-11\" file-name=\"src/main.rs\" caption=\"WysyÅ‚anie wielu wiadomoÅ›ci od wielu producentÃ³w\">\n\n```rust,noplayground\n# use std::sync::mpsc;\n# use std::thread;\n# use std::time::Duration;\n# \n# fn main() {\n    // --snip--\n\n    let (tx, rx) = mpsc::channel();\n\n    let tx1 = tx.clone();\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"hi\"),\n            String::from(\"from\"),\n            String::from(\"the\"),\n            String::from(\"thread\"),\n        ];\n\n        for val in vals {\n            tx1.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"more\"),\n            String::from(\"messages\"),\n            String::from(\"for\"),\n            String::from(\"you\"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {\n        println!(\"Got: {received}\");\n    }\n\n    // --snip--\n# }\n```\n\n</Listing>\n\nTym razem, zanim utworzymy pierwszy wÄ…tek, wywoÅ‚ujemy `clone` na nadajniku.\nSpowoduje to utworzenie nowego nadajnika, ktÃ³ry moÅ¼emy przekazaÄ‡ do pierwszego\nutworzonego wÄ…tku. Oryginalny nadajnik przekazujemy do drugiego utworzonego\nwÄ…tku. Daje nam to dwa wÄ…tki, kaÅ¼dy wysyÅ‚ajÄ…cy rÃ³Å¼ne wiadomoÅ›ci do jednego\nodbiornika.\n\nPo uruchomieniu kodu, wynik powinien wyglÄ…daÄ‡ mniej wiÄ™cej tak:\n\n<!-- Not extracting output because changes to this output aren't significant;\nthe changes are likely to be due to the threads running differently rather than\nchanges in the compiler -->\n\n```text\nGot: hi\nGot: more\nGot: from\nGot: messages\nGot: for\nGot: the\nGot: thread\nGot: you\n```\n\nMoÅ¼esz zobaczyÄ‡ wartoÅ›ci w innej kolejnoÅ›ci, w zaleÅ¼noÅ›ci od twojego systemu.\nTo wÅ‚aÅ›nie sprawia, Å¼e wspÃ³Å‚bieÅ¼noÅ›Ä‡ jest interesujÄ…ca, a takÅ¼e trudna. JeÅ›li\npoeksperymentujesz z `thread::sleep`, nadajÄ…c mu rÃ³Å¼ne wartoÅ›ci w rÃ³Å¼nych\nwÄ…tkach, kaÅ¼de uruchomienie bÄ™dzie bardziej niedeterministyczne i za kaÅ¼dym\nrazem bÄ™dzie generowaÄ‡ inne dane wyjÅ›ciowe.\n\nTeraz, gdy przyjrzeliÅ›my siÄ™, jak dziaÅ‚ajÄ… kanaÅ‚y, spÃ³jrzmy na innÄ… metodÄ™\nwspÃ³Å‚bieÅ¼noÅ›ci.",
        "chapter_title": "PrzesyÅ‚anie danych miÄ™dzy wÄ…tkami za pomocÄ… przekazywania wiadomoÅ›ci"
    },
    {
        "file_path": "ch16-03-shared-state.md",
        "content": "## WspÃ³Å‚bieÅ¼noÅ›Ä‡ ze wspÃ³Å‚dzielonym stanem\n\nPrzekazywanie wiadomoÅ›ci to dobry sposÃ³b na obsÅ‚ugÄ™ wspÃ³Å‚bieÅ¼noÅ›ci, ale nie\njedyny. InnÄ… metodÄ… byÅ‚oby, aby wiele wÄ…tkÃ³w uzyskiwaÅ‚o dostÄ™p do tych samych\nwspÃ³Å‚dzielonych danych. Ponownie rozwaÅ¼my tÄ™ czÄ™Å›Ä‡ sloganu z dokumentacji\njÄ™zyka Go: â€Nie komunikuj siÄ™ poprzez wspÃ³Å‚dzielenie pamiÄ™ci.â€\n\nJak wyglÄ…daÅ‚aby komunikacja poprzez wspÃ³Å‚dzielenie pamiÄ™ci? Ponadto, dlaczego\nentuzjaÅ›ci przekazywania wiadomoÅ›ci ostrzegaliby przed uÅ¼ywaniem wspÃ³Å‚dzielenia\npamiÄ™ci?\n\nPod pewnym wzglÄ™dem kanaÅ‚y w kaÅ¼dym jÄ™zyku programowania sÄ… podobne do\npojedynczej wÅ‚asnoÅ›ci, poniewaÅ¼ po przeniesieniu wartoÅ›ci przez kanaÅ‚ nie\npowinno siÄ™ juÅ¼ wiÄ™cej uÅ¼ywaÄ‡ tej wartoÅ›ci. WspÃ³Å‚bieÅ¼noÅ›Ä‡ oparta na wspÃ³Å‚dzielonej\npamiÄ™ci jest jak wielokrotna wÅ‚asnoÅ›Ä‡: Wiele wÄ…tkÃ³w moÅ¼e uzyskiwaÄ‡ dostÄ™p do\ntego samego miejsca w pamiÄ™ci w tym samym czasie. Jak widziaÅ‚eÅ› w Rozdziale 15,\ngdzie wskaÅºniki sprytne umoÅ¼liwiÅ‚y wielokrotnÄ… wÅ‚asnoÅ›Ä‡, wielokrotna wÅ‚asnoÅ›Ä‡\nmoÅ¼e zwiÄ™kszyÄ‡ zÅ‚oÅ¼onoÅ›Ä‡, poniewaÅ¼ ci rÃ³Å¼ni wÅ‚aÅ›ciciele wymagajÄ… zarzÄ…dzania.\nSystem typÃ³w Rust i zasady wÅ‚asnoÅ›ci znacznie pomagajÄ… w prawidÅ‚owym\nzarzÄ…dzaniu. Na przykÅ‚ad, przyjrzyjmy siÄ™ muteksom, jednej z\nnajpopularniejszych prymitywÃ³w wspÃ³Å‚bieÅ¼noÅ›ci dla wspÃ³Å‚dzielonej pamiÄ™ci.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"using-mutexes-to-allow-access-to-data-from-one-thread-at-a-time\"></a>\n\n### Kontrolowanie dostÄ™pu za pomocÄ… muteksÃ³w\n\n_Muteks_ to skrÃ³t od _mutual exclusion_ (wzajemne wykluczenie), co oznacza, Å¼e\nmuteks pozwala tylko jednemu wÄ…tkowi na dostÄ™p do danych w danym momencie.\nAby uzyskaÄ‡ dostÄ™p do danych w muteksie, wÄ…tek musi najpierw zasygnalizowaÄ‡,\nÅ¼e chce uzyskaÄ‡ dostÄ™p, proszÄ…c o nabycie blokady muteksu. _Blokada_ to\nstruktura danych, ktÃ³ra jest czÄ™Å›ciÄ… muteksu i Å›ledzi, kto aktualnie ma\nwyÅ‚Ä…czny dostÄ™p do danych. Dlatego muteks jest opisywany jako _ochraniajÄ…cy_\ndane, ktÃ³re przechowuje, za pomocÄ… systemu blokowania.\n\nMuteksy majÄ… reputacjÄ™ trudnych w uÅ¼yciu, poniewaÅ¼ trzeba pamiÄ™taÄ‡ o dwÃ³ch\nzasadach:\n\n1. Musisz sprÃ³bowaÄ‡ uzyskaÄ‡ blokadÄ™ przed uÅ¼yciem danych.\n2. Kiedy skoÅ„czysz korzystaÄ‡ z danych chronionych przez muteks, musisz\n   zwolniÄ‡ blokadÄ™, aby inne wÄ…tki mogÅ‚y jÄ… uzyskaÄ‡.\n\nNa przykÅ‚ad, wyobraÅº sobie panel dyskusyjny na konferencji z tylko jednym\nmikrofonem. Zanim panelista bÄ™dzie mÃ³gÅ‚ mÃ³wiÄ‡, musi zapytaÄ‡ lub zasygnalizowaÄ‡,\nÅ¼e chce uÅ¼yÄ‡ mikrofonu. Kiedy dostanie mikrofon, moÅ¼e mÃ³wiÄ‡ tak dÅ‚ugo, jak\nchce, a nastÄ™pnie przekazaÄ‡ mikrofon kolejnemu panelistowi, ktÃ³ry poprosi o\nmÃ³wienie. JeÅ›li panelista zapomni oddaÄ‡ mikrofon, gdy skoÅ„czy z niego\nkorzystaÄ‡, nikt inny nie bÄ™dzie mÃ³gÅ‚ mÃ³wiÄ‡. JeÅ›li zarzÄ…dzanie wspÃ³lnym\nmikrofonem pÃ³jdzie Åºle, panel nie zadziaÅ‚a zgodnie z planem!\n\nZarzÄ…dzanie muteksami moÅ¼e byÄ‡ niezwykle trudne do prawidÅ‚owego wykonania,\ndlatego tak wiele osÃ³b jest entuzjastycznie nastawionych do kanaÅ‚Ã³w.\nJednak dziÄ™ki systemowi typÃ³w i zasadom wÅ‚asnoÅ›ci Rust, nie moÅ¼na pomyliÄ‡\nsiÄ™ z blokowaniem i odblokowywaniem.\n\n#### API `Mutex<T>`\n\nJako przykÅ‚ad uÅ¼ycia muteksu, zacznijmy od uÅ¼ycia muteksu w kontekÅ›cie\njednowÄ…tkowym, jak pokazano w Listingu 16-12.\n\n<Listing number=\"16-12\" file-name=\"src/main.rs\" caption=\"Badanie API `Mutex<T>` w kontekÅ›cie jednowÄ…tkowym dla uproszczenia\">\n\n```rust\nuse std::sync::Mutex;\n\nfn main() {\n    let m = Mutex::new(5);\n\n    {\n        let mut num = m.lock().unwrap();\n        *num = 6;\n    }\n\n    println!(\"m = {m:?}\");\n}\n```\n\n</Listing>\n\nPodobnie jak w przypadku wielu typÃ³w, tworzymy `Mutex<T>` za pomocÄ…\nskojarzonej funkcji `new`. Aby uzyskaÄ‡ dostÄ™p do danych wewnÄ…trz muteksu,\nuÅ¼ywamy metody `lock`, aby uzyskaÄ‡ blokadÄ™. To wywoÅ‚anie zablokuje bieÅ¼Ä…cy\nwÄ…tek, tak aby nie mÃ³gÅ‚ on wykonywaÄ‡ Å¼adnej pracy, dopÃ³ki nie nadejdzie nasza\nkolej na uzyskanie blokady.\n\nWywoÅ‚anie `lock` zakoÅ„czyÅ‚oby siÄ™ niepowodzeniem, gdyby inny wÄ…tek trzymajÄ…cy\nblokadÄ™ wywoÅ‚aÅ‚ panikÄ™. W takim przypadku nikt nigdy nie mÃ³gÅ‚by uzyskaÄ‡ blokady,\ndlatego zdecydowaliÅ›my siÄ™ na `unwrap`, aby ten wÄ…tek wywoÅ‚aÅ‚ panikÄ™, jeÅ›li\nznajdziemy siÄ™ w takiej sytuacji.\n\nPo uzyskaniu blokady, moÅ¼emy traktowaÄ‡ zwrÃ³conÄ… wartoÅ›Ä‡, nazwanÄ… w tym przypadku\n`num`, jako mutowalnÄ… referencjÄ™ do wewnÄ™trznych danych. System typÃ³w\ngwarantuje, Å¼e uzyskujemy blokadÄ™ przed uÅ¼yciem wartoÅ›ci w `m`. Typ `m` to\n`Mutex<i32>`, a nie `i32`, wiÄ™c _musimy_ wywoÅ‚aÄ‡ `lock`, aby mÃ³c uÅ¼yÄ‡ wartoÅ›ci\n`i32`. Nie moÅ¼emy zapomnieÄ‡; system typÃ³w w przeciwnym razie nie pozwoli nam\nna dostÄ™p do wewnÄ™trznej wartoÅ›ci `i32`.\n\nWywoÅ‚anie `lock` zwraca typ nazwany `MutexGuard`, opakowany w `LockResult`,\nktÃ³ry obsÅ‚uÅ¼yliÅ›my wywoÅ‚aniem `unwrap`. Typ `MutexGuard` implementuje `Deref`,\naby wskazywaÄ‡ na nasze wewnÄ™trzne dane; typ ten ma rÃ³wnieÅ¼ implementacjÄ™ `Drop`,\nktÃ³ra automatycznie zwalnia blokadÄ™, gdy `MutexGuard` wyjdzie poza zakres,\nco dzieje siÄ™ na koÅ„cu wewnÄ™trznego zakresu. W rezultacie nie ryzykujemy\nzapomnienia o zwolnieniu blokady i zablokowania muteksu przed uÅ¼yciem przez\ninne wÄ…tki, poniewaÅ¼ zwolnienie blokady odbywa siÄ™ automatycznie.\n\nPo zwolnieniu blokady moÅ¼emy wypisaÄ‡ wartoÅ›Ä‡ muteksu i zobaczyÄ‡, Å¼e udaÅ‚o nam\nsiÄ™ zmieniÄ‡ wewnÄ™trznÄ… wartoÅ›Ä‡ `i32` na `6`.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"sharing-a-mutext-between-multiple-threads\"></a>\n\n#### WspÃ³Å‚dzielony dostÄ™p do `Mutex<T>`\n\nTeraz sprÃ³bujmy wspÃ³Å‚dzieliÄ‡ wartoÅ›Ä‡ miÄ™dzy wieloma wÄ…tkami za pomocÄ… `Mutex<T>`.\nUruchomimy 10 wÄ…tkÃ³w i kaÅ¼dy z nich zwiÄ™kszy wartoÅ›Ä‡ licznika o 1, wiÄ™c licznik\nwzroÅ›nie od 0 do 10. PrzykÅ‚ad w Listingu 16-13 spowoduje bÅ‚Ä…d kompilacji, a my\nwykorzystamy ten bÅ‚Ä…d, aby dowiedzieÄ‡ siÄ™ wiÄ™cej o uÅ¼ywaniu `Mutex<T>` i o tym,\njak Rust pomaga nam uÅ¼ywaÄ‡ go poprawnie.\n\n<Listing number=\"16-13\" file-name=\"src/main.rs\" caption=\"DziesiÄ™Ä‡ wÄ…tkÃ³w, z ktÃ³rych kaÅ¼dy zwiÄ™ksza licznik chroniony przez `Mutex<T>`\">\n\n```rust,ignore,does_not_compile\nuse std::sync::Mutex;\nuse std::thread;\n\nfn main() {\n    let counter = Mutex::new(0);\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n```\n\n</Listing>\n\nTworzymy zmiennÄ… `counter` do przechowywania `i32` wewnÄ…trz `Mutex<T>`, tak jak\nzrobiliÅ›my to w Listingu 16-12. NastÄ™pnie tworzymy 10 wÄ…tkÃ³w, iterujÄ…c po\nzakresie liczb. UÅ¼ywamy `thread::spawn` i przekazujemy wszystkim wÄ…tkom to\nsamo domkniÄ™cie: takie, ktÃ³re przenosi licznik do wÄ…tku, uzyskuje blokadÄ™ na\n`Mutex<T>` poprzez wywoÅ‚anie metody `lock`, a nastÄ™pnie dodaje 1 do wartoÅ›ci w\nmuteksie. Gdy wÄ…tek zakoÅ„czy wykonywanie swojego domkniÄ™cia, `num` wyjdzie\npoza zakres i zwolni blokadÄ™, aby inny wÄ…tek mÃ³gÅ‚ jÄ… uzyskaÄ‡.\n\nW gÅ‚Ã³wnym wÄ…tku zbieramy wszystkie uchwyty `join`. NastÄ™pnie, jak to zrobiliÅ›my\nw Listingu 16-2, wywoÅ‚ujemy `join` na kaÅ¼dym uchwycie, aby upewniÄ‡ siÄ™, Å¼e\nwszystkie wÄ…tki siÄ™ zakoÅ„czyÅ‚y. W tym momencie gÅ‚Ã³wny wÄ…tek uzyska blokadÄ™ i\nwypisze wynik tego programu.\n\nSugerowaliÅ›my, Å¼e ten przykÅ‚ad siÄ™ nie skompiluje. Teraz dowiemy siÄ™, dlaczego!\n\n```console\n$ cargo run\n   Compiling shared-state v0.1.0 (file:///projects/shared-state)\nerror[E0382]: borrow of moved value: `counter`\n  --> src/main.rs:21:29\n   |\n 5 |     let counter = Mutex::new(0);\n   |         ------- move occurs because `counter` has type `std::sync::Mutex<i32>`, which does not implement the `Copy` trait\n...\n 8 |     for _ in 0..10 {\n   |     -------------- inside of this loop\n 9 |         let handle = thread::spawn(move || {\n   |                                    ------- value moved into closure here, in previous iteration of loop\n...\n21 |     println!(\"Result: {}\", *counter.lock().unwrap());\n   |                             ^^^^^^^ value borrowed here after move\n   |\nhelp: consider moving the expression out of the loop so it is only moved once\n   |\n 8 ~     let mut value = counter.lock();\n 9 ~     for _ in 0..10 {\n10 |         let handle = thread::spawn(move || {\n11 ~             let mut num = value.unwrap();\n   |\n\nFor more information about this error, try `rustc --explain E0382`.\nerror: could not compile `shared-state` (bin \"shared-state\") due to 1 previous error\n```\n\nKomunikat o bÅ‚Ä™dzie wskazuje, Å¼e wartoÅ›Ä‡ `counter` zostaÅ‚a przeniesiona w\npoprzedniej iteracji pÄ™tli. Rust informuje nas, Å¼e nie moÅ¼emy przenieÅ›Ä‡ wÅ‚asnoÅ›ci\nblokady `counter` do wielu wÄ…tkÃ³w. Naprawmy bÅ‚Ä…d kompilacji, uÅ¼ywajÄ…c metody\nwielokrotnej wÅ‚asnoÅ›ci, ktÃ³rÄ… omÃ³wiliÅ›my w Rozdziale 15.\n\n#### Wielokrotna wÅ‚asnoÅ›Ä‡ z wieloma wÄ…tkami\n\nW Rozdziale 15, nadaliÅ›my wartoÅ›Ä‡ wielu wÅ‚aÅ›cicielom, uÅ¼ywajÄ…c wskaÅºnika\nsprytnego `Rc<T>` do stworzenia wartoÅ›ci zliczanej referencjami. ZrÃ³bmy to samo\ntutaj i zobaczmy, co siÄ™ stanie. Opakujemy `Mutex<T>` w `Rc<T>` w Listingu 16-14\ni sklonujemy `Rc<T>` przed przeniesieniem wÅ‚asnoÅ›ci do wÄ…tku.\n\n<Listing number=\"16-14\" file-name=\"src/main.rs\" caption=\"PrÃ³ba uÅ¼ycia `Rc<T>`, aby umoÅ¼liwiÄ‡ wielu wÄ…tkom posiadanie `Mutex<T>`\">\n\n```rust,ignore,does_not_compile\nuse std::rc::Rc;\nuse std::sync::Mutex;\nuse std::thread;\n\nfn main() {\n    let counter = Rc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Rc::clone(&counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n```\n\n</Listing>\n\nPonownie kompilujemy i otrzymujemy... inne bÅ‚Ä™dy! Kompilator wiele nas uczy:\n\n```console\n$ cargo run\n   Compiling shared-state v0.1.0 (file:///projects/shared-state)\nerror[E0277]: `Rc<std::sync::Mutex<i32>>` cannot be sent between threads safely\n  --> src/main.rs:11:36\n   |\n11 |           let handle = thread::spawn(move || {\n   |                        ------------- ^------\n   |                        |             |\n   |  ______________________|_____________within this `{closure@src/main.rs:11:36: 11:43}`\n   | |                      |\n   | |                      required by a bound introduced by this call\n12 | |             let mut num = counter.lock().unwrap();\n13 | |\n14 | |             *num += 1;\n15 | |         });\n   | |_________^ `Rc<std::sync::Mutex<i32>>` cannot be sent between threads safely\n   |\n   = help: within `{closure@src/main.rs:11:36: 11:43}`, the trait `Send` is not implemented for `Rc<std::sync::Mutex<i32>>`\nnote: required because it's used within this closure\n  --> src/main.rs:11:36\n   |\n11 |         let handle = thread::spawn(move || {\n   |                                    ^^^^^^^\nnote: required by a bound in `spawn`\n  --> /rustc/1159e78c4747b02ef996e55082b704c09b970588/library/std/src/thread/mod.rs:723:1\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `shared-state` (bin \"shared-state\") due to 1 previous error\n```\n\nWow, ten komunikat o bÅ‚Ä™dzie jest bardzo rozwlekÅ‚y! Oto najwaÅ¼niejsza czÄ™Å›Ä‡, na\nktÃ³rej naleÅ¼y siÄ™ skupiÄ‡: `` `Rc<Mutex<i32>>` cannot be sent between threads\nsafely ``. Kompilator podaje nam rÃ³wnieÅ¼ przyczynÄ™: `` the trait `Send` is not\nimplemented for `Rc<Mutex<i32>>` ``. O `Send` bÄ™dziemy rozmawiaÄ‡ w nastÄ™pnej\nsekcji: Jest to jedna z cech, ktÃ³ra zapewnia, Å¼e typy, ktÃ³rych uÅ¼ywamy z\nwÄ…tkami, sÄ… przeznaczone do uÅ¼ytku w sytuacjach wspÃ³Å‚bieÅ¼nych.\n\nNiestety, `Rc<T>` nie jest bezpieczny do wspÃ³Å‚dzielenia miÄ™dzy wÄ…tkami. Kiedy\n`Rc<T>` zarzÄ…dza licznikiem referencji, dodaje do licznika dla kaÅ¼dego wywoÅ‚ania\n`clone` i odejmuje od licznika, gdy kaÅ¼dy klon zostanie usuniÄ™ty. Ale nie uÅ¼ywa\nÅ¼adnych prymitywÃ³w wspÃ³Å‚bieÅ¼noÅ›ci, aby upewniÄ‡ siÄ™, Å¼e zmiany w liczniku nie\nmogÄ… byÄ‡ przerwane przez inny wÄ…tek. MoÅ¼e to prowadziÄ‡ do bÅ‚Ä™dnych licznikÃ³w\nâ€” subtelnych bÅ‚Ä™dÃ³w, ktÃ³re z kolei mogÄ… prowadziÄ‡ do wyciekÃ³w pamiÄ™ci lub\nprzedwczesnego usuniÄ™cia wartoÅ›ci. Potrzebujemy typu, ktÃ³ry jest dokÅ‚adnie\ntaki jak `Rc<T>`, ale ktÃ³ry dokonuje zmian w liczniku referencji w sposÃ³b\nbardzo bezpieczny dla wÄ…tkÃ³w.\n\n#### Atomowe zliczanie referencji za pomocÄ… `Arc<T>`\n\nNa szczÄ™Å›cie `Arc<T>` _jest_ typem podobnym do `Rc<T>`, ktÃ³ry jest bezpieczny\nw uÅ¼yciu w sytuacjach wspÃ³Å‚bieÅ¼nych. Litera _a_ oznacza _atomic_, co oznacza,\nÅ¼e jest to typ _atomowo zliczajÄ…cy referencje_. Atomy to dodatkowy rodzaj\nprymitywu wspÃ³Å‚bieÅ¼noÅ›ci, ktÃ³rego nie bÄ™dziemy szczegÃ³Å‚owo omawiaÄ‡: WiÄ™cej\nszczegÃ³Å‚Ã³w moÅ¼na znaleÅºÄ‡ w dokumentacji biblioteki standardowej dla\n[`std::sync::atomic`][atomic]<!-- ignore -->. W tym momencie wystarczy wiedzieÄ‡,\nÅ¼e atomy dziaÅ‚ajÄ… jak typy prymitywne, ale sÄ… bezpieczne do wspÃ³Å‚dzielenia\nmiÄ™dzy wÄ…tkami.\n\nMoÅ¼esz siÄ™ wtedy zastanawiaÄ‡, dlaczego wszystkie typy prymitywne nie sÄ…\natomowe i dlaczego typy biblioteki standardowej nie sÄ… domyÅ›lnie\nzimplementowane do uÅ¼ywania `Arc<T>`. Powodem jest to, Å¼e bezpieczeÅ„stwo\nwÄ…tkowe wiÄ…Å¼e siÄ™ z karÄ… wydajnoÅ›ciowÄ…, ktÃ³rÄ… chcesz ponieÅ›Ä‡ tylko wtedy, gdy\nrzeczywiÅ›cie tego potrzebujesz. JeÅ›li wykonujesz operacje na wartoÅ›ciach\njednowÄ…tkowo, twÃ³j kod moÅ¼e dziaÅ‚aÄ‡ szybciej, jeÅ›li nie musi egzekwowaÄ‡\ngwarancji zapewnianych przez atomy.\n\nWrÃ³Ä‡my do naszego przykÅ‚adu: `Arc<T>` i `Rc<T>` majÄ… to samo API, wiÄ™c\nnaprawiamy nasz program, zmieniajÄ…c liniÄ™ `use`, wywoÅ‚anie `new` i wywoÅ‚anie\n`clone`. Kod w Listingu 16-15 ostatecznie skompiluje siÄ™ i uruchomi.\n\n<Listing number=\"16-15\" file-name=\"src/main.rs\" caption=\"UÅ¼ycie `Arc<T>` do opakowania `Mutex<T>`, aby mÃ³c wspÃ³Å‚dzieliÄ‡ wÅ‚asnoÅ›Ä‡ miÄ™dzy wieloma wÄ…tkami\">\n\n```rust\nuse std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn main() {\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Arc::clone(&counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n```\n\n</Listing>\n\nTen kod wypisze nastÄ™pujÄ…ce:\n\n<!-- Not extracting output because changes to this output aren't significant;\nthe changes are likely to be due to the threads running differently rather than\nchanges in the compiler -->\n\n```text\nResult: 10\n```\n\nUdaÅ‚o siÄ™! PoliczyliÅ›my od 0 do 10, co moÅ¼e nie wydawaÄ‡ siÄ™ zbyt imponujÄ…ce,\nale wiele nas nauczyÅ‚o o `Mutex<T>` i bezpieczeÅ„stwie wÄ…tkowym. MoÅ¼esz rÃ³wnieÅ¼\nwykorzystaÄ‡ strukturÄ™ tego programu do bardziej skomplikowanych operacji niÅ¼\nsamo zwiÄ™kszanie licznika. UÅ¼ywajÄ…c tej strategii, moÅ¼esz podzieliÄ‡ obliczenia\nna niezaleÅ¼ne czÄ™Å›ci, rozdzieliÄ‡ te czÄ™Å›ci miÄ™dzy wÄ…tki, a nastÄ™pnie uÅ¼yÄ‡\n`Mutex<T>`, aby kaÅ¼dy wÄ…tek aktualizowaÅ‚ ostateczny wynik swojÄ… czÄ™Å›ciÄ….\n\nZauwaÅ¼, Å¼e jeÅ›li wykonujesz proste operacje numeryczne, istniejÄ… typy\nprostsze niÅ¼ `Mutex<T>` udostÄ™pniane przez moduÅ‚\n[`std::sync::atomic` biblioteki standardowej][atomic]<!-- ignore -->. Typy te\nzapewniajÄ… bezpieczny, wspÃ³Å‚bieÅ¼ny, atomowy dostÄ™p do typÃ³w prymitywnych.\nWybraliÅ›my uÅ¼ycie `Mutex<T>` z typem prymitywnym w tym przykÅ‚adzie, abyÅ›my mogli\nskupiÄ‡ siÄ™ na tym, jak dziaÅ‚a `Mutex<T>`.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"similarities-between-refcelltrct-and-mutextarct\"></a>\n\n### PorÃ³wnanie `RefCell<T>`/`Rc<T>` i `Mutex<T>`/`Arc<T>`\n\nByÄ‡ moÅ¼e zauwaÅ¼yÅ‚eÅ›, Å¼e `counter` jest niemutowalny, ale mogliÅ›my uzyskaÄ‡ do\nwartoÅ›ci w nim mutowalnÄ… referencjÄ™; oznacza to, Å¼e `Mutex<T>` zapewnia\nmutowalnoÅ›Ä‡ wewnÄ™trznÄ…, podobnie jak rodzina `Cell`. W ten sam sposÃ³b, w jaki\nwykorzystaliÅ›my `RefCell<T>` w Rozdziale 15, aby umoÅ¼liwiÄ‡ nam mutowanie\nzawartoÅ›ci wewnÄ…trz `Rc<T>`, uÅ¼ywamy `Mutex<T>` do mutowania zawartoÅ›ci wewnÄ…trz\n`Arc<T>`.\n\nKolejny szczegÃ³Å‚ do odnotowania to to, Å¼e Rust nie jest w stanie ochroniÄ‡ CiÄ™\nprzed wszystkimi rodzajami bÅ‚Ä™dÃ³w logicznych, gdy uÅ¼ywasz `Mutex<T>`. Przypomnij\nsobie z RozdziaÅ‚u 15, Å¼e uÅ¼ycie `Rc<T>` wiÄ…zaÅ‚o siÄ™ z ryzykiem tworzenia cykli\nreferencji, gdzie dwie wartoÅ›ci `Rc<T>` odwoÅ‚ujÄ… siÄ™ do siebie nawzajem,\npowodujÄ…c wycieki pamiÄ™ci. Podobnie, `Mutex<T>` wiÄ…Å¼e siÄ™ z ryzykiem tworzenia\n_zakleszczeÅ„_. Dzieje siÄ™ to, gdy operacja musi zablokowaÄ‡ dwa zasoby, a dwa\nwÄ…tki uzyskaÅ‚y po jednej blokadzie, powodujÄ…c, Å¼e czekajÄ… na siebie nawzajem w\nnieskoÅ„czonoÅ›Ä‡. JeÅ›li interesujÄ… CiÄ™ zakleszczenia, sprÃ³buj stworzyÄ‡ program\nw Rust, ktÃ³ry ma zakleszczenie; nastÄ™pnie zbadaj strategie Å‚agodzenia\nzakleszczeÅ„ dla muteksÃ³w w dowolnym jÄ™zyku i sprÃ³buj je zaimplementowaÄ‡ w Rust.\nDokumentacja API biblioteki standardowej dla `Mutex<T>` i `MutexGuard` oferuje\nprzydatne informacje.\n\nUkoÅ„czymy ten rozdziaÅ‚, mÃ³wiÄ…c o cechach `Send` i `Sync` oraz o tym, jak moÅ¼emy\nich uÅ¼ywaÄ‡ z niestandardowymi typami.\n\n[atomic]: ../std/sync/atomic/index.html",
        "chapter_title": "WspÃ³Å‚bieÅ¼noÅ›Ä‡ ze wspÃ³Å‚dzielonym stanem"
    },
    {
        "file_path": "ch16-04-extensible-concurrency-sync-and-send.md",
        "content": "<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"extensible-concurrency-with-the-sync-and-send-traits\"></a>\n<a id=\"extensible-concurrency-with-the-send-and-sync-traits\"></a>\n\n## Rozszerzalna wspÃ³Å‚bieÅ¼noÅ›Ä‡ dziÄ™ki cechom `Send` i `Sync`\n\nCo ciekawe, prawie kaÅ¼da funkcja wspÃ³Å‚bieÅ¼noÅ›ci, o ktÃ³rej do tej pory\nmÃ³wiliÅ›my w tym rozdziale, byÅ‚a czÄ™Å›ciÄ… biblioteki standardowej, a nie jÄ™zyka.\nTwoje opcje obsÅ‚ugi wspÃ³Å‚bieÅ¼noÅ›ci nie ograniczajÄ… siÄ™ do jÄ™zyka ani\nbiblioteki standardowej; moÅ¼esz pisaÄ‡ wÅ‚asne funkcje wspÃ³Å‚bieÅ¼noÅ›ci lub\nkorzystaÄ‡ z tych napisanych przez innych.\n\nJednakÅ¼e, wÅ›rÃ³d kluczowych koncepcji wspÃ³Å‚bieÅ¼noÅ›ci, ktÃ³re sÄ… osadzone w jÄ™zyku,\na nie w bibliotece standardowej, znajdujÄ… siÄ™ cechy znacznika `std::marker`\n`Send` i `Sync`.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"allowing-transference-of-ownership-between-threads-with-send\"></a>\n\n### Przenoszenie wÅ‚asnoÅ›ci miÄ™dzy wÄ…tkami\n\nCecha znacznikowa `Send` wskazuje, Å¼e wÅ‚asnoÅ›Ä‡ wartoÅ›ci typu implementujÄ…cego\n`Send` moÅ¼e byÄ‡ przenoszona miÄ™dzy wÄ…tkami. Prawie kaÅ¼dy typ Rust\nimplementuje `Send`, ale istniejÄ… pewne wyjÄ…tki, w tym `Rc<T>`: Nie moÅ¼e on\nimplementowaÄ‡ `Send`, poniewaÅ¼ gdybyÅ› sklonowaÅ‚ wartoÅ›Ä‡ `Rc<T>` i prÃ³bowaÅ‚\nprzenieÅ›Ä‡ wÅ‚asnoÅ›Ä‡ klonu do innego wÄ…tku, oba wÄ…tki mogÅ‚yby jednoczeÅ›nie\nzaktualizowaÄ‡ licznik referencji. Z tego powodu `Rc<T>` jest zaimplementowany\ndo uÅ¼ytku w sytuacjach jednowÄ…tkowych, gdzie nie chcesz ponosiÄ‡ kary\nwydajnoÅ›ciowej zwiÄ…zanej z bezpieczeÅ„stwem wÄ…tkÃ³w.\n\nDlatego system typÃ³w Rust i ograniczenia cech zapewniajÄ…, Å¼e nigdy nie moÅ¼esz\nprzypadkowo wysÅ‚aÄ‡ wartoÅ›ci `Rc<T>` miÄ™dzy wÄ…tkami w sposÃ³b niebezpieczny.\nKiedy prÃ³bowaliÅ›my to zrobiÄ‡ w Listingu 16-14, otrzymaliÅ›my bÅ‚Ä…d `` the trait\n`Send` is not implemented for `Rc<Mutex<i32>>` ``. Kiedy zmieniliÅ›my na `Arc<T>`,\nktÃ³ry implementuje `Send`, kod siÄ™ skompilowaÅ‚.\n\nKaÅ¼dy typ skÅ‚adajÄ…cy siÄ™ wyÅ‚Ä…cznie z typÃ³w `Send` jest automatycznie\noznaczany jako `Send`. Prawie wszystkie typy prymitywne sÄ… `Send`, poza\nsurowymi wskaÅºnikami, o ktÃ³rych bÄ™dziemy rozmawiaÄ‡ w Rozdziale 20.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"allowing-access-from-multiple-threads-with-sync\"></a>\n\n### DostÄ™p z wielu wÄ…tkÃ³w\n\nCecha znacznikowa `Sync` wskazuje, Å¼e bezpieczne jest odwoÅ‚ywanie siÄ™ do typu\nimplementujÄ…cego `Sync` z wielu wÄ…tkÃ³w. Innymi sÅ‚owy, kaÅ¼dy typ `T`\nimplementuje `Sync`, jeÅ›li `&T` (niemutowalna referencja do `T`) implementuje\n`Send`, co oznacza, Å¼e referencja moÅ¼e byÄ‡ bezpiecznie wysÅ‚ana do innego wÄ…tku.\nPodobnie jak `Send`, wszystkie typy prymitywne implementujÄ… `Sync`, a typy\nskÅ‚adajÄ…ce siÄ™ wyÅ‚Ä…cznie z typÃ³w implementujÄ…cych `Sync` rÃ³wnieÅ¼ implementujÄ…\n`Sync`.\n\nWskaÅºnik sprytny `Rc<T>` rÃ³wnieÅ¼ nie implementuje `Sync` z tych samych powodÃ³w,\ndla ktÃ³rych nie implementuje `Send`. Typ `RefCell<T>` (o ktÃ³rym mÃ³wiliÅ›my w\nRozdziale 15) i rodzina powiÄ…zanych typÃ³w `Cell<T>` nie implementujÄ… `Sync`.\nImplementacja sprawdzania poÅ¼yczeÅ„, ktÃ³rÄ… `RefCell<T>` wykonuje w czasie\nwykonania, nie jest bezpieczna wÄ…tkowo. WskaÅºnik sprytny `Mutex<T>` implementuje\n`Sync` i moÅ¼e byÄ‡ uÅ¼ywany do wspÃ³Å‚dzielenia dostÄ™pu z wieloma wÄ…tkami, jak\nwidziaÅ‚eÅ› w sekcji [â€WspÃ³Å‚dzielony dostÄ™p do `Mutex<T>`â€][shared-access]<!-- ignore -->.\n\n### RÄ™czna implementacja `Send` i `Sync` jest niebezpieczna\n\nPoniewaÅ¼ typy skÅ‚adajÄ…ce siÄ™ wyÅ‚Ä…cznie z innych typÃ³w, ktÃ³re implementujÄ…\ncechy `Send` i `Sync`, automatycznie implementujÄ… rÃ³wnieÅ¼ `Send` i `Sync`, nie\nmusimy implementowaÄ‡ tych cech rÄ™cznie. Jako cechy znacznikowe, nie majÄ… one\nnawet Å¼adnych metod do zaimplementowania. SÄ… po prostu przydatne do\negzekwowania niezmiennikÃ³w zwiÄ…zanych ze wspÃ³Å‚bieÅ¼noÅ›ciÄ….\n\nRÄ™czna implementacja tych cech wiÄ…Å¼e siÄ™ z uÅ¼yciem niebezpiecznego kodu Rust.\nO uÅ¼ywaniu niebezpiecznego kodu Rust bÄ™dziemy rozmawiaÄ‡ w Rozdziale 20;\nna razie waÅ¼nÄ… informacjÄ… jest to, Å¼e budowanie nowych typÃ³w wspÃ³Å‚bieÅ¼nych nie\nskÅ‚adajÄ…cych siÄ™ z czÄ™Å›ci `Send` i `Sync` wymaga starannego przemyÅ›lenia w\nc celu utrzymania gwarancji bezpieczeÅ„stwa. [â€The Rustonomiconâ€][nomicon]\nzawiera wiÄ™cej informacji na temat tych gwarancji i sposobÃ³w ich\npodtrzymywania.\n\n## Podsumowanie\n\nTo nie jest ostatni raz, kiedy spotkasz siÄ™ ze wspÃ³Å‚bieÅ¼noÅ›ciÄ… w tej ksiÄ…Å¼ce:\nnastÄ™pny rozdziaÅ‚ skupia siÄ™ na programowaniu asynchronicznym, a projekt w\nRozdziale 21 wykorzysta koncepcje z tego rozdziaÅ‚u w bardziej realistycznej\nsytuacji niÅ¼ omÃ³wione tutaj mniejsze przykÅ‚ady.\n\nJak wspomniano wczeÅ›niej, poniewaÅ¼ niewiele z tego, jak Rust obsÅ‚uguje\nwspÃ³Å‚bieÅ¼noÅ›Ä‡, jest czÄ™Å›ciÄ… jÄ™zyka, wiele rozwiÄ…zaÅ„ wspÃ³Å‚bieÅ¼noÅ›ci jest\nimplementowanych jako crate'y. EwoluujÄ… one szybciej niÅ¼ biblioteka standardowa,\nwiÄ™c pamiÄ™taj, aby szukaÄ‡ w Internecie aktualnych, najnowoczeÅ›niejszych\ncrate'Ã³w do uÅ¼ycia w sytuacjach wielowÄ…tkowych.\n\nBiblioteka standardowa Rust zapewnia kanaÅ‚y do przekazywania wiadomoÅ›ci oraz\ntypy wskaÅºnikÃ³w sprytnych, takie jak `Mutex<T>` i `Arc<T>`, ktÃ³re sÄ… bezpieczne\nw uÅ¼yciu w kontekstach wspÃ³Å‚bieÅ¼nych. System typÃ³w i sprawdzajÄ…cy poÅ¼yczki\nzapewniajÄ…, Å¼e kod uÅ¼ywajÄ…cy tych rozwiÄ…zaÅ„ nie doprowadzi do wyÅ›cigÃ³w danych\noraz do niewaÅ¼nych referencji. Gdy kod siÄ™ skompiluje, moÅ¼esz byÄ‡ pewien, Å¼e\nbÄ™dzie dziaÅ‚aÅ‚ na wielu wÄ…tkach bez trudnych do znalezienia bÅ‚Ä™dÃ³w, typowych\ndla innych jÄ™zykÃ³w. Programowanie wspÃ³Å‚bieÅ¼ne nie jest juÅ¼ pojÄ™ciem, ktÃ³rego\nnaleÅ¼y siÄ™ obawiaÄ‡: idÅº i spraw, aby twoje programy byÅ‚y wspÃ³Å‚bieÅ¼ne,\nbez strachu!\n\n[shared-access]: ch16-03-shared-state.html#shared-access-to-mutext\n[nomicon]: ../nomicon/index.html",
        "chapter_title": "Rozszerzalna wspÃ³Å‚bieÅ¼noÅ›Ä‡ dziÄ™ki cechom `Send` i `Sync`"
    },
    {
        "file_path": "ch17-00-async-await.md",
        "content": "# Podstawy programowania asynchronicznego: Async, Await, Futures i Streams\n\nWiele operacji, o ktÃ³re prosimy komputer, moÅ¼e zajÄ…Ä‡ trochÄ™ czasu. Dobrze by\nbyÅ‚o, gdybyÅ›my mogli robiÄ‡ coÅ› innego, czekajÄ…c na zakoÅ„czenie tych\ndÅ‚ugotrwaÅ‚ych procesÃ³w. Nowoczesne komputery oferujÄ… dwie techniki pracy nad\nwiÄ™cej niÅ¼ jednÄ… operacjÄ… jednoczeÅ›nie: rÃ³wnolegÅ‚oÅ›Ä‡ i wspÃ³Å‚bieÅ¼noÅ›Ä‡. Logika\nnaszych programÃ³w jest jednak pisana w sposÃ³b gÅ‚Ã³wnie liniowy. ChcielibyÅ›my\nmÃ³c okreÅ›laÄ‡ operacje, ktÃ³re program powinien wykonaÄ‡, oraz punkty, w ktÃ³rych\nfunkcja mogÅ‚aby siÄ™ zatrzymaÄ‡, a jakaÅ› inna czÄ™Å›Ä‡ programu mogÅ‚aby dziaÅ‚aÄ‡\nzamiast niej, bez koniecznoÅ›ci wczeÅ›niejszego precyzowania dokÅ‚adnej\nkolejnoÅ›ci i sposobu, w jaki kaÅ¼dy fragment kodu powinien dziaÅ‚aÄ‡.\n_Programowanie asynchroniczne_ to abstrakcja, ktÃ³ra pozwala nam wyraÅ¼aÄ‡ kod w\nterminach potencjalnych punktÃ³w pauzy i ostatecznych wynikÃ³w, ktÃ³ra zajmuje\nsiÄ™ szczegÃ³Å‚ami koordynacji za nas.\n\nTen rozdziaÅ‚ opiera siÄ™ na uÅ¼yciu wÄ…tkÃ³w do rÃ³wnolegÅ‚oÅ›ci i wspÃ³Å‚bieÅ¼noÅ›ci z\nRozdziaÅ‚u 16, wprowadzajÄ…c alternatywne podejÅ›cie do pisania kodu: futures i\nstreams Rust oraz skÅ‚adniÄ™ `async` i `await`, ktÃ³re pozwalajÄ… nam wyraziÄ‡, jak\noperacje mogÄ… byÄ‡ asynchroniczne, oraz crate'y zewnÄ™trzne, ktÃ³re\nimplementujÄ… Å›rodowiska uruchomieniowe asynchroniczne: kod, ktÃ³ry zarzÄ…dza i\nkoordynuje wykonywanie operacji asynchronicznych.\n\nRozwaÅ¼my przykÅ‚ad. Powiedzmy, Å¼e eksportujesz wideo, ktÃ³re stworzyÅ‚eÅ› z\nrodzinnej uroczystoÅ›ci â€“ operacja, ktÃ³ra moÅ¼e trwaÄ‡ od kilku minut do kilku\ngodzin. Eksport wideo wykorzysta tyle mocy CPU i GPU, ile tylko moÅ¼e. GdybyÅ›\nmiaÅ‚ tylko jeden rdzeÅ„ CPU, a system operacyjny nie wstrzymywaÅ‚by tego eksportu\ndo momentu jego zakoÅ„czenia â€“ to znaczy, gdyby wykonywaÅ‚ eksport\n_synchronicznie_ â€“ nie mÃ³gÅ‚byÅ› robiÄ‡ niczego innego na swoim komputerze, podczas\ngdy to zadanie byÅ‚oby uruchomione. ByÅ‚oby to doÅ›Ä‡ frustrujÄ…ce doÅ›wiadczenie.\nNa szczÄ™Å›cie system operacyjny twojego komputera moÅ¼e, i robi to, niewidocznie\nprzerywaÄ‡ eksport wystarczajÄ…co czÄ™sto, abyÅ› mÃ³gÅ‚ jednoczeÅ›nie wykonywaÄ‡ innÄ…\npracÄ™.\n\nTeraz powiedzmy, Å¼e pobierasz wideo udostÄ™pnione przez kogoÅ› innego, co rÃ³wnieÅ¼\nmoÅ¼e trochÄ™ potrwaÄ‡, ale nie zajmuje tyle czasu procesora. W tym przypadku\nprocesor musi czekaÄ‡ na dane z sieci. ChociaÅ¼ moÅ¼esz zaczÄ…Ä‡ odczytywaÄ‡ dane, gdy\nzacznÄ… napÅ‚ywaÄ‡, moÅ¼e minÄ…Ä‡ trochÄ™ czasu, zanim wszystkie siÄ™ pojawiÄ…. Nawet\ngdy wszystkie dane sÄ… juÅ¼ dostÄ™pne, jeÅ›li wideo jest doÅ›Ä‡ duÅ¼e, zaÅ‚adowanie\ncaÅ‚oÅ›ci moÅ¼e zajÄ…Ä‡ co najmniej sekundÄ™ lub dwie. MoÅ¼e to nie brzmieÄ‡ jak wiele,\nale to bardzo dÅ‚ugo dla nowoczesnego procesora, ktÃ³ry potrafi wykonywaÄ‡\nmiliardy operacji na sekundÄ™. Ponownie, system operacyjny niewidocznie\nprzerwie TwÃ³j program, aby umoÅ¼liwiÄ‡ procesorowi wykonywanie innej pracy,\npodczas gdy czeka na zakoÅ„czenie wywoÅ‚ania sieciowego.\n\nEksport wideo jest przykÅ‚adem operacji _CPU-bound_ (ograniczonej przez CPU)\nlub _compute-bound_ (ograniczonej przez obliczenia). Jest ograniczony przez\npotencjalnÄ… szybkoÅ›Ä‡ przetwarzania danych przez komputer w obrÄ™bie CPU lub GPU\noraz przez to, ile z tej szybkoÅ›ci moÅ¼e poÅ›wiÄ™ciÄ‡ na operacjÄ™. Pobieranie wideo\njest przykÅ‚adem operacji _I/O-bound_ (ograniczonej przez wejÅ›cie/wyjÅ›cie),\nponiewaÅ¼ jest ograniczone szybkoÅ›ciÄ… _wejÅ›cia i wyjÅ›cia_ komputera; moÅ¼e dziaÅ‚aÄ‡\ntylko tak szybko, jak dane mogÄ… byÄ‡ przesyÅ‚ane przez sieÄ‡.\n\nW obu tych przykÅ‚adach niewidoczne przerwania systemu operacyjnego zapewniajÄ…\npewnÄ… formÄ™ wspÃ³Å‚bieÅ¼noÅ›ci. WspÃ³Å‚bieÅ¼noÅ›Ä‡ ta ma jednak miejsce tylko na\npoziomie caÅ‚ego programu: system operacyjny przerywa jeden program, aby\ninne programy mogÅ‚y wykonywaÄ‡ swojÄ… pracÄ™. W wielu przypadkach, poniewaÅ¼\nrozumiemy nasze programy na znacznie bardziej szczegÃ³Å‚owym poziomie niÅ¼ system\noperacyjny, moÅ¼emy dostrzec moÅ¼liwoÅ›ci wspÃ³Å‚bieÅ¼noÅ›ci, ktÃ³rych system\noperacyjny nie jest w stanie zobaczyÄ‡.\n\nNa przykÅ‚ad, jeÅ›li budujemy narzÄ™dzie do zarzÄ…dzania pobieraniem plikÃ³w,\npowinniÅ›my mÃ³c napisaÄ‡ nasz program tak, aby rozpoczÄ™cie jednego pobierania\nnie blokowaÅ‚o interfejsu uÅ¼ytkownika, a uÅ¼ytkownicy mogli rozpoczÄ…Ä‡ wiele\npobieraÅ„ jednoczeÅ›nie. Wiele API systemÃ³w operacyjnych do interakcji z sieciÄ…\njest jednak _blokujÄ…cych_; to znaczy, blokujÄ… one postÄ™p programu, dopÃ³ki\nprzetwarzane dane nie bÄ™dÄ… caÅ‚kowicie gotowe.\n\n> Uwaga: Tak dziaÅ‚a _wiÄ™kszoÅ›Ä‡_ wywoÅ‚aÅ„ funkcji, jeÅ›li siÄ™ nad tym zastanowisz.\n> Jednak termin _blokujÄ…cy_ jest zazwyczaj zarezerwowany dla wywoÅ‚aÅ„ funkcji,\n> ktÃ³re wspÃ³Å‚dziaÅ‚ajÄ… z plikami, sieciÄ… lub innymi zasobami na komputerze,\n> poniewaÅ¼ to wÅ‚aÅ›nie w tych przypadkach indywidualny program skorzystaÅ‚by na\n> tym, aby operacja byÅ‚a _nie_-blokujÄ…ca.\n\nMoglibyÅ›my uniknÄ…Ä‡ blokowania naszego gÅ‚Ã³wnego wÄ…tku, tworzÄ…c dedykowany\nwÄ…tek do pobierania kaÅ¼dego pliku. Jednak narzut zasobÃ³w systemowych\nwykorzystywanych przez te wÄ…tki w koÅ„cu staÅ‚by siÄ™ problemem. ByÅ‚oby lepiej,\ngdyby wywoÅ‚anie w ogÃ³le nie blokowaÅ‚o, a zamiast tego moglibyÅ›my zdefiniowaÄ‡\nwiele zadaÅ„, ktÃ³re chcielibyÅ›my, aby nasz program wykonaÅ‚, i pozwoliÄ‡ Å›rodowisku\nuruchomieniowemu wybraÄ‡ najlepszÄ… kolejnoÅ›Ä‡ i sposÃ³b ich wykonania.\n\nWÅ‚aÅ›nie to zapewnia nam abstrakcja _async_ (skrÃ³t od _asynchronous_) w Rust.\nW tym rozdziale dowiesz siÄ™ wszystkiego o async, omawiajÄ…c nastÄ™pujÄ…ce tematy:\n\n- Jak uÅ¼ywaÄ‡ skÅ‚adni `async` i `await` Rust oraz wykonywaÄ‡ funkcje\n  asynchroniczne w Å›rodowisku uruchomieniowym\n- Jak uÅ¼ywaÄ‡ modelu async do rozwiÄ…zywania niektÃ³rych z tych samych problemÃ³w,\n  ktÃ³re rozwaÅ¼aliÅ›my w Rozdziale 16\n- Jak wielowÄ…tkowoÅ›Ä‡ i async zapewniajÄ… uzupeÅ‚niajÄ…ce siÄ™ rozwiÄ…zania, ktÃ³re\n  moÅ¼na Å‚Ä…czyÄ‡ w wielu przypadkach\n\nZanim jednak zobaczymy, jak async dziaÅ‚a w praktyce, musimy zrobiÄ‡ krÃ³tki\nobjazd, aby omÃ³wiÄ‡ rÃ³Å¼nice miÄ™dzy rÃ³wnolegÅ‚oÅ›ciÄ… a wspÃ³Å‚bieÅ¼noÅ›ciÄ….\n\n## RÃ³wnolegÅ‚oÅ›Ä‡ i wspÃ³Å‚bieÅ¼noÅ›Ä‡\n\nDo tej pory traktowaliÅ›my rÃ³wnolegÅ‚oÅ›Ä‡ i wspÃ³Å‚bieÅ¼noÅ›Ä‡ jako w wiÄ™kszoÅ›ci\nwymienne. Teraz musimy je precyzyjniej rozrÃ³Å¼niÄ‡, poniewaÅ¼ rÃ³Å¼nice pojawiÄ…\nsiÄ™, gdy zaczniemy pracowaÄ‡.\n\nRozwaÅ¼my rÃ³Å¼ne sposoby, w jakie zespÃ³Å‚ mÃ³gÅ‚by podzieliÄ‡ pracÄ™ nad projektem\no programowaniu. MoÅ¼na by przydzieliÄ‡ jednemu czÅ‚onkowi wiele zadaÅ„, kaÅ¼demu\nczÅ‚onkowi jedno zadanie, lub zastosowaÄ‡ poÅ‚Ä…czenie obu podejÅ›Ä‡.\n\nKiedy jednostka pracuje nad kilkoma rÃ³Å¼nymi zadaniami, zanim ktÃ³rekolwiek z\nnich zostanie ukoÅ„czone, jest to _wspÃ³Å‚bieÅ¼noÅ›Ä‡_. Jeden ze sposobÃ³w\nimplementacji wspÃ³Å‚bieÅ¼noÅ›ci jest podobny do posiadania dwÃ³ch rÃ³Å¼nych\nprojektÃ³w pobranych na komputerze, a kiedy siÄ™ znudzisz lub utkniesz na jednym\nprojekcie, przeÅ‚Ä…czasz siÄ™ na drugi. JesteÅ› tylko jednÄ… osobÄ…, wiÄ™c nie moÅ¼esz\npoczyniÄ‡ postÄ™pÃ³w w obu zadaniach dokÅ‚adnie w tym samym czasie, ale moÅ¼esz\nwielozadaniowo, robiÄ…c postÄ™py w jednym zadaniu naraz, przeÅ‚Ä…czajÄ…c siÄ™ miÄ™dzy\nnimi (patrz Rysunek 17-1).\n\n<figure>\n\n<img src=\"img/trpl17-01.svg\" class=\"center\" alt=\"A diagram with stacked boxes labeled Task A and Task B, with diamonds in them representing subtasks. Arrows point from A1 to B1, B1 to A2, A2 to B2, B2 to A3, A3 to A4, and A4 to B3. The arrows between the subtasks cross the boxes between Task A and Task B.\" />\n\n<figcaption>Rysunek 17-1: WspÃ³Å‚bieÅ¼ny przepÅ‚yw pracy, przeÅ‚Ä…czanie miÄ™dzy Zadaniem A i Zadaniem B</figcaption>\n\n</figure>\n\nKiedy zespÃ³Å‚ dzieli grupÄ™ zadaÅ„, tak Å¼e kaÅ¼dy czÅ‚onek bierze jedno zadanie i\npracuje nad nim samodzielnie, jest to _rÃ³wnolegÅ‚oÅ›Ä‡_. KaÅ¼da osoba w zespole\nmoÅ¼e robiÄ‡ postÄ™py dokÅ‚adnie w tym samym czasie (patrz Rysunek 17-2).\n\n<figure>\n\n<img src=\"img/trpl17-02.svg\" class=\"center\" alt=\"A diagram with stacked boxes labeled Task A and Task B, with diamonds in them representing subtasks. Arrows point from A1 to A2, A2 to A3, A3 to A4, B1 to B2, and B2 to B3. No arrows cross between the boxes for Task A and Task B.\" />\n\n<figcaption>Rysunek 17-2: RÃ³wnolegÅ‚y przepÅ‚yw pracy, gdzie praca odbywa siÄ™ niezaleÅ¼nie w Zadaniu A i Zadaniu B</figcaption>\n\n</figure>\n\nW obu tych przepÅ‚ywach pracy, moÅ¼esz musieÄ‡ koordynowaÄ‡ dziaÅ‚ania miÄ™dzy\nrÃ³Å¼nymi zadaniami. MoÅ¼e myÅ›laÅ‚eÅ›, Å¼e zadanie przydzielone jednej osobie byÅ‚o\ncaÅ‚kowicie niezaleÅ¼ne od pracy innych, ale w rzeczywistoÅ›ci wymaga ono od innej\nosoby w zespole najpierw zakoÅ„czenia swojego zadania. CzÄ™Å›Ä‡ pracy mogÅ‚a byÄ‡\nwykonana rÃ³wnolegle, ale czÄ™Å›Ä‡ z nich byÅ‚a w rzeczywistoÅ›ci _sekwencyjna_: mogÅ‚a\ndziaÄ‡ siÄ™ tylko w serii, jedno zadanie po drugim, jak na Rysunku 17-3.\n\n<figure>\n\n<img src=\"img/trpl17-03.svg\" class=\"center\" alt=\"A diagram with stacked boxes labeled Task A and Task B, with diamonds in them representing subtasks. In Task A, arrows point from A1 to A2, from A2 to a pair of thick vertical lines like a â€œpauseâ€ symbol, and from that symbol to A3. In task B, arrows point from B1 to B2, from B2 to B3, from B3 to A3, and from B3 to B4.\" />\n\n<figcaption>Rysunek 17-3: CzÄ™Å›ciowo rÃ³wnolegÅ‚y przepÅ‚yw pracy, gdzie praca odbywa siÄ™ niezaleÅ¼nie w Zadaniu A i Zadaniu B, dopÃ³ki Zadanie A3 nie zostanie zablokowane przez wyniki Zadania B3.</figcaption>\n\n</figure>\n\nPodobnie, moÅ¼esz zdaÄ‡ sobie sprawÄ™, Å¼e jedno z twoich zadaÅ„ zaleÅ¼y od innego z\ntwoich zadaÅ„. Wtedy twoja wspÃ³Å‚bieÅ¼na praca rÃ³wnieÅ¼ staÅ‚a siÄ™ szeregowa.\n\nRÃ³wnolegÅ‚oÅ›Ä‡ i wspÃ³Å‚bieÅ¼noÅ›Ä‡ mogÄ… siÄ™ rÃ³wnieÅ¼ ze sobÄ… krzyÅ¼owaÄ‡. JeÅ›li dowiesz\nsiÄ™, Å¼e kolega utknÄ…Å‚, dopÃ³ki nie skoÅ„czysz jednego ze swoich zadaÅ„,\nprawdopodobnie skupisz wszystkie swoje wysiÅ‚ki na tym zadaniu, aby â€odblokowaÄ‡â€\nswojego kolegÄ™. Ty i twÃ³j wspÃ³Å‚pracownik nie jesteÅ›cie juÅ¼ w stanie pracowaÄ‡\nrÃ³wnolegle, a takÅ¼e nie jesteÅ›cie juÅ¼ w stanie pracowaÄ‡ wspÃ³Å‚bieÅ¼nie nad\nwÅ‚asnymi zadaniami.\n\nTa sama podstawowa dynamika wchodzi w grÄ™ w oprogramowaniu i sprzÄ™cie. Na\nmaszynie z pojedynczym rdzeniem CPU, CPU moÅ¼e wykonywaÄ‡ tylko jednÄ… operacjÄ™ na\nraz, ale nadal moÅ¼e dziaÅ‚aÄ‡ wspÃ³Å‚bieÅ¼nie. UÅ¼ywajÄ…c narzÄ™dzi takich jak wÄ…tki,\nprocesy i async, komputer moÅ¼e wstrzymaÄ‡ jednÄ… aktywnoÅ›Ä‡ i przeÅ‚Ä…czyÄ‡ siÄ™ na\ninne, zanim ostatecznie powrÃ³ci do tej pierwszej aktywnoÅ›ci. Na maszynie z\nwieloma rdzeniami CPU, moÅ¼e rÃ³wnieÅ¼ wykonywaÄ‡ pracÄ™ rÃ³wnolegle. Jeden rdzeÅ„ moÅ¼e\nwykonywaÄ‡ jedno zadanie, podczas gdy inny rdzeÅ„ wykonuje zupeÅ‚nie\nniepowiÄ…zane zadanie, a te operacje faktycznie dziejÄ… siÄ™ w tym samym czasie.\n\nUruchamianie kodu async w Rust zazwyczaj odbywa siÄ™ wspÃ³Å‚bieÅ¼nie. W zaleÅ¼noÅ›ci\nod sprzÄ™tu, systemu operacyjnego i uÅ¼ywanego Å›rodowiska asynchronicznego\n(wiÄ™cej o Å›rodowiskach asynchronicznych wkrÃ³tce), ta wspÃ³Å‚bieÅ¼noÅ›Ä‡ moÅ¼e rÃ³wnieÅ¼\nwykorzystywaÄ‡ rÃ³wnolegÅ‚oÅ›Ä‡ pod maskÄ….\n\nTeraz zagÅ‚Ä™bmy siÄ™ w to, jak faktycznie dziaÅ‚a programowanie asynchroniczne w\nRust.",
        "chapter_title": "Podstawy programowania asynchronicznego: Async, Await, Futures i Streams"
    },
    {
        "file_path": "ch17-01-futures-and-syntax.md",
        "content": "## Futures i skÅ‚adnia `async`\n\nKluczowymi elementami programowania asynchronicznego w Rust sÄ… _futures_ oraz\nsÅ‚owa kluczowe `async` i `await` Rust.\n\n_Future_ to wartoÅ›Ä‡, ktÃ³ra moÅ¼e nie byÄ‡ gotowa teraz, ale stanie siÄ™ gotowa w\npewnym momencie w przyszÅ‚oÅ›ci. (Ta sama koncepcja pojawia siÄ™ w wielu jÄ™zykach,\nczasami pod innymi nazwami, takimi jak _task_ lub _promise_.) Rust zapewnia\ncechÄ™ `Future` jako element konstrukcyjny, dziÄ™ki czemu rÃ³Å¼ne operacje\nasynchroniczne mogÄ… byÄ‡ implementowane z rÃ³Å¼nymi strukturami danych, ale z\njednolitym interfejsem. W Rust futures to typy, ktÃ³re implementujÄ… cechÄ™\n`Future`. KaÅ¼da przyszÅ‚oÅ›Ä‡ przechowuje wÅ‚asne informacje o postÄ™pie, ktÃ³ry\nzostaÅ‚ osiÄ…gniÄ™ty, i co oznacza â€gotowyâ€.\n\nMoÅ¼esz zastosowaÄ‡ sÅ‚owo kluczowe `async` do blokÃ³w i funkcji, aby okreÅ›liÄ‡,\nÅ¼e mogÄ… byÄ‡ one przerywane i wznawiane. WewnÄ…trz bloku async lub funkcji async,\nmoÅ¼esz uÅ¼yÄ‡ sÅ‚owa kluczowego `await`, aby _oczekiwaÄ‡ na przyszÅ‚oÅ›Ä‡_ (czyli\npoczekaÄ‡, aÅ¼ stanie siÄ™ gotowa). KaÅ¼dy punkt, w ktÃ³rym oczekujesz na przyszÅ‚oÅ›Ä‡\nw bloku async lub funkcji async, jest potencjalnym miejscem, w ktÃ³rym ten blok\nlub funkcja moÅ¼e siÄ™ zatrzymaÄ‡ i wznowiÄ‡. Proces sprawdzania z przyszÅ‚oÅ›ciÄ…, czy\njej wartoÅ›Ä‡ jest juÅ¼ dostÄ™pna, nazywa siÄ™ _polling_ (odpytywaniem).\n\nNiektÃ³re inne jÄ™zyki, takie jak C# i JavaScript, rÃ³wnieÅ¼ uÅ¼ywajÄ… sÅ‚Ã³w\nkluczowych `async` i `await` do programowania asynchronicznego. JeÅ›li znasz te\njÄ™zyki, moÅ¼esz zauwaÅ¼yÄ‡ pewne znaczÄ…ce rÃ³Å¼nice w sposobie obsÅ‚ugi skÅ‚adni przez\nRust. Ma to dobry powÃ³d, jak zobaczymy!\n\nPiszÄ…c kod async w Rust, uÅ¼ywamy sÅ‚Ã³w kluczowych `async` i `await` przez wiÄ™kszoÅ›Ä‡\nczasu. Rust kompiluje je do rÃ³wnowaÅ¼nego kodu uÅ¼ywajÄ…cego cechy `Future`,\npodobnie jak kompiluje pÄ™tle `for` do rÃ³wnowaÅ¼nego kodu uÅ¼ywajÄ…cego cechy\n`Iterator`. PoniewaÅ¼ Rust zapewnia cechÄ™ `Future`, moÅ¼esz jÄ… rÃ³wnieÅ¼\nzaimplementowaÄ‡ dla wÅ‚asnych typÃ³w danych, gdy tego potrzebujesz. Wiele funkcji,\nktÃ³re zobaczymy w tym rozdziale, zwraca typy z wÅ‚asnymi implementacjami\n`Future`. WrÃ³Ä‡my do definicji cechy na koÅ„cu rozdziaÅ‚u i zagÅ‚Ä™bmy siÄ™ w to, jak\ndziaÅ‚a, ale to wystarczy, abyÅ›my mogli kontynuowaÄ‡.\n\nWszystko to moÅ¼e wydawaÄ‡ siÄ™ nieco abstrakcyjne, wiÄ™c napiszmy nasz pierwszy\nprogram asynchroniczny: maÅ‚y scraper internetowy. PrzekaÅ¼emy dwa adresy URL z\nwiersza poleceÅ„, pobierzemy je oba wspÃ³Å‚bieÅ¼nie i zwrÃ³cimy wynik tego, ktÃ³ry\nzakoÅ„czy siÄ™ jako pierwszy. Ten przykÅ‚ad bÄ™dzie zawieraÅ‚ sporo nowej skÅ‚adni,\nale nie martw siÄ™ â€“ wyjaÅ›nimy wszystko, co musisz wiedzieÄ‡, w trakcie.\n\n## Nasz pierwszy program asynchroniczny\n\nAby skupiÄ‡ siÄ™ w tym rozdziale na nauce async, a nie na Å¼onglowaniu czÄ™Å›ciami\nekosystemu, stworzyliÅ›my crate `trpl` (`trpl` to skrÃ³t od â€The Rust Programming\nLanguageâ€). Reeksportuje on wszystkie typy, cechy i funkcje, ktÃ³rych bÄ™dziesz\npotrzebowaÄ‡, gÅ‚Ã³wnie z crate'Ã³w [`futures`][futures-crate]<!-- ignore --> i\n[`tokio`][tokio]<!-- ignore -->. Crate `futures` jest oficjalnym miejscem\neksperymentÃ³w Rust dla kodu async i to wÅ‚aÅ›nie tam pierwotnie zaprojektowano\ncechÄ™ `Future`. Tokio jest obecnie najczÄ™Å›ciej uÅ¼ywanym Å›rodowiskiem\nasynchronicznym w Rust, zwÅ‚aszcza w aplikacjach internetowych. IstniejÄ… inne\ndobre Å›rodowiska uruchomieniowe, ktÃ³re mogÄ… byÄ‡ bardziej odpowiednie dla Twoich\npotrzeb. UÅ¼ywamy crate'a `tokio` pod maskÄ… dla `trpl`, poniewaÅ¼ jest dobrze\nprzetestowany i szeroko stosowany.\n\nW niektÃ³rych przypadkach `trpl` rÃ³wnieÅ¼ zmienia nazwy lub opakowuje oryginalne\nAPI, abyÅ› skupiÅ‚ siÄ™ na szczegÃ³Å‚ach istotnych dla tego rozdziaÅ‚u. JeÅ›li chcesz\nzrozumieÄ‡, co robi ten crate, zachÄ™camy do zapoznania siÄ™ z [jego kodem\nÅºrÃ³dÅ‚owym][crate-source]. BÄ™dziesz mÃ³gÅ‚ zobaczyÄ‡, z ktÃ³rego crate'a pochodzi\nkaÅ¼dy reeksport, a my zostawiliÅ›my obszerne komentarze wyjaÅ›niajÄ…ce, co robi\ncrate.\n\nStwÃ³rzmy nowy projekt binarny o nazwie `hello-async` i dodajmy crate `trpl`\njako zaleÅ¼noÅ›Ä‡:\n\n```console\n$ cargo new hello-async\n$ cd hello-async\n$ cargo add trpl\n```\n\nTeraz moÅ¼emy uÅ¼yÄ‡ rÃ³Å¼nych elementÃ³w dostarczonych przez `trpl` do napisania\nnaszego pierwszego programu asynchronicznego. Zbudujemy maÅ‚e narzÄ™dzie\nwiersza poleceÅ„, ktÃ³re pobierze dwie strony internetowe, wyciÄ…gnie z kaÅ¼dej z\nnich element `<title>` i wypisze tytuÅ‚ tej strony, ktÃ³ra zakoÅ„czy caÅ‚y proces\npierwsza.\n\n### Definiowanie funkcji `page_title`\n\nZacznijmy od napisania funkcji, ktÃ³ra przyjmuje jeden URL strony jako parametr,\nwykonuje do niego Å¼Ä…danie i zwraca tekst elementu `<title>` (patrz Listing 17-1).\n\n<Listing number=\"17-1\" file-name=\"src/main.rs\" caption=\"Definiowanie funkcji `async` do pobierania elementu `title` ze strony HTML\">\n\n```rust\n# extern crate trpl; // required for mdbook test\n# \n# fn main() {\n#     // TODO: we'll add this next!\n# }\n# \nuse trpl::Html;\n\nasync fn page_title(url: &str) -> Option<String> {\n    let response = trpl::get(url).await;\n    let response_text = response.text().await;\n    Html::parse(&response_text)\n        .select_first(\"title\")\n        .map(|title| title.inner_html())\n}\n```\n\n</Listing>\n\nNajpierw definiujemy funkcjÄ™ o nazwie `page_title` i oznaczamy jÄ… sÅ‚owem\nkluczowym `async`. NastÄ™pnie uÅ¼ywamy funkcji `trpl::get`, aby pobraÄ‡ dowolny\nprzekazany URL i dodajemy sÅ‚owo kluczowe `await`, aby oczekiwaÄ‡ na\nodpowiedÅº. Aby uzyskaÄ‡ tekst `response`, wywoÅ‚ujemy jego metodÄ™ `text` i\nponownie oczekujemy na niÄ… za pomocÄ… sÅ‚owa kluczowego `await`. Oba te kroki\nsÄ… asynchroniczne. Dla funkcji `get` musimy poczekaÄ‡, aÅ¼ serwer odeÅ›le\npierwszÄ… czÄ™Å›Ä‡ swojej odpowiedzi, ktÃ³ra bÄ™dzie zawieraÅ‚a nagÅ‚Ã³wki HTTP,\nciasteczka itd. i moÅ¼e byÄ‡ dostarczana osobno od treÅ›ci odpowiedzi. ZwÅ‚aszcza\njeÅ›li treÅ›Ä‡ jest bardzo duÅ¼a, jej dotarcie moÅ¼e zajÄ…Ä‡ trochÄ™ czasu. PoniewaÅ¼\nmusimy poczekaÄ‡ na _caÅ‚oÅ›Ä‡_ odpowiedzi, metoda `text` rÃ³wnieÅ¼ jest asynchroniczna.\n\nMusimy jawnie oczekiwaÄ‡ na obie te futures, poniewaÅ¼ futures w Rust sÄ…\n_leniwymi_: nie robiÄ… nic, dopÃ³ki nie poprosisz ich o to sÅ‚owem kluczowym\n`await`. (W rzeczywistoÅ›ci Rust wyÅ›wietli ostrzeÅ¼enie kompilatora, jeÅ›li nie\nuÅ¼yjesz future.) To moÅ¼e przypominaÄ‡ dyskusjÄ™ o iteratorach w sekcji\n[â€Przetwarzanie sekwencji elementÃ³w za pomocÄ… iteratorÃ³wâ€][iterators-lazy]<!--\nignore --> w Rozdziale 13. Iteratory nic nie robiÄ…, dopÃ³ki nie wywoÅ‚asz ich\nmetody `next` â€“ bezpoÅ›rednio lub za pomocÄ… pÄ™tli `for` lub metod takich jak\n`map`, ktÃ³re uÅ¼ywajÄ… `next` pod maskÄ…. Podobnie, futures nic nie robiÄ…, dopÃ³ki\nnie poprosisz ich o to jawnie. Ta leniwoÅ›Ä‡ pozwala Rustowi uniknÄ…Ä‡\nuruchamiania kodu async, dopÃ³ki nie jest on faktycznie potrzebny.\n\n> Uwaga: RÃ³Å¼ni siÄ™ to od zachowania, ktÃ³re widzieliÅ›my podczas uÅ¼ywania\n> `thread::spawn` w sekcji [â€Tworzenie nowego wÄ…tku za pomocÄ…\n> spawnâ€][thread-spawn]<!-- ignore --> w Rozdziale 16, gdzie domkniÄ™cie,\n> ktÃ³re przekazaliÅ›my do innego wÄ…tku, zaczÄ™Å‚o dziaÅ‚aÄ‡ natychmiast. RÃ³Å¼ni siÄ™\n> to rÃ³wnieÅ¼ od podejÅ›cia wielu innych jÄ™zykÃ³w do async. Ale jest to waÅ¼ne,\n> aby Rust mÃ³gÅ‚ zapewniÄ‡ swoje gwarancje wydajnoÅ›ci, tak jak w przypadku\n> iteratorÃ³w.\n\nGdy mamy `response_text`, moÅ¼emy jÄ… przetworzyÄ‡ na instancjÄ™ typu `Html` za\npomocÄ… `Html::parse`. Zamiast surowego ciÄ…gu znakÃ³w, mamy teraz typ danych,\nktÃ³rego moÅ¼emy uÅ¼yÄ‡ do pracy z HTML-em jako bogatszÄ… strukturÄ… danych. W\nszczegÃ³lnoÅ›ci, moÅ¼emy uÅ¼yÄ‡ metody `select_first` do znalezienia pierwszej\ninstancji danego selektora CSS. PrzekazujÄ…c ciÄ…g `\"title\"`, otrzymamy pierwszy\nelement `<title>` w dokumencie, jeÅ›li taki istnieje. PoniewaÅ¼ moÅ¼e nie byÄ‡\nÅ¼adnego pasujÄ…cego elementu, `select_first` zwraca `Option<ElementRef>`.\nNa koniec uÅ¼ywamy metody `Option::map`, ktÃ³ra pozwala nam pracowaÄ‡ z elementem\nw `Option`, jeÅ›li jest obecny, i nic nie robiÄ‡, jeÅ›li go nie ma. (MoglibyÅ›my\nteÅ¼ uÅ¼yÄ‡ tutaj wyraÅ¼enia `match`, ale `map` jest bardziej idiomatyczne.) W treÅ›ci\nfunkcji, ktÃ³rÄ… przekazujemy do `map`, wywoÅ‚ujemy `inner_html` na `title`, aby\npobraÄ‡ jego zawartoÅ›Ä‡, ktÃ³ra jest `String`. Po wszystkim mamy\n`Option<String>`.\n\nZauwaÅ¼, Å¼e sÅ‚owo kluczowe `await` w Rust znajduje siÄ™ _po_ wyraÅ¼eniu, na ktÃ³re\noczekujesz, a nie przed nim. To znaczy, jest to sÅ‚owo kluczowe _postfixowe_.\nMoÅ¼e siÄ™ to rÃ³Å¼niÄ‡ od tego, do czego jesteÅ› przyzwyczajony, jeÅ›li uÅ¼ywaÅ‚eÅ›\n`async` w innych jÄ™zykach, ale w Rust sprawia, Å¼e Å‚aÅ„cuchy metod sÄ… znacznie\nprzyjemniejsze w pracy. W rezultacie, mogliÅ›my zmieniÄ‡ ciaÅ‚o `page_title`, aby\npoÅ‚Ä…czyÄ‡ wywoÅ‚ania funkcji `trpl::get` i `text` za pomocÄ… `await` miÄ™dzy nimi,\njak pokazano w Listingu 17-2.\n\n<Listing number=\"17-2\" file-name=\"src/main.rs\" caption=\"ÅaÅ„cuchowanie ze sÅ‚owem kluczowym `await`\">\n\n```rust\n# extern crate trpl; // required for mdbook test\n# \n# use trpl::Html;\n# \n# fn main() {\n#     // TODO: we'll add this next!\n# }\n# \n# async fn page_title(url: &str) -> Option<String> {\n    let response_text = trpl::get(url).await.text().await;\n#     Html::parse(&response_text)\n#         .select_first(\"title\")\n#         .map(|title| title.inner_html())\n# }\n```\n\n</Listing>\n\nI w ten sposÃ³b pomyÅ›lnie napisaliÅ›my naszÄ… pierwszÄ… funkcjÄ™ asynchronicznÄ…!\nZanim dodamy kod w `main`, aby jÄ… wywoÅ‚aÄ‡, porozmawiajmy trochÄ™ wiÄ™cej o tym,\nco napisaliÅ›my i co to oznacza.\n\nKiedy Rust widzi _blok_ oznaczony sÅ‚owem kluczowym `async`, kompiluje go do\nunikalnego, anonimowego typu danych, ktÃ³ry implementuje cechÄ™ `Future`. Kiedy\nRust widzi _funkcjÄ™_ oznaczonÄ… `async`, kompiluje jÄ… do funkcji nieasync,\nktÃ³rej ciaÅ‚o jest blokiem async. Typ zwracany przez funkcjÄ™ async jest typem\nanonimowego typu danych, ktÃ³ry kompilator tworzy dla tego bloku async.\n\nW zwiÄ…zku z tym, pisanie `async fn` jest rÃ³wnowaÅ¼ne pisaniu funkcji,\nktÃ³ra zwraca _future_ typu zwracanego. Dla kompilatora, definicja funkcji,\ntaka jak `async fn page_title` w Listingu 17-1, jest z grubsza rÃ³wnowaÅ¼na\nfunkcji nieasync zdefiniowanej w ten sposÃ³b:\n\n```rust\n# extern crate trpl; // required for mdbook test\nuse std::future::Future;\nuse trpl::Html;\n\nfn page_title(url: &str) -> impl Future<Output = Option<String>> {\n    async move {\n        let text = trpl::get(url).await.text().await;\n        Html::parse(&text)\n            .select_first(\"title\")\n            .map(|title| title.inner_html())\n    }\n}\n```\n\nPrzejdÅºmy przez kaÅ¼dÄ… czÄ™Å›Ä‡ przeksztaÅ‚conej wersji:\n\n- UÅ¼ywa skÅ‚adni `impl Trait`, ktÃ³rÄ… omÃ³wiliÅ›my w Rozdziale 10 w sekcji\n  [â€Cechy jako parametryâ€][impl-trait]<!-- ignore -->.\n- ZwrÃ³cona wartoÅ›Ä‡ implementuje cechÄ™ `Future` ze skojarzonym typem `Output`.\n  ZauwaÅ¼, Å¼e typ `Output` to `Option<String>`, czyli ten sam typ, co oryginalny\n  typ zwracany przez wersjÄ™ `async fn` `page_title`.\n- CaÅ‚y kod wywoÅ‚any w treÅ›ci oryginalnej funkcji jest opakowany w blok\n  `async move`. PamiÄ™taj, Å¼e bloki sÄ… wyraÅ¼eniami. CaÅ‚y ten blok jest\n  wyraÅ¼eniem zwracanym z funkcji.\n- Ten blok async produkuje wartoÅ›Ä‡ typu `Option<String>`, jak wÅ‚aÅ›nie\n  opisano. Ta wartoÅ›Ä‡ odpowiada typowi `Output` w typie zwracanym. Jest to\n  tak samo jak inne bloki, ktÃ³re widziaÅ‚eÅ›.\n- Nowe ciaÅ‚o funkcji to blok `async move` ze wzglÄ™du na sposÃ³b uÅ¼ycia parametru\n  `url`. (O `async` kontra `async move` bÄ™dziemy rozmawiaÄ‡ znacznie wiÄ™cej\n  pÃ³Åºniej w rozdziale.)\n\nTeraz moÅ¼emy wywoÅ‚aÄ‡ `page_title` w `main`.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id =\"determining-a-single-pages-title\"></a>\n\n### Wykonanie funkcji `async` w Å›rodowisku uruchomieniowym\n\nAby zaczÄ…Ä‡, pobierzemy tytuÅ‚ dla pojedynczej strony, pokazany w Listingu 17-3.\nNiestety, ten kod jeszcze siÄ™ nie skompiluje.\n\n<Listing number=\"17-3\" file-name=\"src/main.rs\" caption=\"WywoÅ‚anie funkcji `page_title` z `main` z argumentem dostarczonym przez uÅ¼ytkownika\">\n\n```rust,ignore,does_not_compile\n# extern crate trpl; // required for mdbook test\n# \n# use trpl::Html;\n# \nasync fn main() {\n    let args: Vec<String> = std::env::args().collect();\n    let url = &args[1];\n    match page_title(url).await {\n        Some(title) => println!(\"The title for {url} was {title}\"),\n        None => println!(\"{url} had no title\"),\n    }\n}\n# \n# async fn page_title(url: &str) -> Option<String> {\n#     let response_text = trpl::get(url).await.text().await;\n#     Html::parse(&response_text)\n#         .select_first(\"title\")\n#         .map(|title| title.inner_html())\n# }\n```\n\n</Listing>\n\nPostÄ™pujemy zgodnie z tym samym wzorcem, ktÃ³rego uÅ¼yliÅ›my do pobierania\nargumentÃ³w wiersza poleceÅ„ w sekcji [â€Akceptowanie argumentÃ³w wiersza\npoleceÅ„â€][cli-args]<!-- ignore --> w Rozdziale 12. NastÄ™pnie przekazujemy\nargument URL do `page_title` i czekamy na wynik. PoniewaÅ¼ wartoÅ›Ä‡\nprodukowana przez future jest `Option<String>`, uÅ¼ywamy wyraÅ¼enia `match`, aby\nwypisaÄ‡ rÃ³Å¼ne komunikaty w zaleÅ¼noÅ›ci od tego, czy strona miaÅ‚a element\n`<title>`.\n\nJedynym miejscem, w ktÃ³rym moÅ¼emy uÅ¼yÄ‡ sÅ‚owa kluczowego `await`, sÄ… funkcje\nlub bloki async, a Rust nie pozwoli nam oznaczyÄ‡ specjalnej funkcji `main` jako\n`async`.\n\n<!-- manual-regeneration\ncd listings/ch17-async-await/listing-17-03\ncargo build # skip all the build noise\ncopy just the compiler error\n-->\n\n```text\nerror[E0752]: `main` function is not allowed to be `async`\n --> src/main.rs:6:1\n  |\n6 | async fn main() {\n  | ^^^^^^^^^^^^^^^ `main` function is not allowed to be `async`\n```\n\nPowodem, dla ktÃ³rego `main` nie moÅ¼e byÄ‡ oznaczona jako `async`, jest to, Å¼e\nkod asynchroniczny potrzebuje _Å›rodowiska uruchomieniowego_ (runtime): crate'a\nRust, ktÃ³ry zarzÄ…dza szczegÃ³Å‚ami wykonywania kodu asynchronicznego. Funkcja\n`main` programu moÅ¼e _zainicjalizowaÄ‡_ Å›rodowisko uruchomieniowe, ale sama nie\njest Å›rodowiskiem uruchomieniowym. (WiÄ™cej o tym, dlaczego tak jest, dowiemy\nsiÄ™ za chwilÄ™.) KaÅ¼dy program Rust, ktÃ³ry wykonuje kod asynchroniczny, ma\nprzynajmniej jedno miejsce, w ktÃ³rym konfiguruje Å›rodowisko uruchomieniowe,\nktÃ³re wykonuje futures.\n\nWiÄ™kszoÅ›Ä‡ jÄ™zykÃ³w obsÅ‚ugujÄ…cych async dostarcza Å›rodowisko uruchomieniowe,\nale Rust tego nie robi. Zamiast tego dostÄ™pnych jest wiele rÃ³Å¼nych\nÅ›rodowisk uruchomieniowych async, z ktÃ³rych kaÅ¼de dokonuje rÃ³Å¼nych\nkompromisÃ³w, odpowiednich dla docelowego przypadku uÅ¼ycia. Na przykÅ‚ad,\nwydajny serwer webowy z wieloma rdzeniami CPU i duÅ¼Ä… iloÅ›ciÄ… pamiÄ™ci RAM ma\nbardzo rÃ³Å¼ne potrzeby niÅ¼ mikrokontroler z pojedynczym rdzeniem, maÅ‚Ä… iloÅ›ciÄ…\npamiÄ™ci RAM i brakiem moÅ¼liwoÅ›ci alokacji na stercie. Crates, ktÃ³re\ndostarczajÄ… te Å›rodowiska uruchomieniowe, czÄ™sto dostarczajÄ… rÃ³wnieÅ¼\nasynchroniczne wersje typowych funkcji, takich jak wejÅ›cie/wyjÅ›cie plikÃ³w\nlub sieci.\n\nTutaj i przez resztÄ™ tego rozdziaÅ‚u bÄ™dziemy uÅ¼ywaÄ‡ funkcji `block_on` z crate'a\n`trpl`, ktÃ³ra przyjmuje przyszÅ‚oÅ›Ä‡ jako argument i blokuje bieÅ¼Ä…cy wÄ…tek,\ndopÃ³ki ta przyszÅ‚oÅ›Ä‡ nie zostanie ukoÅ„czona. Pod maskÄ…, wywoÅ‚anie `block_on`\nkonfiguruje Å›rodowisko uruchomieniowe za pomocÄ… crate'a `tokio`, ktÃ³re jest\nuÅ¼ywane do uruchamiania przekazanej przyszÅ‚oÅ›ci (zachowanie `trpl::block_on`\njest podobne do funkcji `block_on` innych crate'Ã³w Å›rodowiskowych).\nGdy przyszÅ‚oÅ›Ä‡ zostanie ukoÅ„czona, `block_on` zwraca wartoÅ›Ä‡, ktÃ³rÄ… przyszÅ‚oÅ›Ä‡\nwyprodukowaÅ‚a.\n\nMoglibyÅ›my przekazaÄ‡ przyszÅ‚oÅ›Ä‡ zwrÃ³conÄ… przez `page_title` bezpoÅ›rednio do\n`block_on` i, po jej zakoÅ„czeniu, dopasowaÄ‡ wynikowy `Option<String>`, jak to\nprÃ³bowaliÅ›my zrobiÄ‡ w Listingu 17-3. Jednak w wiÄ™kszoÅ›ci przykÅ‚adÃ³w w rozdziale\n(i w wiÄ™kszoÅ›ci kodu async w prawdziwym Å›wiecie) bÄ™dziemy wykonywaÄ‡ wiÄ™cej niÅ¼\njedno wywoÅ‚anie funkcji async, wiÄ™c zamiast tego przekaÅ¼emy blok `async` i\njawnie poczekamy na wynik wywoÅ‚ania `page_title`, jak w Listingu 17-4.\n\n<Listing number=\"17-4\" caption=\"Oczekiwanie na blok `async` za pomocÄ… `trpl::block_on`\" file-name=\"src/main.rs\">\n\n<!-- should_panic,noplayground because mdbook test does not pass args -->\n\n```rust,should_panic,noplayground\n# extern crate trpl; // required for mdbook test\n# \n# use trpl::Html;\n# \nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n\n    trpl::block_on(async {\n        let url = &args[1];\n        match page_title(url).await {\n            Some(title) => println!(\"The title for {url} was {title}\"),\n            None => println!(\"{url} had no title\"),\n        }\n    })\n}\n# \n# async fn page_title(url: &str) -> Option<String> {\n#     let response_text = trpl::get(url).await.text().await;\n#     Html::parse(&response_text)\n#         .select_first(\"title\")\n#         .map(|title| title.inner_html())\n# }\n```\n\n</Listing>\n\nPo uruchomieniu tego kodu otrzymujemy zachowanie, ktÃ³rego poczÄ…tkowo siÄ™\nspodziewaliÅ›my:\n\n<!-- manual-regeneration\ncd listings/ch17-async-await/listing-17-04\ncargo build # skip all the build noise\ncargo run -- \"https://www.rust-lang.org\"\n# copy the output here\n-->\n\n```console\n$ cargo run -- \"https://www.rust-lang.org\"\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.05s\n     Running `target/debug/async_await 'https://www.rust-lang.org'`\nThe title for https://www.rust-lang.org was\n            Rust Programming Language\n```\n\nUff â€“ w koÅ„cu mamy dziaÅ‚ajÄ…cy kod async! Ale zanim dodamy kod do wyÅ›cigÃ³w\ndwÃ³ch witryn ze sobÄ…, poÅ›wiÄ™Ä‡my chwilÄ™, aby powrÃ³ciÄ‡ do tego, jak dziaÅ‚ajÄ…\nfutures.\n\nKaÅ¼dy _punkt oczekiwania_ â€“ to znaczy kaÅ¼de miejsce, w ktÃ³rym kod uÅ¼ywa sÅ‚owa\nkluczowego `await` â€“ reprezentuje miejsce, w ktÃ³rym kontrola zostaje\nprzekazana z powrotem do Å›rodowiska uruchomieniowego. Aby to zadziaÅ‚aÅ‚o, Rust\nmusi Å›ledziÄ‡ stan zaangaÅ¼owany w blok async, tak aby Å›rodowisko uruchomieniowe\nmogÅ‚o rozpoczÄ…Ä‡ innÄ… pracÄ™, a nastÄ™pnie powrÃ³ciÄ‡, gdy bÄ™dzie gotowe, aby\nponownie sprÃ³bowaÄ‡ posunÄ…Ä‡ pierwszÄ… pracÄ™. Jest to niewidoczna maszyna stanÃ³w,\ntak jakbyÅ› napisaÅ‚ enum w ten sposÃ³b, aby zapisaÄ‡ bieÅ¼Ä…cy stan w kaÅ¼dym punkcie\noczekiwania:\n\n```rust\n# extern crate trpl; // required for mdbook test\n# \nenum PageTitleFuture<'a> {\n    Initial { url: &'a str },\n    GetAwaitPoint { url: &'a str },\n    TextAwaitPoint { response: trpl::Response },\n}\n```\n\nRÄ™czne pisanie kodu do przechodzenia miÄ™dzy poszczegÃ³lnymi stanami byÅ‚oby\nudrÄ™kÄ… i podatne na bÅ‚Ä™dy, zwÅ‚aszcza gdy trzeba pÃ³Åºniej dodaÄ‡ wiÄ™cej\nfunkcjonalnoÅ›ci i stanÃ³w do kodu. Na szczÄ™Å›cie kompilator Rust automatycznie\ntworzy i zarzÄ…dza strukturami danych maszyny stanÃ³w dla kodu async. Normalne\nzasady poÅ¼yczania i wÅ‚asnoÅ›ci dotyczÄ…ce struktur danych nadal obowiÄ…zujÄ…, a co\nnajwaÅ¼niejsze, kompilator zajmuje siÄ™ rÃ³wnieÅ¼ ich sprawdzaniem i dostarcza\nprzydatne komunikaty o bÅ‚Ä™dach. Kilka z nich omÃ³wimy pÃ³Åºniej w tym rozdziale.\n\nOstatecznie, coÅ› musi wykonaÄ‡ tÄ™ maszynÄ™ stanÃ³w, a tym czymÅ› jest Å›rodowisko\nuruchomieniowe. (Dlatego moÅ¼esz natknÄ…Ä‡ siÄ™ na wzmianki o _executorach_,\nszukajÄ…c informacji o Å›rodowiskach uruchomieniowych: executor to czÄ™Å›Ä‡\nÅ›rodowiska uruchomieniowego odpowiedzialna za wykonywanie kodu async.)\n\nTeraz widzisz, dlaczego kompilator powstrzymaÅ‚ nas przed uczynieniem `main`\nsamego w sobie funkcjÄ… asynchronicznÄ… w Listingu 17-3. Gdyby `main` byÅ‚o\nfunkcjÄ… asynchronicznÄ…, coÅ› innego musiaÅ‚oby zarzÄ…dzaÄ‡ maszynÄ… stanÃ³w dla\ndowolnej przyszÅ‚oÅ›ci, ktÃ³rÄ… `main` zwrÃ³ciÅ‚o, ale `main` jest punktem\npoczÄ…tkowym programu! Zamiast tego wywoÅ‚aliÅ›my funkcjÄ™ `trpl::block_on` w\n`main`, aby skonfigurowaÄ‡ Å›rodowisko uruchomieniowe i uruchomiÄ‡ przyszÅ‚oÅ›Ä‡\nzwracanÄ… przez blok `async`, dopÃ³ki nie zostanie ona ukoÅ„czona.\n\n> Uwaga: NiektÃ³re Å›rodowiska uruchomieniowe zapewniajÄ… makra, dziÄ™ki czemu _moÅ¼esz_\npisaÄ‡ funkcjÄ™ `main` async. Te makra przepisujÄ… `async fn main() { ... }` na\nzwykÅ‚Ä… funkcjÄ™ `fn main`, ktÃ³ra robi to samo, co zrobiliÅ›my rÄ™cznie w Listingu\n17-4: wywoÅ‚uje funkcjÄ™, ktÃ³ra uruchamia przyszÅ‚oÅ›Ä‡ do koÅ„ca w sposÃ³b, w jaki to\nrobi `trpl::block_on`.\n\nTeraz poÅ‚Ä…czmy te elementy i zobaczmy, jak moÅ¼emy pisaÄ‡ kod wspÃ³Å‚bieÅ¼ny.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"racing-our-two-urls-against-each-other\"></a>\n\n### WyÅ›cig dwÃ³ch adresÃ³w URL ze sobÄ… wspÃ³Å‚bieÅ¼nie\n\nW Listingu 17-5 wywoÅ‚ujemy `page_title` z dwoma rÃ³Å¼nymi adresami URL\nprzekazanymi z wiersza poleceÅ„ i Å›cigamy je, wybierajÄ…c tÄ™ future, ktÃ³ra\nzakoÅ„czy siÄ™ jako pierwsza.\n\n<Listing number=\"17-5\" caption=\"WywoÅ‚anie `page_title` dla dwÃ³ch adresÃ³w URL, aby zobaczyÄ‡, ktÃ³ry zwrÃ³ci siÄ™ pierwszy\" file-name=\"src/main.rs\">\n\n<!-- should_panic,noplayground because mdbook does not pass args -->\n\n```rust,should_panic,noplayground\n# extern crate trpl; // required for mdbook test\n# \nuse trpl::{Either, Html};\n\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n\n    trpl::block_on(async {\n        let title_fut_1 = page_title(&args[1]);\n        let title_fut_2 = page_title(&args[2]);\n\n        let (url, maybe_title) =\n            match trpl::select(title_fut_1, title_fut_2).await {\n                Either::Left(left) => left,\n                Either::Right(right) => right,\n            };\n\n        println!(\"{url} returned first\");\n        match maybe_title {\n            Some(title) => println!(\"Its page title was: '{title}'\"),\n            None => println!(\"It had no title.\"),\n        }\n    })\n}\n\nasync fn page_title(url: &str) -> (&str, Option<String>) {\n    let response_text = trpl::get(url).await.text().await;\n    let title = Html::parse(&response_text)\n        .select_first(\"title\")\n        .map(|title| title.inner_html());\n    (url, title)\n}\n```\n\n</Listing>\n\nZaczynamy od wywoÅ‚ania `page_title` dla kaÅ¼dego z adresÃ³w URL podanych przez\nuÅ¼ytkownika. Wynikowe futures zapisujemy jako `title_fut_1` i `title_fut_2`.\nPamiÄ™taj, Å¼e te futures jeszcze nic nie robiÄ…, poniewaÅ¼ sÄ… leniwe i jeszcze\nna nie nie czekaliÅ›my. NastÄ™pnie przekazujemy futures do `trpl::select`, ktÃ³ry\nzwraca wartoÅ›Ä‡ wskazujÄ…cÄ…, ktÃ³ra z przekazanych do niego futures zakoÅ„czyÅ‚a\ndziaÅ‚anie jako pierwsza.\n\n> Uwaga: Pod maskÄ…, `trpl::select` jest zbudowany na bardziej ogÃ³lnej funkcji\n> `select` zdefiniowanej w crate'cie `futures`. Funkcja `select` z crate'a\n> `futures` potrafi wiele rzeczy, ktÃ³rych funkcja `trpl::select` nie potrafi,\nale ma teÅ¼ pewne dodatkowe zÅ‚oÅ¼onoÅ›ci, ktÃ³re na razie moÅ¼emy pominÄ…Ä‡.\n\nKaÅ¼da przyszÅ‚oÅ›Ä‡ moÅ¼e legalnie â€wygraÄ‡â€, wiÄ™c zwracanie `Result` nie ma sensu.\nZamiast tego, `trpl::select` zwraca typ, ktÃ³rego wczeÅ›niej nie widzieliÅ›my,\n`trpl::Either`. Typ `Either` jest nieco podobny do `Result` w tym, Å¼e ma dwa\nprzypadki. Jednak w przeciwieÅ„stwie do `Result`, w `Either` nie ma pojÄ™cia\nczynnika sukcesu ani poraÅ¼ki. Zamiast tego, uÅ¼ywa `Left` i `Right`, aby wskazaÄ‡\nâ€jedno lub drugieâ€:\n\n```rust\nenum Either<A, B> {\n    Left(A),\n    Right(B),\n}\n```\n\nFunkcja `select` zwraca `Left` z wynikiem tej future, jeÅ›li pierwszy argument\nwygra, i `Right` z wynikiem future drugiego argumentu, jeÅ›li _ta_ wygra.\nOdpowiada to kolejnoÅ›ci, w jakiej argumenty pojawiajÄ… siÄ™ podczas wywoÅ‚ywania\nfunkcji: pierwszy argument jest na lewo od drugiego argumentu.\n\nAktualizujemy rÃ³wnieÅ¼ `page_title`, aby zwracaÅ‚a ten sam URL, ktÃ³ry zostaÅ‚\nprzekazany. W ten sposÃ³b, jeÅ›li strona, ktÃ³ra zwrÃ³ci siÄ™ jako pierwsza, nie ma\n`<title>`, ktÃ³rÄ… moÅ¼emy rozwiÄ…zaÄ‡, nadal moÅ¼emy wypisaÄ‡ sensowny komunikat.\nPo uzyskaniu tych informacji, koÅ„czymy aktualizacjÄ™ naszego wyjÅ›cia `println!`,\naby wskazaÄ‡ zarÃ³wno to, ktÃ³ry URL zakoÅ„czyÅ‚ siÄ™ jako pierwszy, jak i jaki,\njeÅ›li w ogÃ³le, jest `<title>` dla strony internetowej pod tym URL-em.\n\nZbudowaÅ‚eÅ› teraz maÅ‚y, dziaÅ‚ajÄ…cy scraper internetowy! Wybierz kilka adresÃ³w URL\ni uruchom narzÄ™dzie wiersza poleceÅ„. MoÅ¼esz odkryÄ‡, Å¼e niektÃ³re witryny sÄ…\nkonsekwentnie szybsze od innych, podczas gdy w innych przypadkach szybsza\nwitryna zmienia siÄ™ z uruchomienia na uruchomienie. Co waÅ¼niejsze, nauczyÅ‚eÅ›\nsiÄ™ podstaw pracy z futures, wiÄ™c teraz moÅ¼emy zagÅ‚Ä™biÄ‡ siÄ™ w to, co moÅ¼emy\nzrobiÄ‡ z `async`.\n\n[impl-trait]: ch10-02-traits.html#traits-as-parameters\n[iterators-lazy]: ch13-02-iterators.html\n[thread-spawn]: ch16-01-threads.html#creating-a-new-thread-with-spawn\n[cli-args]: ch12-01-accepting-command-line-arguments.html\n\n<!-- TODO: map source link version to version of Rust? -->\n\n[crate-source]: https://github.com/rust-lang/book/tree/main/packages/trpl\n[futures-crate]: https://crates.io/crates/futures\n[tokio]: https://tokio.rs",
        "chapter_title": "Futures i skÅ‚adnia `async`"
    },
    {
        "file_path": "ch17-02-concurrency-with-async.md",
        "content": "<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"concurrency-with-async\"></a>\n\n## Stosowanie wspÃ³Å‚bieÅ¼noÅ›ci z `async`\n\nW tej sekcji zastosujemy async do niektÃ³rych z tych samych wyzwaÅ„\nwspÃ³Å‚bieÅ¼noÅ›ci, ktÃ³re rozwiÄ…zaliÅ›my za pomocÄ… wÄ…tkÃ³w w Rozdziale 16. PoniewaÅ¼\nwiele kluczowych idei zostaÅ‚o tam juÅ¼ omÃ³wionych, w tej sekcji skupimy siÄ™ na\nrÃ³Å¼nicach miÄ™dzy wÄ…tkami a futures.\n\nW wielu przypadkach API do pracy z wspÃ³Å‚bieÅ¼noÅ›ciÄ… przy uÅ¼yciu async sÄ… bardzo\npodobne do tych do pracy z wÄ…tkami. W innych przypadkach sÄ… one zupeÅ‚nie\nrÃ³Å¼ne. Nawet gdy API _wyglÄ…dajÄ…_ podobnie miÄ™dzy wÄ…tkami a async, czÄ™sto majÄ…\nrÃ³Å¼ne zachowania â€” i prawie zawsze majÄ… rÃ³Å¼ne charakterystyki wydajnoÅ›ci.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"counting\"></a>\n\n### Tworzenie nowego zadania za pomocÄ… `spawn_task`\n\nPierwszÄ… operacjÄ…, ktÃ³rÄ… zajÄ™liÅ›my siÄ™ w sekcji [â€Tworzenie nowego wÄ…tku za\npomocÄ… `spawn`â€][thread-spawn]<!-- ignore --> w Rozdziale 16, byÅ‚o zliczanie\nna dwÃ³ch oddzielnych wÄ…tkach. ZrÃ³bmy to samo, uÅ¼ywajÄ…c async. Crate `trpl`\ndostarcza funkcjÄ™ `spawn_task`, ktÃ³ra wyglÄ…da bardzo podobnie do API\n`thread::spawn`, oraz funkcjÄ™ `sleep`, ktÃ³ra jest asynchronicznÄ… wersjÄ… API\n`thread::sleep`. MoÅ¼emy ich uÅ¼yÄ‡ razem do zaimplementowania przykÅ‚adu\nzliczania, jak pokazano w Listingu 17-6.\n\n<Listing number=\"17-6\" caption=\"Tworzenie nowego zadania do wypisania jednej rzeczy, podczas gdy gÅ‚Ã³wne zadanie wypisuje coÅ› innego\" file-name=\"src/main.rs\">\n\n```rust\n# extern crate trpl; // required for mdbook test\n# \nuse std::time::Duration;\n\nfn main() {\n    trpl::block_on(async {\n        trpl::spawn_task(async {\n            for i in 1..10 {\n                println!(\"hi number {i} from the first task!\");\n                trpl::sleep(Duration::from_millis(500)).await;\n            }\n        });\n\n        for i in 1..5 {\n            println!(\"hi number {i} from the second task!\");\n            trpl::sleep(Duration::from_millis(500)).await;\n        }\n    });\n}\n```\n\n</Listing>\n\nJako punkt wyjÅ›cia, konfigurujemy naszÄ… funkcjÄ™ `main` z `trpl::block_on`,\ntak aby nasza funkcja najwyÅ¼szego poziomu mogÅ‚a byÄ‡ asynchroniczna.\n\n> Uwaga: Od tego momentu w rozdziale, kaÅ¼dy przykÅ‚ad bÄ™dzie zawieraÅ‚ ten sam\n> kod opakowujÄ…cy z `trpl::block_on` w `main`, wiÄ™c czÄ™sto bÄ™dziemy go\n> pomijaÄ‡, tak jak to robimy z `main`. PamiÄ™taj, aby uwzglÄ™dniÄ‡ go w swoim\n> kodzie!\n\nNastÄ™pnie piszemy dwie pÄ™tle w tym bloku, kaÅ¼da zawierajÄ…ca wywoÅ‚anie\n`trpl::sleep`, ktÃ³re czeka pÃ³Å‚ sekundy (500 milisekund) przed wysÅ‚aniem\nkolejnej wiadomoÅ›ci. JednÄ… pÄ™tlÄ™ umieszczamy w ciele `trpl::spawn_task`, a drugÄ…\nw pÄ™tli `for` najwyÅ¼szego poziomu. Dodajemy rÃ³wnieÅ¼ `await` po wywoÅ‚aniach\n`sleep`.\n\nTen kod zachowuje siÄ™ podobnie do implementacji opartej na wÄ…tkach â€“ w tym\ntakÅ¼e to, Å¼e moÅ¼esz zobaczyÄ‡ wiadomoÅ›ci pojawiajÄ…ce siÄ™ w innej kolejnoÅ›ci w\nwÅ‚asnym terminalu, gdy go uruchomisz:\n\n<!-- Not extracting output because changes to this output aren't significant;\nthe changes are likely to be due to the threads running differently rather than\nchanges in the compiler -->\n\n```text\nhi number 1 from the second task!\nhi number 1 from the first task!\nhi number 2 from the first task!\nhi number 2 from the second task!\nhi number 3 from the first task!\nhi number 3 from the second task!\nhi number 4 from the first task!\nhi number 4 from the second task!\nhi number 5 from the first task!\n```\n\nTa wersja zatrzymuje siÄ™, gdy tylko zakoÅ„czy siÄ™ pÄ™tla `for` w ciele gÅ‚Ã³wnego\nbloku async, poniewaÅ¼ zadanie uruchomione przez `spawn_task` zostaje\nwyÅ‚Ä…czone, gdy funkcja `main` siÄ™ koÅ„czy. JeÅ›li chcesz, aby dziaÅ‚aÅ‚o do koÅ„ca\nzadania, bÄ™dziesz musiaÅ‚ uÅ¼yÄ‡ uchwytu `join` do oczekiwania na zakoÅ„czenie\npierwszego zadania. W przypadku wÄ…tkÃ³w, uÅ¼yliÅ›my metody `join` do â€blokowaniaâ€,\ndopÃ³ki wÄ…tek nie zakoÅ„czyÅ‚ dziaÅ‚ania. W Listingu 17-7 moÅ¼emy uÅ¼yÄ‡ `await` do\nzrobienia tego samego, poniewaÅ¼ sam uchwyt zadania jest future. Jego typ\n`Output` to `Result`, wiÄ™c rÃ³wnieÅ¼ go rozpakowujemy po oczekiwaniu na niego.\n\n<Listing number=\"17-7\" caption=\"UÅ¼ycie `await` z uchwytem `join` do uruchomienia zadania do koÅ„ca\" file-name=\"src/main.rs\">\n\n```rust\n# extern crate trpl; // required for mdbook test\n# \n# use std::time::Duration;\n# \n# fn main() {\n#     trpl::block_on(async {\n        let handle = trpl::spawn_task(async {\n            for i in 1..10 {\n                println!(\"hi number {i} from the first task!\");\n                trpl::sleep(Duration::from_millis(500)).await;\n            }\n        });\n\n        for i in 1..5 {\n            println!(\"hi number {i} from the second task!\");\n            trpl::sleep(Duration::from_millis(500)).await;\n        }\n\n        handle.await.unwrap();\n#     });\n# }\n```\n\n</Listing>\n\nTa zaktualizowana wersja dziaÅ‚a, dopÃ³ki _obie_ pÄ™tle siÄ™ nie zakoÅ„czÄ…:\n\n<!-- Not extracting output because changes to this output aren't significant;\nthe changes are likely to be due to the threads running differently rather than\nchanges in the compiler -->\n\n```text\nhi number 1 from the second task!\nhi number 1 from the first task!\nhi number 2 from the first task!\nhi number 2 from the second task!\nhi number 3 from the first task!\nhi number 3 from the second task!\nhi number 4 from the first task!\nhi number 4 from the second task!\nhi number 5 from the first task!\nhi number 6 from the first task!\nhi number 7 from the first task!\nhi number 8 from the first task!\nhi number 9 from the first task!\n```\n\nJak dotÄ…d, wydaje siÄ™, Å¼e async i wÄ…tki dajÄ… nam podobne wyniki, tylko z\ninnÄ… skÅ‚adniÄ…: uÅ¼ywajÄ…c `await` zamiast wywoÅ‚ywania `join` na uchwycie `join`,\noraz oczekujÄ…c na wywoÅ‚ania `sleep`.\n\nWiÄ™kszÄ… rÃ³Å¼nicÄ… jest to, Å¼e nie musieliÅ›my tworzyÄ‡ kolejnego wÄ…tku systemu\noperacyjnego, aby to zrobiÄ‡. W rzeczywistoÅ›ci, nie musimy nawet tworzyÄ‡ tutaj\nÅ¼adnego zadania. PoniewaÅ¼ bloki async kompilujÄ… siÄ™ do anonimowych futures,\nmoÅ¼emy umieÅ›ciÄ‡ kaÅ¼dÄ… pÄ™tlÄ™ w bloku async i pozwoliÄ‡ Å›rodowisku uruchomieniowemu\nuruchomiÄ‡ je obie do koÅ„ca za pomocÄ… funkcji `trpl::join`.\n\nW sekcji [â€Czekanie na zakoÅ„czenie wszystkich wÄ…tkÃ³wâ€][join-handles]<!-- ignore\n--> w Rozdziale 16 pokazaliÅ›my, jak uÅ¼ywaÄ‡ metody `join` na typie\n`JoinHandle` zwracanym po wywoÅ‚aniu `std::thread::spawn`. Funkcja `trpl::join`\njest podobna, ale dla futures. Kiedy podasz jej dwie futures, produkuje jednÄ…\nnowÄ… future, ktÃ³rej wynikiem jest krotka zawierajÄ…ca wyniki kaÅ¼dej future,\nktÃ³rÄ… przekazaÅ‚eÅ›, gdy _obie_ zakoÅ„czÄ… dziaÅ‚anie. Tak wiÄ™c, w Listingu 17-8\nuÅ¼ywamy `trpl::join`, aby poczekaÄ‡ na zakoÅ„czenie zarÃ³wno `fut1`, jak i `fut2`.\nNie oczekujemy na `fut1` i `fut2`, ale zamiast tego na nowÄ… future\nprodukowanÄ… przez `trpl::join`. Ignorujemy wynik, poniewaÅ¼ jest to tylko krotka\nzawierajÄ…ca dwie wartoÅ›ci jednostkowe.\n\n<Listing number=\"17-8\" caption=\"UÅ¼ycie `trpl::join` do oczekiwania na dwie anonimowe futures\" file-name=\"src/main.rs\">\n\n```rust\n# extern crate trpl; // required for mdbook test\n# \n# use std::time::Duration;\n# \n# fn main() {\n#     trpl::block_on(async {\n        let fut1 = async {\n            for i in 1..10 {\n                println!(\"hi number {i} from the first task!\");\n                trpl::sleep(Duration::from_millis(500)).await;\n            }\n        };\n\n        let fut2 = async {\n            for i in 1..5 {\n                println!(\"hi number {i} from the second task!\");\n                trpl::sleep(Duration::from_millis(500)).await;\n            }\n        };\n\n        trpl::join(fut1, fut2).await;\n#     });\n# }\n```\n\n</Listing>\n\nPo uruchomieniu widzimy, Å¼e obie futures dziaÅ‚ajÄ… do koÅ„ca:\n\n<!-- Not extracting output because changes to this output aren't significant;\nthe changes are likely to be due to the threads running differently rather than\nchanges in the compiler -->\n\n```text\nhi number 1 from the first task!\nhi number 1 from the second task!\nhi number 2 from the first task!\nhi number 2 from the second task!\nhi number 3 from the first task!\nhi number 3 from the second task!\nhi number 4 from the first task!\nhi number 4 from the second task!\nhi number 5 from the first task!\nhi number 6 from the first task!\nhi number 7 from the first task!\nhi number 8 from the first task!\nhi number 9 from the first task!\n```\n\nTeraz zobaczysz dokÅ‚adnie tÄ™ samÄ… kolejnoÅ›Ä‡ za kaÅ¼dym razem, co jest bardzo\nrÃ³Å¼ne od tego, co widzieliÅ›my w przypadku wÄ…tkÃ³w i `trpl::spawn_task` w Listingu\n17-7. Dzieje siÄ™ tak, poniewaÅ¼ funkcja `trpl::join` jest _sprawiedliwa_,\noznacza to, Å¼e sprawdza kaÅ¼dÄ… future tak samo czÄ™sto, naprzemiennie miÄ™dzy nimi,\ni nigdy nie pozwala jednej wyprzedziÄ‡ drugiej, jeÅ›li ta druga jest gotowa.\nW przypadku wÄ…tkÃ³w, system operacyjny decyduje, ktÃ³ry wÄ…tek sprawdziÄ‡ i jak\ndÅ‚ugo pozwoliÄ‡ mu dziaÅ‚aÄ‡. W przypadku async Rust, Å›rodowisko uruchomieniowe\ndecyduje, ktÃ³re zadanie sprawdziÄ‡. (W praktyce, szczegÃ³Å‚y stajÄ… siÄ™\nskomplikowane, poniewaÅ¼ Å›rodowisko uruchomieniowe async moÅ¼e wykorzystywaÄ‡\nwÄ…tki systemu operacyjnego pod maskÄ… jako czÄ™Å›Ä‡ sposobu zarzÄ…dzania\nwspÃ³Å‚bieÅ¼noÅ›ciÄ…, wiÄ™c zagwarantowanie sprawiedliwoÅ›ci moÅ¼e byÄ‡ bardziej\npracochÅ‚onne dla Å›rodowiska uruchomieniowego â€“ ale nadal jest to moÅ¼liwe!)\nÅšrodowiska uruchomieniowe nie muszÄ… gwarantowaÄ‡ sprawiedliwoÅ›ci dla Å¼adnej\ndanej operacji i czÄ™sto oferujÄ… rÃ³Å¼ne API, aby umoÅ¼liwiÄ‡ wybÃ³r, czy chcesz\nsprawiedliwoÅ›ci, czy nie.\n\nWyprÃ³buj niektÃ³re z tych wariacji oczekiwania na futures i zobacz, co robiÄ…:\n\n- UsuÅ„ blok async wokÃ³Å‚ jednej lub obu pÄ™tli.\n- Oczekuj na kaÅ¼dy blok async natychmiast po jego zdefiniowaniu.\n- Opakuj tylko pierwszÄ… pÄ™tlÄ™ w blok async i oczekuj na wynikowÄ… future po\n  ciele drugiej pÄ™tli.\n\nDodatkowym wyzwaniem jest sprawdzenie, czy potrafisz przewidzieÄ‡, jaki bÄ™dzie\nwynik w kaÅ¼dym przypadku _przed_ uruchomieniem kodu!\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"message-passing\"></a>\n<a id=\"counting-up-on-two-tasks-using-message-passing\"></a>\n\n### PrzesyÅ‚anie danych miÄ™dzy dwoma zadaniami za pomocÄ… przekazywania wiadomoÅ›ci\n\nWspÃ³Å‚dzielenie danych miÄ™dzy futures rÃ³wnieÅ¼ bÄ™dzie znajome: ponownie uÅ¼yjemy\nprzekazywania wiadomoÅ›ci, ale tym razem z asynchronicznymi wersjami typÃ³w i\nfunkcji. Obierzemy nieco innÄ… Å›cieÅ¼kÄ™ niÅ¼ w sekcji [â€PrzesyÅ‚anie danych miÄ™dzy\nwÄ…tkami za pomocÄ… przekazywania wiadomoÅ›ciâ€][message-passing-threads]<!--\nignore --> w Rozdziale 16, aby zilustrowaÄ‡ niektÃ³re kluczowe rÃ³Å¼nice miÄ™dzy\nwspÃ³Å‚bieÅ¼noÅ›ciÄ… opartÄ… na wÄ…tkach a wspÃ³Å‚bieÅ¼noÅ›ciÄ… opartÄ… na futures. W Listingu\n17-9 zaczniemy od pojedynczego bloku async â€“ _nie_ uruchamiajÄ…c oddzielnego\nzadania, tak jak uruchomiliÅ›my oddzielny wÄ…tek.\n\n<Listing number=\"17-9\" caption=\"Tworzenie kanaÅ‚u asynchronicznego i przypisywanie dwÃ³ch poÅ‚Ã³wek do `tx` i `rx`\" file-name=\"src/main.rs\">\n\n```rust\n# extern crate trpl; // required for mdbook test\n# \n# fn main() {\n#     trpl::block_on(async {\n        let (tx, mut rx) = trpl::channel();\n\n        let val = String::from(\"hi\");\n        tx.send(val).unwrap();\n\n        let received = rx.recv().await.unwrap();\n        println!(\"received '{received}'\");\n#     });\n# }\n```\n\n</Listing>\n\nTutaj uÅ¼ywamy `trpl::channel`, asynchronicznej wersji API kanaÅ‚u typu\nwiele-producentÃ³w, jeden-konsument, ktÃ³rego uÅ¼yliÅ›my z wÄ…tkami w Rozdziale 16.\nAsynchroniczna wersja API rÃ³Å¼ni siÄ™ tylko nieco od wersji opartej na wÄ…tkach:\nuÅ¼ywa mutowalnego, a nie niemutowalnego odbiornika `rx`, a jego metoda `recv`\nprodukuje future, na ktÃ³rÄ… musimy czekaÄ‡, zamiast bezpoÅ›rednio produkowaÄ‡\nwartoÅ›Ä‡. Teraz moÅ¼emy wysyÅ‚aÄ‡ wiadomoÅ›ci z nadawcy do odbiornika. ZauwaÅ¼, Å¼e\nnie musimy uruchamiaÄ‡ oddzielnego wÄ…tku ani nawet zadania; wystarczy, Å¼e\nbÄ™dziemy czekaÄ‡ na wywoÅ‚anie `rx.recv`.\n\nSynchroniczna metoda `Receiver::recv` w `std::mpsc::channel` blokuje do czasu\notrzymania wiadomoÅ›ci. Metoda `trpl::Receiver::recv` tego nie robi, poniewaÅ¼\njest asynchroniczna. Zamiast blokowaÄ‡, przekazuje kontrolÄ™ z powrotem do\nÅ›rodowiska uruchomieniowego, dopÃ³ki nie zostanie odebrana wiadomoÅ›Ä‡ lub strona\nwysyÅ‚ajÄ…ca kanaÅ‚u nie zostanie zamkniÄ™ta. Natomiast nie czekamy na wywoÅ‚anie\n`send`, poniewaÅ¼ nie blokuje. Nie musi, poniewaÅ¼ kanaÅ‚, do ktÃ³rego wysyÅ‚amy,\njest nieograniczony.\n\n> Uwaga: PoniewaÅ¼ caÅ‚y ten kod async dziaÅ‚a w bloku async w wywoÅ‚aniu\n> `trpl::block_on`, wszystko w nim moÅ¼e uniknÄ…Ä‡ blokowania. Jednak kod _poza_\nim blokiem bÄ™dzie blokowaÅ‚, dopÃ³ki funkcja `block_on` nie zwrÃ³ci wartoÅ›ci. Na\n> tym polega caÅ‚a idea funkcji `trpl::block_on`: pozwala _wybraÄ‡_, gdzie\n> zablokowaÄ‡ na jakimÅ› zestawie kodu async, a tym samym, gdzie przejÅ›Ä‡ miÄ™dzy\n> kodem synchronicznym a asynchronicznym.\n\nZauwaÅ¼ dwie rzeczy dotyczÄ…ce tego przykÅ‚adu. Po pierwsze, wiadomoÅ›Ä‡ dotrze\nnatychmiast. Po drugie, choÄ‡ uÅ¼ywamy tutaj przyszÅ‚oÅ›ci, nie ma jeszcze\nwspÃ³Å‚bieÅ¼noÅ›ci. Wszystko w listingu dzieje siÄ™ sekwencyjnie, tak jakby nie byÅ‚o\nÅ¼adnych futures.\n\nZajmijmy siÄ™ pierwszÄ… czÄ™Å›ciÄ…, wysyÅ‚ajÄ…c seriÄ™ wiadomoÅ›ci i pauzujÄ…c miÄ™dzy\nnimi, jak pokazano w Listingu 17-10.\n\n<!-- We cannot test this one because it never stops! -->\n\n<Listing number=\"17-10\" caption=\"WysyÅ‚anie i odbieranie wielu wiadomoÅ›ci przez kanaÅ‚ asynchroniczny i pauzowanie z `await` miÄ™dzy kaÅ¼dÄ… wiadomoÅ›ciÄ…\" file-name=\"src/main.rs\">\n\n```rust,ignore\n# extern crate trpl; // required for mdbook test\n# \n# use std::time::Duration;\n# \n# fn main() {\n#     trpl::block_on(async {\n        let (tx, mut rx) = trpl::channel();\n\n        let vals = vec![\n            String::from(\"hi\"),\n            String::from(\"from\"),\n            String::from(\"the\"),\n            String::from(\"future\"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            trpl::sleep(Duration::from_millis(500)).await;\n        }\n\n        while let Some(value) = rx.recv().await {\n            println!(\"received '{value}'\");\n        }\n#     });\n# }\n```\n\n</Listing>\n\nOprÃ³cz wysyÅ‚ania wiadomoÅ›ci, musimy je odbieraÄ‡. W tym przypadku, poniewaÅ¼\nwiemy, ile wiadomoÅ›ci nadejdzie, moglibyÅ›my to zrobiÄ‡ rÄ™cznie, wywoÅ‚ujÄ…c\n`rx.recv().await` cztery razy. Jednak w prawdziwym Å›wiecie zazwyczaj bÄ™dziemy\nczekaÄ‡ na _nieznanÄ…_ liczbÄ™ wiadomoÅ›ci, wiÄ™c musimy czekaÄ‡, aÅ¼ ustalimy, Å¼e\nnie ma juÅ¼ wiÄ™cej wiadomoÅ›ci.\n\nW Listingu 16-10 uÅ¼yliÅ›my pÄ™tli `for` do przetwarzania wszystkich elementÃ³w\notrzymanych z kanaÅ‚u synchronicznego. Rust nie ma jeszcze sposobu na uÅ¼ycie\npÄ™tli `for` z asynchronicznie produkowanym strumieniem elementÃ³w, wiÄ™c musimy\nuÅ¼yÄ‡ pÄ™tli, ktÃ³rej wczeÅ›niej nie widzieliÅ›my: warunkowej pÄ™tli `while let`.\nJest to wersja pÄ™tli konstrukcji `if let`, ktÃ³rÄ… widzieliÅ›my w sekcji [â€ZwiÄ™zÅ‚a\nkontrola przepÅ‚ywu z `if let` i `let...else`â€][if-let]<!-- ignore --> w\nRozdziale 6. PÄ™tla bÄ™dzie wykonywaÄ‡ siÄ™ tak dÅ‚ugo, jak dÅ‚ugo okreÅ›lony wzorzec\nbÄ™dzie pasowaÅ‚ do wartoÅ›ci.\n\nWywoÅ‚anie `rx.recv` produkuje future, na ktÃ³rÄ… czekamy. Åšrodowisko uruchomieniowe\nwstrzyma future, dopÃ³ki nie bÄ™dzie gotowa. Gdy tylko nadejdzie wiadomoÅ›Ä‡,\nfuture rozstrzygnie siÄ™ na `Some(message)` tyle razy, ile wiadomoÅ›ci nadejdzie.\nGdy kanaÅ‚ zostanie zamkniÄ™ty, niezaleÅ¼nie od tego, czy _jakiekolwiek_ wiadomoÅ›ci\nnadeszÅ‚y, future zamiast tego rozstrzygnie siÄ™ na `None`, aby wskazaÄ‡, Å¼e nie\nma juÅ¼ wiÄ™cej wartoÅ›ci i w zwiÄ…zku z tym powinniÅ›my przestaÄ‡ odpytywaÄ‡ â€“ to\nznaczy, przestaÄ‡ oczekiwaÄ‡.\n\nPÄ™tla `while let` Å‚Ä…czy to wszystko w caÅ‚oÅ›Ä‡. JeÅ›li wynik wywoÅ‚ania\n`rx.recv().await` to `Some(message)`, uzyskujemy dostÄ™p do wiadomoÅ›ci i moÅ¼emy\njej uÅ¼ywaÄ‡ w ciele pÄ™tli, tak jak w przypadku `if let`. JeÅ›li wynik to `None`,\npÄ™tla siÄ™ koÅ„czy. Za kaÅ¼dym razem, gdy pÄ™tla siÄ™ koÅ„czy, ponownie trafia na\npunkt oczekiwania, wiÄ™c Å›rodowisko uruchomieniowe ponownie jÄ… wstrzymuje,\ndopÃ³ki nie nadejdzie kolejna wiadomoÅ›Ä‡.\n\nKod teraz pomyÅ›lnie wysyÅ‚a i odbiera wszystkie wiadomoÅ›ci. Niestety, nadal\nistniejÄ… dwa problemy. Po pierwsze, wiadomoÅ›ci nie docierajÄ… w odstÄ™pach\npÃ³Å‚sekundowych. DocierajÄ… wszystkie naraz, 2 sekundy (2000 milisekund) po\nuruchomieniu programu. Po drugie, ten program rÃ³wnieÅ¼ nigdy siÄ™ nie koÅ„czy!\nZamiast tego czeka w nieskoÅ„czonoÅ›Ä‡ na nowe wiadomoÅ›ci. Musisz go wyÅ‚Ä…czyÄ‡,\nuÅ¼ywajÄ…c <kbd>ctrl</kbd>-<kbd>C</kbd>.\n\n#### Kod w jednym bloku Async wykonuje siÄ™ liniowo\n\nZacznijmy od zbadania, dlaczego wiadomoÅ›ci przychodzÄ… wszystkie naraz po peÅ‚nym\nopÃ³Åºnieniu, zamiast przychodziÄ‡ z opÃ³Åºnieniami miÄ™dzy kaÅ¼dÄ… z nich. W danym\nbloku async kolejnoÅ›Ä‡, w jakiej sÅ‚owa kluczowe `await` pojawiajÄ… siÄ™ w kodzie,\njest rÃ³wnieÅ¼ kolejnoÅ›ciÄ…, w jakiej sÄ… wykonywane, gdy program dziaÅ‚a.\n\nW Listingu 17-10 jest tylko jeden blok async, wiÄ™c wszystko w nim dziaÅ‚a\nliniowo. Nadal nie ma wspÃ³Å‚bieÅ¼noÅ›ci. Wszystkie wywoÅ‚ania `tx.send` odbywajÄ… siÄ™,\nprzeplatane wszystkimi wywoÅ‚aniami `trpl::sleep` i ich powiÄ…zanymi punktami\noczekiwania. Dopiero wtedy pÄ™tla `while let` moÅ¼e przejÅ›Ä‡ przez ktÃ³rykolwiek z\npunktÃ³w oczekiwania na wywoÅ‚ania `recv`.\n\nAby uzyskaÄ‡ poÅ¼Ä…dane zachowanie, w ktÃ³rym opÃ³Åºnienie snu nastÄ™puje miÄ™dzy\nkaÅ¼dÄ… wiadomoÅ›ciÄ…, musimy umieÅ›ciÄ‡ operacje `tx` i `rx` w ich wÅ‚asnych blokach\nasync, jak pokazano w Listingu 17-11. Wtedy Å›rodowisko uruchomieniowe moÅ¼e\nwykonaÄ‡ kaÅ¼dÄ… z nich oddzielnie, uÅ¼ywajÄ…c funkcji `trpl::join`, podobnie jak\nw Listingu 17-8. Ponownie, czekamy na wynik wywoÅ‚ania `trpl::join`, a nie na\nposzczegÃ³lne futures. GdybyÅ›my czekali na poszczegÃ³lne futures w sekwencji,\nskutkowaÅ‚oby to powrotem do sekwencyjnego przepÅ‚ywu â€“ dokÅ‚adnie tego, czego\nprÃ³bujemy _nie_ robiÄ‡.\n\n<!-- We cannot test this one because it never stops! -->\n\n<Listing number=\"17-11\" caption=\"Rozdzielenie `send` i `recv` na wÅ‚asne bloki `async` i oczekiwanie na futures dla tych blokÃ³w\" file-name=\"src/main.rs\">\n\n```rust,ignore\n# extern crate trpl; // required for mdbook test\n# \n# use std::time::Duration;\n# \n# fn main() {\n#     trpl::block_on(async {\n#         let (tx, mut rx) = trpl::channel();\n# \n        let tx_fut = async {\n            let vals = vec![\n                String::from(\"hi\"),\n                String::from(\"from\"),\n                String::from(\"the\"),\n                String::from(\"future\"),\n            ];\n\n            for val in vals {\n                tx.send(val).unwrap();\n                trpl::sleep(Duration::from_millis(500)).await;\n            }\n        };\n\n        let rx_fut = async {\n            while let Some(value) = rx.recv().await {\n                println!(\"received '{value}'\");\n            }\n        };\n\n        trpl::join(tx_fut, rx_fut).await;\n#     });\n# }\n```\n\n</Listing>\n\nDziÄ™ki zaktualizowanemu kodowi z Listingu 17-11, wiadomoÅ›ci sÄ… drukowane w\nodstÄ™pach 500 milisekund, a nie wszystkie naraz po 2 sekundach.\n\n#### Przenoszenie wÅ‚asnoÅ›ci do bloku `async`\n\nProgram nadal nigdy siÄ™ nie koÅ„czy z powodu sposobu, w jaki pÄ™tla `while let`\nwspÃ³Å‚dziaÅ‚a z `trpl::join`:\n\n- Future zwrÃ³cona przez `trpl::join` koÅ„czy siÄ™ dopiero, gdy _obie_ future,\n  ktÃ³re zostaÅ‚y do niej przekazane, zakoÅ„czÄ… swoje dziaÅ‚anie.\n- Future `tx_fut` koÅ„czy siÄ™, gdy zakoÅ„czy spanie po wysÅ‚aniu ostatniej\n  wiadomoÅ›ci w `vals`.\n- Future `rx_fut` nie zakoÅ„czy siÄ™, dopÃ³ki pÄ™tla `while let` siÄ™ nie zakoÅ„czy.\n- PÄ™tla `while let` nie zakoÅ„czy siÄ™, dopÃ³ki oczekiwanie na `rx.recv` nie\n  zwrÃ³ci `None`.\n- Oczekiwanie na `rx.recv` zwrÃ³ci `None` dopiero po zamkniÄ™ciu drugiego koÅ„ca\n  kanaÅ‚u.\n- KanaÅ‚ zostanie zamkniÄ™ty tylko, jeÅ›li wywoÅ‚amy `rx.close` lub gdy strona\n  nadawcy, `tx`, zostanie usuniÄ™ta.\n- Nigdzie nie wywoÅ‚ujemy `rx.close`, a `tx` nie zostanie usuniÄ™te, dopÃ³ki\n  najbardziej zewnÄ™trzny blok async przekazany do `trpl::block_on` siÄ™ nie\n  zakoÅ„czy.\n- Blok nie moÅ¼e siÄ™ zakoÅ„czyÄ‡, poniewaÅ¼ jest zablokowany przez zakoÅ„czenie\n  `trpl::join`, co cofa nas na poczÄ…tek tej listy.\n\nObecnie blok async, w ktÃ³rym wysyÅ‚amy wiadomoÅ›ci, jedynie _poÅ¼ycza_ `tx`,\nponiewaÅ¼ wysyÅ‚anie wiadomoÅ›ci nie wymaga wÅ‚asnoÅ›ci, ale gdybyÅ›my mogli\n_przenieÅ›Ä‡_ `tx` do tego bloku async, zostaÅ‚oby ono usuniÄ™te po zakoÅ„czeniu\ntego bloku. W sekcji [â€Przechwytywanie referencji lub przenoszenie\nwÅ‚asnoÅ›ciâ€][capture-or-move]<!-- ignore --> w Rozdziale 13 nauczyÅ‚eÅ› siÄ™, jak\nuÅ¼ywaÄ‡ sÅ‚owa kluczowego `move` z domkniÄ™ciami, a jak omÃ³wiono w sekcji\n[â€UÅ¼ywanie domkniÄ™Ä‡ `move` z wÄ…tkamiâ€][move-threads]<!-- ignore --> w Rozdziale\n16, czÄ™sto musimy przenosiÄ‡ dane do domkniÄ™Ä‡, pracujÄ…c z wÄ…tkami. Te same\npodstawowe dynamiki dotyczÄ… blokÃ³w async, wiÄ™c sÅ‚owo kluczowe `move` dziaÅ‚a z\nblokami async tak samo, jak z domkniÄ™ciami.\n\nW Listingu 17-12 zmieniamy blok uÅ¼ywany do wysyÅ‚ania wiadomoÅ›ci z `async` na\n`async move`.\n\n<Listing number=\"17-12\" caption=\"Poprawiona wersja kodu z Listingu 17-11, ktÃ³ra poprawnie zamyka siÄ™ po zakoÅ„czeniu\" file-name=\"src/main.rs\">\n\n```rust\n# extern crate trpl; // required for mdbook test\n# \n# use std::time::Duration;\n# \n# fn main() {\n#     trpl::block_on(async {\n        let (tx, mut rx) = trpl::channel();\n\n        let tx_fut = async move {\n            // --snip--\n#             let vals = vec![\n#                 String::from(\"hi\"),\n#                 String::from(\"from\"),\n#                 String::from(\"the\"),\n#                 String::from(\"future\"),\n#             ];\n# \n#             for val in vals {\n#                 tx.send(val).unwrap();\n#                 trpl::sleep(Duration::from_millis(500)).await;\n#             }\n#         };\n# \n#         let rx_fut = async {\n#             while let Some(value) = rx.recv().await {\n#                 println!(\"received '{value}'\");\n#             }\n#         };\n# \n#         trpl::join(tx_fut, rx_fut).await;\n#     });\n# }\n```\n\n</Listing>\n\nPo uruchomieniu _tej_ wersji kodu, zamyka siÄ™ ona pÅ‚ynnie po wysÅ‚aniu i\nodebraniu ostatniej wiadomoÅ›ci. NastÄ™pnie, zobaczmy, co musiaÅ‚oby siÄ™ zmieniÄ‡,\naby wysyÅ‚aÄ‡ dane z wiÄ™cej niÅ¼ jednej future.\n\n#### ÅÄ…czenie wielu futures za pomocÄ… makra `join!`\n\nTen kanaÅ‚ async jest rÃ³wnieÅ¼ kanaÅ‚em wieloproducentowym, wiÄ™c moÅ¼emy wywoÅ‚aÄ‡\n`clone` na `tx`, jeÅ›li chcemy wysyÅ‚aÄ‡ wiadomoÅ›ci z wielu futures, jak pokazano\nw Listingu 17-13.\n\n<Listing number=\"17-13\" caption=\"UÅ¼ycie wielu producentÃ³w z blokami `async`\" file-name=\"src/main.rs\">\n\n```rust\n# extern crate trpl; // required for mdbook test\n# \n# use std::time::Duration;\n# \n# fn main() {\n#     trpl::block_on(async {\n        let (tx, mut rx) = trpl::channel();\n\n        let tx1 = tx.clone();\n        let tx1_fut = async move {\n            let vals = vec![\n                String::from(\"hi\"),\n                String::from(\"from\"),\n                String::from(\"the\"),\n                String::from(\"future\"),\n            ];\n\n            for val in vals {\n                tx1.send(val).unwrap();\n                trpl::sleep(Duration::from_millis(500)).await;\n            }\n        };\n\n        let rx_fut = async {\n            while let Some(value) = rx.recv().await {\n                println!(\"received '{value}'\");\n            }\n        };\n\n        let tx_fut = async move {\n            let vals = vec![\n                String::from(\"more\"),\n                String::from(\"messages\"),\n                String::from(\"for\"),\n                String::from(\"you\"),\n            ];\n\n            for val in vals {\n                tx.send(val).unwrap();\n                trpl::sleep(Duration::from_millis(1500)).await;\n            }\n        };\n\n        trpl::join!(tx1_fut, tx_fut, rx_fut);\n#     });\n# }\n```\n\n</Listing>\n\nNajpierw klonujemy `tx`, tworzÄ…c `tx1` poza pierwszym blokiem async. Przenosimy\n`tx1` do tego bloku, tak jak wczeÅ›niej z `tx`. NastÄ™pnie, pÃ³Åºniej, przenosimy\noryginalne `tx` do _nowego_ bloku async, gdzie wysyÅ‚amy wiÄ™cej wiadomoÅ›ci z\nnieco wolniejszym opÃ³Åºnieniem. Akurat umieszczamy ten nowy blok async po bloku\nasync do odbierania wiadomoÅ›ci, ale rÃ³wnie dobrze mÃ³gÅ‚by byÄ‡ przed nim. Kluczem\njest kolejnoÅ›Ä‡, w jakiej futures sÄ… oczekiwane, a nie w jakiej sÄ… tworzone.\n\nOba bloki async do wysyÅ‚ania wiadomoÅ›ci muszÄ… byÄ‡ blokami `async move`,\ntak aby zarÃ³wno `tx`, jak i `tx1` zostaÅ‚y usuniÄ™te po zakoÅ„czeniu tych blokÃ³w.\nW przeciwnym razie wrÃ³cimy do tej samej nieskoÅ„czonej pÄ™tli, w ktÃ³rej zaczÄ™liÅ›my.\n\nNa koniec, przeÅ‚Ä…czamy siÄ™ z `trpl::join` na `trpl::join!`, aby obsÅ‚uÅ¼yÄ‡\ndodatkowe future: makro `join!` oczekuje na dowolnÄ… liczbÄ™ futures, gdzie\nliczbÄ™ futures znamy w czasie kompilacji. O oczekiwaniu na kolekcjÄ™ nieznanej\nliczby futures bÄ™dziemy rozmawiaÄ‡ pÃ³Åºniej w tym rozdziale.\n\nTeraz widzimy wszystkie wiadomoÅ›ci z obu futures wysyÅ‚ajÄ…cych, a poniewaÅ¼\nfutures wysyÅ‚ajÄ…ce uÅ¼ywajÄ… nieco innych opÃ³ÅºnieÅ„ po wysÅ‚aniu, wiadomoÅ›ci sÄ…\nrÃ³wnieÅ¼ odbierane w tych rÃ³Å¼nych odstÄ™pach czasu:\n\n<!-- Not extracting output because changes to this output aren't significant;\nthe changes are likely to be due to the threads running differently rather than\nchanges in the compiler -->\n\n```text\nreceived 'hi'\nreceived 'more'\nreceived 'from'\nreceived 'the'\nreceived 'messages'\nreceived 'future'\nreceived 'for'\nreceived 'you'\n```\n\nMoÅ¼esz zobaczyÄ‡ wartoÅ›ci w innej kolejnoÅ›ci, w zaleÅ¼noÅ›ci od twojego systemu.\nTo wÅ‚aÅ›nie sprawia, Å¼e wspÃ³Å‚bieÅ¼noÅ›Ä‡ jest interesujÄ…ca, a takÅ¼e trudna. JeÅ›li\npoeksperymentujesz z `thread::sleep`, nadajÄ…c mu rÃ³Å¼ne wartoÅ›ci w rÃ³Å¼nych\nwÄ…tkach, kaÅ¼de uruchomienie bÄ™dzie bardziej niedeterministyczne i za kaÅ¼dym\nrazem bÄ™dzie generowaÄ‡ inne dane wyjÅ›ciowe.\n\nTeraz, gdy przyjrzeliÅ›my siÄ™, jak dziaÅ‚ajÄ… kanaÅ‚y, spÃ³jrzmy na innÄ… metodÄ™\nwspÃ³Å‚bieÅ¼noÅ›ci.\n\n[thread-spawn]: ch16-01-threads.html#creating-a-new-thread-with-spawn\n[join-handles]: ch16-01-threads.html#waiting-for-all-threads-to-finish\n[message-passing-threads]: ch16-02-message-passing.html\n[if-let]: ch06-03-if-let.html\n[capture-or-move]: ch13-01-closures.html#capturing-references-or-moving-ownership\n[move-threads]: ch16-01-threads.html#using-move-closures-with-threads",
        "chapter_title": "Stosowanie wspÃ³Å‚bieÅ¼noÅ›ci z `async`"
    },
    {
        "file_path": "ch17-03-more-futures.md",
        "content": "\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"yielding\"></a>\n\n### Przekazywanie kontroli do Å›rodowiska wykonawczego\n\nPrzypomnijmy z sekcji [â€Nasz pierwszy program asynchronicznyâ€][async-program]<!-- ignore -->, Å¼e w kaÅ¼dym punkcie `await` Rust daje Å›rodowisku wykonawczemu szansÄ™ na wstrzymanie zadania i przeÅ‚Ä…czenie siÄ™ na inne, jeÅ›li oczekiwany future nie jest gotowy. OdwrotnoÅ›Ä‡ jest rÃ³wnieÅ¼ prawdziwa: Rust _tylko_ wstrzymuje bloki asynchroniczne i przekazuje kontrolÄ™ Å›rodowisku wykonawczemu w punkcie `await`. Wszystko pomiÄ™dzy punktami `await` jest synchroniczne.\n\nOznacza to, Å¼e jeÅ›li wykonasz duÅ¼o pracy w bloku asynchronicznym bez punktu `await`, ten future zablokuje postÄ™p innych futures. Czasami usÅ‚yszysz, Å¼e jeden future _zagÅ‚adza_ inne futures. W niektÃ³rych przypadkach moÅ¼e to nie byÄ‡ duÅ¼y problem. Jednak jeÅ›li wykonujesz jakÄ…Å› kosztownÄ… konfiguracjÄ™ lub dÅ‚ugotrwaÅ‚Ä… pracÄ™, albo jeÅ›li masz future, ktÃ³re bÄ™dzie wykonywaÄ‡ pewne zadanie w nieskoÅ„czonoÅ›Ä‡, bÄ™dziesz musiaÅ‚ pomyÅ›leÄ‡ o tym, kiedy i gdzie przekazaÄ‡ kontrolÄ™ Å›rodowisku wykonawczemu.\n\nZasymulujmy dÅ‚ugotrwaÅ‚Ä… operacjÄ™, aby zilustrowaÄ‡ problem zagÅ‚adzania, a nastÄ™pnie zbadajmy, jak go rozwiÄ…zaÄ‡. Listing 17-14 wprowadza funkcjÄ™ `slow`.\n\n<Listing number=\"17-14\" caption=\"UÅ¼ycie `thread::sleep` do symulacji wolnych operacji\" file-name=\"src/main.rs\">\n\n```rust\n# extern crate trpl; // required for mdbook test\n# \n# use std::{thread, time::Duration};\n# \n# fn main() {\n#     trpl::block_on(async {\n#         // We will call `slow` here later\n#     });\n# }\n# \nfn slow(name: &str, ms: u64) {\n    thread::sleep(Duration::from_millis(ms));\n    println!(\"'{name}' ran for {ms}ms\");\n}\n```\n\n</Listing>\n\nTen kod uÅ¼ywa `std::thread::sleep` zamiast `trpl::sleep`, wiÄ™c wywoÅ‚anie `slow` zablokuje bieÅ¼Ä…cy wÄ…tek na okreÅ›lonÄ… liczbÄ™ milisekund. MoÅ¼emy uÅ¼yÄ‡ `slow` do reprezentowania rzeczywistych operacji, ktÃ³re sÄ… zarÃ³wno dÅ‚ugotrwaÅ‚e, jak i blokujÄ…ce.\n\nW Listing 17-15 uÅ¼ywamy `slow` do emulacji tego rodzaju pracy zwiÄ…zanej z CPU w parze futures.\n\n<Listing number=\"17-15\" caption=\"WywoÅ‚ywanie funkcji `slow` w celu symulacji wolnych operacji\" file-name=\"src/main.rs\">\n\n```rust\n# extern crate trpl; // required for mdbook test\n# \n# use std::{thread, time::Duration};\n# \n# fn main() {\n#     trpl::block_on(async {\n        let a = async {\n            println!(\"'a' started.\");\n            slow(\"a\", 30);\n            slow(\"a\", 10);\n            slow(\"a\", 20);\n            trpl::sleep(Duration::from_millis(50)).await;\n            println!(\"'a' finished.\");\n        };\n\n        let b = async {\n            println!(\"'b' started.\");\n            slow(\"b\", 75);\n            slow(\"b\", 10);\n            slow(\"b\", 15);\n            slow(\"b\", 350);\n            trpl::sleep(Duration::from_millis(50)).await;\n            println!(\"'b' finished.\");\n        };\n\n        trpl::select(a, b).await;\n#     });\n# }\n# \n# fn slow(name: &str, ms: u64) {\n#     thread::sleep(Duration::from_millis(ms));\n#     println!(\"'{name}' ran for {ms}ms\");\n# }\n```\n\n</Listing>\n\nKaÅ¼dy future przekazuje kontrolÄ™ Å›rodowisku wykonawczemu dopiero _po_ wykonaniu szeregu wolnych operacji. JeÅ›li uruchomisz ten kod, zobaczysz nastÄ™pujÄ…cy wynik:\n\n<!-- manual-regeneration\ncd listings/ch17-async-await/listing-17-15/\ncargo run\ncopy just the output\n-->\n\n```text\n'a' started.\n'a' ran for 30ms\n'a' ran for 10ms\n'a' ran for 20ms\n'b' started.\n'b' ran for 75ms\n'b' ran for 10ms\n'b' ran for 15ms\n'b' ran for 350ms\n'a' finished.\n```\n\nPodobnie jak w Listing 17-5, gdzie uÅ¼yliÅ›my `trpl::select` do wspÃ³Å‚zawodnictwa futures pobierajÄ…cych dwa adresy URL, `select` nadal koÅ„czy dziaÅ‚anie, gdy tylko `a` zostanie zakoÅ„czone. Nie ma jednak przeplatania miÄ™dzy wywoÅ‚aniami `slow` w dwÃ³ch futures. Future `a` wykonuje caÅ‚Ä… swojÄ… pracÄ™, dopÃ³ki nie zostanie oczekiwane wywoÅ‚anie `trpl::sleep`, nastÄ™pnie future `b` wykonuje caÅ‚Ä… swojÄ… pracÄ™, dopÃ³ki nie zostanie oczekiwane jego wÅ‚asne wywoÅ‚anie `trpl::sleep`, a na koniec future `a` zostaje zakoÅ„czone. Aby umoÅ¼liwiÄ‡ obu futures postÄ™p miÄ™dzy ich wolnymi zadaniami, potrzebujemy punktÃ³w `await`, abyÅ›my mogli przekazaÄ‡ kontrolÄ™ Å›rodowisku wykonawczemu. Oznacza to, Å¼e potrzebujemy czegoÅ›, na co moÅ¼emy czekaÄ‡!\n\nJuÅ¼ widzimy, jak tego rodzaju przekazywanie dzieje siÄ™ w Listing 17-15: gdybyÅ›my usunÄ™li `trpl::sleep` na koÅ„cu future `a`, zostaÅ‚oby ono zakoÅ„czone bez _jakiegokolwiek_ uruchomienia future `b`. SprÃ³bujmy uÅ¼yÄ‡ funkcji `trpl::sleep` jako punktu wyjÅ›cia do umoÅ¼liwienia operacjom przeÅ‚Ä…czania siÄ™ w celu osiÄ…gania postÄ™pu, jak pokazano w Listing 17-16.\n\n<Listing number=\"17-16\" caption=\"UÅ¼ycie `trpl::sleep` do umoÅ¼liwienia operacjom przeÅ‚Ä…czania siÄ™ w celu osiÄ…gania postÄ™pu\" file-name=\"src/main.rs\">\n\n```rust\n# extern crate trpl; // required for mdbook test\n# \n# use std::{thread, time::Duration};\n# \n# fn main() {\n#     trpl::block_on(async {\n        let one_ms = Duration::from_millis(1);\n\n        let a = async {\n            println!(\"'a' started.\");\n            slow(\"a\", 30);\n            trpl::sleep(one_ms).await;\n            slow(\"a\", 10);\n            trpl::sleep(one_ms).await;\n            slow(\"a\", 20);\n            trpl::sleep(one_ms).await;\n            println!(\"'a' finished.\");\n        };\n\n        let b = async {\n            println!(\"'b' started.\");\n            slow(\"b\", 75);\n            trpl::sleep(one_ms).await;\n            slow(\"b\", 10);\n            trpl::sleep(one_ms).await;\n            slow(\"b\", 15);\n            trpl::sleep(one_ms).await;\n            slow(\"b\", 350);\n            trpl::sleep(one_ms).await;\n            println!(\"'b' finished.\");\n        };\n# \n#         trpl::select(a, b).await;\n#     });\n# }\n# \n# fn slow(name: &str, ms: u64) {\n#     thread::sleep(Duration::from_millis(ms));\n#     println!(\"'{name}' ran for {ms}ms\");\n# }\n```\n\n</Listing>\n\nDodaliÅ›my wywoÅ‚ania `trpl::sleep` z punktami `await` miÄ™dzy kaÅ¼dym wywoÅ‚aniem `slow`. Teraz praca obu futures jest przeplatana:\n\n<!-- manual-regeneration\ncd listings/ch17-async-await/listing-17-16\ncargo run\ncopy just the output\n-->\n\n```text\n'a' started.\n'a' ran for 30ms\n'b' started.\n'b' ran for 75ms\n'a' ran for 10ms\n'b' ran for 10ms\n'a' ran for 20ms\n'b' ran for 15ms\n'a' finished.\n```\n\nFuture `a` nadal dziaÅ‚a przez chwilÄ™, zanim przekaÅ¼e kontrolÄ™ do `b`, poniewaÅ¼ wywoÅ‚uje `slow` przed wywoÅ‚aniem `trpl::sleep`, ale potem futures zamieniajÄ… siÄ™ miejscami za kaÅ¼dym razem, gdy jedna z nich osiÄ…ga punkt `await`. W tym przypadku zrobiliÅ›my to po kaÅ¼dym wywoÅ‚aniu `slow`, ale mogliÅ›my podzieliÄ‡ pracÄ™ w sposÃ³b, ktÃ³ry miaÅ‚by dla nas najwiÄ™kszy sens.\n\nNie chcemy jednak tutaj faktycznie _spaÄ‡_: chcemy postÄ™powaÄ‡ tak szybko, jak to moÅ¼liwe. Po prostu musimy przekazaÄ‡ kontrolÄ™ Å›rodowisku wykonawczemu. MoÅ¼emy to zrobiÄ‡ bezpoÅ›rednio, uÅ¼ywajÄ…c funkcji `trpl::yield_now`. W Listing 17-17 zastÄ™pujemy wszystkie te wywoÅ‚ania `trpl::sleep` wywoÅ‚aniami `trpl::yield_now`.\n\n<Listing number=\"17-17\" caption=\"UÅ¼ycie `yield_now` do umoÅ¼liwienia operacjom przeÅ‚Ä…czania siÄ™ w celu osiÄ…gania postÄ™pu\" file-name=\"src/main.rs\">\n\n```rust\n# extern crate trpl; // required for mdbook test\n# \n# use std::{thread, time::Duration};\n# \n# fn main() {\n#     trpl::block_on(async {\n        let a = async {\n            println!(\"'a' started.\");\n            slow(\"a\", 30);\n            trpl::yield_now().await;\n            slow(\"a\", 10);\n            trpl::yield_now().await;\n            slow(\"a\", 20);\n            trpl::yield_now().await;\n            println!(\"'a' finished.\");\n        };\n\n        let b = async {\n            println!(\"'b' started.\");\n            slow(\"b\", 75);\n            trpl::yield_now().await;\n            slow(\"b\", 10);\n            trpl::yield_now().await;\n            slow(\"b\", 15);\n            trpl::yield_now().await;\n            slow(\"b\", 350);\n            trpl::yield_now().await;\n            println!(\"'b' finished.\");\n        };\n# \n#         trpl::select(a, b).await;\n#     });\n# }\n# \n# fn slow(name: &str, ms: u64) {\n#     thread::sleep(Duration::from_millis(ms));\n#     println!(\"'{name}' ran for {ms}ms\");\n# }\n```\n\n</Listing>\n\nTen kod jest zarÃ³wno jaÅ›niejszy pod wzglÄ™dem rzeczywistego zamiaru, jak i moÅ¼e byÄ‡ znacznie szybszy niÅ¼ uÅ¼ycie `sleep`, poniewaÅ¼ timery takie jak ten uÅ¼ywany przez `sleep` czÄ™sto majÄ… ograniczenia co do tego, jak granularne mogÄ… byÄ‡. Na przykÅ‚ad, wersja `sleep`, ktÃ³rej uÅ¼ywamy, zawsze bÄ™dzie spaÄ‡ przez co najmniej milisekundÄ™, nawet jeÅ›li przekaÅ¼emy jej `Duration` o dÅ‚ugoÅ›ci jednej nanosekundy. Ponownie, nowoczesne komputery sÄ… _szybkie_: mogÄ… zrobiÄ‡ wiele w ciÄ…gu jednej milisekundy!\n\nOznacza to, Å¼e async moÅ¼e byÄ‡ uÅ¼yteczne nawet dla zadaÅ„ zwiÄ…zanych z obliczeniami, w zaleÅ¼noÅ›ci od tego, co jeszcze robi twÃ³j program, poniewaÅ¼ dostarcza przydatne narzÄ™dzie do strukturyzowania relacji miÄ™dzy rÃ³Å¼nymi czÄ™Å›ciami programu (ale kosztem narzutu maszyny stanÃ³w async). Jest to forma _wielozadaniowoÅ›ci kooperacyjnej_, gdzie kaÅ¼dy future ma moc decydowania, kiedy przekaÅ¼e kontrolÄ™ za poÅ›rednictwem punktÃ³w `await`. KaÅ¼dy future ponosi zatem rÃ³wnieÅ¼ odpowiedzialnoÅ›Ä‡ za unikanie zbyt dÅ‚ugiego blokowania. W niektÃ³rych wbudowanych systemach operacyjnych opartych na Rust jest to _jedyny_ rodzaj wielozadaniowoÅ›ci!\n\nW rzeczywistym kodzie oczywiÅ›cie nie bÄ™dziesz na kaÅ¼dej linii przeplataÄ‡ wywoÅ‚aÅ„ funkcji z punktami `await`. ChociaÅ¼ przekazywanie kontroli w ten sposÃ³b jest stosunkowo niedrogie, nie jest darmowe. W wielu przypadkach prÃ³ba podziaÅ‚u zadania intensywnie obciÄ…Å¼ajÄ…cego CPU moÅ¼e znacznie je spowolniÄ‡, wiÄ™c czasami dla _ogÃ³lnej_ wydajnoÅ›ci lepiej jest pozwoliÄ‡ operacji na krÃ³tkie zablokowanie. Zawsze mierz, aby zobaczyÄ‡, gdzie sÄ… rzeczywiste wÄ…skie gardÅ‚a wydajnoÅ›ci twojego kodu. WaÅ¼ne jest jednak, aby pamiÄ™taÄ‡ o podstawowej dynamice, jeÅ›li _widzisz_ duÅ¼o pracy wykonywanej szeregowo, a spodziewaÅ‚eÅ› siÄ™, Å¼e bÄ™dzie ona wykonywana rÃ³wnolegle!\n\n### Budowanie wÅ‚asnych abstrakcji asynchronicznych\n\nMoÅ¼emy rÃ³wnieÅ¼ Å‚Ä…czyÄ‡ futures, aby tworzyÄ‡ nowe wzorce. Na przykÅ‚ad moÅ¼emy zbudowaÄ‡ funkcjÄ™ `timeout` z juÅ¼ posiadanych asynchronicznych blokÃ³w konstrukcyjnych. Kiedy skoÅ„czymy, wynik bÄ™dzie kolejnym blokiem konstrukcyjnym, ktÃ³rego moglibyÅ›my uÅ¼yÄ‡ do tworzenia jeszcze bardziej asynchronicznych abstrakcji.\n\nListing 17-18 pokazuje, jak ten `timeout` powinien dziaÅ‚aÄ‡ z wolnym future.\n\n<Listing number=\"17-18\" caption=\"UÅ¼ycie naszego wyobraÅ¼onego `timeout` do uruchomienia wolnej operacji z limitem czasu\" file-name=\"src/main.rs\">\n\n```rust,ignore,does_not_compile\n# extern crate trpl; // required for mdbook test\n# \n# use std::time::Duration;\n# \n# fn main() {\n#     trpl::block_on(async {\n        let slow = async {\n            trpl::sleep(Duration::from_secs(5)).await;\n            \"Finally finished\"\n        };\n\n        match timeout(slow, Duration::from_secs(2)).await {\n            Ok(message) => println!(\"Succeeded with '{message}'\"),\n            Err(duration) => {\n                println!(\"Failed after {} seconds\", duration.as_secs())\n            }\n        }\n#     });\n# }\n```\n\n</Listing>\n\nZaimplementujmy to! Na poczÄ…tek pomyÅ›lmy o API dla `timeout`:\n\n- Musi to byÄ‡ funkcja asynchroniczna sama w sobie, abyÅ›my mogli na niÄ… czekaÄ‡ (`await`).\n- Jej pierwszy parametr powinien byÄ‡ futurem do uruchomienia. MoÅ¼emy uczyniÄ‡ go generycznym, aby mÃ³gÅ‚ dziaÅ‚aÄ‡ z dowolnym futurem.\n- Jej drugi parametr bÄ™dzie maksymalnym czasem oczekiwania. JeÅ›li uÅ¼yjemy `Duration`, uÅ‚atwi to przekazanie do `trpl::sleep`.\n- Powinna zwracaÄ‡ `Result`. JeÅ›li future zakoÅ„czy siÄ™ pomyÅ›lnie, `Result` bÄ™dzie `Ok` z wartoÅ›ciÄ… wyprodukowanÄ… przez future. JeÅ›li limit czasu upÅ‚ynie wczeÅ›niej, `Result` bÄ™dzie `Err` z czasem trwania, na ktÃ³ry timeout czekaÅ‚.\n\nListing 17-19 pokazuje tÄ™ deklaracjÄ™.\n\n<!-- This is not tested because it intentionally does not compile. -->\n\n<Listing number=\"17-19\" caption=\"Definiowanie sygnatury `timeout`\" file-name=\"src/main.rs\">\n\n```rust,ignore,does_not_compile\n# extern crate trpl; // required for mdbook test\n# \n# use std::time::Duration;\n# \n# fn main() {\n#     trpl::block_on(async {\n#         let slow = async {\n#             trpl::sleep(Duration::from_secs(5)).await;\n#             \"Finally finished\"\n#         };\n# \n#         match timeout(slow, Duration::from_secs(2)).await {\n#             Ok(message) => println!(\"Succeeded with '{message}'\"),\n#             Err(duration) => {\n#                 println!(\"Failed after {} seconds\", duration.as_secs())\n#             }\n#         }\n#     });\n# }\n# \nasync fn timeout<F: Future>(\n    future_to_try: F,\n    max_time: Duration,\n) -> Result<F::Output, Duration> {\n    // Here is where our implementation will go!\n}\n```\n\n</Listing>\n\nTo speÅ‚nia nasze cele dotyczÄ…ce typÃ³w. Teraz pomyÅ›lmy o _zachowaniu_, ktÃ³rego potrzebujemy: chcemy, aby future przekazane w tle konkurowaÅ‚o z czasem trwania. MoÅ¼emy uÅ¼yÄ‡ `trpl::sleep`, aby utworzyÄ‡ future timera z czasu trwania, i uÅ¼yÄ‡ `trpl::select`, aby uruchomiÄ‡ ten timer z futurem przekazanym przez wywoÅ‚ujÄ…cego.\n\nW Listing 17-20 implementujemy `timeout` poprzez dopasowanie do wyniku oczekiwania (`await`) na `trpl::select`.\n\n<Listing number=\"17-20\" caption=\"Definiowanie `timeout` za pomocÄ… `select` i `sleep`\" file-name=\"src/main.rs\">\n\n```rust\n# extern crate trpl; // required for mdbook test\n# \n# use std::time::Duration;\n# \nuse trpl::Either;\n\n// --snip--\n\n# fn main() {\n#     trpl::block_on(async {\n#         let slow = async {\n#             trpl::sleep(Duration::from_secs(5)).await;\n#             \"Finally finished\"\n#         };\n# \n#         match timeout(slow, Duration::from_secs(2)).await {\n#             Ok(message) => println!(\"Succeeded with '{message}'\"),\n#             Err(duration) => {\n#                 println!(\"Failed after {} seconds\", duration.as_secs())\n#             }\n#         }\n#     });\n# }\n# \nasync fn timeout<F: Future>(\n    future_to_try: F,\n    max_time: Duration,\n) -> Result<F::Output, Duration> {\n    match trpl::select(future_to_try, trpl::sleep(max_time)).await {\n        Either::Left(output) => Ok(output),\n        Either::Right(_) => Err(max_time),\n    }\n}\n```\n\n</Listing>\n\nImplementacja `trpl::select` nie jest sprawiedliwa: zawsze odpytuje argumenty w kolejnoÅ›ci, w jakiej zostaÅ‚y przekazane (inne implementacje `select` losowo wybierajÄ…, ktÃ³ry argument odpytaÄ‡ jako pierwszy). W ten sposÃ³b przekazujemy `future_to_try` do `select` jako pierwszy, aby miaÅ‚ szansÄ™ na ukoÅ„czenie, nawet jeÅ›li `max_time` jest bardzo krÃ³tkim czasem trwania. JeÅ›li `future_to_try` zakoÅ„czy siÄ™ jako pierwszy, `select` zwrÃ³ci `Left` z wynikiem z `future_to_try`. JeÅ›li `timer` zakoÅ„czy siÄ™ jako pierwszy, `select` zwrÃ³ci `Right` z wynikiem timera `()`.\n\nJeÅ›li `future_to_try` zakoÅ„czy siÄ™ sukcesem i otrzymamy `Left(output)`, zwracamy `Ok(output)`. JeÅ›li zamiast tego upÅ‚ynie czas timera uÅ›pienia i otrzymamy `Right(())`, ignorujemy `()` za pomocÄ… `_` i zamiast tego zwracamy `Err(max_time)`.\n\nDziÄ™ki temu mamy dziaÅ‚ajÄ…cÄ… funkcjÄ™ `timeout` zbudowanÄ… z dwÃ³ch innych asynchronicznych pomocnikÃ³w. JeÅ›li uruchomimy nasz kod, wydrukuje on tryb awarii po upÅ‚ywie limitu czasu:\n\n```text\nFailed after 2 seconds\n```\n\nPoniewaÅ¼ futures komponujÄ… siÄ™ z innymi futures, moÅ¼esz budowaÄ‡ naprawdÄ™ potÄ™Å¼ne narzÄ™dzia, uÅ¼ywajÄ…c mniejszych asynchronicznych blokÃ³w konstrukcyjnych. Na przykÅ‚ad, moÅ¼esz uÅ¼yÄ‡ tego samego podejÅ›cia do Å‚Ä…czenia limitÃ³w czasu z ponownymi prÃ³bami, a z kolei uÅ¼ywaÄ‡ ich z operacjami takimi jak wywoÅ‚ania sieciowe (takie jak te w Listing 17-5).\n\nW praktyce zazwyczaj bÄ™dziesz pracowaÄ‡ bezpoÅ›rednio z `async` i `await`, a w drugiej kolejnoÅ›ci z funkcjami takimi jak `select` i makrami takimi jak makro `join!` do kontrolowania sposobu wykonywania zewnÄ™trznych futures.\n\nWidzieliÅ›my juÅ¼ wiele sposobÃ³w pracy z wieloma futures jednoczeÅ›nie. NastÄ™pnie przyjrzymy siÄ™, jak moÅ¼emy pracowaÄ‡ z wieloma futures w sekwencji w czasie za pomocÄ… _strumieni_.\n\n[async-program]: ch17-01-futures-and-syntax.html#our-first-async-program\n",
        "chapter_title": "Praca z dowolnÄ… liczbÄ… futures"
    },
    {
        "file_path": "ch17-04-streams.md",
        "content": "<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"streams\"></a>\n\n## Strumienie: Futures w sekwencji\n\nPrzypomnijmy, jak uÅ¼ywaliÅ›my odbiornika dla naszego asynchronicznego kanaÅ‚u wczeÅ›niej w tym rozdziale w sekcji [â€Przekazywanie wiadomoÅ›ciâ€][17-02-messages]<!-- ignore -->. Asynchroniczna metoda `recv` wytwarza sekwencjÄ™ elementÃ³w w czasie. Jest to instancja znacznie bardziej ogÃ³lnego wzorca znanego jako _strumieÅ„_. Wiele koncepcji jest naturalnie reprezentowanych jako strumienie: elementy stajÄ… siÄ™ dostÄ™pne w kolejce, fragmenty danych sÄ… pobierane przyrostowo z systemu plikÃ³w, gdy peÅ‚ny zestaw danych jest zbyt duÅ¼y dla pamiÄ™ci komputera, lub dane przychodzÄ… przez sieÄ‡ w czasie. PoniewaÅ¼ strumienie sÄ… futures, moÅ¼emy ich uÅ¼ywaÄ‡ z dowolnym innym rodzajem future i Å‚Ä…czyÄ‡ je w interesujÄ…ce sposoby. Na przykÅ‚ad, moÅ¼emy grupowaÄ‡ zdarzenia, aby uniknÄ…Ä‡ wywoÅ‚ywania zbyt wielu wywoÅ‚aÅ„ sieciowych, ustawiaÄ‡ limity czasu na sekwencje dÅ‚ugotrwaÅ‚ych operacji lub ograniczaÄ‡ zdarzenia interfejsu uÅ¼ytkownika, aby uniknÄ…Ä‡ wykonywania zbÄ™dnej pracy.\n\nWidzieliÅ›my sekwencjÄ™ elementÃ³w w Rozdziale 13, kiedy przyglÄ…daliÅ›my siÄ™ cechom Iterator w sekcji [â€Cechy Iterator i metoda `next`â€][iterator-trait]<!-- ignore -->, ale istniejÄ… dwie rÃ³Å¼nice miÄ™dzy iteratorami a asynchronicznym odbiornikiem kanaÅ‚u. Pierwsza rÃ³Å¼nica to czas: iteratory sÄ… synchroniczne, podczas gdy odbiornik kanaÅ‚u jest asynchroniczny. Druga rÃ³Å¼nica to API. PracujÄ…c bezpoÅ›rednio z `Iterator`, wywoÅ‚ujemy jego synchronicznÄ… metodÄ™ `next`. W przypadku strumienia `trpl::Receiver` w szczegÃ³lnoÅ›ci, zamiast tego wywoÅ‚aliÅ›my asynchronicznÄ… metodÄ™ `recv`. Poza tym te API sÄ… bardzo podobne, a to podobieÅ„stwo nie jest przypadkowe. StrumieÅ„ jest jak asynchroniczna forma iteracji. Podczas gdy `trpl::Receiver` w szczegÃ³lnoÅ›ci czeka na odebranie wiadomoÅ›ci, ogÃ³lne API strumienia jest znacznie szersze: dostarcza nastÄ™pny element w taki sam sposÃ³b jak `Iterator`, ale asynchronicznie.\n\nPodobieÅ„stwo miÄ™dzy iteratorami a strumieniami w Rust oznacza, Å¼e faktycznie moÅ¼emy stworzyÄ‡ strumieÅ„ z dowolnego iteratora. Podobnie jak w przypadku iteratora, moÅ¼emy pracowaÄ‡ ze strumieniem, wywoÅ‚ujÄ…c jego metodÄ™ `next`, a nastÄ™pnie oczekujÄ…c na wynik, jak w Listing 17-21, ktÃ³ry jeszcze siÄ™ nie skompiluje.\n\n<Listing number=\"17-21\" caption=\"Tworzenie strumienia z iteratora i drukowanie jego wartoÅ›ci\" file-name=\"src/main.rs\">\n\n```rust,ignore,does_not_compile\n# extern crate trpl; // required for mdbook test\n# \n# fn main() {\n#     trpl::block_on(async {\n        let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let iter = values.iter().map(|n| n * 2);\n        let mut stream = trpl::stream_from_iter(iter);\n\n        while let Some(value) = stream.next().await {\n            println!(\"The value was: {value}\");\n        }\n#     });\n# }\n```\n\n</Listing>\n\nZaczynamy od tablicy liczb, ktÃ³rÄ… przeksztaÅ‚camy w iterator, a nastÄ™pnie wywoÅ‚ujemy `map`, aby podwoiÄ‡ wszystkie wartoÅ›ci. NastÄ™pnie przeksztaÅ‚camy iterator w strumieÅ„ za pomocÄ… funkcji `trpl::stream_from_iter`. Dalej pÄ™tlujemy po elementach w strumieniu, gdy te docierajÄ…, za pomocÄ… pÄ™tli `while let`.\n\nNiestety, kiedy prÃ³bujemy uruchomiÄ‡ ten kod, nie kompiluje siÄ™ on, lecz zgÅ‚asza brak metody `next`:\n\n<!-- manual-regeneration\ncd listings/ch17-async-await/listing-17-21\ncargo build\ncopy only the error output\n-->\n\n```text\nerror[E0599]: no method named `next` found for struct `tokio_stream::iter::Iter` in the current scope\n  --> src/main.rs:10:40\n   |\n10 |         while let Some(value) = stream.next().await {\n   |                                        ^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `next` are implemented but not in scope; perhaps you want to import one of them\n   |\n1  + use crate::trpl::StreamExt;\n   |\n1  + use futures_util::stream::stream::StreamExt;\n   |\n1  + use std::iter::Iterator;\n   |\n1  + use std::str::pattern::Searcher;\n   |\nhelp: there is a method `try_next` with a similar name\n   |\n10 |         while let Some(value) = stream.try_next().await {\n   |                                        ~~~~~~~~\n```\n\nJak wyjaÅ›nia ten wynik, przyczynÄ… bÅ‚Ä™du kompilacji jest to, Å¼e do uÅ¼ycia metody `next` potrzebujemy odpowiedniej cechy w zasiÄ™gu. BiorÄ…c pod uwagÄ™ naszÄ… dotychczasowÄ… dyskusjÄ™, moÅ¼na by rozsÄ…dnie oczekiwaÄ‡, Å¼e bÄ™dzie to cecha `Stream`, ale w rzeczywistoÅ›ci jest to `StreamExt`. SkrÃ³t od _extension_ (`rozszerzenie`), `Ext` to powszechny wzorzec w spoÅ‚ecznoÅ›ci Rust sÅ‚uÅ¼Ä…cy do rozszerzania jednej cechy innÄ….\n\nCecha `Stream` definiuje niskopoziomowy interfejs, ktÃ³ry skutecznie Å‚Ä…czy cechy `Iterator` i `Future`. `StreamExt` dostarcza wyÅ¼szopoziomowy zestaw API ponad `Stream`, w tym metodÄ™ `next`, a takÅ¼e inne metody narzÄ™dziowe podobne do tych dostarczanych przez cechÄ™ `Iterator`. `Stream` i `StreamExt` nie sÄ… jeszcze czÄ™Å›ciÄ… standardowej biblioteki Rust, ale wiÄ™kszoÅ›Ä‡ skÅ‚adowych ekosystemu uÅ¼ywa podobnych definicji.\n\nNaprawÄ… bÅ‚Ä™du kompilatora jest dodanie instrukcji `use` dla `trpl::StreamExt`, jak w Listing 17-22.\n\n<Listing number=\"17-22\" caption=\"PomyÅ›lne uÅ¼ycie iteratora jako podstawy dla strumienia\" file-name=\"src/main.rs\">\n\n```rust\n# extern crate trpl; // required for mdbook test\n# \nuse trpl::StreamExt;\n\nfn main() {\n    trpl::block_on(async {\n        let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        // --snip--\n#         let iter = values.iter().map(|n| n * 2);\n#         let mut stream = trpl::stream_from_iter(iter);\n# \n#         while let Some(value) = stream.next().await {\n#             println!(\"The value was: {value}\");\n#         }\n#     });\n# }\n```\n\n</Listing>\n\nPo poÅ‚Ä…czeniu wszystkich tych elementÃ³w ten kod dziaÅ‚a tak, jak chcemy! Co wiÄ™cej, teraz, gdy mamy `StreamExt` w zasiÄ™gu, moÅ¼emy uÅ¼ywaÄ‡ wszystkich jego metod narzÄ™dziowych, tak samo jak w przypadku iteratorÃ³w.\n\n[17-02-messages]: ch17-02-concurrency-with-async.html#message-passing\n[iterator-trait]: ch13-02-iterators.html#the-iterator-trait-and-the-next-method\n",
        "chapter_title": "Strumienie: Futures w sekwencji"
    },
    {
        "file_path": "ch17-05-traits-for-async.md",
        "content": "<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"digging-into-the-traits-for-async\"></a>\n\n## BliÅ¼sze spojrzenie na cechy dla Async\n\nW caÅ‚ym rozdziale uÅ¼ywaliÅ›my cech `Future`, `Stream` i `StreamExt` na rÃ³Å¼ne sposoby. Jak dotÄ…d unikaliÅ›my jednak zagÅ‚Ä™biania siÄ™ w szczegÃ³Å‚y ich dziaÅ‚ania lub ich wzajemnego dopasowania, co w wiÄ™kszoÅ›ci przypadkÃ³w jest w porzÄ…dku w codziennej pracy z Rust. Czasami jednak napotkasz sytuacje, w ktÃ³rych bÄ™dziesz musiaÅ‚ zrozumieÄ‡ kilka wiÄ™cej szczegÃ³Å‚Ã³w tych cech, a takÅ¼e typ `Pin` i cechÄ™ `Unpin`. W tej sekcji zagÅ‚Ä™bimy siÄ™ w nie na tyle, aby pomÃ³c w takich scenariuszach, pozostawiajÄ…c _naprawdÄ™_ dogÅ‚Ä™bne badanie innym dokumentacjom.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"future\"></a>\n\n### Cechy `Future`\n\nZacznijmy od bliÅ¼szego przyjrzenia siÄ™, jak dziaÅ‚a cecha `Future`. Oto jak Rust jÄ… definiuje:\n\n```rust\nuse std::pin::Pin;\nuse std::task::{Context, Poll};\n\npub trait Future {\n    type Output;\n\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n}\n```\n\nTa definicja cechy zawiera wiele nowych typÃ³w, a takÅ¼e pewnÄ… skÅ‚adniÄ™, ktÃ³rej wczeÅ›niej nie widzieliÅ›my, wiÄ™c przejdÅºmy przez definicjÄ™ kawaÅ‚ek po kawaÅ‚ku.\n\nPo pierwsze, typ skojarzony `Output` z cechy `Future` mÃ³wi, do czego future siÄ™ rozwiÄ…zuje. Jest to analogiczne do typu skojarzonego `Item` z cechy `Iterator`. Po drugie, cecha `Future` ma metodÄ™ `poll`, ktÃ³ra przyjmuje specjalnÄ… referencjÄ™ `Pin` dla swojego parametru `self` oraz mutowalnÄ… referencjÄ™ do typu `Context` i zwraca `Poll<Self::Output>`. WiÄ™cej o `Pin` i `Context` powiemy za chwilÄ™. Na razie skupmy siÄ™ na tym, co zwraca metoda, czyli na typie `Poll`:\n\n```rust\npub enum Poll<T> {\n    Ready(T),\n    Pending,\n}\n```\n\nTen typ `Poll` jest podobny do `Option`. Ma jeden wariant, ktÃ³ry ma wartoÅ›Ä‡, `Ready(T)`, i jeden, ktÃ³ry nie ma, `Pending`. `Poll` oznacza jednak coÅ› zupeÅ‚nie innego niÅ¼ `Option`! Wariant `Pending` wskazuje, Å¼e future nadal ma pracÄ™ do wykonania, wiÄ™c wywoÅ‚ujÄ…cy bÄ™dzie musiaÅ‚ sprawdziÄ‡ ponownie pÃ³Åºniej. Wariant `Ready` wskazuje, Å¼e `Future` zakoÅ„czyÅ‚o swojÄ… pracÄ™ i wartoÅ›Ä‡ `T` jest dostÄ™pna.\n\n> Uwaga: Rzadko zdarza siÄ™ potrzeba bezpoÅ›redniego wywoÅ‚ania `poll`, ale jeÅ›li zajdzie taka potrzeba, pamiÄ™taj, Å¼e w przypadku wiÄ™kszoÅ›ci futures, wywoÅ‚ujÄ…cy nie powinien ponownie wywoÅ‚ywaÄ‡ `poll` po tym, jak future zwrÃ³ciÅ‚o `Ready`. Wiele futures panikuje, jeÅ›li zostanie ponownie odpytanych po staniu siÄ™ gotowymi. Futures, ktÃ³re sÄ… bezpieczne do ponownego odpytania, bÄ™dÄ… o tym wyraÅºnie informowaÄ‡ w swojej dokumentacji. Jest to podobne do zachowania `Iterator::next`.\n\nKiedy widzisz kod, ktÃ³ry uÅ¼ywa `await`, Rust kompiluje go pod spodem do kodu, ktÃ³ry wywoÅ‚uje `poll`. JeÅ›li spojrzysz ponownie na Listing 17-4, gdzie wydrukowaliÅ›my tytuÅ‚ strony dla pojedynczego adresu URL po jego rozwiÄ…zaniu, Rust kompiluje go do czegoÅ› w rodzaju (choÄ‡ nie dokÅ‚adnie) tego:\n\n```rust,ignore\nmatch page_title(url).poll() {\n    Ready(page_title) => match page_title {\n        Some(title) => println!(\"The title for {url} was {title}\"),\n        None => println!(\"{url} had no title\"),\n    }\n    Pending => {\n        // But what goes here?\n    }\n}\n```\n\nCo powinniÅ›my zrobiÄ‡, gdy future jest nadal w stanie `Pending`? Potrzebujemy jakiegoÅ› sposobu, aby sprÃ³bowaÄ‡ ponownie, i ponownie, i ponownie, aÅ¼ future bÄ™dzie w koÅ„cu gotowe. Innymi sÅ‚owy, potrzebujemy pÄ™tli:\n\n```rust,ignore\nlet mut page_title_fut = page_title(url);\nloop {\n    match page_title_fut.poll() {\n        Ready(value) => match page_title {\n            Some(title) => println!(\"The title for {url} was {title}\"),\n            None => println!(\"{url} had no title\"),\n        }\n        Pending => {\n            // continue\n        }\n    }\n}\n```\n\nJednak gdyby Rust skompilowaÅ‚ to dokÅ‚adnie na taki kod, kaÅ¼de `await` byÅ‚oby blokujÄ…ce â€“ dokÅ‚adnie przeciwnie do tego, co zamierzaliÅ›my! Zamiast tego Rust zapewnia, Å¼e pÄ™tla moÅ¼e przekazaÄ‡ kontrolÄ™ czemuÅ›, co moÅ¼e wstrzymaÄ‡ pracÄ™ nad tym future, aby pracowaÄ‡ nad innymi futures, a nastÄ™pnie sprawdziÄ‡ ten ponownie pÃ³Åºniej. Jak widzieliÅ›my, tym czymÅ› jest Å›rodowisko uruchomieniowe async, a ta praca zwiÄ…zana z planowaniem i koordynacjÄ… jest jednym z jego gÅ‚Ã³wnych zadaÅ„.\n\nW sekcji [â€WysyÅ‚anie danych miÄ™dzy dwoma zadaniami za pomocÄ… przekazywania wiadomoÅ›ciâ€][message-passing]<!-- ignore --> opisaliÅ›my oczekiwanie na `rx.recv`. WywoÅ‚anie `recv` zwraca future, a oczekiwanie na future odpytuje je. ZauwaÅ¼yliÅ›my, Å¼e Å›rodowisko uruchomieniowe wstrzyma future, dopÃ³ki nie bÄ™dzie ono gotowe z `Some(message)` lub `None`, gdy kanaÅ‚ zostanie zamkniÄ™ty. DziÄ™ki naszemu gÅ‚Ä™bszemu zrozumieniu cechy `Future`, a konkretnie `Future::poll`, moÅ¼emy zobaczyÄ‡, jak to dziaÅ‚a. Åšrodowisko uruchomieniowe wie, Å¼e future nie jest gotowe, gdy zwraca `Poll::Pending`. Odwrotnie, Å›rodowisko uruchomieniowe wie, Å¼e future _jest_ gotowe i kontynuuje je, gdy `poll` zwraca `Poll::Ready(Some(message))` lub `Poll::Ready(None)`.\n\nDokÅ‚adne szczegÃ³Å‚y tego, jak Å›rodowisko wykonawcze to robi, wykraczajÄ… poza zakres tej ksiÄ…Å¼ki, ale kluczem jest zrozumienie podstawowych mechanizmÃ³w futures: Å›rodowisko wykonawcze _odpytuje_ kaÅ¼dy future, za ktÃ³ry jest odpowiedzialne, usypiajÄ…c future ponownie, gdy nie jest jeszcze gotowe.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"pinning-and-the-pin-and-unpin-traits\"></a>\n<a id=\"the-pin-and-unpin-traits\"></a>\n\n### Typ `Pin` i cecha `Unpin`\n\nW Listing 17-13 uÅ¼yliÅ›my makra `trpl::join!` do oczekiwania na trzy futures. Jednak czÄ™sto zdarza siÄ™ mieÄ‡ kolekcjÄ™, takÄ… jak wektor, zawierajÄ…cÄ… pewnÄ… liczbÄ™ futures, ktÃ³rej nie bÄ™dzie znana do czasu wykonania. ZmieÅ„my Listing 17-13 na kod z Listing 17-23, ktÃ³ry umieszcza trzy futures w wektorze i wywoÅ‚uje funkcjÄ™ `trpl::join_all` zamiast tego, co jeszcze siÄ™ nie skompiluje.\n\n<Listing number=\"17-23\" caption=\"Oczekiwanie na futures w kolekcji\"  file-name=\"src/main.rs\">\n\n```rust,ignore,does_not_compile\n# extern crate trpl; // required for mdbook test\n# \n# use std::time::Duration;\n# \n# fn main() {\n#     trpl::block_on(async {\n#         let (tx, mut rx) = trpl::channel();\n# \n#         let tx1 = tx.clone();\n#         let tx1_fut = async move {\n#             let vals = vec![\n#                 String::from(\"hi\"),\n#                 String::from(\"from\"),\n#                 String::from(\"the\"),\n#                 String::from(\"future\"),\n#             ];\n# \n#             for val in vals {\n#                 tx1.send(val).unwrap();\n#                 trpl::sleep(Duration::from_secs(1)).await;\n#             }\n#         };\n# \n#         let rx_fut = async {\n#             while let Some(value) = rx.recv().await {\n#                 println!(\"received '{value}'\");\n#             }\n#         };\n# \n        let tx_fut = async move {\n            // --snip--\n#             let vals = vec![\n#                 String::from(\"more\"),\n#                 String::from(\"messages\"),\n#                 String::from(\"for\"),\n#                 String::from(\"you\"),\n#             ];\n# \n#             for val in vals {\n#                 tx.send(val).unwrap();\n#                 trpl::sleep(Duration::from_secs(1)).await;\n#             }\n        };\n\n        let futures: Vec<Box<dyn Future<Output = ()>>> =\n            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];\n\n        trpl::join_all(futures).await;\n#     });\n# }\n```\n\n</Listing>\n\nKaÅ¼dy future umieszczamy w `Box`, aby zamieniÄ‡ je w _obiekty cech_, tak jak to zrobiliÅ›my w sekcji â€Zwracanie bÅ‚Ä™dÃ³w z `run`â€ w Rozdziale 12. (Obiekty cech szczegÃ³Å‚owo omÃ³wimy w Rozdziale 18.) UÅ¼ywanie obiektÃ³w cech pozwala nam traktowaÄ‡ kaÅ¼dy z anonimowych futures wyprodukowanych przez te typy jako ten sam typ, poniewaÅ¼ wszystkie one implementujÄ… cechÄ™ `Future`.\n\nMoÅ¼e to byÄ‡ zaskakujÄ…ce. PrzecieÅ¼ Å¼aden z blokÃ³w async niczego nie zwraca, wiÄ™c kaÅ¼dy z nich produkuje `Future<Output = ()>`. PamiÄ™taj jednak, Å¼e `Future` jest cechÄ…, a kompilator tworzy unikalny enum dla kaÅ¼dego bloku async, nawet jeÅ›li majÄ… identyczne typy wyjÅ›ciowe. Tak jak nie moÅ¼esz umieÅ›ciÄ‡ dwÃ³ch rÃ³Å¼nych, rÄ™cznie napisanych struktur w `Vec`, tak samo nie moÅ¼esz mieszaÄ‡ enumÃ³w generowanych przez kompilator.\n\nNastÄ™pnie przekazujemy kolekcjÄ™ futures do funkcji `trpl::join_all` i czekamy na wynik. Jednak to siÄ™ nie kompiluje; oto odpowiednia czÄ™Å›Ä‡ komunikatÃ³w o bÅ‚Ä™dach.\n\n<!-- manual-regeneration\ncd listings/ch17-async-await/listing-17-23\ncargo build\ncopy *only* the final `error` block from the errors\n-->\n\n```text\nerror[E0277]: `dyn Future<Output = ()>` cannot be unpinned\n  --> src/main.rs:48:33\n   |\n48 |         trpl::join_all(futures).await;\n   |                                 ^^^^^ the trait `Unpin` is not implemented for `dyn Future<Output = ()>`\n   |\n   = note: consider using the `pin!` macro\n           consider using `Box::pin` if you need to access the pinned value outside of the current scope\n   = note: required for `Box<dyn Future<Output = ()>>` to implement `Future`\nnote: required by a bound in `futures_util::future::join_all::JoinAll`\n  --> file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:29:8\n   |\n27 | pub struct JoinAll<F>\n   |            ------- required by a bound in this struct\n28 | where\n29 |     F: Future,\n   |        ^^^^^^ required by this bound in `JoinAll`\n```\n\nNotatka w komunikacie o bÅ‚Ä™dzie mÃ³wi nam, Å¼e powinniÅ›my uÅ¼yÄ‡ makra `pin!`, aby _przypiÄ…Ä‡_ wartoÅ›ci, co oznacza umieszczenie ich w typie `Pin`, ktÃ³ry gwarantuje, Å¼e wartoÅ›ci nie zostanÄ… przeniesione w pamiÄ™ci. Komunikat o bÅ‚Ä™dzie mÃ³wi, Å¼e przypinanie jest wymagane, poniewaÅ¼ `dyn Future<Output = ()>` musi implementowaÄ‡ cechÄ™ `Unpin`, a obecnie tego nie robi.\n\nFunkcja `trpl::join_all` zwraca strukturÄ™ o nazwie `JoinAll`. Ta struktura jest generyczna na typie `F`, ktÃ³ry jest ograniczony do implementacji cechy `Future`. BezpoÅ›rednie oczekiwanie na future za pomocÄ… `await` niejawnie przypina future. Dlatego nie musimy uÅ¼ywaÄ‡ `pin!` wszÄ™dzie tam, gdzie chcemy oczekiwaÄ‡ na futures.\n\nNie oczekujemy tu jednak bezpoÅ›rednio na future. Zamiast tego konstruujemy nowe future, `JoinAll`, przekazujÄ…c kolekcjÄ™ futures do funkcji `join_all`. Sygnatura `join_all` wymaga, aby typy elementÃ³w w kolekcji implementowaÅ‚y cechÄ™ `Future`, a `Box<T>` implementuje `Future` tylko wtedy, gdy opakowywany przez niego `T` jest futurem, ktÃ³ry implementuje cechÄ™ `Unpin`.\n\nTo duÅ¼o do przyswojenia! Aby to naprawdÄ™ zrozumieÄ‡, zagÅ‚Ä™bmy siÄ™ nieco bardziej w to, jak dziaÅ‚a cecha `Future`, szczegÃ³lnie w kontekÅ›cie przypinania. SpÃ³jrzmy jeszcze raz na definicjÄ™ cechy `Future`:\n\n```rust\nuse std::pin::Pin;\nuse std::task::{Context, Poll};\n\npub trait Future {\n    type Output;\n\n    // Required method\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n}\n```\n\nParametr `cx` i jego typ `Context` sÄ… kluczem do tego, jak Å›rodowisko wykonawcze faktycznie wie, kiedy sprawdziÄ‡ dany future, jednoczeÅ›nie pozostajÄ…c leniwym. Ponownie, szczegÃ³Å‚y tego, jak to dziaÅ‚a, wykraczajÄ… poza zakres tego rozdziaÅ‚u, i zazwyczaj musisz o tym myÅ›leÄ‡ tylko wtedy, gdy piszesz niestandardowÄ… implementacjÄ™ `Future`. Zamiast tego skupimy siÄ™ na typie `self`, poniewaÅ¼ jest to pierwszy raz, gdy widzieliÅ›my metodÄ™, w ktÃ³rej `self` ma adnotacjÄ™ typu. Adnotacja typu dla `self` dziaÅ‚a jak adnotacje typu dla innych parametrÃ³w funkcji, ale z dwoma kluczowymi rÃ³Å¼nicami:\n\n- MÃ³wi Rustowi, jakiego typu musi byÄ‡ `self`, aby metoda mogÅ‚a zostaÄ‡ wywoÅ‚ana.\n- Nie moÅ¼e to byÄ‡ dowolny typ. Jest ograniczony do typu, na ktÃ³rym metoda jest zaimplementowana, referencji lub inteligentnego wskaÅºnika do tego typu, lub `Pin` opakowujÄ…cego referencjÄ™ do tego typu.\n\nWiÄ™cej na temat tej skÅ‚adni zobaczymy w [Rozdziale 18][ch-18]<!-- ignore -->. Na razie wystarczy wiedzieÄ‡, Å¼e jeÅ›li chcemy odpytaÄ‡ future, aby sprawdziÄ‡, czy jest `Pending` czy `Ready(Output)`, potrzebujemy mutowalnej referencji do typu opakowanej w `Pin`.\n\n`Pin` to opakowanie dla typÃ³w wskaÅºnikopodobnych, takich jak `&`, `&mut`, `Box` i `Rc`. (Technicznie `Pin` dziaÅ‚a z typami implementujÄ…cymi cechy `Deref` lub `DerefMut`, ale to jest skutecznie rÃ³wnowaÅ¼ne z pracÄ… tylko z referencjami i inteligentnymi wskaÅºnikami.) `Pin` sam w sobie nie jest wskaÅºnikiem i nie ma Å¼adnego wÅ‚asnego zachowania, jak `Rc` i `Arc` zliczajÄ…ce referencje; jest to czysto narzÄ™dzie, ktÃ³rego kompilator moÅ¼e uÅ¼ywaÄ‡ do wymuszania ograniczeÅ„ na uÅ¼ycie wskaÅºnikÃ³w.\n\nPrzypominajÄ…c, Å¼e `await` jest implementowane w kategoriach wywoÅ‚aÅ„ `poll`, zaczyna wyjaÅ›niaÄ‡ siÄ™ komunikat o bÅ‚Ä™dzie, ktÃ³ry widzieliÅ›my wczeÅ›niej, ale byÅ‚ on w kategoriach `Unpin`, a nie `Pin`. Jak wiÄ™c dokÅ‚adnie `Pin` odnosi siÄ™ do `Unpin` i dlaczego `Future` potrzebuje, aby `self` byÅ‚o w typie `Pin`, aby wywoÅ‚aÄ‡ `poll`?\n\nPrzypomnijmy z wczeÅ›niejszej czÄ™Å›ci tego rozdziaÅ‚u, Å¼e seria punktÃ³w oczekiwania w future jest kompilowana w maszynÄ™ stanÃ³w, a kompilator dba o to, aby ta maszyna stanÃ³w przestrzegaÅ‚a wszystkich normalnych zasad Rusta dotyczÄ…cych bezpieczeÅ„stwa, w tym poÅ¼yczania i wÅ‚asnoÅ›ci. Aby to dziaÅ‚aÅ‚o, Rust patrzy na to, jakie dane sÄ… potrzebne miÄ™dzy jednym punktem oczekiwania a nastÄ™pnym punktem oczekiwania lub koÅ„cem bloku async. NastÄ™pnie tworzy odpowiedni wariant w skompilowanej maszynie stanÃ³w. KaÅ¼dy wariant uzyskuje potrzebny dostÄ™p do danych, ktÃ³re bÄ™dÄ… uÅ¼ywane w tej sekcji kodu ÅºrÃ³dÅ‚owego, albo poprzez przejÄ™cie wÅ‚asnoÅ›ci tych danych, albo poprzez uzyskanie mutowalnej lub niemutowalnej referencji do nich.\n\nJak dotÄ…d, wszystko dobrze: jeÅ›li popeÅ‚nimy bÅ‚Ä…d w kwestii wÅ‚asnoÅ›ci lub referencji w danym bloku async, narzÄ™dzie borrow checker nas o tym poinformuje. Kiedy chcemy przenosiÄ‡ future odpowiadajÄ…ce temu blokowi â€“ na przykÅ‚ad przenoszÄ…c je do `Vec`, aby przekazaÄ‡ do `join_all` â€“ sprawy stajÄ… siÄ™ bardziej skomplikowane.\n\nKiedy przenosimy future â€“ czy to poprzez wÅ‚oÅ¼enie go do struktury danych w celu uÅ¼ycia jako iteratora z `join_all`, czy zwracajÄ…c je z funkcji â€“ oznacza to faktycznie przeniesienie maszyny stanÃ³w, ktÃ³rÄ… Rust dla nas tworzy. I w przeciwieÅ„stwie do wiÄ™kszoÅ›ci innych typÃ³w w Rust, futures, ktÃ³re Rust tworzy dla blokÃ³w async, mogÄ… mieÄ‡ odwoÅ‚ania do samych siebie w polach dowolnego wariantu, jak pokazano na uproszczonej ilustracji na Rysunku 17-4.\n\n<figure>\n\n<img alt=\"A single-column, three-row table representing a future, fut1, which has data values 0 and 1 in the first two rows and an arrow pointing from the third row back to the second row, representing an internal reference within the future.\" src=\"img/trpl17-04.svg\" class=\"center\" />\n\n<figcaption>Rysunek 17-4: Typ danych z referencjami do siebie</figcaption>\n\n</figure>\n\nJednakÅ¼e, domyÅ›lnie kaÅ¼dy obiekt, ktÃ³ry ma do siebie referencjÄ™, jest niebezpieczny do przenoszenia, poniewaÅ¼ referencje zawsze wskazujÄ… na rzeczywisty adres pamiÄ™ci tego, do czego siÄ™ odnoszÄ… (patrz Rysunek 17-5). JeÅ›li przeniesiesz samÄ… strukturÄ™ danych, te wewnÄ™trzne referencje bÄ™dÄ… wskazywaÄ‡ na stare miejsce. Jednak to miejsce w pamiÄ™ci jest teraz nieprawidÅ‚owe. Po pierwsze, jego wartoÅ›Ä‡ nie zostanie zaktualizowana, gdy wprowadzisz zmiany w strukturze danych. Po drugie â€“ co waÅ¼niejsze â€“ komputer moÅ¼e teraz swobodnie ponownie wykorzystaÄ‡ tÄ™ pamiÄ™Ä‡ do innych celÃ³w! PÃ³Åºniej moÅ¼esz odczytaÄ‡ zupeÅ‚nie niepowiÄ…zane dane.\n\n<figure>\n\n<img alt=\"Two tables, depicting two futures, fut1 and fut2, each of which has one column and three rows, representing the result of having moved a future out of fut1 into fut2. The first, fut1, is grayed out, with a question mark in each index, representing unknown memory. The second, fut2, has 0 and 1 in the first and second rows and an arrow pointing from its third row back to the second row of fut1, representing a pointer that is referencing the old location in memory of the future before it was moved.\" src=\"img/trpl17-05.svg\" class=\"center\" />\n\n<figcaption>Rysunek 17-5: Niebezpieczny wynik przenoszenia typu danych z referencjami do siebie</figcaption>\n\n</figure>\n\nTeoretycznie, kompilator Rust mÃ³gÅ‚by prÃ³bowaÄ‡ aktualizowaÄ‡ kaÅ¼dÄ… referencjÄ™ do obiektu, gdy jest on przenoszony, ale to mogÅ‚oby dodaÄ‡ wiele narzutu wydajnoÅ›ciowego, zwÅ‚aszcza jeÅ›li caÅ‚a sieÄ‡ referencji wymaga aktualizacji. GdybyÅ›my zamiast tego mogli zapewniÄ‡, Å¼e dana struktura danych _nie przesuwa siÄ™ w pamiÄ™ci_, nie musielibyÅ›my aktualizowaÄ‡ Å¼adnych referencji. Do tego wÅ‚aÅ›nie sÅ‚uÅ¼y borrow checker Rusta: w bezpiecznym kodzie zapobiega przenoszeniu jakiegokolwiek elementu, do ktÃ³rego istnieje aktywna referencja.\n\n`Pin` opiera siÄ™ na tym, aby zapewniÄ‡ nam dokÅ‚adnie takÄ… gwarancjÄ™, jakiej potrzebujemy. Kiedy _przypinamy_ wartoÅ›Ä‡, opakowujÄ…c wskaÅºnik do tej wartoÅ›ci w `Pin`, nie moÅ¼e siÄ™ ona juÅ¼ przesuwaÄ‡. Zatem, jeÅ›li masz `Pin<Box<SomeType>>`, faktycznie przypinasz wartoÅ›Ä‡ `SomeType`, _nie_ wskaÅºnik `Box`. Rysunek 17-6 ilustruje ten proces.\n\n<figure>\n\n<img alt=\"Three boxes laid out side by side. The first is labeled â€œPinâ€, the second â€œb1â€, and the third â€œpinnedâ€. Within â€œpinnedâ€ is a table labeled â€œfutâ€, with a single column; it represents a future with cells for each part of the data structure. Its first cell has the value â€œ0â€, its second cell has an arrow coming out of it and pointing to the fourth and final cell, which has the value â€œ1â€ in it, and the third cell has dashed lines and an ellipsis to indicate there may be other parts to the data structure. All together, the â€œfutâ€ table represents a future which is self-referential. An arrow leaves the box labeled â€œPinâ€, goes through the box labeled â€œb1â€ and terminates inside the â€œpinnedâ€ box at the â€œfutâ€ table.\" src=\"img/trpl17-06.svg\" class=\"center\" />\n\n<figcaption>Rysunek 17-6: Przypinanie `Box`, ktÃ³ry wskazuje na samoodwoÅ‚ujÄ…cy siÄ™ typ future</figcaption>\n\n</figure>\n\nW rzeczywistoÅ›ci wskaÅºnik `Box` moÅ¼e nadal swobodnie siÄ™ przemieszczaÄ‡. PamiÄ™taj: zaleÅ¼y nam na tym, aby dane, do ktÃ³rych ostatecznie siÄ™ odwoÅ‚ujemy, pozostaÅ‚y na miejscu. JeÅ›li wskaÅºnik siÄ™ przemieszcza, _ale dane, na ktÃ³re wskazuje_, znajdujÄ… siÄ™ w tym samym miejscu, jak na Rysunku 17-7, nie ma potencjalnego problemu. (Jako niezaleÅ¼ne Ä‡wiczenie, spÃ³jrz na dokumentacjÄ™ typÃ³w oraz moduÅ‚u `std::pin` i sprÃ³buj ustaliÄ‡, jak byÅ› to zrobiÅ‚ z `Pin` opakowujÄ…cym `Box`.) Kluczem jest to, Å¼e samoodwoÅ‚ujÄ…cy siÄ™ typ sam w sobie nie moÅ¼e siÄ™ przemieszczaÄ‡, poniewaÅ¼ jest nadal przypiÄ™ty.\n\n<figure>\n\n<img alt=\"Four boxes laid out in three rough columns, identical to the previous diagram with a change to the second column. Now there are two boxes in the second column, labeled â€œb1â€ and â€œb2â€, â€œb1â€ is grayed out, and the arrow from â€œPinâ€ goes through â€œb2â€ instead of â€œb1â€, indicating that the pointer has moved from â€œb1â€ to â€œb2â€, but the data in â€œpinnedâ€ has not moved.\" src=\"img/trpl17-07.svg\" class=\"center\" />\n\n<figcaption>Rysunek 17-7: Przenoszenie `Box`, ktÃ³ry wskazuje na samoodwoÅ‚ujÄ…cy siÄ™ typ future</figcaption>\n\n</figure>\n\nJednak wiÄ™kszoÅ›Ä‡ typÃ³w jest caÅ‚kowicie bezpieczna do przenoszenia, nawet jeÅ›li znajdujÄ… siÄ™ za wskaÅºnikiem `Pin`. Musimy myÅ›leÄ‡ o przypinaniu tylko wtedy, gdy elementy majÄ… wewnÄ™trzne referencje. Prymitywne wartoÅ›ci, takie jak liczby i wartoÅ›ci logiczne, sÄ… bezpieczne, poniewaÅ¼ oczywiÅ›cie nie majÄ… Å¼adnych wewnÄ™trznych referencji.\nPodobnie jak wiÄ™kszoÅ›Ä‡ typÃ³w, z ktÃ³rymi normalnie pracujesz w Rust. MoÅ¼esz przenosiÄ‡ `Vec`, na przykÅ‚ad, bez obaw. BiorÄ…c pod uwagÄ™ to, co widzieliÅ›my do tej pory, jeÅ›li masz `Pin<Vec<String>>`, musiaÅ‚byÅ› robiÄ‡ wszystko za pomocÄ… bezpiecznych, ale restrykcyjnych API dostarczonych przez `Pin`, mimo Å¼e `Vec<String>` jest zawsze bezpieczny do przenoszenia, jeÅ›li nie ma do niego innych referencji. Potrzebujemy sposobu, aby powiedzieÄ‡ kompilatorowi, Å¼e w takich przypadkach moÅ¼na przenosiÄ‡ elementy â€“ i tu wÅ‚aÅ›nie wchodzi `Unpin`.\n\n`Unpin` to cecha znacznikowa, podobna do cech `Send` i `Sync`, ktÃ³re widzieliÅ›my w Rozdziale 16, i dlatego nie ma wÅ‚asnej funkcjonalnoÅ›ci. Cechy znacznikowe istniejÄ… tylko po to, aby poinformowaÄ‡ kompilator, Å¼e bezpieczne jest uÅ¼ycie typu implementujÄ…cego danÄ… cechÄ™ w okreÅ›lonym kontekÅ›cie. `Unpin` informuje kompilator, Å¼e dany typ _nie_ musi przestrzegaÄ‡ Å¼adnych gwarancji dotyczÄ…cych tego, czy dana wartoÅ›Ä‡ moÅ¼e byÄ‡ bezpiecznie przeniesiona.\n\n<!--\n  The inline `<code>` in the next block is to allow the inline `<em>` inside it,\n  matching what NoStarch does style-wise, and emphasizing within the text here\n  that it is something distinct from a normal type.\n-->\n\nPodobnie jak w przypadku `Send` i `Sync`, kompilator automatycznie implementuje `Unpin` dla wszystkich typÃ³w, dla ktÃ³rych moÅ¼e to udowodniÄ‡, Å¼e jest bezpieczne. SzczegÃ³lnym przypadkiem, ponownie podobnym do `Send` i `Sync`, jest sytuacja, gdy `Unpin` _nie_ jest implementowany dla typu. Oznaczenie dla tego to <code>impl !Unpin for <em>SomeType</em></code>, gdzie <code><em>SomeType</em></code> to nazwa typu, ktÃ³ry _musi_ przestrzegaÄ‡ tych gwarancji, aby byÄ‡ bezpiecznym za kaÅ¼dym razem, gdy wskaÅºnik do tego typu jest uÅ¼ywany w `Pin`.\n\nInnymi sÅ‚owy, istniejÄ… dwie rzeczy, o ktÃ³rych naleÅ¼y pamiÄ™taÄ‡ w zwiÄ…zku z relacjÄ… miÄ™dzy `Pin` a `Unpin`. Po pierwsze, `Unpin` jest przypadkiem â€normalnymâ€, a `!Unpin` jest przypadkiem specjalnym. Po drugie, to, czy typ implementuje `Unpin` czy `!Unpin`, ma znaczenie _tylko_ wtedy, gdy uÅ¼ywasz przypiÄ™tego wskaÅºnika do tego typu, takiego jak <code>Pin<&mut <em>SomeType</em>></code>.\n\nAby to uÅ›ciÅ›liÄ‡, pomyÅ›l o `String`: ma dÅ‚ugoÅ›Ä‡ i znaki Unicode, ktÃ³re jÄ… tworzÄ…. MoÅ¼emy opakowaÄ‡ `String` w `Pin`, jak widaÄ‡ na Rysunku 17-8. Jednak `String` automatycznie implementuje `Unpin`, podobnie jak wiÄ™kszoÅ›Ä‡ innych typÃ³w w Rust.\n\n<figure>\n\n<img alt=\"A box labeled â€œPinâ€ on the left with an arrow going from it to a box labeled â€œStringâ€ on the right. The â€œStringâ€ box contains the data 5usize, representing the length of the string, and the letters â€œhâ€, â€œeâ€, â€œlâ€, â€œlâ€, and â€œoâ€ representing the characters of the string â€œhelloâ€ stored in this String instance. A dotted rectangle surrounds the â€œStringâ€ box and its label, but not the â€œPinâ€ box.\" src=\"img/trpl17-08.svg\" class=\"center\" />\n\n<figcaption>Rysunek 17-8: Przypinanie `String`; przerywana linia wskazuje, Å¼e `String` implementuje cechÄ™ `Unpin` i dlatego nie jest przypiÄ™ty</figcaption>\n\n</figure>\n\nW rezultacie moÅ¼emy robiÄ‡ rzeczy, ktÃ³re byÅ‚yby nielegalne, gdyby `String` implementowaÅ‚ zamiast tego `!Unpin`, takie jak zastÄ™powanie jednego ciÄ…gu znakÃ³w innym w dokÅ‚adnie tym samym miejscu w pamiÄ™ci, jak na Rysunku 17-9. Nie narusza to kontraktu `Pin`, poniewaÅ¼ `String` nie ma wewnÄ™trznych odwoÅ‚aÅ„, ktÃ³re czyniÅ‚yby jego przenoszenie niebezpiecznym. WÅ‚aÅ›nie dlatego implementuje `Unpin`, a nie `!Unpin`.\n\n<figure>\n\n<img alt=\"The same â€œhelloâ€ string data from the previous example, now labeled â€œs1â€ and grayed out. The â€œPinâ€ box from the previous example now points to a different String instance, one that is labeled â€œs2â€, is valid, has a length of 7usize, and contains the characters of the string â€œgoodbyeâ€. s2 is surrounded by a dotted rectangle because it, too, implements the Unpin trait.\" src=\"img/trpl17-09.svg\" class=\"center\" />\n\n<figcaption>Rysunek 17-9: ZastÄ™powanie `String` zupeÅ‚nie innym `String` w pamiÄ™ci</figcaption>\n\n</figure>\n\nTeraz wiemy wystarczajÄ…co duÅ¼o, aby zrozumieÄ‡ bÅ‚Ä™dy zgÅ‚oszone dla wywoÅ‚ania `join_all` z Listing 17-23. Pierwotnie prÃ³bowaliÅ›my przenieÅ›Ä‡ futures wyprodukowane przez bloki async do `Vec<Box<dyn Future<Output = ()>>>`, ale jak widzieliÅ›my, te futures mogÄ… mieÄ‡ wewnÄ™trzne referencje, wiÄ™c nie implementujÄ… automatycznie `Unpin`. Po ich przypiÄ™ciu moÅ¼emy przekazaÄ‡ wynikowy typ `Pin` do `Vec`, ufajÄ…c, Å¼e bazowe dane w futures _nie_ zostanÄ… przeniesione. Listing 17-24 pokazuje, jak naprawiÄ‡ kod, wywoÅ‚ujÄ…c makro `pin!` tam, gdzie zdefiniowane sÄ… wszystkie trzy futures, i dostosowujÄ…c typ obiektu cechy.\n\n<Listing number=\"17-24\" caption=\"Przypinanie futures, aby umoÅ¼liwiÄ‡ ich przenoszenie do wektora\">\n\n```rust\n# extern crate trpl; // required for mdbook test\n# \nuse std::pin::{Pin, pin};\n\n// --snip--\n\n# use std::time::Duration;\n# \n# fn main() {\n#     trpl::block_on(async {\n#         let (tx, mut rx) = trpl::channel();\n# \n#         let tx1 = tx.clone();\n        let tx1_fut = pin!(async move {\n            // --snip--\n#             let vals = vec![\n#                 String::from(\"hi\"),\n#                 String::from(\"from\"),\n#                 String::from(\"the\"),\n#                 String::from(\"future\"),\n#             ];\n# \n#             for val in vals {\n#                 tx1.send(val).unwrap();\n#                 trpl::sleep(Duration::from_secs(1)).await;\n#             }\n        });\n\n        let rx_fut = pin!(async {\n            // --snip--\n#             while let Some(value) = rx.recv().await {\n#                 println!(\"received '{value}'\");\n#             }\n        });\n\n        let tx_fut = pin!(async move {\n            // --snip--\n#             let vals = vec![\n#                 String::from(\"more\"),\n#                 String::from(\"messages\"),\n#                 String::from(\"for\"),\n#                 String::from(\"you\"),\n#             ];\n# \n#             for val in vals {\n#                 tx.send(val).unwrap();\n#                 trpl::sleep(Duration::from_secs(1)).await;\n#             }\n        });\n\n        let futures: Vec<Pin<&mut dyn Future<Output = ()>>> =\n            vec![tx1_fut, rx_fut, tx_fut];\n# \n#         trpl::join_all(futures).await;\n#     });\n# }\n```\n\n</Listing>\n\nTen przykÅ‚ad kompiluje siÄ™ i dziaÅ‚a, a my moglibyÅ›my dodawaÄ‡ lub usuwaÄ‡ futures z wektora w czasie wykonania i Å‚Ä…czyÄ‡ je wszystkie.\n\n`Pin` i `Unpin` sÄ… gÅ‚Ã³wnie waÅ¼ne przy tworzeniu bibliotek niÅ¼szego poziomu lub gdy budujesz samo Å›rodowisko wykonawcze, a nie w codziennym kodzie Rust. Kiedy jednak zobaczysz te cechy w komunikatach o bÅ‚Ä™dach, bÄ™dziesz miaÅ‚ lepszy pomysÅ‚, jak naprawiÄ‡ swÃ³j kod!\n\n> Uwaga: To poÅ‚Ä…czenie `Pin` i `Unpin` umoÅ¼liwia bezpiecznÄ… implementacjÄ™ caÅ‚ej klasy zÅ‚oÅ¼onych typÃ³w w Rust, ktÃ³re w przeciwnym razie okazaÅ‚yby siÄ™ trudne, poniewaÅ¼ sÄ… samoreferencyjne. Typy wymagajÄ…ce `Pin` pojawiajÄ… siÄ™ najczÄ™Å›ciej w dzisiejszym asynchronicznym Rust, ale co jakiÅ› czas moÅ¼esz je rÃ³wnieÅ¼ zobaczyÄ‡ w innych kontekstach.\n>\n> SzczegÃ³Å‚y dotyczÄ…ce dziaÅ‚ania `Pin` i `Unpin` oraz zasad, ktÃ³rych muszÄ… przestrzegaÄ‡, sÄ… szczegÃ³Å‚owo omÃ³wione w dokumentacji API dla `std::pin`, wiÄ™c jeÅ›li jesteÅ› zainteresowany pogÅ‚Ä™bianiem wiedzy, to Å›wietne miejsce, aby zaczÄ…Ä‡.\n>\n> JeÅ›li chcesz zrozumieÄ‡, jak wszystko dziaÅ‚a pod maskÄ… jeszcze bardziej szczegÃ³Å‚owo, zobacz RozdziaÅ‚y [2][under-the-hood]<!-- ignore --> i [4][pinning]<!-- ignore --> z ksiÄ…Å¼ki _Asynchronous Programming in Rust_ [async-book].\n\n### Cecha `Stream`\n\nTeraz, gdy masz gÅ‚Ä™bsze zrozumienie cech `Future`, `Pin` i `Unpin`, moÅ¼emy zwrÃ³ciÄ‡ uwagÄ™ na cechÄ™ `Stream`. Jak dowiedziaÅ‚eÅ› siÄ™ wczeÅ›niej w rozdziale, strumienie sÄ… podobne do asynchronicznych iteratorÃ³w. Jednak w przeciwieÅ„stwie do `Iterator` i `Future`, `Stream` nie ma definicji w standardowej bibliotece w momencie pisania tego tekstu, ale _istnieje_ bardzo powszechna definicja z kraty `futures` uÅ¼ywana w caÅ‚ym ekosystemie.\n\nPrzyjrzyjmy siÄ™ definicjom cech `Iterator` i `Future`, zanim zastanowimy siÄ™, jak cecha `Stream` mogÅ‚aby je poÅ‚Ä…czyÄ‡. Z `Iterator` mamy ideÄ™ sekwencji: jego metoda `next` dostarcza `Option<Self::Item>`. Z `Future` mamy ideÄ™ gotowoÅ›ci w czasie: jego metoda `poll` dostarcza `Poll<Self::Output>`. Aby reprezentowaÄ‡ sekwencjÄ™ elementÃ³w, ktÃ³re stajÄ… siÄ™ gotowe w czasie, definiujemy cechÄ™ `Stream`, ktÃ³ra Å‚Ä…czy te funkcje:\n\n```rust\nuse std::pin::Pin;\nuse std::task::{Context, Poll};\n\ntrait Stream {\n    type Item;\n\n    fn poll_next(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>\n    ) -> Poll<Option<Self::Item>>;\n}\n```\n\nCecha `Stream` definiuje typ skojarzony o nazwie `Item` dla typu elementÃ³w wytwarzanych przez strumieÅ„. Jest to podobne do `Iterator`, gdzie moÅ¼e byÄ‡ zero lub wiele elementÃ³w, i w przeciwieÅ„stwie do `Future`, gdzie zawsze jest pojedynczy `Output`, nawet jeÅ›li jest to typ jednostkowy `()`.\n\n`Stream` definiuje rÃ³wnieÅ¼ metodÄ™ do pobierania tych elementÃ³w. Nazywamy jÄ… `poll_next`, aby jasno pokazaÄ‡, Å¼e odpytuje w ten sam sposÃ³b, co `Future::poll`, i wytwarza sekwencjÄ™ elementÃ³w w ten sam sposÃ³b, co `Iterator::next`. Jej typ zwracany Å‚Ä…czy `Poll` z `Option`. Typ zewnÄ™trzny to `Poll`, poniewaÅ¼ musi byÄ‡ sprawdzany pod kÄ…tem gotowoÅ›ci, tak jak future. Typ wewnÄ™trzny to `Option`, poniewaÅ¼ musi sygnalizowaÄ‡, czy sÄ… wiÄ™cej wiadomoÅ›ci, tak jak iterator.\n\nCoÅ› bardzo podobnego do tej definicji prawdopodobnie znajdzie siÄ™ w standardowej bibliotece Rusta. W miÄ™dzyczasie jest to czÄ™Å›Ä‡ zestawu narzÄ™dzi wiÄ™kszoÅ›ci Å›rodowisk wykonawczych, wiÄ™c moÅ¼esz na tym polegaÄ‡, a wszystko, co omÃ³wimy dalej, powinno generalnie obowiÄ…zywaÄ‡!\n\nW przykÅ‚adach, ktÃ³re widzieliÅ›my w sekcji [â€Strumienie: Futures w sekwencjiâ€][streams]<!-- ignore -->, nie uÅ¼yliÅ›my jednak `poll_next` _ani_ `Stream`, lecz `next` i `StreamExt`. OczywiÅ›cie _mogliÅ›my_ pracowaÄ‡ bezpoÅ›rednio w kategoriach API `poll_next`, rÄ™cznie piszÄ…c wÅ‚asne maszyny stanÃ³w `Stream`, tak samo jak _mogliÅ›my_ pracowaÄ‡ z futures bezpoÅ›rednio za poÅ›rednictwem ich metody `poll`. UÅ¼ycie `await` jest jednak znacznie przyjemniejsze, a cecha `StreamExt` dostarcza metodÄ™ `next`, dziÄ™ki czemu moÅ¼emy to zrobiÄ‡:\n\n```rust\n# use std::pin::Pin;\n# use std::task::{Context, Poll};\n# \n# trait Stream {\n#     type Item;\n#     fn poll_next(\n#         self: Pin<&mut Self>,\n#         cx: &mut Context<'_>,\n#     ) -> Poll<Option<Self::Item>>;\n# }\n# \ntrait StreamExt: Stream {\n    async fn next(&mut self) -> Option<Self::Item>\n    where\n        Self: Unpin;\n\n    // other methods...\n}\n```\n\n<!--\nTODO: update this if/when tokio/etc. update their MSRV and switch to using async functions\nin traits, since the lack thereof is the reason they do not yet have this.\n-->\n\n> Uwaga: Rzeczywista definicja, ktÃ³rej uÅ¼yliÅ›my wczeÅ›niej w rozdziale, wyglÄ…da nieco inaczej, poniewaÅ¼ obsÅ‚uguje wersje Rust, ktÃ³re nie obsÅ‚ugiwaÅ‚y jeszcze uÅ¼ywania funkcji async w cechach. W rezultacie wyglÄ…da to tak:\n>\n> ```rust,ignore\n> fn next(&mut self) -> Next<'_, Self> where Self: Unpin;\n> ```\n>\n> Ten typ `Next` to `struct`, ktÃ³ra implementuje `Future` i pozwala nam nazwaÄ‡ czas Å¼ycia referencji do `self` za pomocÄ… `Next<'_, Self>`, tak aby `await` mÃ³gÅ‚ dziaÅ‚aÄ‡ z tÄ… metodÄ….\n\nCecha `StreamExt` jest rÃ³wnieÅ¼ miejscem, gdzie znajdujÄ… siÄ™ wszystkie interesujÄ…ce metody dostÄ™pne do uÅ¼ytku ze strumieniami. `StreamExt` jest automatycznie implementowana dla kaÅ¼dego typu, ktÃ³ry implementuje `Stream`, ale te cechy sÄ… definiowane oddzielnie, aby umoÅ¼liwiÄ‡ spoÅ‚ecznoÅ›ci iterowanie po wygodnych API bez wpÅ‚ywu na podstawowÄ… cechÄ™.\n\nW wersji `StreamExt` uÅ¼ytej w skrzynce `trpl` cecha ta nie tylko definiuje metodÄ™ `next`, ale takÅ¼e dostarcza domyÅ›lnÄ… implementacjÄ™ `next`, ktÃ³ra poprawnie obsÅ‚uguje szczegÃ³Å‚y wywoÅ‚ywania `Stream::poll_next`. Oznacza to, Å¼e nawet gdy musisz napisaÄ‡ wÅ‚asny typ danych strumieniowych, _tylko_ musisz zaimplementowaÄ‡ `Stream`, a nastÄ™pnie kaÅ¼dy, kto uÅ¼ywa twojego typu danych, moÅ¼e automatycznie uÅ¼ywaÄ‡ `StreamExt` i jego metod.\n\nTo wszystko, co omÃ³wimy w kwestii niskopoziomowych szczegÃ³Å‚Ã³w tych cech. Na zakoÅ„czenie zastanÃ³wmy siÄ™, jak futures (w tym strumienie), zadania i wÄ…tki pasujÄ… do siebie!\n\n[message-passing]: ch17-02-concurrency-with-async.md#sending-data-between-two-tasks-using-message-passing\n[ch-18]: ch18-00-oop.html\n[async-book]: https://rust-lang.github.io/async-book/\n[under-the-hood]: https://rust-lang.github.io/async-book/02_execution/01_chapter.html\n[pinning]: https://rust-lang.github.io/async-book/04_pinning/01_chapter.html\n[first-async]: ch17-01-futures-and-syntax.html#our-first-async-program\n[any-number-futures]: ch17-03-more-futures.html#working-with-any-number-of-futures\n[streams]: ch17-04-streams.html\n",
        "chapter_title": "BliÅ¼sze spojrzenie na cechy dla async"
    },
    {
        "file_path": "ch21-01-single-threaded.md",
        "content": "## Budowanie jednowÄ…tkowego serwera WWW\n\nZaczniemy od uruchomienia jednowÄ…tkowego serwera WWW. Zanim zaczniemy, spÃ³jrzmy na szybki przeglÄ…d protokoÅ‚Ã³w zaangaÅ¼owanych w budowanie serwerÃ³w WWW. SzczegÃ³Å‚y tych protokoÅ‚Ã³w wykraczajÄ… poza zakres tej ksiÄ…Å¼ki, ale krÃ³tki przeglÄ…d dostarczy ci niezbÄ™dnych informacji.\n\nDwa gÅ‚Ã³wne protokoÅ‚y zaangaÅ¼owane w serwery WWW to _Hypertext Transfer Protocol_ _(HTTP)_ i _Transmission Control Protocol_ _(TCP)_. Oba protokoÅ‚y sÄ… protokoÅ‚ami typu _Å¼Ä…danie-odpowiedÅº_, co oznacza, Å¼e _klient_ inicjuje Å¼Ä…dania, a _serwer_ nasÅ‚uchuje Å¼Ä…daÅ„ i dostarcza klientowi odpowiedÅº. ZawartoÅ›Ä‡ tych Å¼Ä…daÅ„ i odpowiedzi jest definiowana przez protokoÅ‚y.\n\nTCP to protokÃ³Å‚ niÅ¼szego poziomu, ktÃ³ry opisuje szczegÃ³Å‚y, jak informacje trafiajÄ… z jednego serwera do drugiego, ale nie precyzuje, czym sÄ… te informacje. HTTP buduje na TCP, definiujÄ…c zawartoÅ›Ä‡ Å¼Ä…daÅ„ i odpowiedzi. Technicznie moÅ¼liwe jest uÅ¼ywanie HTTP z innymi protokoÅ‚ami, ale w zdecydowanej wiÄ™kszoÅ›ci przypadkÃ³w HTTP wysyÅ‚a swoje dane przez TCP. BÄ™dziemy pracowaÄ‡ z surowymi bajtami Å¼Ä…daÅ„ i odpowiedzi TCP i HTTP.\n\n### NasÅ‚uchiwanie poÅ‚Ä…czeÅ„ TCP\n\nNasz serwer WWW musi nasÅ‚uchiwaÄ‡ poÅ‚Ä…czeÅ„ TCP, wiÄ™c to jest pierwsza czÄ™Å›Ä‡, nad ktÃ³rÄ… bÄ™dziemy pracowaÄ‡. Biblioteka standardowa oferuje moduÅ‚ `std::net`, ktÃ³ry nam to umoÅ¼liwia. StwÃ³rzmy nowy projekt w zwykÅ‚y sposÃ³b:\n\n```console\n$ cargo new hello\n     Utworzono projekt binarny (aplikacja) `hello`\n$ cd hello\n```\n\nTeraz wprowadÅº kod z Listingu 21-1 do _src/main.rs_, aby rozpoczÄ…Ä‡. Ten kod bÄ™dzie nasÅ‚uchiwaÅ‚ przy lokalnym adresie `127.0.0.1:7878` na przychodzÄ…ce strumienie TCP. Kiedy otrzyma przychodzÄ…cy strumieÅ„, wydrukuje `Connection established!`.\n\n<Listing number=\"21-1\" file-name=\"src/main.rs\" caption=\"NasÅ‚uchiwanie przychodzÄ…cych strumieni i wyÅ›wietlanie komunikatu po odebraniu strumienia\">\n\n```rust,no_run\nuse std::net::TcpListener;\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n\n        println!(\"Connection established!\");\n    }\n}\n```\n\n</Listing>\n\nUÅ¼ywajÄ…c `TcpListener`, moÅ¼emy nasÅ‚uchiwaÄ‡ poÅ‚Ä…czeÅ„ TCP pod adresem `127.0.0.1:7878`. W adresie, sekcja przed dwukropkiem to adres IP reprezentujÄ…cy twÃ³j komputer (jest taki sam na kaÅ¼dym komputerze i nie reprezentuje konkretnie komputera autorÃ³w), a `7878` to port. WybraliÅ›my ten port z dwÃ³ch powodÃ³w: HTTP nie jest zwykle akceptowany na tym porcie, wiÄ™c nasz serwer raczej nie bÄ™dzie kolidowaÅ‚ z Å¼adnym innym serwerem WWW, ktÃ³ry moÅ¼esz mieÄ‡ uruchomiony na swojej maszynie, a 7878 to _rust_ wpisane na telefonie.\n\nFunkcja `bind` w tym scenariuszu dziaÅ‚a jak funkcja `new` w tym sensie, Å¼e zwrÃ³ci nowÄ… instancjÄ™ `TcpListener`. Funkcja nazywa siÄ™ `bind`, poniewaÅ¼ w sieciach poÅ‚Ä…czenie z portem w celu nasÅ‚uchiwania jest znane jako â€wiÄ…zanie siÄ™ z portemâ€.\n\nFunkcja `bind` zwraca `Result<T, E>`, co wskazuje, Å¼e wiÄ…zanie moÅ¼e siÄ™ nie powieÅ›Ä‡, na przykÅ‚ad, gdybyÅ›my uruchomili dwie instancje naszego programu i tym samym mieli dwa programy nasÅ‚uchujÄ…ce na tym samym porcie. PoniewaÅ¼ piszemy podstawowy serwer wyÅ‚Ä…cznie w celach edukacyjnych, nie bÄ™dziemy martwiÄ‡ siÄ™ o obsÅ‚ugÄ™ tego typu bÅ‚Ä™dÃ³w; zamiast tego uÅ¼ywamy `unwrap`, aby zatrzymaÄ‡ program, jeÅ›li wystÄ…piÄ… bÅ‚Ä™dy.\n\nMetoda `incoming` na `TcpListener` zwraca iterator, ktÃ³ry dostarcza nam sekwencjÄ™ strumieni (dokÅ‚adniej, strumieni typu `TcpStream`). Pojedynczy _strumieÅ„_ reprezentuje otwarte poÅ‚Ä…czenie miÄ™dzy klientem a serwerem. _PoÅ‚Ä…czenie_ to nazwa peÅ‚nego procesu Å¼Ä…danie-odpowiedÅº, w ktÃ³rym klient Å‚Ä…czy siÄ™ z serwerem, serwer generuje odpowiedÅº i serwer zamyka poÅ‚Ä…czenie. W zwiÄ…zku z tym bÄ™dziemy czytaÄ‡ z `TcpStream`, aby zobaczyÄ‡, co klient wysÅ‚aÅ‚, a nastÄ™pnie zapiszemy naszÄ… odpowiedÅº do strumienia, aby wysÅ‚aÄ‡ dane z powrotem do klienta. OgÃ³lnie rzecz biorÄ…c, ta pÄ™tla `for` bÄ™dzie przetwarzaÄ‡ kaÅ¼de poÅ‚Ä…czenie po kolei i generowaÄ‡ seriÄ™ strumieni, ktÃ³re bÄ™dziemy obsÅ‚ugiwaÄ‡.\n\nNa razie nasza obsÅ‚uga strumienia polega na wywoÅ‚aniu `unwrap`, aby zakoÅ„czyÄ‡ program, jeÅ›li strumieÅ„ ma jakieÅ› bÅ‚Ä™dy; jeÅ›li bÅ‚Ä™dÃ³w nie ma, program wyÅ›wietla komunikat. W nastÄ™pnym listingu dodamy wiÄ™cej funkcjonalnoÅ›ci dla przypadku sukcesu. Powodem, dla ktÃ³rego moÅ¼emy otrzymaÄ‡ bÅ‚Ä™dy z metody `incoming`, gdy klient Å‚Ä…czy siÄ™ z serwerem, jest to, Å¼e nie iterujemy faktycznie po poÅ‚Ä…czeniach. Zamiast tego iterujemy po _prÃ³bach poÅ‚Ä…czenia_. PoÅ‚Ä…czenie moÅ¼e siÄ™ nie powieÅ›Ä‡ z wielu powodÃ³w, z ktÃ³rych wiele jest specyficznych dla systemu operacyjnego. Na przykÅ‚ad, wiele systemÃ³w operacyjnych ma limit liczby jednoczesnych otwartych poÅ‚Ä…czeÅ„, ktÃ³re mogÄ… obsÅ‚ugiwaÄ‡; nowe prÃ³by poÅ‚Ä…czenia powyÅ¼ej tej liczby bÄ™dÄ… generowaÄ‡ bÅ‚Ä…d, dopÃ³ki niektÃ³re z otwartych poÅ‚Ä…czeÅ„ nie zostanÄ… zamkniÄ™te.\n\nSprÃ³bujmy uruchomiÄ‡ ten kod! WywoÅ‚aj `cargo run` w terminalu, a nastÄ™pnie zaÅ‚aduj _127.0.0.1:7878_ w przeglÄ…darce internetowej. PrzeglÄ…darka powinna wyÅ›wietliÄ‡ komunikat o bÅ‚Ä™dzie, taki jak â€Connection resetâ€, poniewaÅ¼ serwer obecnie nie wysyÅ‚a Å¼adnych danych. Ale kiedy spojrzysz na swÃ³j terminal, powinieneÅ› zobaczyÄ‡ kilka komunikatÃ³w, ktÃ³re zostaÅ‚y wydrukowane, gdy przeglÄ…darka poÅ‚Ä…czyÅ‚a siÄ™ z serwerem!\n\n```text\n     Uruchamianie `target/debug/hello`\nPoÅ‚Ä…czenie nawiÄ…zane!\nPoÅ‚Ä…czenie nawiÄ…zane!\nPoÅ‚Ä…czenie nawiÄ…zane!\n```\n\nCzasami zobaczysz wiele komunikatÃ³w wydrukowanych dla jednego Å¼Ä…dania przeglÄ…darki; powodem moÅ¼e byÄ‡ to, Å¼e przeglÄ…darka wysyÅ‚a Å¼Ä…danie o stronÄ™, a takÅ¼e Å¼Ä…danie o inne zasoby, takie jak ikona _favicon.ico_, ktÃ³ra pojawia siÄ™ w zakÅ‚adce przeglÄ…darki.\n\nMoÅ¼e siÄ™ rÃ³wnieÅ¼ zdarzyÄ‡, Å¼e przeglÄ…darka prÃ³buje poÅ‚Ä…czyÄ‡ siÄ™ z serwerem wielokrotnie, poniewaÅ¼ serwer nie odpowiada Å¼adnymi danymi. Gdy `stream` wychodzi poza zakres i jest porzucony na koÅ„cu pÄ™tli, poÅ‚Ä…czenie jest zamykane w ramach implementacji `drop`. PrzeglÄ…darki czasami radzÄ… sobie z zamkniÄ™tymi poÅ‚Ä…czeniami, ponawiajÄ…c prÃ³bÄ™, poniewaÅ¼ problem moÅ¼e byÄ‡ tymczasowy.\n\nPrzeglÄ…darki czasami otwierajÄ… rÃ³wnieÅ¼ wiele poÅ‚Ä…czeÅ„ z serwerem bez wysyÅ‚ania Å¼adnych Å¼Ä…daÅ„, aby w przypadku pÃ³Åºniejszego wysÅ‚ania Å¼Ä…daÅ„, te Å¼Ä…dania mogÅ‚y nastÄ…piÄ‡ szybciej. Kiedy to nastÄ…pi, nasz serwer zobaczy kaÅ¼de poÅ‚Ä…czenie, niezaleÅ¼nie od tego, czy istniejÄ… jakiekolwiek Å¼Ä…dania przez to poÅ‚Ä…czenie. Robi tak wiele wersji przeglÄ…darek opartych na Chrome, na przykÅ‚ad; moÅ¼esz wyÅ‚Ä…czyÄ‡ tÄ™ optymalizacjÄ™, uÅ¼ywajÄ…c trybu przeglÄ…dania prywatnego lub innej przeglÄ…darki.\n\nWaÅ¼nym czynnikiem jest to, Å¼e z powodzeniem uzyskaliÅ›my uchwyt do poÅ‚Ä…czenia TCP!\n\nPamiÄ™taj, aby zatrzymaÄ‡ program, naciskajÄ…c <kbd>ctrl</kbd>-<kbd>C</kbd>, gdy skoÅ„czysz uruchamiaÄ‡ okreÅ›lonÄ… wersjÄ™ kodu. NastÄ™pnie uruchom program ponownie, wywoÅ‚ujÄ…c polecenie `cargo run` po wprowadzeniu kaÅ¼dej serii zmian w kodzie, aby upewniÄ‡ siÄ™, Å¼e uruchamiasz najnowszy kod.\n\n### Odczytywanie Å¼Ä…dania\n\nZaimplementujmy funkcjonalnoÅ›Ä‡ do odczytywania Å¼Ä…dania z przeglÄ…darki! Aby oddzieliÄ‡ kwestie nawiÄ…zania poÅ‚Ä…czenia od wykonania jakiejÅ› akcji z nim zwiÄ…zanej, rozpoczniemy nowÄ… funkcjÄ™ do przetwarzania poÅ‚Ä…czeÅ„. W tej nowej funkcji `handle_connection` bÄ™dziemy czytaÄ‡ dane ze strumienia TCP i drukowaÄ‡ je, abyÅ›my mogli zobaczyÄ‡ dane wysyÅ‚ane z przeglÄ…darki. ZmieÅ„ kod, aby wyglÄ…daÅ‚ jak na Listingu 21-2.\n\n<Listing number=\"21-2\" file-name=\"src/main.rs\" caption=\"Odczytywanie ze strumienia `TcpStream` i drukowanie danych\">\n\n```rust,no_run\nuse std::{\n    io::{BufReader, prelude::*},\n    net::{TcpListener, TcpStream},\n};\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n\n        handle_connection(stream);\n    }\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&stream);\n    let http_request: Vec<_> = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    println!(\"Å»Ä…danie: {http_request:#?}\");\n}\n```\n\n</Listing>\n\nWprowadzamy `std::io::BufReader` i `std::io::prelude` do zakresu, aby uzyskaÄ‡ dostÄ™p do cech i typÃ³w, ktÃ³re pozwalajÄ… nam czytaÄ‡ i zapisywaÄ‡ do strumienia. W pÄ™tli `for` w funkcji `main`, zamiast wyÅ›wietlaÄ‡ komunikat informujÄ…cy o nawiÄ…zaniu poÅ‚Ä…czenia, wywoÅ‚ujemy teraz nowÄ… funkcjÄ™ `handle_connection` i przekazujemy jej `stream`.\n\nW funkcji `handle_connection` tworzymy nowÄ… instancjÄ™ `BufReader`, ktÃ³ra opakowuje referencjÄ™ do `stream`. `BufReader` dodaje buforowanie, zarzÄ…dzajÄ…c za nas wywoÅ‚aniami metod cechy `std::io::Read`.\n\nTworzymy zmiennÄ… o nazwie `http_request`, aby zbieraÄ‡ linie Å¼Ä…dania, ktÃ³re przeglÄ…darka wysyÅ‚a do naszego serwera. Wskazujemy, Å¼e chcemy zebraÄ‡ te linie w wektorze, dodajÄ…c adnotacjÄ™ typu `Vec<_>`.\n\n`BufReader` implementuje cechÄ™ `std::io::BufRead`, ktÃ³ra dostarcza metodÄ™ `lines`. Metoda `lines` zwraca iterator `Result<String, std::io::Error>`, dzielÄ…c strumieÅ„ danych za kaÅ¼dym razem, gdy zobaczy znak nowej linii. Aby uzyskaÄ‡ kaÅ¼dy `String`, `map`ujemy i `unwrap`ujemy kaÅ¼dy `Result`. `Result` moÅ¼e byÄ‡ bÅ‚Ä™dem, jeÅ›li dane nie sÄ… prawidÅ‚owym UTF-8 lub jeÅ›li wystÄ…piÅ‚ problem podczas czytania ze strumienia. Ponownie, program produkcyjny powinien obsÅ‚ugiwaÄ‡ te bÅ‚Ä™dy bardziej elegancko, ale my decydujemy siÄ™ na zatrzymanie programu w przypadku bÅ‚Ä™du dla uproszczenia.\n\nPrzeglÄ…darka sygnalizuje koniec Å¼Ä…dania HTTP, wysyÅ‚ajÄ…c dwa znaki nowej linii z rzÄ™du, wiÄ™c aby uzyskaÄ‡ jedno Å¼Ä…danie ze strumienia, pobieramy linie, dopÃ³ki nie otrzymamy linii, ktÃ³ra jest pustym ciÄ…giem znakÃ³w. Po zebraniu linii do wektora, drukujemy je, uÅ¼ywajÄ…c Å‚adnego formatowania debugowania, abyÅ›my mogli przyjrzeÄ‡ siÄ™ instrukcjom, ktÃ³re przeglÄ…darka internetowa wysyÅ‚a do naszego serwera.\n\nSprÃ³bujmy tego kodu! Uruchom program i ponownie wyÅ›lij Å¼Ä…danie w przeglÄ…darce internetowej. ZauwaÅ¼, Å¼e nadal otrzymamy stronÄ™ bÅ‚Ä™du w przeglÄ…darce, ale wynik naszego programu w terminalu bÄ™dzie teraz wyglÄ…daÅ‚ podobnie do tego:\n\n<!-- manual-regeneration\ncd listings/ch21-web-server/listing-21-02\ncargo run\nwyÅ›lij Å¼Ä…danie na 127.0.0.1:7878\nNie moÅ¼na zautomatyzowaÄ‡, poniewaÅ¼ wynik zaleÅ¼y od wysyÅ‚ania Å¼Ä…daÅ„\n-->\n\n```console\n$ cargo run\n   Kompilowanie hello v0.1.0 (file:///projects/hello)\n    ZakoÅ„czono `dev` profil [nieoptymalny + debuginfo] cel(e) w 0.42s\n     Uruchamianie `target/debug/hello`\nÅ»Ä…danie: [\n    \"GET / HTTP/1.1\",\n    \"Host: 127.0.0.1:7878\",\n    \"User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0\",\n    \"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\",\n    \"Accept-Language: en-US,en;q=0.5\",\n    \"Accept-Encoding: gzip, deflate, br\",\n    \"DNT: 1\",\n    \"Connection: keep-alive\",\n    \"Upgrade-Insecure-Requests: 1\",\n    \"Sec-Fetch-Dest: document\",\n    \"Sec-Fetch-Mode: navigate\",\n    \"Sec-Fetch-Site: none\",\n    \"Sec-Fetch-User: ?1\",\n    \"Cache-Control: max-age=0\",\n]\n```\n\nW zaleÅ¼noÅ›ci od przeglÄ…darki, moÅ¼esz otrzymaÄ‡ nieco inny wynik. Teraz, gdy drukujemy dane Å¼Ä…dania, moÅ¼emy zobaczyÄ‡, dlaczego otrzymujemy wiele poÅ‚Ä…czeÅ„ z jednego Å¼Ä…dania przeglÄ…darki, patrzÄ…c na Å›cieÅ¼kÄ™ po `GET` w pierwszej linii Å¼Ä…dania. JeÅ›li powtarzajÄ…ce siÄ™ poÅ‚Ä…czenia wszystkie Å¼Ä…dajÄ… _/_, wiemy, Å¼e przeglÄ…darka prÃ³buje wielokrotnie pobraÄ‡ _/_, poniewaÅ¼ nie otrzymuje odpowiedzi z naszego programu.\n\nPrzeanalizujmy te dane Å¼Ä…dania, aby zrozumieÄ‡, o co przeglÄ…darka prosi nasz program.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"a-closer-look-at-an-http-request\"></a>\n<a id=\"looking-closer-at-an-http-request\"></a>\n\n### BliÅ¼sze spojrzenie na Å¼Ä…danie HTTP\n\nHTTP to protokÃ³Å‚ tekstowy, a Å¼Ä…danie ma nastÄ™pujÄ…cy format:\n\n```text\nMetoda Identyfikator-Å¼Ä…dania Wersja-HTTP CRLF\nnagÅ‚Ã³wki CRLF\nciaÅ‚o-wiadomoÅ›ci\n```\n\nPierwsza linia to _linia Å¼Ä…dania_, ktÃ³ra zawiera informacje o tym, czego klient Å¼Ä…da. Pierwsza czÄ™Å›Ä‡ linii Å¼Ä…dania wskazuje uÅ¼ywanÄ… metodÄ™, takÄ… jak `GET` lub `POST`, ktÃ³ra opisuje, w jaki sposÃ³b klient wysyÅ‚a to Å¼Ä…danie. Nasz klient uÅ¼yÅ‚ Å¼Ä…dania `GET`, co oznacza, Å¼e prosi o informacje.\n\nNastÄ™pnÄ… czÄ™Å›ciÄ… linii Å¼Ä…dania jest _/_, ktÃ³ra wskazuje _uniform resource identifier_ _(URI)_, o ktÃ³ry prosi klient: URI jest prawie, ale niezupeÅ‚nie, tym samym co _uniform resource locator_ _(URL)_. RÃ³Å¼nica miÄ™dzy URI a URL nie jest istotna dla naszych celÃ³w w tym rozdziale, ale specyfikacja HTTP uÅ¼ywa terminu _URI_, wiÄ™c moÅ¼emy tutaj po prostu mentalnie zastÄ…piÄ‡ _URL_ przez _URI_.\n\nOstatniÄ… czÄ™Å›ciÄ… jest wersja HTTP uÅ¼ywana przez klienta, a nastÄ™pnie linia Å¼Ä…dania koÅ„czy siÄ™ sekwencjÄ… CRLF. (CRLF to skrÃ³t od _carriage return_ i _line feed_, co sÄ… terminami z czasÃ³w maszyn do pisania!) SekwencjÄ™ CRLF moÅ¼na rÃ³wnieÅ¼ zapisaÄ‡ jako `\\r\\n`, gdzie `\\r` to znak powrotu karetki, a `\\n` to znak nowej linii. _Sekwencja CRLF_ oddziela liniÄ™ Å¼Ä…dania od reszty danych Å¼Ä…dania. ZauwaÅ¼, Å¼e gdy CRLF jest drukowane, widzimy poczÄ…tek nowej linii, a nie `\\r\\n`.\n\nPatrzÄ…c na dane linii Å¼Ä…dania, ktÃ³re otrzymaliÅ›my po uruchomieniu naszego programu, widzimy, Å¼e `GET` to metoda, _/_ to URI Å¼Ä…dania, a `HTTP/1.1` to wersja.\n\nPo linii Å¼Ä…dania, pozostaÅ‚e linie zaczynajÄ…ce siÄ™ od `Host:` to nagÅ‚Ã³wki. Å»Ä…dania `GET` nie majÄ… ciaÅ‚a.\n\nSprÃ³buj wysÅ‚aÄ‡ Å¼Ä…danie z innej przeglÄ…darki lub poprosiÄ‡ o inny adres, na przykÅ‚ad _127.0.0.1:7878/test_, aby zobaczyÄ‡, jak zmieniajÄ… siÄ™ dane Å¼Ä…dania.\n\nTeraz, gdy wiemy, o co prosi przeglÄ…darka, wyÅ›lijmy z powrotem jakieÅ› dane!\n\n### Pisanie odpowiedzi\n\nZaimplementujemy wysyÅ‚anie danych w odpowiedzi na Å¼Ä…danie klienta. Odpowiedzi majÄ… nastÄ™pujÄ…cy format:\n\n```text\nWersja-HTTP Kod-statusu Fraza-powodowa CRLF\nnagÅ‚Ã³wki CRLF\nciaÅ‚o-wiadomoÅ›ci\n```\n\nPierwsza linia to _linia statusu_, ktÃ³ra zawiera wersjÄ™ HTTP uÅ¼ywanÄ… w odpowiedzi, numeryczny kod statusu, ktÃ³ry podsumowuje wynik Å¼Ä…dania, oraz frazÄ™ powodowÄ…, ktÃ³ra zawiera tekstowy opis kodu statusu. Po sekwencji CRLF nastÄ™pujÄ… nagÅ‚Ã³wki, kolejna sekwencja CRLF i treÅ›Ä‡ odpowiedzi.\n\nPoniÅ¼ej znajduje siÄ™ przykÅ‚adowa odpowiedÅº, ktÃ³ra uÅ¼ywa protokoÅ‚u HTTP w wersji 1.1 i ma kod statusu 200, frazÄ™ â€OKâ€, brak nagÅ‚Ã³wkÃ³w i brak treÅ›ci:\n\n```text\nHTTP/1.1 200 OK\\r\\n\\r\\n\n```\n\nKod statusu 200 to standardowa odpowiedÅº sukcesu. Tekst to maÅ‚a, udana odpowiedÅº HTTP. Zapiszmy to do strumienia jako naszÄ… odpowiedÅº na udane Å¼Ä…danie! Z funkcji `handle_connection` usuÅ„ `println!`, ktÃ³re drukowaÅ‚o dane Å¼Ä…dania, i zastÄ…p je kodem z Listingu 21-3.\n\n<Listing number=\"21-3\" file-name=\"src/main.rs\" caption=\"Zapisywanie krÃ³tkiej, udanej odpowiedzi HTTP do strumienia\">\n\n```rust,no_run\n# use std::{\n#     io::{BufReader, prelude::*},\n#     net::{TcpListener, TcpStream},\n# };\n# \n# fn main() {\n#     let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n# \n#     for stream in listener.incoming() {\n#         let stream = stream.unwrap();\n# \n#         handle_connection(stream);\n#     }\n# }\n# \nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&stream);\n    let http_request: Vec<_> = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    let response = \"HTTP/1.1 200 OK\\r\\n\\r\\n\";\n\n    stream.write_all(response.as_bytes()).unwrap();\n}\n```\n\n</Listing>\n\nPierwsza nowa linia definiuje zmiennÄ… `response`, ktÃ³ra przechowuje dane wiadomoÅ›ci o sukcesie. NastÄ™pnie wywoÅ‚ujemy `as_bytes` na naszym `response`, aby przekonwertowaÄ‡ dane ciÄ…gu na bajty. Metoda `write_all` na `stream` przyjmuje `&[u8]` i wysyÅ‚a te bajty bezpoÅ›rednio przez poÅ‚Ä…czenie. PoniewaÅ¼ operacja `write_all` moÅ¼e zakoÅ„czyÄ‡ siÄ™ niepowodzeniem, uÅ¼ywamy `unwrap` dla kaÅ¼dego wyniku bÅ‚Ä™du, tak jak poprzednio. Ponownie, w prawdziwej aplikacji, naleÅ¼aÅ‚oby tutaj dodaÄ‡ obsÅ‚ugÄ™ bÅ‚Ä™dÃ³w.\n\nDziÄ™ki tym zmianom, uruchommy nasz kod i wyÅ›lijmy Å¼Ä…danie. Nie drukujemy juÅ¼ Å¼adnych danych do terminala, wiÄ™c nie zobaczymy Å¼adnego wyniku poza danymi z Cargo. Gdy zaÅ‚adujesz _127.0.0.1:7878_ w przeglÄ…darce internetowej, powinieneÅ› otrzymaÄ‡ pustÄ… stronÄ™ zamiast bÅ‚Ä™du. WÅ‚aÅ›nie rÄ™cznie zakodowaÅ‚eÅ› odbieranie Å¼Ä…dania HTTP i wysyÅ‚anie odpowiedzi!\n\n### Zwracanie prawdziwego kodu HTML\n\nZaimplementujmy funkcjonalnoÅ›Ä‡ zwracania czegoÅ› wiÄ™cej niÅ¼ pustej strony. UtwÃ³rz nowy plik _hello.html_ w katalogu gÅ‚Ã³wnym swojego projektu, a nie w katalogu _src_. MoÅ¼esz wpisaÄ‡ dowolny kod HTML; Listing 21-4 pokazuje jednÄ… z moÅ¼liwoÅ›ci.\n\n<Listing number=\"21-4\" file-name=\"hello.html\" caption=\"PrzykÅ‚adowy plik HTML do zwrÃ³cenia w odpowiedzi\">\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Witaj!</title>\n  </head>\n  <body>\n    <h1>Witaj!</h1>\n    <p>CzeÅ›Ä‡ z Rust</p>\n  </body>\n</html>\n```\n\n</Listing>\n\nJest to minimalny dokument HTML5 z nagÅ‚Ã³wkiem i tekstem. Aby zwrÃ³ciÄ‡ go z serwera po otrzymaniu Å¼Ä…dania, zmodyfikujemy `handle_connection`, jak pokazano na Listingu 21-5, aby odczytaÄ‡ plik HTML, dodaÄ‡ go do odpowiedzi jako ciaÅ‚o i wysÅ‚aÄ‡.\n\n<Listing number=\"21-5\" file-name=\"src/main.rs\" caption=\"WysyÅ‚anie zawartoÅ›ci *hello.html* jako treÅ›ci odpowiedzi\">\n\n```rust,no_run\nuse std::{\n    fs,\n    io::{BufReader, prelude::*},\n    net::{TcpListener, TcpStream},\n};\n// --snip--\n\n# fn main() {\n#     let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n# \n#     for stream in listener.incoming() {\n#         let stream = stream.unwrap();\n# \n#         handle_connection(stream);\n#     }\n# }\n# \nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&stream);\n    let http_request: Vec<_> = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    let status_line = \"HTTP/1.1 200 OK\";\n    let contents = fs::read_to_string(\"hello.html\").unwrap();\n    let length = contents.len();\n\n    let response =\n        format!(\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\");\n\n    stream.write_all(response.as_bytes()).unwrap();\n}\n```\n\n</Listing>\n\nDodaliÅ›my `fs` do instrukcji `use`, aby wprowadziÄ‡ moduÅ‚ systemu plikÃ³w biblioteki standardowej do zakresu. Kod do odczytywania zawartoÅ›ci pliku do ciÄ…gu znakÃ³w powinien wyglÄ…daÄ‡ znajomo; uÅ¼yliÅ›my go, gdy czytaliÅ›my zawartoÅ›Ä‡ pliku dla naszego projektu I/O w Listingu 12-4.\n\nNastÄ™pnie uÅ¼ywamy `format!` do dodania zawartoÅ›ci pliku jako treÅ›ci odpowiedzi sukcesu. Aby zapewniÄ‡ prawidÅ‚owÄ… odpowiedÅº HTTP, dodajemy nagÅ‚Ã³wek `Content-Length`, ktÃ³ry jest ustawiony na rozmiar naszej treÅ›ci odpowiedzi â€“ w tym przypadku, rozmiar `hello.html`.\n\nUruchom ten kod za pomocÄ… `cargo run` i zaÅ‚aduj _127.0.0.1:7878_ w swojej przeglÄ…darce; powinieneÅ› zobaczyÄ‡ wyrenderowany HTML!\n\nObecnie ignorujemy dane Å¼Ä…dania w `http_request` i po prostu bezwarunkowo wysyÅ‚amy z powrotem zawartoÅ›Ä‡ pliku HTML. Oznacza to, Å¼e jeÅ›li sprÃ³bujesz zaÅ¼Ä…daÄ‡ _127.0.0.1:7878/cos-innego_ w przeglÄ…darce, nadal otrzymasz tÄ™ samÄ… odpowiedÅº HTML. W tej chwili nasz serwer jest bardzo ograniczony i nie robi tego, co robi wiÄ™kszoÅ›Ä‡ serwerÃ³w WWW. Chcemy dostosowaÄ‡ nasze odpowiedzi w zaleÅ¼noÅ›ci od Å¼Ä…dania i wysyÅ‚aÄ‡ plik HTML tylko dla dobrze sformuÅ‚owanego Å¼Ä…dania do _/_.\n\n### Walidacja Å¼Ä…dania i selektywne odpowiadanie\n\nW tej chwili nasz serwer WWW zwrÃ³ci HTML w pliku niezaleÅ¼nie od tego, co klient zaÅ¼Ä…daÅ‚. Dodajmy funkcjonalnoÅ›Ä‡, aby sprawdziÄ‡, czy przeglÄ…darka Å¼Ä…da _/_ przed zwrÃ³ceniem pliku HTML i aby zwrÃ³ciÄ‡ bÅ‚Ä…d, jeÅ›li przeglÄ…darka zaÅ¼Ä…da czegoÅ› innego. W tym celu musimy zmodyfikowaÄ‡ `handle_connection`, jak pokazano na Listingu 21-6. Ten nowy kod sprawdza zawartoÅ›Ä‡ otrzymanego Å¼Ä…dania w porÃ³wnaniu z tym, jak wyglÄ…da Å¼Ä…danie do _/_, i dodaje bloki `if` i `else`, aby traktowaÄ‡ Å¼Ä…dania inaczej.\n\n<Listing number=\"21-6\" file-name=\"src/main.rs\" caption=\"ObsÅ‚uga Å¼Ä…daÅ„ do */* inaczej niÅ¼ innych Å¼Ä…daÅ„\">\n\n```rust,no_run\n# use std::{\n#     fs,\n#     io::{BufReader, prelude::*},\n#     net::{TcpListener, TcpStream},\n# };\n# \n# fn main() {\n#     let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n# \n#     for stream in listener.incoming() {\n#         let stream = stream.unwrap();\n# \n#         handle_connection(stream);\n#     }\n# }\n// --snip--\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&stream);\n    let request_line = buf_reader.lines().next().unwrap().unwrap();\n\n    if request_line == \"GET / HTTP/1.1\" {\n        let status_line = \"HTTP/1.1 200 OK\";\n        let contents = fs::read_to_string(\"hello.html\").unwrap();\n        let length = contents.len();\n\n        let response = format!(\n            \"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"\n        );\n\n        stream.write_all(response.as_bytes()).unwrap();\n    } else {\n        // inne Å¼Ä…danie\n    }\n}\n```\n\n</Listing>\n\nBÄ™dziemy tylko patrzeÄ‡ na pierwszÄ… liniÄ™ Å¼Ä…dania HTTP, wiÄ™c zamiast odczytywaÄ‡ caÅ‚e Å¼Ä…danie do wektora, wywoÅ‚ujemy `next`, aby pobraÄ‡ pierwszy element z iteratora. Pierwszy `unwrap` zajmuje siÄ™ `Option` i zatrzymuje program, jeÅ›li iterator nie ma Å¼adnych elementÃ³w. Drugi `unwrap` obsÅ‚uguje `Result` i ma taki sam efekt jak `unwrap`, ktÃ³ry zostaÅ‚ dodany w `map` w Listingu 21-2.\n\nNastÄ™pnie sprawdzamy `request_line`, aby zobaczyÄ‡, czy jest rÃ³wna linii Å¼Ä…dania GET do Å›cieÅ¼ki _/_. JeÅ›li tak, blok `if` zwraca zawartoÅ›Ä‡ naszego pliku HTML.\n\nJeÅ›li `request_line` _nie_ jest rÃ³wne Å¼Ä…daniu GET do Å›cieÅ¼ki _/_, oznacza to, Å¼e otrzymaliÅ›my jakieÅ› inne Å¼Ä…danie. Za chwilÄ™ dodamy kod do bloku `else`, aby odpowiedzieÄ‡ na wszystkie inne Å¼Ä…dania.\n\nUruchom ten kod teraz i zaÅ¼Ä…daj _127.0.0.1:7878_; powinieneÅ› otrzymaÄ‡ HTML z _hello.html_. JeÅ›li wyÅ›lesz jakiekolwiek inne Å¼Ä…danie, takie jak _127.0.0.1:7878/cos-innego_, otrzymasz bÅ‚Ä…d poÅ‚Ä…czenia, podobny do tych, ktÃ³re widziaÅ‚eÅ›, uruchamiajÄ…c kod z Listingu 21-1 i Listingu 21-2.\n\nTeraz dodajmy kod z Listingu 21-7 do bloku `else`, aby zwrÃ³ciÄ‡ odpowiedÅº z kodem statusu 404, ktÃ³ry sygnalizuje, Å¼e zawartoÅ›Ä‡ dla Å¼Ä…dania nie zostaÅ‚a znaleziona. ZwrÃ³cimy rÃ³wnieÅ¼ kod HTML dla strony, aby przeglÄ…darka mogÅ‚a jÄ… wyrenderowaÄ‡, wskazujÄ…c odpowiedÅº uÅ¼ytkownikowi koÅ„cowemu.\n\n<Listing number=\"21-7\" file-name=\"src/main.rs\" caption=\"OdpowiedÅº z kodem statusu 404 i stronÄ… bÅ‚Ä™du, jeÅ›li zaÅ¼Ä…dano czegoÅ› innego niÅ¼ */*\">\n\n```rust,no_run\n# use std::{\n#     fs,\n#     io::{BufReader, prelude::*},\n#     net::{TcpListener, TcpStream},\n# };\n# \n# fn main() {\n#     let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n# \n#     for stream in listener.incoming() {\n#         let stream = stream.unwrap();\n# \n#         handle_connection(stream);\n#     }\n# }\n# \n# fn handle_connection(mut stream: TcpStream) {\n#     let buf_reader = BufReader::new(&stream);\n#     let request_line = buf_reader.lines().next().unwrap().unwrap();\n# \n#     if request_line == \"GET / HTTP/1.1\" {\n#         let status_line = \"HTTP/1.1 200 OK\";\n#         let contents = fs::read_to_string(\"hello.html\").unwrap();\n#         let length = contents.len();\n# \n#         let response = format!(\n#             \"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"\n#         );\n# \n#         stream.write_all(response.as_bytes()).unwrap();\n    // --snip--\n    } else {\n        let status_line = \"HTTP/1.1 404 NOT FOUND\";\n        let contents = fs::read_to_string(\"404.html\").unwrap();\n        let length = contents.len();\n\n        let response = format!(\n            \"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"\n        );\n\n        stream.write_all(response.as_bytes()).unwrap();\n    }\n# }\n```\n\n</Listing>\n\nTutaj nasza odpowiedÅº zawiera liniÄ™ statusu z kodem statusu 404 i frazÄ… powodu `NOT FOUND`. CiaÅ‚em odpowiedzi bÄ™dzie HTML z pliku _404.html_. BÄ™dziesz musiaÅ‚ utworzyÄ‡ plik _404.html_ obok _hello.html_ dla strony bÅ‚Ä™du; ponownie, moÅ¼esz uÅ¼yÄ‡ dowolnego kodu HTML, jaki chcesz, lub uÅ¼yÄ‡ przykÅ‚adowego kodu HTML z Listingu 21-8.\n\n<Listing number=\"21-8\" file-name=\"404.html\" caption=\"PrzykÅ‚adowa zawartoÅ›Ä‡ strony do odesÅ‚ania z dowolnÄ… odpowiedziÄ… 404\">\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Witaj!</title>\n  </head>\n  <body>\n    <h1>Ups!</h1>\n    <p>Przepraszam, nie wiem, o co prosisz.</p>\n  </body>\n</html>\n```\n\n</Listing>\n\nDziÄ™ki tym zmianom uruchom ponownie swÃ³j serwer. Å»Ä…danie _127.0.0.1:7878_ powinno zwrÃ³ciÄ‡ zawartoÅ›Ä‡ pliku _hello.html_, a kaÅ¼de inne Å¼Ä…danie, takie jak _127.0.0.1:7878/foo_, powinno zwrÃ³ciÄ‡ kod HTML bÅ‚Ä™du z _404.html_.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"a-touch-of-refactoring\"></a>\n\n### Refaktoryzacja\n\nW tej chwili bloki `if` i `else` majÄ… wiele powtÃ³rzeÅ„: oba odczytujÄ… pliki i zapisujÄ… zawartoÅ›Ä‡ plikÃ³w do strumienia. Jedyne rÃ³Å¼nice to linia statusu i nazwa pliku. UczyÅ„my kod bardziej zwiÄ™zÅ‚ym, wyodrÄ™bniajÄ…c te rÃ³Å¼nice w osobne linie `if` i `else`, ktÃ³re przypiszÄ… wartoÅ›ci linii statusu i nazwy pliku do zmiennych; moÅ¼emy nastÄ™pnie uÅ¼yÄ‡ tych zmiennych bezwarunkowo w kodzie do odczytu pliku i zapisu odpowiedzi. Listing 21-9 pokazuje wynikowy kod po zastÄ…pieniu duÅ¼ych blokÃ³w `if` i `else`.\n\n<Listing number=\"21-9\" file-name=\"src/main.rs\" caption=\"Refaktoryzacja blokÃ³w `if` i `else`, aby zawieraÅ‚y tylko kod, ktÃ³ry rÃ³Å¼ni siÄ™ miÄ™dzy dwoma przypadkami\">\n\n```rust,no_run\n# use std::{\n#     fs,\n#     io::{BufReader, prelude::*},\n#     net::{TcpListener, TcpStream},\n# };\n# \n# fn main() {\n#     let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n# \n#     for stream in listener.incoming() {\n#         let stream = stream.unwrap();\n# \n#         handle_connection(stream);\n#     }\n# }\n// --snip--\n\nfn handle_connection(mut stream: TcpStream) {\n    // --snip--\n#     let buf_reader = BufReader::new(&stream);\n#     let request_line = buf_reader.lines().next().unwrap().unwrap();\n\n    let (status_line, filename) = if request_line == \"GET / HTTP/1.1\" {\n        (\"HTTP/1.1 200 OK\", \"hello.html\")\n    } else {\n        (\"HTTP/1.1 404 NOT FOUND\", \"404.html\")\n    };\n\n    let contents = fs::read_to_string(filename).unwrap();\n    let length = contents.len();\n\n    let response =\n        format!(\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\");\n\n    stream.write_all(response.as_bytes()).unwrap();\n}\n```\n\n</Listing>\n\nTeraz bloki `if` i `else` zwracajÄ… tylko odpowiednie wartoÅ›ci dla linii statusu i nazwy pliku w krotce; nastÄ™pnie uÅ¼ywamy dekompozycji do przypisania tych dwÃ³ch wartoÅ›ci do `status_line` i `filename` za pomocÄ… wzorca w instrukcji `let`, jak omÃ³wiono w Rozdziale 19.\n\nPoprzednio zduplikowany kod znajduje siÄ™ teraz poza blokami `if` i `else` i uÅ¼ywa zmiennych `status_line` i `filename`. UÅ‚atwia to dostrzeÅ¼enie rÃ³Å¼nicy miÄ™dzy dwoma przypadkami, a takÅ¼e oznacza, Å¼e mamy tylko jedno miejsce do aktualizacji kodu, jeÅ›li chcemy zmieniÄ‡ sposÃ³b dziaÅ‚ania odczytu plikÃ³w i zapisu odpowiedzi. Zachowanie kodu z Listingu 21-9 bÄ™dzie takie samo jak z Listingu 21-7.\n\nÅšwietnie! Mamy teraz prosty serwer WWW w okoÅ‚o 40 liniach kodu Rust, ktÃ³ry odpowiada na jedno Å¼Ä…danie stronÄ… treÅ›ci i na wszystkie inne Å¼Ä…dania odpowiedziÄ… 404.\n\nObecnie nasz serwer dziaÅ‚a w jednym wÄ…tku, co oznacza, Å¼e moÅ¼e obsÅ‚ugiwaÄ‡ tylko jedno Å¼Ä…danie na raz. Zbadajmy, jak to moÅ¼e byÄ‡ problemem, symulujÄ…c kilka wolnych Å¼Ä…daÅ„. NastÄ™pnie naprawimy to, aby nasz serwer mÃ³gÅ‚ obsÅ‚ugiwaÄ‡ wiele Å¼Ä…daÅ„ jednoczeÅ›nie.\n",
        "chapter_title": "Budowanie jednowÄ…tkowego serwera WWW"
    },
    {
        "file_path": "ch21-02-multithreaded.md",
        "content": "<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"turning-our-single-threaded-server-into-a-multithreaded-server\"></a>\n<a id=\"from-single-threaded-to-multithreaded-server\"></a>\n\n## Od serwera jednowÄ…tkowego do wielowÄ…tkowego\n\nObecnie serwer bÄ™dzie przetwarzaÅ‚ kaÅ¼de Å¼Ä…danie po kolei, co oznacza, Å¼e nie przetworzy drugiego poÅ‚Ä…czenia, dopÃ³ki pierwsze poÅ‚Ä…czenie nie zostanie zakoÅ„czone. Gdyby serwer otrzymywaÅ‚ coraz wiÄ™cej Å¼Ä…daÅ„, to wykonanie sekwencyjne byÅ‚oby coraz mniej optymalne. JeÅ›li serwer otrzyma Å¼Ä…danie, ktÃ³rego przetwarzanie zajmuje duÅ¼o czasu, kolejne Å¼Ä…dania bÄ™dÄ… musiaÅ‚y czekaÄ‡, aÅ¼ dÅ‚ugie Å¼Ä…danie zostanie zakoÅ„czone, nawet jeÅ›li nowe Å¼Ä…dania mogÄ… byÄ‡ przetworzone szybko. BÄ™dziemy musieli to naprawiÄ‡, ale najpierw przyjrzymy siÄ™ problemowi w dziaÅ‚aniu.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"simulating-a-slow-request-in-the-current-server-implementation\"></a>\n\n### Symulacja wolnego Å¼Ä…dania\n\nPrzyjrzymy siÄ™, jak wolno przetwarzane Å¼Ä…danie moÅ¼e wpÅ‚ywaÄ‡ na inne Å¼Ä…dania wysyÅ‚ane do naszej obecnej implementacji serwera. Listing 21-10 implementuje obsÅ‚ugÄ™ Å¼Ä…dania do _/sleep_ z symulowanÄ… wolnÄ… odpowiedziÄ…, ktÃ³ra spowoduje, Å¼e serwer bÄ™dzie spaÅ‚ przez piÄ™Ä‡ sekund przed odpowiedziÄ….\n\n<Listing number=\"21-10\" file-name=\"src/main.rs\" caption=\"Symulacja wolnego Å¼Ä…dania poprzez uÅ›pienie na piÄ™Ä‡ sekund\">\n\n```rust,no_run\nuse std::{\n    fs,\n    io::{BufReader, prelude::*},\n    net::{TcpListener, TcpStream},\n    thread,\n    time::Duration,\n};\n// --snip--\n# \n# fn main() {\n#     let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n# \n#     for stream in listener.incoming() {\n#         let stream = stream.unwrap();\n# \n#         handle_connection(stream);\n#     }\n# }\n\nfn handle_connection(mut stream: TcpStream) {\n    // --snip--\n\n#     let buf_reader = BufReader::new(&stream);\n#     let request_line = buf_reader.lines().next().unwrap().unwrap();\n# \n    let (status_line, filename) = match &request_line[..] {\n        \"GET / HTTP/1.1\" => (\"HTTP/1.1 200 OK\", \"hello.html\"),\n        \"GET /sleep HTTP/1.1\" => {\n            thread::sleep(Duration::from_secs(5));\n            (\"HTTP/1.1 200 OK\", \"hello.html\")\n        }\n        _ => (\"HTTP/1.1 404 NOT FOUND\", \"404.html\"),\n    };\n\n    // --snip--\n# \n#     let contents = fs::read_to_string(filename).unwrap();\n#     let length = contents.len();\n# \n#     let response =\n#         format!(\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\");\n# \n#     stream.write_all(response.as_bytes()).unwrap();\n}\n```\n\n</Listing>\n\nPrzeÅ‚Ä…czyliÅ›my siÄ™ z `if` na `match`, poniewaÅ¼ mamy teraz trzy przypadki. Musimy jawnie dopasowaÄ‡ do wycinka `request_line`, aby dopasowaÄ‡ wzorce do wartoÅ›ci literaÅ‚Ã³w ciÄ…gÃ³w znakÃ³w; `match` nie wykonuje automatycznego referencjonowania i dereferencjonowania, tak jak to robi metoda rÃ³wnoÅ›ci.\n\nPierwsze ramiÄ™ jest takie samo jak blok `if` z Listingu 21-9. Drugie ramiÄ™ pasuje do Å¼Ä…dania do _/sleep_. Po odebraniu tego Å¼Ä…dania serwer bÄ™dzie spaÅ‚ przez piÄ™Ä‡ sekund przed renderowaniem pomyÅ›lnej strony HTML. Trzecie ramiÄ™ jest takie samo jak blok `else` z Listingu 21-9.\n\nMoÅ¼esz zobaczyÄ‡, jak prymitywny jest nasz serwer: prawdziwe biblioteki obsÅ‚ugiwaÅ‚yby rozpoznawanie wielu Å¼Ä…daÅ„ w znacznie mniej obszerny sposÃ³b!\n\nUruchom serwer za pomocÄ… `cargo run`. NastÄ™pnie otwÃ³rz dwa okna przeglÄ…darki: jedno dla _http://127.0.0.1:7878_ i drugie dla _http://127.0.0.1:7878/sleep_. JeÅ›li wprowadzisz URI _/_ kilka razy, jak poprzednio, zobaczysz, Å¼e odpowiada szybko. Ale jeÅ›li wprowadzisz _/sleep_, a nastÄ™pnie zaÅ‚adujesz _/_, zobaczysz, Å¼e _/_ czeka, aÅ¼ `sleep` zakoÅ„czy swÃ³j peÅ‚ny piÄ™ciosekundowy czas, zanim zostanie zaÅ‚adowane.\n\nIstnieje wiele technik, ktÃ³rych moglibyÅ›my uÅ¼yÄ‡, aby uniknÄ…Ä‡ kumulowania siÄ™ Å¼Ä…daÅ„ za wolnym Å¼Ä…daniem, w tym uÅ¼ycie async, jak zrobiliÅ›my to w Rozdziale 17; ta, ktÃ³rÄ… zaimplementujemy, to pula wÄ…tkÃ³w.\n\n### ZwiÄ™kszanie przepustowoÅ›ci za pomocÄ… puli wÄ…tkÃ³w\n\n_Pula wÄ…tkÃ³w_ to grupa uruchomionych wÄ…tkÃ³w, ktÃ³re sÄ… gotowe i czekajÄ… na obsÅ‚ugÄ™ zadania. Kiedy program otrzymuje nowe zadanie, przypisuje jeden z wÄ…tkÃ³w w puli do tego zadania, a ten wÄ…tek bÄ™dzie przetwarzaÅ‚ zadanie. PozostaÅ‚e wÄ…tki w puli sÄ… dostÄ™pne do obsÅ‚ugi wszelkich innych zadaÅ„, ktÃ³re nadejdÄ…, podczas gdy pierwszy wÄ…tek przetwarza. Kiedy pierwszy wÄ…tek zakoÅ„czy przetwarzanie swojego zadania, zostaje on zwrÃ³cony do puli bezczynnych wÄ…tkÃ³w, gotowy do obsÅ‚ugi nowego zadania. Pula wÄ…tkÃ³w pozwala na wspÃ³Å‚bieÅ¼ne przetwarzanie poÅ‚Ä…czeÅ„, zwiÄ™kszajÄ…c przepustowoÅ›Ä‡ serwera.\n\nOgraniczymy liczbÄ™ wÄ…tkÃ³w w puli do niewielkiej liczby, aby chroniÄ‡ siÄ™ przed atakami DoS; gdyby nasz program tworzyÅ‚ nowy wÄ…tek dla kaÅ¼dego Å¼Ä…dania, gdy ono nadejdzie, ktoÅ›, kto wykona 10 milionÃ³w Å¼Ä…daÅ„ do naszego serwera, mÃ³gÅ‚by spowodowaÄ‡ chaos, zuÅ¼ywajÄ…c wszystkie zasoby naszego serwera i zatrzymujÄ…c przetwarzanie Å¼Ä…daÅ„.\n\nZamiast tworzyÄ‡ nieograniczonÄ… liczbÄ™ wÄ…tkÃ³w, bÄ™dziemy mieÄ‡ staÅ‚Ä… liczbÄ™ wÄ…tkÃ³w oczekujÄ…cych w puli. Å»Ä…dania, ktÃ³re nadejdÄ…, sÄ… wysyÅ‚ane do puli do przetworzenia. Pula bÄ™dzie utrzymywaÄ‡ kolejkÄ™ przychodzÄ…cych Å¼Ä…daÅ„. KaÅ¼dy z wÄ…tkÃ³w w puli pobierze Å¼Ä…danie z tej kolejki, obsÅ‚uÅ¼y je, a nastÄ™pnie poprosi kolejkÄ™ o kolejne Å¼Ä…danie. DziÄ™ki tej konstrukcji moÅ¼emy przetwarzaÄ‡ do _`N`_ Å¼Ä…daÅ„ wspÃ³Å‚bieÅ¼nie, gdzie _`N`_ to liczba wÄ…tkÃ³w. JeÅ›li kaÅ¼dy wÄ…tek odpowiada na dÅ‚ugotrwaÅ‚e Å¼Ä…danie, kolejne Å¼Ä…dania mogÄ… nadal gromadziÄ‡ siÄ™ w kolejce, ale zwiÄ™kszyliÅ›my liczbÄ™ dÅ‚ugotrwaÅ‚ych Å¼Ä…daÅ„, ktÃ³re moÅ¼emy obsÅ‚uÅ¼yÄ‡, zanim osiÄ…gniemy ten punkt.\n\nTa technika to tylko jeden z wielu sposobÃ³w na zwiÄ™kszenie przepustowoÅ›ci serwera WWW. Inne opcje, ktÃ³re moÅ¼esz zbadaÄ‡, to model fork/join, jednowÄ…tkowy model asynchronicznego I/O oraz wielowÄ…tkowy model asynchronicznego I/O. JeÅ›li interesuje CiÄ™ ten temat, moÅ¼esz poczytaÄ‡ wiÄ™cej o innych rozwiÄ…zaniach i sprÃ³bowaÄ‡ je zaimplementowaÄ‡; w jÄ™zyku niskiego poziomu, takim jak Rust, wszystkie te opcje sÄ… moÅ¼liwe.\n\nZanim zaczniemy implementowaÄ‡ pulÄ™ wÄ…tkÃ³w, porozmawiajmy o tym, jak powinno wyglÄ…daÄ‡ uÅ¼ycie puli. Kiedy prÃ³bujesz zaprojektowaÄ‡ kod, najpierw napisanie interfejsu klienta moÅ¼e pomÃ³c w kierowaniu twoim projektem. Napisz API kodu tak, aby byÅ‚o ono ustrukturyzowane w sposÃ³b, w jaki chcesz je wywoÅ‚aÄ‡; nastÄ™pnie zaimplementuj funkcjonalnoÅ›Ä‡ w ramach tej struktury, zamiast implementowaÄ‡ funkcjonalnoÅ›Ä‡, a nastÄ™pnie projektowaÄ‡ publiczne API.\n\nPodobnie jak w Rozdziale 12 stosowaliÅ›my rozwÃ³j sterowany testami, tutaj zastosujemy rozwÃ³j sterowany kompilatorem. Napiszemy kod, ktÃ³ry wywoÅ‚uje poÅ¼Ä…dane funkcje, a nastÄ™pnie bÄ™dziemy analizowaÄ‡ bÅ‚Ä™dy kompilatora, aby okreÅ›liÄ‡, co powinniÅ›my zmieniÄ‡, aby kod zadziaÅ‚aÅ‚. Zanim to jednak zrobimy, zbadamy technikÄ™, ktÃ³rej nie bÄ™dziemy uÅ¼ywaÄ‡ jako punktu wyjÅ›cia.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"code-structure-if-we-could-spawn-a-thread-for-each-request\"></a>\n\n#### Struktura kodu, gdybyÅ›my mogli tworzyÄ‡ wÄ…tek dla kaÅ¼dego Å¼Ä…dania\n\nNajpierw zbadajmy, jak nasz kod mÃ³gÅ‚by wyglÄ…daÄ‡, gdyby tworzyÅ‚ nowy wÄ…tek dla kaÅ¼dego poÅ‚Ä…czenia. Jak wspomniano wczeÅ›niej, nie jest to nasz ostateczny plan ze wzglÄ™du na problemy z potencjalnym tworzeniem nieograniczonej liczby wÄ…tkÃ³w, ale jest to punkt wyjÅ›cia do uzyskania najpierw dziaÅ‚ajÄ…cego serwera wielowÄ…tkowego. NastÄ™pnie dodamy pulÄ™ wÄ…tkÃ³w jako ulepszenie, a kontrastowanie obu rozwiÄ…zaÅ„ bÄ™dzie Å‚atwiejsze.\n\nListing 21-11 pokazuje zmiany, ktÃ³re naleÅ¼y wprowadziÄ‡ w funkcji `main`, aby utworzyÄ‡ nowy wÄ…tek do obsÅ‚ugi kaÅ¼dego strumienia w pÄ™tli `for`.\n\n<Listing number=\"21-11\" file-name=\"src/main.rs\" caption=\"Tworzenie nowego wÄ…tku dla kaÅ¼dego strumienia\">\n\n```rust,no_run\n# use std::{\n#     fs,\n#     io::{BufReader, prelude::*},\n#     net::{TcpListener, TcpStream},\n#     thread,\n#     time::Duration,\n# };\n# \nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n\n        thread::spawn(|| {\n            handle_connection(stream);\n        });\n    }\n}\n# \n# fn handle_connection(mut stream: TcpStream) {\n#     let buf_reader = BufReader::new(&stream);\n#     let request_line = buf_reader.lines().next().unwrap().unwrap();\n# \n#     let (status_line, filename) = match &request_line[..] {\n#         \"GET / HTTP/1.1\" => (\"HTTP/1.1 200 OK\", \"hello.html\"),\n#         \"GET /sleep HTTP/1.1\" => {\n#             thread::sleep(Duration::from_secs(5));\n#             (\"HTTP/1.1 200 OK\", \"hello.html\")\n#         }\n#         _ => (\"HTTP/1.1 404 NOT FOUND\", \"404.html\"),\n#     };\n# \n#     let contents = fs::read_to_string(filename).unwrap();\n#     let length = contents.len();\n# \n#     let response =\n#         format!(\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\");\n# \n#     stream.write_all(response.as_bytes()).unwrap();\n# }\n```\n\n</Listing>\n\nJak nauczyÅ‚eÅ› siÄ™ w Rozdziale 16, `thread::spawn` utworzy nowy wÄ…tek, a nastÄ™pnie uruchomi kod w zamkniÄ™ciu w nowym wÄ…tku. JeÅ›li uruchomisz ten kod i zaÅ‚adujesz _/sleep_ w przeglÄ…darce, a nastÄ™pnie _/_ w dwÃ³ch kolejnych zakÅ‚adkach przeglÄ…darki, faktycznie zobaczysz, Å¼e Å¼Ä…dania do _/_ nie muszÄ… czekaÄ‡ na zakoÅ„czenie _/sleep_. Jednak, jak wspomnieliÅ›my, ostatecznie to przeciÄ…Å¼y system, poniewaÅ¼ tworzyÅ‚byÅ› nowe wÄ…tki bez Å¼adnego limitu.\n\nMoÅ¼esz rÃ³wnieÅ¼ pamiÄ™taÄ‡ z RozdziaÅ‚u 17, Å¼e to jest dokÅ‚adnie ten rodzaj sytuacji, w ktÃ³rej async i await naprawdÄ™ bÅ‚yszczÄ…! Miej to na uwadze, gdy budujemy pulÄ™ wÄ…tkÃ³w i zastanawiamy siÄ™, jak wyglÄ…daÅ‚yby rzeczy inaczej lub tak samo z async.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"creating-a-similar-interface-for-a-finite-number-of-threads\"></a>\n\n#### Tworzenie skoÅ„czonej liczby wÄ…tkÃ³w\n\nChcemy, aby nasza pula wÄ…tkÃ³w dziaÅ‚aÅ‚a w podobny, znajomy sposÃ³b, tak aby przejÅ›cie z wÄ…tkÃ³w na pulÄ™ wÄ…tkÃ³w nie wymagaÅ‚o duÅ¼ych zmian w kodzie, ktÃ³ry uÅ¼ywa naszego API. Listing 21-12 przedstawia hipotetyczny interfejs struktury `ThreadPool`, ktÃ³rej chcemy uÅ¼yÄ‡ zamiast `thread::spawn`.\n\n<Listing number=\"21-12\" file-name=\"src/main.rs\" caption=\"Nasz idealny interfejs `ThreadPool`\">\n\n```rust,ignore,does_not_compile\n# use std::{\n#     fs,\n#     io::{BufReader, prelude::*},\n#     net::{TcpListener, TcpStream},\n#     thread,\n#     time::Duration,\n# };\n# \nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    let pool = ThreadPool::new(4);\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n\n        pool.execute(|| {\n            handle_connection(stream);\n        });\n    }\n}\n# \n# fn handle_connection(mut stream: TcpStream) {\n#     let buf_reader = BufReader::new(&stream);\n#     let request_line = buf_reader.lines().next().unwrap().unwrap();\n# \n#     let (status_line, filename) = match &request_line[..] {\n#         \"GET / HTTP/1.1\" => (\"HTTP/1.1 200 OK\", \"hello.html\"),\n#         \"GET /sleep HTTP/1.1\" => {\n#             thread::sleep(Duration::from_secs(5));\n#             (\"HTTP/1.1 200 OK\", \"hello.html\")\n#         }\n#         _ => (\"HTTP/1.1 404 NOT FOUND\", \"404.html\"),\n#     };\n# \n#     let contents = fs::read_to_string(filename).unwrap();\n#     let length = contents.len();\n# \n#     let response =\n#         format!(\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\");\n# \n#     stream.write_all(response.as_bytes()).unwrap();\n# }\n```\n\n</Listing>\n\nUÅ¼ywamy `ThreadPool::new` do utworzenia nowej puli wÄ…tkÃ³w z konfigurowalnÄ… liczbÄ… wÄ…tkÃ³w, w tym przypadku czterech. NastÄ™pnie, w pÄ™tli `for`, `pool.execute` ma podobny interfejs do `thread::spawn` w tym sensie, Å¼e przyjmuje zamkniÄ™cie, ktÃ³re pula powinna uruchomiÄ‡ dla kaÅ¼dego strumienia. Musimy zaimplementowaÄ‡ `pool.execute` tak, aby przyjmowaÅ‚ zamkniÄ™cie i przekazywaÅ‚ je do wÄ…tku w puli do uruchomienia. Ten kod jeszcze siÄ™ nie skompiluje, ale sprÃ³bujemy, aby kompilator mÃ³gÅ‚ nas poprowadziÄ‡, jak go naprawiÄ‡.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"building-the-threadpool-struct-using-compiler-driven-development\"></a>\n\n#### Budowanie `ThreadPool` za pomocÄ… rozwoju sterowanego kompilatorem\n\nWprowadÅº zmiany z Listingu 21-12 do _src/main.rs_, a nastÄ™pnie uÅ¼yjmy bÅ‚Ä™dÃ³w kompilatora z `cargo check`, aby kierowaÄ‡ naszym rozwojem. Oto pierwszy bÅ‚Ä…d, ktÃ³ry otrzymujemy:\n\n```console\n$ cargo check\n    Sprawdzanie hello v0.1.0 (file:///projects/hello)\nerror[E0433]: nie udaÅ‚o siÄ™ rozwiÄ…zaÄ‡: uÅ¼ycie niezadeklarowanego typu `ThreadPool`\n  --> src/main.rs:11:16\n   |\n11 |     let pool = ThreadPool::new(4);\n   |                ^^^^^^^^^^ uÅ¼ycie niezadeklarowanego typu `ThreadPool`\n\nWiÄ™cej informacji o tym bÅ‚Ä™dzie znajdziesz, uÅ¼ywajÄ…c `rustc --explain E0433`.\nerror: nie udaÅ‚o siÄ™ skompilowaÄ‡ `hello` (bin \"hello\") z powodu 1 poprzedniego bÅ‚Ä™du\n```\n\nÅšwietnie! Ten bÅ‚Ä…d mÃ³wi nam, Å¼e potrzebujemy typu lub moduÅ‚u `ThreadPool`, wiÄ™c teraz go zbudujemy. Nasza implementacja `ThreadPool` bÄ™dzie niezaleÅ¼na od rodzaju pracy, jakÄ… wykonuje nasz serwer WWW. Zatem, zmieÅ„my skrzynkÄ™ `hello` z skrzynki binarnej na skrzynkÄ™ biblioteki, aby przechowywaÄ‡ naszÄ… implementacjÄ™ `ThreadPool`. Po zmianie na skrzynkÄ™ biblioteki, moglibyÅ›my rÃ³wnieÅ¼ uÅ¼ywaÄ‡ oddzielnej biblioteki puli wÄ…tkÃ³w do dowolnej pracy, ktÃ³rÄ… chcemy wykonaÄ‡ za pomocÄ… puli wÄ…tkÃ³w, a nie tylko do obsÅ‚ugi Å¼Ä…daÅ„ WWW.\n\nUtwÃ³rz plik _src/lib.rs_ zawierajÄ…cy nastÄ™pujÄ…cÄ…, najprostszÄ… definicjÄ™ struktury `ThreadPool`, jakÄ… moÅ¼emy na razie mieÄ‡:\n\n<Listing file-name=\"src/lib.rs\">\n\n```rust,noplayground\npub struct ThreadPool;\n```\n\n</Listing>\n\n\nNastÄ™pnie edytuj plik _main.rs_, aby wprowadziÄ‡ `ThreadPool` do zakresu z skrzynki biblioteki, dodajÄ…c nastÄ™pujÄ…cy kod na poczÄ…tku _src/main.rs_:\n\n<Listing file-name=\"src/main.rs\">\n\n```rust,ignore\nuse hello::ThreadPool;\n# use std::{\n#     fs,\n#     io::{BufReader, prelude::*},\n#     net::{TcpListener, TcpStream},\n#     thread,\n#     time::Duration,\n# };\n# \n# fn main() {\n#     let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n#     let pool = ThreadPool::new(4);\n# \n#     for stream in listener.incoming() {\n#         let stream = stream.unwrap();\n# \n#         pool.execute(|| {\n#             handle_connection(stream);\n#         });\n#     }\n# }\n# \n# fn handle_connection(mut stream: TcpStream) {\n#     let buf_reader = BufReader::new(&stream);\n#     let request_line = buf_reader.lines().next().unwrap().unwrap();\n# \n#     let (status_line, filename) = match &request_line[..] {\n#         \"GET / HTTP/1.1\" => (\"HTTP/1.1 200 OK\", \"hello.html\"),\n#         \"GET /sleep HTTP/1.1\" => {\n#             thread::sleep(Duration::from_secs(5));\n#             (\"HTTP/1.1 200 OK\", \"hello.html\")\n#         }\n#         _ => (\"HTTP/1.1 404 NOT FOUND\", \"404.html\"),\n#     };\n# \n#     let contents = fs::read_to_string(filename).unwrap();\n#     let length = contents.len();\n# \n#     let response =\n#         format!(\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\");\n# \n#     stream.write_all(response.as_bytes()).unwrap();\n# }\n```\n\n</Listing>\n\nTen kod nadal nie bÄ™dzie dziaÅ‚aÄ‡, ale sprawdÅºmy go ponownie, aby otrzymaÄ‡ nastÄ™pny bÅ‚Ä…d, ktÃ³rym musimy siÄ™ zajÄ…Ä‡:\n\n```console\n$ cargo check\n    Sprawdzanie hello v0.1.0 (file:///projects/hello)\nerror[E0599]: nie znaleziono funkcji ani elementu stowarzyszonego o nazwie `new` dla struktury `ThreadPool` w bieÅ¼Ä…cym zakresie\n  --> src/main.rs:12:28\n   |\n12 |     let pool = ThreadPool::new(4);\n   |                            ^^^ nie znaleziono funkcji ani elementu stowarzyszonego w `ThreadPool`\n\nWiÄ™cej informacji o tym bÅ‚Ä™dzie znajdziesz, uÅ¼ywajÄ…c `rustc --explain E0599`.\nerror: nie udaÅ‚o siÄ™ skompilowaÄ‡ `hello` (bin \"hello\") z powodu 1 poprzedniego bÅ‚Ä™du\n```\n\nTen bÅ‚Ä…d wskazuje, Å¼e nastÄ™pnym krokiem jest utworzenie stowarzyszonej funkcji o nazwie `new` dla `ThreadPool`. Wiemy rÃ³wnieÅ¼, Å¼e `new` musi mieÄ‡ jeden parametr, ktÃ³ry moÅ¼e przyjÄ…Ä‡ `4` jako argument i powinien zwracaÄ‡ instancjÄ™ `ThreadPool`. Zaimplementujmy najprostszÄ… funkcjÄ™ `new`, ktÃ³ra bÄ™dzie miaÅ‚a te cechy:\n\n<Listing file-name=\"src/lib.rs\">\n\n```rust,noplayground\npub struct ThreadPool;\n\nimpl ThreadPool {\n    pub fn new(size: usize) -> ThreadPool {\n        ThreadPool\n    }\n}\n```\n\n</Listing>\n\nWybraliÅ›my `usize` jako typ parametru `size`, poniewaÅ¼ wiemy, Å¼e ujemna liczba wÄ…tkÃ³w nie ma sensu. Wiemy rÃ³wnieÅ¼, Å¼e uÅ¼yjemy tej `4` jako liczby elementÃ³w w kolekcji wÄ…tkÃ³w, do czego sÅ‚uÅ¼y typ `usize`, jak omÃ³wiono w sekcji [â€Typy caÅ‚kowiteâ€][integer-types]<!-- ignore --> w Rozdziale 3.\n\nSprawdÅºmy ponownie kod:\n\n```console\n$ cargo check\n    Sprawdzanie hello v0.1.0 (file:///projects/hello)\nerror[E0599]: nie znaleziono metody o nazwie `execute` dla struktury `ThreadPool` w bieÅ¼Ä…cym zakresie\n  --> src/main.rs:17:14\n   |\n17 |         pool.execute(|| {\n   |         -----^^^^^^^ nie znaleziono metody w `ThreadPool`\n\nWiÄ™cej informacji o tym bÅ‚Ä™dzie znajdziesz, uÅ¼ywajÄ…c `rustc --explain E0599`.\nerror: nie udaÅ‚o siÄ™ skompilowaÄ‡ `hello` (bin \"hello\") z powodu 1 poprzedniego bÅ‚Ä™du\n```\n\nTeraz bÅ‚Ä…d wystÄ™puje, poniewaÅ¼ nie mamy metody `execute` na `ThreadPool`. Przypomnij sobie z sekcji [â€Tworzenie skoÅ„czonej liczby wÄ…tkÃ³wâ€](#creating-a-finite-number-of-threads)<!-- ignore -->, Å¼e zdecydowaliÅ›my, iÅ¼ nasza pula wÄ…tkÃ³w powinna mieÄ‡ interfejs podobny do `thread::spawn`. Ponadto, zaimplementujemy funkcjÄ™ `execute` tak, aby pobieraÅ‚a przekazane jej zamkniÄ™cie i oddawaÅ‚a je bezczynnemu wÄ…tkowi w puli do uruchomienia.\n\nZdefiniujemy metodÄ™ `execute` na `ThreadPool`, aby przyjmowaÅ‚a zamkniÄ™cie jako parametr. Przypomnij sobie z sekcji [â€Przenoszenie przechwyconych wartoÅ›ci poza zamkniÄ™ciaâ€][moving-out-of-closures]<!-- ignore --> w Rozdziale 13, Å¼e moÅ¼emy przyjmowaÄ‡ zamkniÄ™cia jako parametry z trzema rÃ³Å¼nymi cechami: `Fn`, `FnMut` i `FnOnce`. Musimy zdecydowaÄ‡, jaki rodzaj zamkniÄ™cia uÅ¼yÄ‡ tutaj. Wiemy, Å¼e skoÅ„czymy robiÄ…c coÅ› podobnego do implementacji `thread::spawn` z biblioteki standardowej, wiÄ™c moÅ¼emy spojrzeÄ‡ na ograniczenia, jakie ma sygnatura `thread::spawn` na swoim parametrze. Dokumentacja pokazuje nam nastÄ™pujÄ…ce:\n\n```rust,ignore\npub fn spawn<F, T>(f: F) -> JoinHandle<T>\n    where\n        F: FnOnce() -> T,\n        F: Send + 'static,\n        T: Send + 'static,\n```\n\nParametr typu `F` jest tym, ktÃ³ry nas tutaj interesuje; parametr typu `T` jest zwiÄ…zany z wartoÅ›ciÄ… zwracanÄ…, a tym siÄ™ nie zajmujemy. Widzimy, Å¼e `spawn` uÅ¼ywa `FnOnce` jako ograniczenia cechy dla `F`. To prawdopodobnie to, czego chcemy, poniewaÅ¼ ostatecznie przekaÅ¼emy argument, ktÃ³ry otrzymamy w `execute`, do `spawn`. MoÅ¼emy byÄ‡ jeszcze bardziej pewni, Å¼e `FnOnce` to cecha, ktÃ³rej chcemy uÅ¼yÄ‡, poniewaÅ¼ wÄ…tek do uruchomienia Å¼Ä…dania wykona zamkniÄ™cie tego Å¼Ä…dania tylko raz, co pasuje do `Once` w `FnOnce`.\n\nParametr typu `F` ma rÃ³wnieÅ¼ ograniczenie cechy `Send` i ograniczenie czasu Å¼ycia `'static`, ktÃ³re sÄ… przydatne w naszej sytuacji: potrzebujemy `Send` do przeniesienia zamkniÄ™cia z jednego wÄ…tku do drugiego oraz `'static`, poniewaÅ¼ nie wiemy, jak dÅ‚ugo wÄ…tek bÄ™dzie wykonywaÅ‚. StwÃ³rzmy metodÄ™ `execute` na `ThreadPool`, ktÃ³ra bÄ™dzie przyjmowaÄ‡ parametr generyczny typu `F` z tymi ograniczeniami:\n\n<Listing file-name=\"src/lib.rs\">\n\n```rust,noplayground\n# pub struct ThreadPool;\n# \nimpl ThreadPool {\n    // --snip--\n#     pub fn new(size: usize) -> ThreadPool {\n#         ThreadPool\n#     }\n# \n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static,\n    {\n    }\n}\n```\n\n</Listing>\n\nNadal uÅ¼ywamy `()` po `FnOnce`, poniewaÅ¼ to `FnOnce` reprezentuje zamkniÄ™cie, ktÃ³re nie przyjmuje Å¼adnych parametrÃ³w i zwraca typ jednostkowy `()`. Podobnie jak w definicjach funkcji, typ zwracany moÅ¼e byÄ‡ pominiÄ™ty z sygnatury, ale nawet jeÅ›li nie mamy parametrÃ³w, nadal potrzebujemy nawiasÃ³w.\n\nPowoÅ‚ujÄ…c siÄ™ na to, jest to najprostsza implementacja metody `execute`: nic nie robi, ale staramy siÄ™ tylko, aby nasz kod siÄ™ skompilowaÅ‚. SprawdÅºmy to ponownie:\n\n```console\n$ cargo check\n    Sprawdzanie hello v0.1.0 (file:///projects/hello)\n    ZakoÅ„czono `dev` profil [nieoptymalny + debuginfo] cel(e) w 0.24s\n```\n\nKompiluje siÄ™! Ale zwrÃ³Ä‡ uwagÄ™, Å¼e jeÅ›li sprÃ³bujesz `cargo run` i wyÅ›lesz Å¼Ä…danie w przeglÄ…darce, zobaczysz bÅ‚Ä™dy w przeglÄ…darce, ktÃ³re widzieliÅ›my na poczÄ…tku rozdziaÅ‚u. Nasza biblioteka jeszcze nie wywoÅ‚uje zamkniÄ™cia przekazanego do `execute`!\n\n> Uwaga: Powiedzenie, ktÃ³re moÅ¼esz usÅ‚yszeÄ‡ o jÄ™zykach z rygorystycznymi kompilatorami, takich jak Haskell i Rust, brzmi: â€JeÅ›li kod siÄ™ kompiluje, to dziaÅ‚aâ€. Ale to powiedzenie nie jest uniwersalnie prawdziwe. Nasz projekt siÄ™ kompiluje, ale absolutnie nic nie robi! GdybyÅ›my budowali prawdziwy, kompletny projekt, byÅ‚by to dobry moment, aby zaczÄ…Ä‡ pisaÄ‡ testy jednostkowe, aby sprawdziÄ‡, czy kod siÄ™ kompiluje _i_ ma poÅ¼Ä…dane zachowanie.\n\nZastanÃ³w siÄ™: co byÅ‚oby tu inne, gdybyÅ›my zamiast zamkniÄ™cia wykonywali przyszÅ‚oÅ›Ä‡?\n\n#### Walidacja liczby wÄ…tkÃ³w w `new`\n\nNic nie robimy z parametrami `new` i `execute`. Zaimplementujmy ciaÅ‚a tych funkcji z poÅ¼Ä…danym zachowaniem. Na poczÄ…tek pomyÅ›lmy o `new`. WczeÅ›niej wybraliÅ›my typ bez znaku dla parametru `size`, poniewaÅ¼ pula z ujemnÄ… liczbÄ… wÄ…tkÃ³w nie ma sensu. Jednak pula z zerowÄ… liczbÄ… wÄ…tkÃ³w rÃ³wnieÅ¼ nie ma sensu, a zero jest jak najbardziej prawidÅ‚owym `usize`. Dodamy kod, ktÃ³ry sprawdzi, czy `size` jest wiÄ™ksze od zera, zanim zwrÃ³cimy instancjÄ™ `ThreadPool`, i spowodujemy panikÄ™ programu, jeÅ›li otrzyma zero, uÅ¼ywajÄ…c makra `assert!`, jak pokazano na Listingu 21-13.\n\n<Listing number=\"21-13\" file-name=\"src/lib.rs\" caption=\"Implementacja `ThreadPool::new` w celu paniki, jeÅ›li `size` wynosi zero\">\n\n```rust,noplayground\n# pub struct ThreadPool;\n# \nimpl ThreadPool {\n    /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.\n    ///\n    /// `size` to liczba wÄ…tkÃ³w w puli.\n    ///\n    /// # Panics\n    ///\n    /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        ThreadPool\n    }\n\n    // --snip--\n#     pub fn execute<F>(&self, f: F)\n#     where\n#         F: FnOnce() + Send + 'static,\n#     {\n#     }\n}\n```\n\n</Listing>\n\nDodaliÅ›my rÃ³wnieÅ¼ dokumentacjÄ™ dla naszego `ThreadPool` za pomocÄ… komentarzy doc. ZauwaÅ¼, Å¼e zastosowaliÅ›my dobre praktyki dokumentacyjne, dodajÄ…c sekcjÄ™, ktÃ³ra wskazuje sytuacje, w ktÃ³rych nasza funkcja moÅ¼e spowodowaÄ‡ panikÄ™, jak omÃ³wiono w Rozdziale 14. SprÃ³buj uruchomiÄ‡ `cargo doc --open` i kliknÄ…Ä‡ strukturÄ™ `ThreadPool`, aby zobaczyÄ‡, jak wyglÄ…dajÄ… wygenerowane dokumenty dla `new`!\n\nZamiast dodawaÄ‡ makro `assert!`, jak to zrobiliÅ›my tutaj, moglibyÅ›my zmieniÄ‡ `new` na `build` i zwrÃ³ciÄ‡ `Result`, tak jak zrobiliÅ›my to z `Config::build` w projekcie I/O w Listingu 12-9. Ale w tym przypadku zdecydowaliÅ›my, Å¼e prÃ³ba utworzenia puli wÄ…tkÃ³w bez Å¼adnych wÄ…tkÃ³w powinna byÄ‡ nieodwracalnym bÅ‚Ä™dem. JeÅ›li czujesz siÄ™ ambitny, sprÃ³buj napisaÄ‡ funkcjÄ™ o nazwie `build` z nastÄ™pujÄ…cÄ… sygnaturÄ…, aby porÃ³wnaÄ‡ jÄ… z funkcjÄ… `new`:\n\n```rust,ignore\npub fn build(size: usize) -> Result<ThreadPool, PoolCreationError> {\n```\n\n#### Tworzenie miejsca na przechowywanie wÄ…tkÃ³w\n\nTeraz, gdy wiemy, Å¼e mamy prawidÅ‚owÄ… liczbÄ™ wÄ…tkÃ³w do przechowywania w puli, moÅ¼emy utworzyÄ‡ te wÄ…tki i przechowywaÄ‡ je w strukturze `ThreadPool` przed zwrÃ³ceniem tej struktury. Ale jak â€przechowujemyâ€ wÄ…tek? SpÃ³jrzmy jeszcze raz na sygnaturÄ™ `thread::spawn`:\n\n```rust,ignore\npub fn spawn<F, T>(f: F) -> JoinHandle<T>\n    where\n        F: FnOnce() -> T,\n        F: Send + 'static,\n        T: Send + 'static,\n```\n\nFunkcja `spawn` zwraca `JoinHandle<T>`, gdzie `T` to typ, ktÃ³ry zwraca zamkniÄ™cie. SprÃ³bujmy uÅ¼yÄ‡ `JoinHandle` i zobaczmy, co siÄ™ stanie. W naszym przypadku zamkniÄ™cia, ktÃ³re przekazujemy do puli wÄ…tkÃ³w, bÄ™dÄ… obsÅ‚ugiwaÄ‡ poÅ‚Ä…czenie i nic nie zwracaÄ‡, wiÄ™c `T` bÄ™dzie typem jednostkowym `()`.\n\nKod z Listingu 21-14 skompiluje siÄ™, ale jeszcze nie tworzy Å¼adnych wÄ…tkÃ³w. ZmieniliÅ›my definicjÄ™ `ThreadPool`, aby przechowywaÅ‚a wektor instancji `thread::JoinHandle<()>`, zainicjalizowaliÅ›my wektor o pojemnoÅ›ci `size`, skonfigurowaliÅ›my pÄ™tlÄ™ `for`, ktÃ³ra uruchomi kod do tworzenia wÄ…tkÃ³w, i zwrÃ³ciÅ‚a instancjÄ™ `ThreadPool` zawierajÄ…cÄ… je.\n\n<Listing number=\"21-14\" file-name=\"src/lib.rs\" caption=\"Tworzenie wektora dla `ThreadPool` do przechowywania wÄ…tkÃ³w\">\n\n```rust,ignore,not_desired_behavior\nuse std::thread;\n\npub struct ThreadPool {\n    threads: Vec<thread::JoinHandle<()>>,\n}\n\nimpl ThreadPool {\n    // --snip--\n#     /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.\n#     ///\n#     /// `size` to liczba wÄ…tkÃ³w w puli.\n#     ///\n#     /// # Panics\n#     ///\n#     /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let mut threads = Vec::with_capacity(size);\n\n        for _ in 0..size {\n            // utwÃ³rz kilka wÄ…tkÃ³w i zapisz je w wektorze\n        }\n\n        ThreadPool { threads }\n    }\n    // --snip--\n# \n#     pub fn execute<F>(&self, f: F)\n#     where\n#         F: FnOnce() + Send + 'static,\n#     {\n#     }\n}\n```\n\n</Listing>\n\nWprowadziliÅ›my `std::thread` do zakresu w skrzynce biblioteki, poniewaÅ¼ uÅ¼ywamy `thread::JoinHandle` jako typu elementÃ³w w wektorze w `ThreadPool`.\n\nPo otrzymaniu prawidÅ‚owego rozmiaru, nasz `ThreadPool` tworzy nowy wektor, ktÃ³ry moÅ¼e przechowywaÄ‡ `size` elementÃ³w. Funkcja `with_capacity` wykonuje to samo zadanie co `Vec::new`, ale z waÅ¼nÄ… rÃ³Å¼nicÄ…: wstÄ™pnie alokuje miejsce w wektorze. PoniewaÅ¼ wiemy, Å¼e musimy przechowywaÄ‡ `size` elementÃ³w w wektorze, wykonanie tej alokacji z gÃ³ry jest nieco bardziej wydajne niÅ¼ uÅ¼ycie `Vec::new`, ktÃ³ry zmienia rozmiar w miarÄ™ wstawiania elementÃ³w.\n\nPo ponownym uruchomieniu `cargo check` powinno siÄ™ udaÄ‡.\n\n<!-- Old headings. Do not remove or links may break. -->\n<a id =\"a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread\"></a>\n\n#### WysyÅ‚anie kodu z `ThreadPool` do wÄ…tku\n\nZostawiliÅ›my komentarz w pÄ™tli `for` w Listingu 21-14 dotyczÄ…cy tworzenia wÄ…tkÃ³w. Tutaj przyjrzymy siÄ™, jak faktycznie tworzymy wÄ…tki. Biblioteka standardowa zapewnia `thread::spawn` jako sposÃ³b tworzenia wÄ…tkÃ³w, a `thread::spawn` oczekuje kodu, ktÃ³ry wÄ…tek powinien uruchomiÄ‡ natychmiast po utworzeniu wÄ…tku. Jednak w naszym przypadku chcemy utworzyÄ‡ wÄ…tki i sprawiÄ‡, by _czekaÅ‚y_ na kod, ktÃ³ry wyÅ›lemy pÃ³Åºniej. Implementacja wÄ…tkÃ³w w bibliotece standardowej nie zawiera sposobu, aby to zrobiÄ‡; musimy to zaimplementowaÄ‡ rÄ™cznie.\n\nZaimplementujemy to zachowanie, wprowadzajÄ…c nowÄ… strukturÄ™ danych miÄ™dzy `ThreadPool` a wÄ…tkami, ktÃ³ra bÄ™dzie zarzÄ…dzaÄ‡ tym nowym zachowaniem. Nazwiemy tÄ™ strukturÄ™ danych _Worker_, co jest powszechnym terminem w implementacjach puli. `Worker` pobiera kod, ktÃ³ry musi zostaÄ‡ uruchomiony, i uruchamia go w swoim wÄ…tku.\n\nPomyÅ›l o ludziach pracujÄ…cych w kuchni w restauracji: pracownicy czekajÄ…, aÅ¼ przyjdÄ… zamÃ³wienia od klientÃ³w, a nastÄ™pnie sÄ… odpowiedzialni za przyjÄ™cie tych zamÃ³wieÅ„ i ich zrealizowanie.\n\nZamiast przechowywaÄ‡ wektor instancji `JoinHandle<()>` w puli wÄ…tkÃ³w, bÄ™dziemy przechowywaÄ‡ instancje struktury `Worker`. KaÅ¼dy `Worker` bÄ™dzie przechowywaÅ‚ pojedynczÄ… instancjÄ™ `JoinHandle<()>`. NastÄ™pnie zaimplementujemy metodÄ™ w `Worker`, ktÃ³ra przyjmie zamkniÄ™cie kodu do uruchomienia i wyÅ›le je do juÅ¼ dziaÅ‚ajÄ…cego wÄ…tku do wykonania. KaÅ¼demu `Workerowi` nadamy rÃ³wnieÅ¼ `id`, abyÅ›my mogli odrÃ³Å¼niÄ‡ rÃ³Å¼ne instancje `Worker` w puli podczas logowania lub debugowania.\n\nOto nowy proces, ktÃ³ry nastÄ…pi po utworzeniu `ThreadPool`. Kod, ktÃ³ry wysyÅ‚a zamkniÄ™cie do wÄ…tku, zaimplementujemy po skonfigurowaniu `Worker` w ten sposÃ³b:\n\n1. Zdefiniuj strukturÄ™ `Worker`, ktÃ³ra zawiera `id` i `JoinHandle<()>`. \n2. ZmieÅ„ `ThreadPool`, aby zawieraÅ‚ wektor instancji `Worker`. \n3. Zdefiniuj funkcjÄ™ `Worker::new`, ktÃ³ra przyjmuje numer `id` i zwraca instancjÄ™ `Worker` zawierajÄ…cÄ… `id` i wÄ…tek uruchomiony z pustym zamkniÄ™ciem. \n4. W `ThreadPool::new` uÅ¼yj licznika pÄ™tli `for` do wygenerowania `id`, utwÃ³rz nowego `Worker` z tym `id` i przechowuj `Worker` w wektorze.\n\nJeÅ›li jesteÅ› gotowy na wyzwanie, sprÃ³buj samodzielnie zaimplementowaÄ‡ te zmiany, zanim spojrzysz na kod w Listingu 21-15.\n\nGotowy? Oto Listing 21-15 z jednym ze sposobÃ³w wprowadzenia powyÅ¼szych modyfikacji.\n\n<Listing number=\"21-15\" file-name=\"src/lib.rs\" caption=\"Modyfikacja `ThreadPool` w celu przechowywania instancji `Worker` zamiast bezpoÅ›redniego przechowywania wÄ…tkÃ³w\">\n\n```rust,noplayground\nuse std::thread;\n\npub struct ThreadPool {\n    workers: Vec<Worker>,\n}\n\nimpl ThreadPool {\n    // --snip--\n#     /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.\n#     ///\n#     /// `size` to liczba wÄ…tkÃ³w w puli.\n#     ///\n#     /// # Panics\n#     ///\n#     /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id));\n        }\n\n        ThreadPool { workers }\n    }\n    // --snip--\n# \n#     pub fn execute<F>(&self, f: F)\n#     where\n#         F: FnOnce() + Send + 'static,\n#     {\n#     }\n}\n\nstruct Worker {\n    id: usize,\n    thread: thread::JoinHandle<()>,\n}\n\nimpl Worker {\n    fn new(id: usize) -> Worker {\n        let thread = thread::spawn(|| {});\n\n        Worker { id, thread }\n    }\n}\n```\n\n</Listing>\n\nZmieniliÅ›my nazwÄ™ pola w `ThreadPool` z `threads` na `workers`, poniewaÅ¼ teraz przechowuje ono instancje `Worker` zamiast instancji `JoinHandle<()>`. UÅ¼ywamy licznika w pÄ™tli `for` jako argumentu do `Worker::new` i przechowujemy kaÅ¼dego nowego `Worker` w wektorze o nazwie `workers`.\n\nZewnÄ™trzny kod (taki jak nasz serwer w _src/main.rs_) nie musi znaÄ‡ szczegÃ³Å‚Ã³w implementacji dotyczÄ…cych uÅ¼ywania struktury `Worker` w `ThreadPool`, dlatego sprawiamy, Å¼e struktura `Worker` i jej funkcja `new` sÄ… prywatne. Funkcja `Worker::new` uÅ¼ywa podanego przez nas `id` i przechowuje instancjÄ™ `JoinHandle<()>`, ktÃ³ra jest tworzona poprzez uruchomienie nowego wÄ…tku za pomocÄ… pustego zamkniÄ™cia.\n\n> Uwaga: JeÅ›li system operacyjny nie moÅ¼e utworzyÄ‡ wÄ…tku z powodu niewystarczajÄ…cych zasobÃ³w systemowych, `thread::spawn` spowoduje panikÄ™. To spowoduje panikÄ™ caÅ‚ego naszego serwera, nawet jeÅ›li utworzenie niektÃ³rych wÄ…tkÃ³w moÅ¼e siÄ™ powieÅ›Ä‡. Dla uproszczenia, takie zachowanie jest w porzÄ…dku, ale w produkcyjnej implementacji puli wÄ…tkÃ³w prawdopodobnie chciaÅ‚byÅ› uÅ¼yÄ‡ [`std::thread::Builder`][builder]<!-- ignore --> i jego metody [`spawn`][builder-spawn]<!-- ignore -->, ktÃ³ra zamiast tego zwraca `Result`.\n\nTen kod skompiluje siÄ™ i przechowuje liczbÄ™ instancji `Worker`, ktÃ³rÄ… okreÅ›liliÅ›my jako argument do `ThreadPool::new`. Ale _nadal_ nie przetwarzamy zamkniÄ™cia, ktÃ³re otrzymujemy w `execute`. Przyjrzyjmy siÄ™, jak to zrobiÄ‡ w nastÄ™pnej kolejnoÅ›ci.\n\n#### WysyÅ‚anie Å¼Ä…daÅ„ do wÄ…tkÃ³w za poÅ›rednictwem kanaÅ‚Ã³w\n\nNastÄ™pny problem, ktÃ³rym siÄ™ zajmiemy, to fakt, Å¼e zamkniÄ™cia przekazane do `thread::spawn` absolutnie nic nie robiÄ…. Obecnie zamkniÄ™cie, ktÃ³re chcemy wykonaÄ‡, otrzymujemy w metodzie `execute`. Ale musimy przekazaÄ‡ `thread::spawn` zamkniÄ™cie do uruchomienia, gdy tworzymy kaÅ¼dego `Worker` podczas tworzenia `ThreadPool`.\n\nChcemy, aby struktury `Worker`, ktÃ³re wÅ‚aÅ›nie utworzyliÅ›my, pobieraÅ‚y kod do uruchomienia z kolejki przechowywanej w `ThreadPool` i wysyÅ‚aÅ‚y ten kod do swojego wÄ…tku do wykonania.\n\nKanaÅ‚y, o ktÃ³rych dowiedzieliÅ›my siÄ™ w Rozdziale 16 â€“ prosty sposÃ³b komunikacji miÄ™dzy dwoma wÄ…tkami â€“ byÅ‚yby idealne do tego zastosowania. UÅ¼yjemy kanaÅ‚u do peÅ‚nienia funkcji kolejki zadaÅ„, a `execute` wyÅ›le zadanie z `ThreadPool` do instancji `Worker`, ktÃ³re wyÅ›lÄ… zadanie do swojego wÄ…tku. Oto plan:\n\n1. `ThreadPool` utworzy kanaÅ‚ i bÄ™dzie trzymaÄ‡ siÄ™ nadawcy.\n2. KaÅ¼dy `Worker` bÄ™dzie trzymaÄ‡ siÄ™ odbiorcy.\n3. Utworzymy nowÄ… strukturÄ™ `Job`, ktÃ³ra bÄ™dzie przechowywaÄ‡ zamkniÄ™cia, ktÃ³re chcemy wysÅ‚aÄ‡ kanaÅ‚em.\n4. Metoda `execute` wyÅ›le zadanie, ktÃ³re chce wykonaÄ‡, za poÅ›rednictwem nadawcy.\n5. W swoim wÄ…tku, `Worker` bÄ™dzie iterowaÅ‚ po swoim odbiorniku i wykonywaÅ‚ zamkniÄ™cia wszystkich otrzymanych zadaÅ„.\n\nZacznijmy od utworzenia kanaÅ‚u w `ThreadPool::new` i przechowywania nadawcy w instancji `ThreadPool`, jak pokazano na Listingu 21-16. Struktura `Job` na razie nic nie przechowuje, ale bÄ™dzie typem elementu, ktÃ³ry wysyÅ‚amy kanaÅ‚em.\n\n<Listing number=\"21-16\" file-name=\"src/lib.rs\" caption=\"Modyfikacja `ThreadPool` w celu przechowywania nadawcy kanaÅ‚u, ktÃ³ry przesyÅ‚a instancje `Job`\">\n\n```rust,noplayground\nuse std::{sync::mpsc, thread};\n\npub struct ThreadPool {\n    workers: Vec<Worker>,\n    sender: mpsc::Sender<Job>,\n}\n\nstruct Job;\n\nimpl ThreadPool {\n    // --snip--\n#     /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.\n#     ///\n#     /// `size` to liczba wÄ…tkÃ³w w puli.\n#     ///\n#     /// # Panics\n#     ///\n#     /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let (sender, receiver) = mpsc::channel();\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id));\n        }\n\n        ThreadPool { workers, sender }\n    }\n    // --snip--\n# \n#     pub fn execute<F>(&self, f: F)\n#     where\n#         F: FnOnce() + Send + 'static,\n#     {\n#     }\n}\n# \n# struct Worker {\n#     id: usize,\n#     thread: thread::JoinHandle<()>,\n# }\n# \n# impl Worker {\n#     fn new(id: usize, receiver: mpsc::Receiver<Job>) -> Worker {\n#         let thread = thread::spawn(|| {});\n# \n#         Worker { id, thread }\n#     }\n# }\n```\n\n</Listing>\n\nW `ThreadPool::new` tworzymy nasz nowy kanaÅ‚ i sprawiamy, Å¼e pula przechowuje nadawcÄ™. To siÄ™ pomyÅ›lnie skompiluje.\n\nSprÃ³bujmy przekazaÄ‡ odbiornik kanaÅ‚u do kaÅ¼dego `Worker`'a, gdy pula wÄ…tkÃ³w tworzy kanaÅ‚. Wiemy, Å¼e chcemy uÅ¼yÄ‡ odbiornika w wÄ…tku, ktÃ³ry uruchamiajÄ… instancje `Worker`, wiÄ™c odwoÅ‚amy siÄ™ do parametru `receiver` w zamkniÄ™ciu. Kod z Listingu 21-17 jeszcze siÄ™ nie skompiluje.\n\n<Listing number=\"21-17\" file-name=\"src/lib.rs\" caption=\"Przekazywanie odbiornika do kaÅ¼dego `Worker`a\">\n\n```rust,ignore,does_not_compile\n# use std::{sync::mpsc, thread};\n# \n# pub struct ThreadPool {\n#     workers: Vec<Worker>,\n#     sender: mpsc::Sender<Job>,\n# }\n# \n# struct Job;\n# \nimpl ThreadPool {\n    // --snip--\n#     /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.\n#     ///\n#     /// `size` to liczba wÄ…tkÃ³w w puli.\n#     ///\n#     /// # Panics\n#     ///\n#     /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let (sender, receiver) = mpsc::channel();\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id, receiver));\n        }\n\n        ThreadPool { workers, sender }\n    }\n    // --snip--\n# \n#     pub fn execute<F>(&self, f: F)\n#     where\n#         F: FnOnce() + Send + 'static,\n#     {\n#     }\n}\n\n// --snip--\n\n# \n# struct Worker {\n#     id: usize,\n#     thread: thread::JoinHandle<()>,\n# }\n# \nimpl Worker {\n    fn new(id: usize, receiver: mpsc::Receiver<Job>) -> Worker {\n        let thread = thread::spawn(|| {\n            receiver;\n        });\n\n        Worker { id, thread }\n    }\n}\n```\n\n</Listing>\n\nWprowadziliÅ›my kilka maÅ‚ych i prostych zmian: przekazujemy odbiornik do `Worker::new`, a nastÄ™pnie uÅ¼ywamy go wewnÄ…trz zamkniÄ™cia.\n\nKiedy prÃ³bujemy sprawdziÄ‡ ten kod, otrzymujemy nastÄ™pujÄ…cy bÅ‚Ä…d:\n\n```console\n$ cargo check\n    Sprawdzanie hello v0.1.0 (file:///projects/hello)\nerror[E0382]: uÅ¼ycie przeniesionej wartoÅ›ci: `receiver`\n  --> src/lib.rs:26:42\n   |\n21 |         let (sender, receiver) = mpsc::channel();\n   |                      -------- nastÄ™puje przeniesienie, poniewaÅ¼ `receiver` ma typ `std::sync::mpsc::Receiver<Job>`, ktÃ³ry nie implementuje cechy `Copy`\n...\n25 |         for id in 0..size {\n   |         ----------------- wewnÄ…trz tej pÄ™tli\n26 |             workers.push(Worker::new(id, receiver));\n   |                                          ^^^^^^^^ wartoÅ›Ä‡ przeniesiona tutaj, w poprzedniej iteracji pÄ™tli\n   |\nnote: rozwaÅ¼ zmianÄ™ typu tego parametru w metodzie `new` na poÅ¼yczanie, jeÅ›li posiadanie wartoÅ›ci nie jest konieczne\n  --> src/lib.rs:47:33\n   |\n47 |     fn new(id: usize, receiver: mpsc::Receiver<Job>) -> Worker {\n   |        --- w tej metodzie       ^^^^^^^^^^^^^^^^^^^ ten parametr przejmuje wÅ‚asnoÅ›Ä‡ wartoÅ›ci\nhelp: rozwaÅ¼ przeniesienie wyraÅ¼enia poza pÄ™tlÄ™, aby byÅ‚o przeniesione tylko raz\n   |\n25 ~         let mut value = Worker::new(id, receiver);\n26 ~         for id in 0..size {\n27 ~             workers.push(value);\n   |\n\nWiÄ™cej informacji o tym bÅ‚Ä™dzie znajdziesz, uÅ¼ywajÄ…c `rustc --explain E0382`.\nerror: nie udaÅ‚o siÄ™ skompilowaÄ‡ `hello` (lib) z powodu 1 poprzedniego bÅ‚Ä™du\n```\n\nKod prÃ³buje przekazaÄ‡ `receiver` do wielu instancji `Worker`. To nie zadziaÅ‚a, jak pamiÄ™tacie z RozdziaÅ‚u 16: implementacja kanaÅ‚u dostarczana przez Rusta to kanaÅ‚ wielu _producentÃ³w_, jednego _konsumenta_. Oznacza to, Å¼e nie moÅ¼emy po prostu sklonowaÄ‡ koÅ„ca konsumujÄ…cego kanaÅ‚u, aby naprawiÄ‡ ten kod. Nie chcemy rÃ³wnieÅ¼ wysyÅ‚aÄ‡ wiadomoÅ›ci wielokrotnie do wielu konsumentÃ³w; chcemy jednej listy wiadomoÅ›ci z wieloma instancjami `Worker`, tak aby kaÅ¼da wiadomoÅ›Ä‡ byÅ‚a przetwarzana raz.\n\nDodatkowo, pobieranie zadania z kolejki kanaÅ‚u wiÄ…Å¼e siÄ™ z mutacjÄ… `receiver`, wiÄ™c wÄ…tki potrzebujÄ… bezpiecznego sposobu na wspÃ³Å‚dzielenie i modyfikowanie `receiver`; w przeciwnym razie mogÄ… wystÄ…piÄ‡ warunki wyÅ›cigu (omÃ³wione w Rozdziale 16).\n\nPrzypomnij sobie inteligentne wskaÅºniki bezpieczne dla wÄ…tkÃ³w omÃ³wione w Rozdziale 16: Aby wspÃ³Å‚dzieliÄ‡ wÅ‚asnoÅ›Ä‡ miÄ™dzy wieloma wÄ…tkami i umoÅ¼liwiÄ‡ wÄ…tkom mutacjÄ™ wartoÅ›ci, musimy uÅ¼yÄ‡ `Arc<Mutex<T>>`. Typ `Arc` pozwoli wielu instancjom `Worker` posiadaÄ‡ odbiornik, a `Mutex` zapewni, Å¼e tylko jeden `Worker` pobierze zadanie z odbiornika na raz. Listing 21-18 pokazuje zmiany, ktÃ³re musimy wprowadziÄ‡.\n\n<Listing number=\"21-18\" file-name=\"src/lib.rs\" caption=\"WspÃ³Å‚dzielenie odbiornika miÄ™dzy instancjami `Worker` za pomocÄ… `Arc` i `Mutex`\">\n\n```rust,noplayground\nuse std::{\n    sync::{Arc, Mutex, mpsc},\n    thread,\n};\n// --snip--\n\n# pub struct ThreadPool {\n#     workers: Vec<Worker>,\n#     sender: mpsc::Sender<Job>,\n# }\n# \n# struct Job;\n# \nimpl ThreadPool {\n    // --snip--\n#     /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.\n#     ///\n#     /// `size` to liczba wÄ…tkÃ³w w puli.\n#     ///\n#     /// # Panics\n#     ///\n#     /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let (sender, receiver) = mpsc::channel();\n\n        let receiver = Arc::new(Mutex::new(receiver));\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id, Arc::clone(&receiver)));\n        }\n\n        ThreadPool { workers, sender }\n    }\n\n    // --snip--\n# \n#     pub fn execute<F>(&self, f: F)\n#     where\n#         F: FnOnce() + Send + 'static,\n#     {\n#     }\n}\n\n// --snip--\n\n# struct Worker {\n#     id: usize,\n#     thread: thread::JoinHandle<()>,\n# }\n# \nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n        // --snip--\n#         let thread = thread::spawn(|| {\n#             receiver;\n#         });\n# \n#         Worker { id, thread }\n    }\n}\n```\n\n</Listing>\n\nW `ThreadPool::new` umieszczamy odbiornik w `Arc` i `Mutex`. Dla kaÅ¼dego nowego `Worker`, klonujemy `Arc`, aby zwiÄ™kszyÄ‡ licznik referencji, tak aby instancje `Worker` mogÅ‚y wspÃ³Å‚dzieliÄ‡ wÅ‚asnoÅ›Ä‡ odbiornika.\n\nDziÄ™ki tym zmianom kod siÄ™ kompiluje! Coraz bliÅ¼ej!\n\n#### Implementacja metody `execute`\n\nZaimplementujmy w koÅ„cu metodÄ™ `execute` na `ThreadPool`. Zmienimy rÃ³wnieÅ¼ `Job` ze struktury na alias typu dla obiektu cechy, ktÃ³ry przechowuje typ zamkniÄ™cia, ktÃ³ry otrzymuje `execute`. Jak omÃ³wiono w sekcji [â€Synonimy typÃ³w i aliasy typÃ³wâ€][type-aliases]<!-- ignore --> w Rozdziale 20, aliasy typÃ³w pozwalajÄ… nam skracaÄ‡ dÅ‚ugie typy dla uÅ‚atwienia uÅ¼ytkowania. SpÃ³jrz na Listing 21-19.\n\n<Listing number=\"21-19\" file-name=\"src/lib.rs\" caption=\"Tworzenie aliasu typu `Job` dla `Box`a, ktÃ³ry przechowuje kaÅ¼de zamkniÄ™cie, a nastÄ™pnie wysyÅ‚anie zadania kanaÅ‚em\">\n\n```rust,noplayground\n# use std::{\n#     sync::{Arc, Mutex, mpsc},\n#     thread,\n# };\n# \n# pub struct ThreadPool {\n#     workers: Vec<Worker>,\n#     sender: mpsc::Sender<Job>,\n# }\n# \n// --snip--\n\ntype Job = Box<dyn FnOnce() + Send + 'static>;\n\nimpl ThreadPool {\n    // --snip--\n#     /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.\n#     ///\n#     /// `size` to liczba wÄ…tkÃ³w w puli.\n#     ///\n#     /// # Panics\n#     ///\n#     /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.\n#     pub fn new(size: usize) -> ThreadPool {\n#         assert!(size > 0);\n# \n#         let (sender, receiver) = mpsc::channel();\n# \n#         let receiver = Arc::new(Mutex::new(receiver));\n# \n#         let mut workers = Vec::with_capacity(size);\n# \n#         for id in 0..size {\n#             workers.push(Worker::new(id, Arc::clone(&receiver)));\n#         }\n# \n#         ThreadPool { workers, sender }\n#     }\n\n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static,\n    {\n        let job = Box::new(f);\n\n        self.sender.send(job).unwrap();\n    }\n}\n\n// --snip--\n# \n# struct Worker {\n#     id: usize,\n#     thread: thread::JoinHandle<()>,\n# }\n# \n# impl Worker {\n#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n#         let thread = thread::spawn(|| {\n#             receiver;\n#         });\n# \n#         Worker { id, thread }\n#     }\n# }\n```\n\n</Listing>\n\nPo utworzeniu nowej instancji `Job` za pomocÄ… zamkniÄ™cia, ktÃ³re otrzymujemy w `execute`, wysyÅ‚amy to zadanie przez koniec wysyÅ‚ajÄ…cy kanaÅ‚u. WywoÅ‚ujemy `unwrap` na `send` w przypadku, gdy wysyÅ‚anie siÄ™ nie powiedzie. MoÅ¼e siÄ™ to zdarzyÄ‡, jeÅ›li na przykÅ‚ad zatrzymamy wszystkie nasze wÄ…tki od wykonywania, co oznacza, Å¼e koniec odbierajÄ…cy przestaÅ‚ odbieraÄ‡ nowe wiadomoÅ›ci. W tej chwili nie moÅ¼emy zatrzymaÄ‡ naszych wÄ…tkÃ³w od wykonywania: nasze wÄ…tki kontynuujÄ… wykonywanie tak dÅ‚ugo, jak dÅ‚ugo istnieje pula. Powodem, dla ktÃ³rego uÅ¼ywamy `unwrap`, jest to, Å¼e wiemy, Å¼e przypadek bÅ‚Ä™du siÄ™ nie zdarzy, ale kompilator tego nie wie.\n\nAle jeszcze nie skoÅ„czyliÅ›my! W `Worker`, nasze zamkniÄ™cie przekazywane do `thread::spawn` nadal tylko _referuje_ koniec odbiorczy kanaÅ‚u. Zamiast tego, potrzebujemy, aby zamkniÄ™cie zapÄ™tlaÅ‚o siÄ™ w nieskoÅ„czonoÅ›Ä‡, proszÄ…c koniec odbiorczy kanaÅ‚u o zadanie i uruchamiajÄ…c zadanie, gdy je otrzyma. WprowadÅºmy zmianÄ™ pokazanÄ… na Listingu 21-20 w `Worker::new`.\n\n<Listing number=\"21-20\" file-name=\"src/lib.rs\" caption=\"Odbieranie i wykonywanie zadaÅ„ w wÄ…tku instancji `Worker`\">\n\n```rust,noplayground\n# use std::{\n#     sync::{Arc, Mutex, mpsc},\n#     thread,\n# };\n# \n# pub struct ThreadPool {\n#     workers: Vec<Worker>,\n#     sender: mpsc::Sender<Job>,\n# }\n# \n# type Job = Box<dyn FnOnce() + Send + 'static>;\n# \n# impl ThreadPool {\n#     /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.\n#     ///\n#     /// `size` to liczba wÄ…tkÃ³w w puli.\n#     ///\n#     /// # Panics\n#     ///\n#     /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.\n#     pub fn new(size: usize) -> ThreadPool {\n#         assert!(size > 0);\n# \n#         let (sender, receiver) = mpsc::channel();\n# \n#         let receiver = Arc::new(Mutex::new(receiver));\n# \n#         let mut workers = Vec::with_capacity(size);\n# \n#         for id in 0..size {\n#             workers.push(Worker::new(id, Arc::clone(&receiver)));\n#         }\n# \n#         ThreadPool { workers, sender }\n#     }\n# \n#     pub fn execute<F>(&self, f: F)\n#     where\n#         F: FnOnce() + Send + 'static,\n#     {\n#         let job = Box::new(f);\n# \n#         self.sender.send(job).unwrap();\n#     }\n# }\n# \n# struct Worker {\n#     id: usize,\n#     thread: thread::JoinHandle<()>,\n# }\n# \n// --snip--\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n        let thread = thread::spawn(move || {\n            loop {\n                let job = receiver.lock().unwrap().recv().unwrap();\n\n                println!(\"Worker {id} otrzymaÅ‚ zadanie; wykonujÄ™.\");\n\n                job();\n            }\n        });\n\n        Worker { id, thread }\n    }\n}\n```\n\n</Listing>\n\nTutaj najpierw wywoÅ‚ujemy `lock` na `receiver`, aby uzyskaÄ‡ muteks, a nastÄ™pnie wywoÅ‚ujemy `unwrap`, aby spowodowaÄ‡ panikÄ™ w przypadku bÅ‚Ä™dÃ³w. Uzyskanie blokady moÅ¼e zakoÅ„czyÄ‡ siÄ™ niepowodzeniem, jeÅ›li muteks jest w stanie _zatrucia_, co moÅ¼e siÄ™ zdarzyÄ‡, jeÅ›li jakiÅ› inny wÄ…tek panikowaÅ‚, trzymajÄ…c blokadÄ™, zamiast jÄ… zwolniÄ‡. W tej sytuacji wywoÅ‚anie `unwrap` w celu spowodowania paniki tego wÄ…tku jest prawidÅ‚owym dziaÅ‚aniem. MoÅ¼esz zmieniÄ‡ to `unwrap` na `expect` z komunikatem o bÅ‚Ä™dzie, ktÃ³ry jest dla ciebie sensowny.\n\nJeÅ›li uzyskamy blokadÄ™ na muteksie, wywoÅ‚ujemy `recv`, aby otrzymaÄ‡ `Job` z kanaÅ‚u. Ostateczny `unwrap` rÃ³wnieÅ¼ tutaj pomija wszelkie bÅ‚Ä™dy, ktÃ³re mogÄ… wystÄ…piÄ‡, jeÅ›li wÄ…tek posiadajÄ…cy nadawcÄ™ zostaÅ‚ zamkniÄ™ty, podobnie jak metoda `send` zwraca `Err`, jeÅ›li odbiornik zostanie zamkniÄ™ty.\n\nWywoÅ‚anie `recv` blokuje, wiÄ™c jeÅ›li nie ma jeszcze zadania, bieÅ¼Ä…cy wÄ…tek bÄ™dzie czekaÅ‚, aÅ¼ zadanie stanie siÄ™ dostÄ™pne. `Mutex<T>` zapewnia, Å¼e tylko jeden wÄ…tek `Worker` w danym momencie prÃ³buje zaÅ¼Ä…daÄ‡ zadania.\n\nNasza pula wÄ…tkÃ³w jest teraz w stanie dziaÅ‚ajÄ…cym! Uruchom jÄ… za pomocÄ… `cargo run` i wyÅ›lij kilka Å¼Ä…daÅ„:\n\n<!-- manual-regeneration\ncd listings/ch21-web-server/listing-21-20\ncargo run\nwyÅ›lij kilka Å¼Ä…daÅ„ na 127.0.0.1:7878\nNie moÅ¼na zautomatyzowaÄ‡, poniewaÅ¼ wynik zaleÅ¼y od wysyÅ‚ania Å¼Ä…daÅ„\n-->\n\n```console\n$ cargo run\n   Kompilowanie hello v0.1.0 (file:///projects/hello)\nwarning: pole `workers` nigdy nie jest odczytywane\n --> src/lib.rs:7:5\n  |\n6 | pub struct ThreadPool {\n  |            ---------- pole w tej strukturze\n7 |     workers: Vec<Worker>,\n  |     ^^^^^^^\n  |\n  = note: `#[warn(dead_code)]` domyÅ›lnie wÅ‚Ä…czone\n\nwarning: pola `id` i `thread` nigdy nie sÄ… odczytywane\n  --> src/lib.rs:48:5\n   |\n47 | struct Worker {\n   |        ------ pola w tej strukturze\n48 |     id: usize,\n   |     ^^\n49 |     thread: thread::JoinHandle<()>,\n   |     ^^^^^^\n\nwarning: `hello` (lib) wygenerowaÅ‚o 2 ostrzeÅ¼enia\n    ZakoÅ„czono `dev` profil [nieoptymalny + debuginfo] cel(e) w 4.91s\n     Uruchamianie `target/debug/hello`\nWorker 0 otrzymaÅ‚ zadanie; wykonujÄ™.\nWorker 2 otrzymaÅ‚ zadanie; wykonujÄ™.\nWorker 1 otrzymaÅ‚ zadanie; wykonujÄ™.\nWorker 3 otrzymaÅ‚ zadanie; wykonujÄ™.\nWorker 0 otrzymaÅ‚ zadanie; wykonujÄ™.\nWorker 2 otrzymaÅ‚ zadanie; wykonujÄ™.\nWorker 1 otrzymaÅ‚ zadanie; wykonujÄ™.\nWorker 3 otrzymaÅ‚ zadanie; wykonujÄ™.\nWorker 0 otrzymaÅ‚ zadanie; wykonujÄ™.\nWorker 2 otrzymaÅ‚ zadanie; wykonujÄ™.\n```\n\nSukces! Mamy teraz pulÄ™ wÄ…tkÃ³w, ktÃ³ra wykonuje poÅ‚Ä…czenia asynchronicznie. Nigdy nie jest tworzonych wiÄ™cej niÅ¼ cztery wÄ…tki, wiÄ™c nasz system nie zostanie przeciÄ…Å¼ony, jeÅ›li serwer otrzyma wiele Å¼Ä…daÅ„. JeÅ›li wyÅ›lemy Å¼Ä…danie do _/sleep_, serwer bÄ™dzie mÃ³gÅ‚ obsÅ‚uÅ¼yÄ‡ inne Å¼Ä…dania, zlecajÄ…c je innym wÄ…tkom.\n\n> Uwaga: JeÅ›li otworzysz _/sleep_ w wielu oknach przeglÄ…darki jednoczeÅ›nie, mogÄ… siÄ™ Å‚adowaÄ‡ po kolei w piÄ™ciosekundowych odstÄ™pach. NiektÃ³re przeglÄ…darki internetowe wykonujÄ… wiele instancji tego samego Å¼Ä…dania sekwencyjnie z powodÃ³w buforowania. To ograniczenie nie jest spowodowane przez nasz serwer WWW.\n\nTo dobry moment, aby zatrzymaÄ‡ siÄ™ i zastanowiÄ‡, jak kod z ListingÃ³w 21-18, 21-19 i 21-20 rÃ³Å¼niÅ‚by siÄ™, gdybyÅ›my uÅ¼ywali przyszÅ‚oÅ›ci zamiast zamkniÄ™cia dla wykonywanej pracy. Jakie typy ulegÅ‚yby zmianie? Jak rÃ³Å¼niÅ‚yby siÄ™ sygnatury metod, jeÅ›li w ogÃ³le? Jakie czÄ™Å›ci kodu pozostaÅ‚yby takie same?\n\nPo zapoznaniu siÄ™ z pÄ™tlÄ… `while let` w Rozdziale 17 i Rozdziale 19, moÅ¼esz siÄ™ zastanawiaÄ‡, dlaczego nie napisaliÅ›my kodu wÄ…tku `Worker`, jak pokazano na Listingu 21-21.\n\n<Listing number=\"21-21\" file-name=\"src/lib.rs\" caption=\"Alternatywna implementacja `Worker::new` za pomocÄ… `while let`\">\n\n```rust,ignore,not_desired_behavior\n# use std::{\n#     sync::{Arc, Mutex, mpsc},\n#     thread,\n# };\n# \n# pub struct ThreadPool {\n#     workers: Vec<Worker>,\n#     sender: mpsc::Sender<Job>,\n# }\n# \n# type Job = Box<dyn FnOnce() + Send + 'static>;\n# \n# impl ThreadPool {\n#     /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.\n#     ///\n#     /// `size` to liczba wÄ…tkÃ³w w puli.\n#     ///\n#     /// # Panics\n#     ///\n#     /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.\n#     pub fn new(size: usize) -> ThreadPool {\n#         assert!(size > 0);\n# \n#         let (sender, receiver) = mpsc::channel();\n# \n#         let receiver = Arc::new(Mutex::new(receiver));\n# \n#         let mut workers = Vec::with_capacity(size);\n# \n#         for id in 0..size {\n#             workers.push(Worker::new(id, Arc::clone(&receiver)));\n#         }\n# \n#         ThreadPool { workers, sender }\n#     }\n# \n#     pub fn execute<F>(&self, f: F)\n#     where\n#         F: FnOnce() + Send + 'static,\n#     {\n#         let job = Box::new(f);\n# \n#         self.sender.send(job).unwrap();\n#     }\n# }\n# \n# struct Worker {\n#     id: usize,\n#     thread: thread::JoinHandle<()>,\n# }\n// --snip--\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n        let thread = thread::spawn(move || {\n            while let Ok(job) = receiver.lock().unwrap().recv() {\n                println!(\"Worker {id} otrzymaÅ‚ zadanie; wykonujÄ™.\");\n\n                job();\n            }\n        });\n\n        Worker { id, thread }\n    }\n}\n```\n\n</Listing>\n\nTen kod kompiluje siÄ™ i dziaÅ‚a, ale nie prowadzi do poÅ¼Ä…danego zachowania wÄ…tkowoÅ›ci: wolne Å¼Ä…danie nadal bÄ™dzie powodowaÄ‡, Å¼e inne Å¼Ä…dania bÄ™dÄ… czekaÄ‡ na przetworzenie. PowÃ³d jest nieco subtelny: struktura `Mutex` nie ma publicznej metody `unlock`, poniewaÅ¼ wÅ‚asnoÅ›Ä‡ blokady opiera siÄ™ na czasie Å¼ycia `MutexGuard<T>` wewnÄ…trz `LockResult<MutexGuard<T>>`, ktÃ³re zwraca metoda `lock`. W czasie kompilacji, checker poÅ¼yczeÅ„ moÅ¼e wymusiÄ‡ zasadÄ™, Å¼e zasÃ³b chroniony przez `Mutex` nie moÅ¼e byÄ‡ dostÄ™pny, chyba Å¼e posiadamy blokadÄ™. Jednak ta implementacja moÅ¼e rÃ³wnieÅ¼ spowodowaÄ‡, Å¼e blokada bÄ™dzie utrzymywana dÅ‚uÅ¼ej niÅ¼ zamierzono, jeÅ›li nie bÄ™dziemy pamiÄ™taÄ‡ o czasie Å¼ycia `MutexGuard<T>`.\n\nKod z Listingu 21-20, ktÃ³ry uÅ¼ywa `let job = receiver.lock().unwrap().recv().unwrap();` dziaÅ‚a, poniewaÅ¼ w przypadku `let`, wszelkie tymczasowe wartoÅ›ci uÅ¼yte w wyraÅ¼eniu po prawej stronie znaku rÃ³wnoÅ›ci sÄ… natychmiast usuwane, gdy koÅ„czy siÄ™ instrukcja `let`. Jednak `while let` (oraz `if let` i `match`) nie usuwa tymczasowych wartoÅ›ci aÅ¼ do koÅ„ca powiÄ…zanego bloku. W Listingu 21-21 blokada pozostaje w posiadaniu przez caÅ‚y czas trwania wywoÅ‚ania `job()`, co oznacza, Å¼e inne instancje `Worker` nie mogÄ… odbieraÄ‡ zadaÅ„.\n\n[type-aliases]: ch20-03-advanced-types.html#type-synonyms-and-type-aliases\n[integer-types]: ch03-02-data-types.html#integer-types\n[moving-out-of-closures]: ch13-01-closures.html#moving-captured-values-out-of-closures\n[builder]: ../std/thread/struct.Builder.html\n[builder-spawn]: ../std/thread/struct.Builder.html#method.spawn\n",
        "chapter_title": "Od serwera jednowÄ…tkowego do wielowÄ…tkowego"
    },
    {
        "file_path": "ch21-03-graceful-shutdown-and-cleanup.md",
        "content": "## Delikatne zamykanie i sprzÄ…tanie\n\nKod z Listingu 21-20 odpowiada na Å¼Ä…dania asynchronicznie, uÅ¼ywajÄ…c puli wÄ…tkÃ³w, tak jak zamierzaliÅ›my. Otrzymujemy kilka ostrzeÅ¼eÅ„ o polach `workers`, `id` i `thread`, ktÃ³rych nie uÅ¼ywamy w bezpoÅ›redni sposÃ³b, co przypomina nam, Å¼e nic nie sprzÄ…tamy. Gdy uÅ¼yjemy mniej eleganckiej metody <kbd>ctrl</kbd>-<kbd>C</kbd> do zatrzymania gÅ‚Ã³wnego wÄ…tku, wszystkie inne wÄ…tki sÄ… natychmiast zatrzymywane, nawet jeÅ›li sÄ… w trakcie obsÅ‚ugi Å¼Ä…dania.\n\nNastÄ™pnie zaimplementujemy cechÄ™ `Drop`, aby wywoÅ‚aÄ‡ `join` dla kaÅ¼dego z wÄ…tkÃ³w w puli, aby mogÅ‚y zakoÅ„czyÄ‡ pracÄ™ nad Å¼Ä…daniami, zanim siÄ™ zamknÄ…. NastÄ™pnie zaimplementujemy sposÃ³b, aby poinformowaÄ‡ wÄ…tki, Å¼e powinny przestaÄ‡ akceptowaÄ‡ nowe Å¼Ä…dania i zamknÄ…Ä‡ siÄ™. Aby zobaczyÄ‡ ten kod w akcji, zmodyfikujemy nasz serwer, aby akceptowaÅ‚ tylko dwa Å¼Ä…dania przed delikatnym zamkniÄ™ciem puli wÄ…tkÃ³w.\n\nJedna rzecz do zauwaÅ¼enia, gdy bÄ™dziemy postÄ™powaÄ‡: nic z tego nie wpÅ‚ywa na czÄ™Å›ci kodu, ktÃ³re obsÅ‚ugujÄ… wykonywanie zamkniÄ™Ä‡, wiÄ™c wszystko tutaj byÅ‚oby takie samo, gdybyÅ›my uÅ¼ywali puli wÄ…tkÃ³w do asynchronicznego Å›rodowiska uruchomieniowego.\n\n### Implementacja cechy `Drop` dla `ThreadPool`\n\nZacznijmy od zaimplementowania `Drop` dla naszej puli wÄ…tkÃ³w. Kiedy pula zostanie zrzucona, wszystkie nasze wÄ…tki powinny siÄ™ poÅ‚Ä…czyÄ‡, aby upewniÄ‡ siÄ™, Å¼e zakoÅ„czyÅ‚y swojÄ… pracÄ™. Listing 21-22 pokazuje pierwszÄ… prÃ³bÄ™ implementacji `Drop`; ten kod jeszcze nie bÄ™dzie dziaÅ‚aÅ‚ poprawnie.\n\n<Listing number=\"21-22\" file-name=\"src/lib.rs\" caption=\"ÅÄ…czenie kaÅ¼dego wÄ…tku, gdy pula wÄ…tkÃ³w wychodzi poza zakres\">\n\n```rust,ignore,does_not_compile\n# use std::{\n#     sync::{Arc, Mutex, mpsc},\n#     thread,\n# };\n# \n# pub struct ThreadPool {\n#     workers: Vec<Worker>,\n#     sender: mpsc::Sender<Job>,\n# }\n# \n# type Job = Box<dyn FnOnce() + Send + 'static>;\n# \n# impl ThreadPool {\n#     /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.\n#     ///\n#     /// `size` to liczba wÄ…tkÃ³w w puli.\n#     ///\n#     /// # Panics\n#     ///\n#     /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.\n#     pub fn new(size: usize) -> ThreadPool {\n#         assert!(size > 0);\n# \n#         let (sender, receiver) = mpsc::channel();\n# \n#         let receiver = Arc::new(Mutex::new(receiver));\n# \n#         let mut workers = Vec::with_capacity(size);\n# \n#         for id in 0..size {\n#             workers.push(Worker::new(id, Arc::clone(&receiver)));\n#         }\n# \n#         ThreadPool { workers, sender }\n#     }\n# \n#     pub fn execute<F>(&self, f: F)\n#     where\n#         F: FnOnce() + Send + 'static,\n#     {\n#         let job = Box::new(f);\n# \n#         self.sender.send(job).unwrap();\n#     }\n# }\n# \nimpl Drop for ThreadPool {\n    fn drop(&mut self) {\n        for worker in &mut self.workers {\n            println!(\"Zamykanie wÄ…tku roboczego {}\", worker.id);\n\n            worker.thread.join().unwrap();\n        }\n    }\n}\n# \n# struct Worker {\n#     id: usize,\n#     thread: thread::JoinHandle<()>,\n# }\n# \n# impl Worker {\n#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n#         let thread = thread::spawn(move || {\n#             loop {\n#                 let job = receiver.lock().unwrap().recv().unwrap();\n# \n#                 println!(\"Worker {id} otrzymaÅ‚ zadanie; wykonujÄ™.\");\n# \n#                 job();\n#             }\n#         });\n# \n#         Worker { id, thread }\n#     }\n# }\n```\n\n</Listing>\n\nNajpierw przechodzimy przez kaÅ¼dego z `workerÃ³w` puli wÄ…tkÃ³w. UÅ¼ywamy `&mut` do tego, poniewaÅ¼ `self` jest mutowalnÄ… referencjÄ…, a my musimy rÃ³wnieÅ¼ byÄ‡ w stanie mutowaÄ‡ `worker`. Dla kaÅ¼dego `worker`a, drukujemy komunikat informujÄ…cy, Å¼e ta konkretna instancja `Worker` jest zamykana, a nastÄ™pnie wywoÅ‚ujemy `join` na wÄ…tku tej instancji `Worker`. JeÅ›li wywoÅ‚anie `join` zakoÅ„czy siÄ™ niepowodzeniem, uÅ¼ywamy `unwrap`, aby Rust panikowaÅ‚ i przeszedÅ‚ w stan nieÅ‚askawego zamkniÄ™cia.\n\nOto bÅ‚Ä…d, ktÃ³ry otrzymujemy podczas kompilacji tego kodu:\n\n```console\n$ cargo check\n    Sprawdzanie hello v0.1.0 (file:///projects/hello)\nerror[E0507]: nie moÅ¼na przenieÅ›Ä‡ z `worker.thread`, ktÃ³ry znajduje siÄ™ za mutowalnÄ… referencjÄ…\n  --> src/lib.rs:52:13\n   |\n52 |             worker.thread.join().unwrap();\n   |             ^^^^^^^^^^^^^ ------ `worker.thread` przeniesiony z powodu wywoÅ‚ania tej metody\n   |             |\n   |             przeniesienie nastÄ™puje, poniewaÅ¼ `worker.thread` ma typ `JoinHandle<()>`, ktÃ³ry nie implementuje cechy `Copy`\n   |\nnote: `JoinHandle::<T>::join` przejmuje wÅ‚asnoÅ›Ä‡ odbiornika `self`, co przenosi `worker.thread`\n  --> /rustc/1159e78c4747b02ef996e55082b704c09b970588/library/std/src/thread/mod.rs:1921:17\n\nWiÄ™cej informacji o tym bÅ‚Ä™dzie znajdziesz, uÅ¼ywajÄ…c `rustc --explain E0507`.\nerror: nie udaÅ‚o siÄ™ skompilowaÄ‡ `hello` (lib) z powodu 1 poprzedniego bÅ‚Ä™du\n```\n\nBÅ‚Ä…d mÃ³wi nam, Å¼e nie moÅ¼emy wywoÅ‚aÄ‡ `join`, poniewaÅ¼ mamy tylko mutowalne poÅ¼yczenie kaÅ¼dego `worker`a, a `join` przejmuje wÅ‚asnoÅ›Ä‡ swojego argumentu. Aby rozwiÄ…zaÄ‡ ten problem, musimy przenieÅ›Ä‡ wÄ…tek z instancji `Worker`, ktÃ³ra jest wÅ‚aÅ›cicielem `thread`, tak aby `join` mogÅ‚o zuÅ¼yÄ‡ wÄ…tek. Jednym ze sposobÃ³w jest zastosowanie tego samego podejÅ›cia, ktÃ³re przyjÄ™liÅ›my w Listingu 18-15. Gdyby `Worker` zawieraÅ‚ `Option<thread::JoinHandle<()>>`, moglibyÅ›my wywoÅ‚aÄ‡ metodÄ™ `take` na `Option`, aby przenieÅ›Ä‡ wartoÅ›Ä‡ z wariantu `Some` i pozostawiÄ‡ wariant `None` na jego miejscu. Innymi sÅ‚owy, dziaÅ‚ajÄ…cy `Worker` miaÅ‚by wariant `Some` w `thread`, a gdybyÅ›my chcieli posprzÄ…taÄ‡ `Worker`a, zastÄ…pilibyÅ›my `Some` przez `None`, aby `Worker` nie miaÅ‚ wÄ…tku do uruchomienia.\n\nJednakÅ¼e, _jedynym_ momentem, kiedy to by siÄ™ pojawiÅ‚o, byÅ‚oby zrzucanie `Worker`a. W zamian, musielibyÅ›my radziÄ‡ sobie z `Option<thread::JoinHandle<()>>` wszÄ™dzie, gdzie uzyskiwaliÅ›my dostÄ™p do `worker.thread`. Idiomatyczny Rust czÄ™sto uÅ¼ywa `Option`, ale gdy zauwaÅ¼ysz, Å¼e opakowujesz coÅ›, co wiesz, Å¼e zawsze bÄ™dzie obecne, w `Option` jako obejÅ›cie, to dobrym pomysÅ‚em jest poszukanie alternatywnych podejÅ›Ä‡, aby uczyniÄ‡ kod czystszym i mniej podatnym na bÅ‚Ä™dy.\n\nW tym przypadku istnieje lepsza alternatywa: metoda `Vec::drain`. Akceptuje parametr zakresu, aby okreÅ›liÄ‡, ktÃ³re elementy usunÄ…Ä‡ z wektora i zwraca iterator tych elementÃ³w. Przekazanie skÅ‚adni zakresu `..` usunie *wszystkie* wartoÅ›ci z wektora.\n\nZatem musimy zaktualizowaÄ‡ implementacjÄ™ `drop` w `ThreadPool` w nastÄ™pujÄ…cy sposÃ³b:\n\n<Listing file-name=\"src/lib.rs\">\n\n```rust\n# use std::{\n#     sync::{Arc, Mutex, mpsc},\n#     thread,\n# };\n# \n# pub struct ThreadPool {\n#     workers: Vec<Worker>,\n#     sender: mpsc::Sender<Job>,\n# }\n# \n# type Job = Box<dyn FnOnce() + Send + 'static>;\n# \n# impl ThreadPool {\n#     /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.\n#     ///\n#     /// `size` to liczba wÄ…tkÃ³w w puli.\n#     ///\n#     /// # Panics\n#     ///\n#     /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.\n#     pub fn new(size: usize) -> ThreadPool {\n#         assert!(size > 0);\n# \n#         let (sender, receiver) = mpsc::channel();\n# \n#         let receiver = Arc::new(Mutex::new(receiver));\n# \n#         let mut workers = Vec::with_capacity(size);\n# \n#         for id in 0..size {\n#             workers.push(Worker::new(id, Arc::clone(&receiver)));\n#         }\n# \n#         ThreadPool { workers, sender }\n#     }\n# \n#     pub fn execute<F>(&self, f: F)\n#     where\n#         F: FnOnce() + Send + 'static,\n#     {\n#         let job = Box::new(f);\n# \n#         self.sender.send(job).unwrap();\n#     }\n# }\n# \nimpl Drop for ThreadPool {\n    fn drop(&mut self) {\n        for worker in self.workers.drain(..) {\n            println!(\"Zamykanie wÄ…tku roboczego {}\", worker.id);\n\n            worker.thread.join().unwrap();\n        }\n    }\n}\n# \n# struct Worker {\n#     id: usize,\n#     thread: thread::JoinHandle<()>,\n# }\n# \n# impl Worker {\n#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n#         let thread = thread::spawn(move || {\n#             loop {\n#                 let job = receiver.lock().unwrap().recv().unwrap();\n# \n#                 println!(\"Worker {id} otrzymaÅ‚ zadanie; wykonujÄ™.\");\n# \n#                 job();\n#             }\n#         });\n# \n#         Worker { id, thread }\n#     }\n# }\n```\n\n</Listing>\n\nTo rozwiÄ…zuje bÅ‚Ä…d kompilatora i nie wymaga Å¼adnych innych zmian w naszym kodzie. ZauwaÅ¼, Å¼e poniewaÅ¼ `drop` moÅ¼e byÄ‡ wywoÅ‚any podczas paniki, `unwrap` rÃ³wnieÅ¼ moÅ¼e spowodowaÄ‡ panikÄ™ i doprowadziÄ‡ do podwÃ³jnej paniki, co natychmiastowo crashuje program i koÅ„czy wszelkie trwajÄ…ce sprzÄ…tanie. Jest to w porzÄ…dku dla przykÅ‚adowego programu, ale nie jest zalecane dla kodu produkcyjnego.\n\n### Sygnalizowanie wÄ…tkom, aby przestaÅ‚y nasÅ‚uchiwaÄ‡ zadaÅ„\n\nDziÄ™ki wszystkim zmianom, ktÃ³re wprowadziliÅ›my, nasz kod kompiluje siÄ™ bez Å¼adnych ostrzeÅ¼eÅ„. Niestety, ten kod nie dziaÅ‚a tak, jak byÅ›my chcieli. Klucz leÅ¼y w logice zamkniÄ™Ä‡ uruchamianych przez wÄ…tki instancji `Worker`: obecnie wywoÅ‚ujemy `join`, ale to nie spowoduje zamkniÄ™cia wÄ…tkÃ³w, poniewaÅ¼ one `loop` w nieskoÅ„czonoÅ›Ä‡, szukajÄ…c zadaÅ„. JeÅ›li sprÃ³bujemy zrzuciÄ‡ nasz `ThreadPool` z naszÄ… obecnÄ… implementacjÄ… `drop`, gÅ‚Ã³wny wÄ…tek bÄ™dzie blokowaÅ‚ siÄ™ w nieskoÅ„czonoÅ›Ä‡, czekajÄ…c na zakoÅ„czenie pierwszego wÄ…tku.\n\nAby rozwiÄ…zaÄ‡ ten problem, bÄ™dziemy potrzebowaÄ‡ zmiany w implementacji `drop` dla `ThreadPool`, a nastÄ™pnie zmiany w pÄ™tli `Worker`.\n\nNajpierw zmienimy implementacjÄ™ `drop` w `ThreadPool` tak, aby jawnie zrzuciÄ‡ `sender` przed oczekiwaniem na zakoÅ„czenie wÄ…tkÃ³w. Listing 21-23 pokazuje zmiany w `ThreadPool` w celu jawnego zrzucenia `sender`. W przeciwieÅ„stwie do wÄ…tku, tutaj _musimy_ uÅ¼yÄ‡ `Option`, aby mÃ³c przenieÅ›Ä‡ `sender` z `ThreadPool` za pomocÄ… `Option::take`.\n\n<Listing number=\"21-23\" file-name=\"src/lib.rs\" caption=\"Jawne zrzucanie `sender` przed doÅ‚Ä…czeniem wÄ…tkÃ³w `Worker`\">\n\n```rust,noplayground,not_desired_behavior\n# use std::{\n#     sync::{Arc, Mutex, mpsc},\n#     thread,\n# };\n# \npub struct ThreadPool {\n    workers: Vec<Worker>,\n    sender: Option<mpsc::Sender<Job>>,\n}\n// --snip--\n# \n# type Job = Box<dyn FnOnce() + Send + 'static>;\n# \nimpl ThreadPool {\n#     /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.\n#     ///\n#     /// `size` to liczba wÄ…tkÃ³w w puli.\n#     ///\n#     /// # Panics\n#     ///\n#     /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.\n    pub fn new(size: usize) -> ThreadPool {\n        // --snip--\n\n#         assert!(size > 0);\n# \n#         let (sender, receiver) = mpsc::channel();\n# \n#         let receiver = Arc::new(Mutex::new(receiver));\n# \n#         let mut workers = Vec::with_capacity(size);\n# \n#         for id in 0..size {\n#             workers.push(Worker::new(id, Arc::clone(&receiver)));\n#         }\n# \n        ThreadPool {\n            workers,\n            sender: Some(sender),\n        }\n    }\n\n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static,\n    {\n        let job = Box::new(f);\n\n        self.sender.as_ref().unwrap().send(job).unwrap();\n    }\n}\n\nimpl Drop for ThreadPool {\n    fn drop(&mut self) {\n        drop(self.sender.take());\n\n        for worker in self.workers.drain(..) {\n            println!(\"Zamykanie wÄ…tku roboczego {}\", worker.id);\n\n            worker.thread.join().unwrap();\n        }\n    }\n}\n# \n# struct Worker {\n#     id: usize,\n#     thread: thread::JoinHandle<()>,\n# }\n# \n# impl Worker {\n#     fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n#         let thread = thread::spawn(move || {\n#             loop {\n#                 let job = receiver.lock().unwrap().recv().unwrap();\n# \n#                 println!(\"Worker {id} otrzymaÅ‚ zadanie; wykonujÄ™.\");\n# \n#                 job();\n#             }\n#         });\n# \n#         Worker { id, thread }\n#     }\n# }\n```\n\n</Listing>\n\nZrzucenie `sender` zamyka kanaÅ‚, co oznacza, Å¼e wiÄ™cej wiadomoÅ›ci nie zostanie wysÅ‚anych. Kiedy to nastÄ…pi, wszystkie wywoÅ‚ania `recv`, ktÃ³re instancje `Worker` wykonujÄ… w nieskoÅ„czonej pÄ™tli, zwrÃ³cÄ… bÅ‚Ä…d. W Listingu 21-24 zmieniamy pÄ™tlÄ™ `Worker` tak, aby w tym przypadku elegancko wychodziÅ‚a z pÄ™tli, co oznacza, Å¼e wÄ…tki zakoÅ„czÄ… dziaÅ‚anie, gdy implementacja `drop` w `ThreadPool` wywoÅ‚a na nich `join`.\n\n<Listing number=\"21-24\" file-name=\"src/lib.rs\" caption=\"Jawne wyjÅ›cie z pÄ™tli, gdy `recv` zwraca bÅ‚Ä…d\">\n\n```rust,noplayground\n# use std::{\n#     sync::{Arc, Mutex, mpsc},\n#     thread,\n# };\n# \n# pub struct ThreadPool {\n#     workers: Vec<Worker>,\n#     sender: Option<mpsc::Sender<Job>>,\n# }\n# \n# type Job = Box<dyn FnOnce() + Send + 'static>;\n# \n# impl ThreadPool {\n#     /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.\n#     ///\n#     /// `size` to liczba wÄ…tkÃ³w w puli.\n#     ///\n#     /// # Panics\n#     ///\n#     /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.\n#     pub fn new(size: usize) -> ThreadPool {\n#         assert!(size > 0);\n# \n#         let (sender, receiver) = mpsc::channel();\n# \n#         let receiver = Arc::new(Mutex::new(receiver));\n# \n#         let mut workers = Vec::with_capacity(size);\n# \n#         for id in 0..size {\n#             workers.push(Worker::new(id, Arc::clone(&receiver)));\n#         }\n# \n#         ThreadPool {\n#             workers,\n#             sender: Some(sender),\n#         }\n#     }\n# \n#     pub fn execute<F>(&self, f: F)\n#     where\n#         F: FnOnce() + Send + 'static,\n#     {\n#         let job = Box::new(f);\n# \n#         self.sender.as_ref().unwrap().send(job).unwrap();\n#     }\n# }\n# \n# impl Drop for ThreadPool {\n#     fn drop(&mut self) {\n#         drop(self.sender.take());\n# \n#         for worker in self.workers.drain(..) {\n#             println!(\"Zamykanie wÄ…tku roboczego {}\", worker.id);\n# \n#             worker.thread.join().unwrap();\n#         }\n#     }\n# }\n# \n# struct Worker {\n#     id: usize,\n#     thread: thread::JoinHandle<()>,\n# }\n# \nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n        let thread = thread::spawn(move || {\n            loop {\n                let message = receiver.lock().unwrap().recv();\n\n                match message {\n                    Ok(job) => {\n                        println!(\"Worker {id} otrzymaÅ‚ zadanie; wykonujÄ™.\");\n\n                        job();\n                    }\n                    Err(_) => {\n                        println!(\"Worker {id} rozÅ‚Ä…czyÅ‚ siÄ™; zamykam.\");\n                        break;\n                    }\n                }\n            }\n        });\n\n        Worker { id, thread }\n    }\n}\n```\n\n</Listing>\n\nAby zobaczyÄ‡ ten kod w akcji, zmodyfikujmy `main`, aby akceptowaÅ‚ tylko dwa Å¼Ä…dania przed delikatnym zamkniÄ™ciem serwera, jak pokazano na Listingu 21-25.\n\n<Listing number=\"21-25\" file-name=\"src/main.rs\" caption=\"Zamykanie serwera po obsÅ‚uÅ¼eniu dwÃ³ch Å¼Ä…daÅ„ poprzez wyjÅ›cie z pÄ™tli\">\n\n```rust,ignore\n# use hello::ThreadPool;\n# use std::{\n#     fs,\n#     io::{BufReader, prelude::*},\n#     net::{TcpListener, TcpStream},\n#     thread,\n#     time::Duration,\n# };\n# \nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    let pool = ThreadPool::new(4);\n\n    for stream in listener.incoming().take(2) {\n        let stream = stream.unwrap();\n\n        pool.execute(|| {\n            handle_connection(stream);\n        });\n    }\n\n    println!(\"Zamykam.\");\n}\n# \n# fn handle_connection(mut stream: TcpStream) {\n#     let buf_reader = BufReader::new(&stream);\n#     let request_line = buf_reader.lines().next().unwrap().unwrap();\n# \n#     let (status_line, filename) = match &request_line[..] {\n#         \"GET / HTTP/1.1\" => (\"HTTP/1.1 200 OK\", \"hello.html\"),\n#         \"GET /sleep HTTP/1.1\" => {\n#             thread::sleep(Duration::from_secs(5));\n#             (\"HTTP/1.1 200 OK\", \"hello.html\")\n#         }\n#         _ => (\"HTTP/1.1 404 NOT FOUND\", \"404.html\"),\n#     };\n# \n#     let contents = fs::read_to_string(filename).unwrap();\n#     let length = contents.len();\n# \n#     let response =\n#         format!(\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\");\n# \n#     stream.write_all(response.as_bytes()).unwrap();\n# }\n```\n\n</Listing>\n\nNie chciaÅ‚byÅ›, aby prawdziwy serwer WWW zamykaÅ‚ siÄ™ po obsÅ‚uÅ¼eniu zaledwie dwÃ³ch Å¼Ä…daÅ„. Ten kod jedynie demonstruje, Å¼e delikatne zamykanie i sprzÄ…tanie dziaÅ‚a poprawnie.\n\nMetoda `take` jest zdefiniowana w ceche `Iterator` i ogranicza iteracjÄ™ do maksymalnie dwÃ³ch pierwszych elementÃ³w. `ThreadPool` wyjdzie poza zakres na koÅ„cu `main`, a implementacja `drop` zostanie uruchomiona.\n\nUruchom serwer za pomocÄ… `cargo run` i wyÅ›lij trzy Å¼Ä…dania. Trzecie Å¼Ä…danie powinno zakoÅ„czyÄ‡ siÄ™ bÅ‚Ä™dem, a w terminalu powinieneÅ› zobaczyÄ‡ wynik podobny do tego:\n\n<!-- manual-regeneration\ncd listings/ch21-web-server/listing-21-25\ncargo run\ncurl http://127.0.0.1:7878\ncurl http://127.0.0.1:7878\ncurl http://127.0.0.1:7878\ntrzecie Å¼Ä…danie zakoÅ„czy siÄ™ bÅ‚Ä™dem, poniewaÅ¼ serwer zostanie zamkniÄ™ty\nskopiuj wyjÅ›cie poniÅ¼ej\nNie moÅ¼na zautomatyzowaÄ‡, poniewaÅ¼ wynik zaleÅ¼y od wysyÅ‚ania Å¼Ä…daÅ„\n-->\n\n```console\n$ cargo run\n   Kompilowanie hello v0.1.0 (file:///projects/hello)\n    ZakoÅ„czono `dev` profil [nieoptymalny + debuginfo] cel(e) w 0.41s\n     Uruchamianie `target/debug/hello`\nWorker 0 otrzymaÅ‚ zadanie; wykonujÄ™.\nZamykam.\nZamykanie wÄ…tku roboczego 0\nWorker 3 otrzymaÅ‚ zadanie; wykonujÄ™.\nWorker 1 rozÅ‚Ä…czyÅ‚ siÄ™; zamykam.\nWorker 2 rozÅ‚Ä…czyÅ‚ siÄ™; zamykam.\nWorker 3 rozÅ‚Ä…czyÅ‚ siÄ™; zamykam.\nWorker 0 rozÅ‚Ä…czyÅ‚ siÄ™; zamykam.\nZamykanie wÄ…tku roboczego 1\nZamykanie wÄ…tku roboczego 2\nZamykanie wÄ…tku roboczego 3\n```\n\nMoÅ¼esz zobaczyÄ‡ innÄ… kolejnoÅ›Ä‡ identyfikatorÃ³w `Worker` i wydrukowanych komunikatÃ³w. Z komunikatÃ³w widzimy, jak dziaÅ‚a ten kod: instancje `Worker` 0 i 3 otrzymaÅ‚y pierwsze dwa Å¼Ä…dania. Serwer przestaÅ‚ akceptowaÄ‡ poÅ‚Ä…czenia po drugim poÅ‚Ä…czeniu, a implementacja `Drop` w `ThreadPool` zaczyna siÄ™ wykonywaÄ‡, zanim `Worker 3` nawet rozpocznie swoje zadanie. Zrzucone `sender` odÅ‚Ä…cza wszystkie instancje `Worker` i informuje je o zamkniÄ™ciu. Instancje `Worker` drukujÄ… komunikat, gdy siÄ™ odÅ‚Ä…czajÄ…, a nastÄ™pnie pula wÄ…tkÃ³w wywoÅ‚uje `join`, aby poczekaÄ‡, aÅ¼ kaÅ¼dy wÄ…tek `Worker` zakoÅ„czy dziaÅ‚anie.\n\nZauwaÅ¼ jeden ciekawy aspekt tego konkretnego wykonania: `ThreadPool` zrzuciÅ‚ `sender`, a zanim ktÃ³rykolwiek `Worker` otrzymaÅ‚ bÅ‚Ä…d, prÃ³bowaliÅ›my doÅ‚Ä…czyÄ‡ `Worker 0`. `Worker 0` nie otrzymaÅ‚ jeszcze bÅ‚Ä™du z `recv`, wiÄ™c gÅ‚Ã³wny wÄ…tek zablokowaÅ‚ siÄ™, czekajÄ…c na zakoÅ„czenie `Worker 0`. W miÄ™dzyczasie `Worker 3` otrzymaÅ‚ zadanie, a nastÄ™pnie wszystkie wÄ…tki otrzymaÅ‚y bÅ‚Ä…d. Gdy `Worker 0` zakoÅ„czyÅ‚ dziaÅ‚anie, gÅ‚Ã³wny wÄ…tek czekaÅ‚ na zakoÅ„czenie pozostaÅ‚ych instancji `Worker`. W tym momencie wszystkie one wyszÅ‚y ze swoich pÄ™tli i zatrzymaÅ‚y siÄ™.\n\nGratulacje! WÅ‚aÅ›nie zakoÅ„czyliÅ›my nasz projekt; mamy podstawowy serwer WWW, ktÃ³ry uÅ¼ywa puli wÄ…tkÃ³w do asynchronicznej odpowiedzi. JesteÅ›my w stanie wykonaÄ‡ delikatne zamkniÄ™cie serwera, ktÃ³re czyÅ›ci wszystkie wÄ…tki w puli.\n\nPoniÅ¼ej znajduje siÄ™ caÅ‚y kod dla odniesienia:\n\n<Listing file-name=\"src/main.rs\">\n\n```rust,ignore\nuse hello::ThreadPool;\nuse std::{\n    fs,\n    io::{BufReader, prelude::*},\n    net::{TcpListener, TcpStream},\n    thread,\n    time::Duration,\n};\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    let pool = ThreadPool::new(4);\n\n    for stream in listener.incoming().take(2) {\n        let stream = stream.unwrap();\n\n        pool.execute(|| {\n            handle_connection(stream);\n        });\n    }\n\n    println!(\"Zamykam.\");\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&stream);\n    let request_line = buf_reader.lines().next().unwrap().unwrap();\n\n    let (status_line, filename) = match &request_line[..] {\n        \"GET / HTTP/1.1\" => (\"HTTP/1.1 200 OK\", \"hello.html\"),\n        \"GET /sleep HTTP/1.1\" => {\n            thread::sleep(Duration::from_secs(5));\n            (\"HTTP/1.1 200 OK\", \"hello.html\")\n        }\n        _ => (\"HTTP/1.1 404 NOT FOUND\", \"404.html\"),\n    };\n\n    let contents = fs::read_to_string(filename).unwrap();\n    let length = contents.len();\n\n    let response =\n        format!(\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\");\n\n    stream.write_all(response.as_bytes()).unwrap();\n}\n```\n\n</Listing>\n\n<Listing file-name=\"src/lib.rs\">\n\n```rust,noplayground\nuse std::{\n    sync::{Arc, Mutex, mpsc},\n    thread,\n};\n\npub struct ThreadPool {\n    workers: Vec<Worker>,\n    sender: Option<mpsc::Sender<Job>>,\n}\n\ntype Job = Box<dyn FnOnce() + Send + 'static>;\n\nimpl ThreadPool {\n    /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.\n    ///\n    /// `size` to liczba wÄ…tkÃ³w w puli.\n    ///\n    /// # Panics\n    ///\n    /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let (sender, receiver) = mpsc::channel();\n\n        let receiver = Arc::new(Mutex::new(receiver));\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id, Arc::clone(&receiver)));\n        }\n\n        ThreadPool {\n            workers,\n            sender: Some(sender),\n        }\n    }\n\n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static,\n    {\n        let job = Box::new(f);\n\n        self.sender.as_ref().unwrap().send(job).unwrap();\n    }\n}\n\nimpl Drop for ThreadPool {\n    fn drop(&mut self) {\n        drop(self.sender.take());\n\n        for worker in &mut self.workers {\n            println!(\"Zamykanie wÄ…tku roboczego {}\", worker.id);\n\n            if let Some(thread) = worker.thread.take() {\n                thread.join().unwrap();\n            }\n        }\n    }\n}\n\nstruct Worker {\n    id: usize,\n    thread: Option<thread::JoinHandle<()>>,\n}\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n        let thread = thread::spawn(move || {\n            loop {\n                let message = receiver.lock().unwrap().recv();\n\n                match message {\n                    Ok(job) => {\n                        println!(\"Worker {id} otrzymaÅ‚ zadanie; wykonujÄ™.\");\n\n                        job();\n                    }\n                    Err(_) => {\n                        println!(\"Worker {id} rozÅ‚Ä…czyÅ‚ siÄ™; zamykam.\");\n                        break;\n                    }\n                }\n            }\n        });\n\n        Worker {\n            id,\n            thread: Some(thread),\n        }\n    }\n}\n```\n\n</Listing>\n\nMoÅ¼na by tu zrobiÄ‡ wiÄ™cej! JeÅ›li chcesz kontynuowaÄ‡ ulepszanie tego projektu, oto kilka pomysÅ‚Ã³w:\n\n- Dodaj wiÄ™cej dokumentacji do `ThreadPool` i jego publicznych metod.\n- Dodaj testy funkcjonalnoÅ›ci biblioteki.\n- ZmieÅ„ wywoÅ‚ania `unwrap` na bardziej solidnÄ… obsÅ‚ugÄ™ bÅ‚Ä™dÃ³w.\n- UÅ¼yj `ThreadPool` do wykonania innego zadania niÅ¼ obsÅ‚uga Å¼Ä…daÅ„ WWW.\n- ZnajdÅº skrzynkÄ™ puli wÄ…tkÃ³w na [crates.io](https://crates.io/) i zaimplementuj podobny serwer WWW, uÅ¼ywajÄ…c zamiast tego tej skrzynki. NastÄ™pnie porÃ³wnaj jej API i solidnoÅ›Ä‡ z zaimplementowanÄ… przez nas pulÄ… wÄ…tkÃ³w.\n\n## Podsumowanie\n\nÅšwietnie! DotarÅ‚eÅ› do koÅ„ca ksiÄ…Å¼ki! Chcemy podziÄ™kowaÄ‡ za doÅ‚Ä…czenie do nas w tej podrÃ³Å¼y po Rust. JesteÅ› teraz gotowy, aby zaimplementowaÄ‡ wÅ‚asne projekty Rust i pomagaÄ‡ w projektach innych ludzi. PamiÄ™taj, Å¼e istnieje goÅ›cinna spoÅ‚ecznoÅ›Ä‡ innych Rustaceans, ktÃ³rzy z przyjemnoÅ›ciÄ… pomogÄ… ci w wszelkich wyzwaniach, ktÃ³re napotkasz w swojej podrÃ³Å¼y z Rustem.\n",
        "chapter_title": "Delikatne zamykanie i sprzÄ…tanie"
    },
    {
        "file_path": "appendix-00.md",
        "content": "# Dodatek\n\nPoniÅ¼sze sekcje zawierajÄ… materiaÅ‚y referencyjne, ktÃ³re mogÄ… okazaÄ‡ siÄ™ przydatne w Twojej podrÃ³Å¼y z Rustem.\n",
        "chapter_title": "Dodatek"
    },
    {
        "file_path": "appendix-01-keywords.md",
        "content": "## Dodatek A: SÅ‚owa kluczowe\n\nPoniÅ¼sze listy zawierajÄ… sÅ‚owa kluczowe, ktÃ³re sÄ… zarezerwowane do obecnego lub przyszÅ‚ego uÅ¼ytku przez jÄ™zyk Rust. W zwiÄ…zku z tym nie mogÄ… byÄ‡ uÅ¼ywane jako identyfikatory (z wyjÄ…tkiem surowych identyfikatorÃ³w, jak omawiamy w sekcji [â€Surowe identyfikatoryâ€][raw-identifiers]<!-- ignore -->). _Identyfikatory_ to nazwy funkcji, zmiennych, parametrÃ³w, pÃ³l struktur, moduÅ‚Ã³w, skrzynek, staÅ‚ych, makr, wartoÅ›ci statycznych, atrybutÃ³w, typÃ³w, cech lub czasÃ³w Å¼ycia.\n\n[raw-identifiers]: #raw-identifiers\n\n### SÅ‚owa kluczowe obecnie w uÅ¼yciu\n\nPoniÅ¼ej znajduje siÄ™ lista sÅ‚Ã³w kluczowych obecnie uÅ¼ywanych, z opisem ich funkcjonalnoÅ›ci.\n\n- **`as`**: Wykonuje prymitywnÄ… konwersjÄ™ typÃ³w, rozrÃ³Å¼nia konkretnÄ… cechÄ™ zawierajÄ…cÄ… element lub zmienia nazwy elementÃ³w w instrukcjach `use`.\n- **`async`**: Zwraca `Future` zamiast blokowania bieÅ¼Ä…cego wÄ…tku.\n- **`await`**: Zawiesza wykonywanie, dopÃ³ki wynik `Future` nie bÄ™dzie gotowy.\n- **`break`**: Natychmiast wychodzi z pÄ™tli.\n- **`const`**: Definiuje staÅ‚e elementy lub staÅ‚e surowe wskaÅºniki.\n- **`continue`**: Przechodzi do nastÄ™pnej iteracji pÄ™tli.\n- **`crate`**: W Å›cieÅ¼ce moduÅ‚u odnosi siÄ™ do katalogu gÅ‚Ã³wnego skrzynki (crate).\n- **`dyn`**: Dynamiczne wysyÅ‚anie do obiektu cechy.\n- **`else`**: Alternatywa dla konstrukcji sterujÄ…cych `if` i `if let`.\n- **`enum`**: Definiuje wyliczenie.\n- **`extern`**: ÅÄ…czy funkcjÄ™ lub zmiennÄ… zewnÄ™trznÄ….\n- **`false`**: LiteraÅ‚ boolowski faÅ‚sz.\n- **`fn`**: Definiuje funkcjÄ™ lub typ wskaÅºnika na funkcjÄ™.\n- **`for`**: Iteruje po elementach z iteratora, implementuje cechÄ™ lub okreÅ›la czas Å¼ycia wyÅ¼szego rzÄ™du.\n- **`if`**: RozgaÅ‚Ä™zia kod na podstawie wyniku wyraÅ¼enia warunkowego.\n- **`impl`**: Implementuje wbudowanÄ… lub cechowÄ… funkcjonalnoÅ›Ä‡.\n- **`in`**: CzÄ™Å›Ä‡ skÅ‚adni pÄ™tli `for`.\n- **`let`**: WiÄ…Å¼e zmiennÄ….\n- **`loop`**: PÄ™tla bezwarunkowa.\n- **`match`**: Dopasowuje wartoÅ›Ä‡ do wzorcÃ³w.\n- **`mod`**: Definiuje moduÅ‚.\n- **`move`**: Sprawia, Å¼e zamkniÄ™cie przejmuje wÅ‚asnoÅ›Ä‡ wszystkich swoich przechwyconych wartoÅ›ci.\n- **`mut`**: Oznacza zmiennoÅ›Ä‡ w referencjach, surowych wskaÅºnikach lub wiÄ…zaniach wzorcowych.\n- **`pub`**: Oznacza publicznÄ… widocznoÅ›Ä‡ w polach struktur, blokach `impl` lub moduÅ‚ach.\n- **`ref`**: WiÄ…Å¼e przez referencjÄ™.\n- **`return`**: Zwraca z funkcji.\n- **`Self`**: Alias typu dla definiowanego lub implementowanego typu.\n- **`self`**: Podmiot metody lub bieÅ¼Ä…cy moduÅ‚.\n- **`static`**: Zmienna globalna lub czas Å¼ycia trwajÄ…cy przez caÅ‚e wykonanie programu.\n- **`struct`**: Definiuje strukturÄ™.\n- **`super`**: ModuÅ‚ nadrzÄ™dny bieÅ¼Ä…cego moduÅ‚u.\n- **`trait`**: Definiuje cechÄ™.\n- **`true`**: LiteraÅ‚ boolowski prawda.\n- **`type`**: Definiuje alias typu lub stowarzyszony typ.\n- **`union`**: Definiuje [uniÄ™][union]<!-- ignore -->; jest sÅ‚owem kluczowym tylko wtedy, gdy uÅ¼ywane w deklaracji unii.\n- **`unsafe`**: Oznacza niebezpieczny kod, funkcje, cechy lub implementacje.\n- **`use`**: Wprowadza symbole do zakresu.\n- **`where`**: Oznacza klauzule, ktÃ³re ograniczajÄ… typ.\n- **`while`**: PÄ™tla warunkowa na podstawie wyniku wyraÅ¼enia.\n\n[union]: ../reference/items/unions.html\n\n### SÅ‚owa kluczowe zarezerwowane do przyszÅ‚ego uÅ¼ytku\n\nPoniÅ¼sze sÅ‚owa kluczowe nie majÄ… jeszcze Å¼adnej funkcjonalnoÅ›ci, ale sÄ… zarezerwowane przez Rust do potencjalnego przyszÅ‚ego uÅ¼ytku:\n\n- `abstract`\n- `become`\n- `box`\n- `do`\n- `final`\n- `gen`\n- `macro`\n- `override`\n- `priv`\n- `try`\n- `typeof`\n- `unsized`\n- `virtual`\n- `yield`\n\n### Surowe identyfikatory\n\n_Surowe identyfikatory_ to skÅ‚adnia, ktÃ³ra pozwala uÅ¼ywaÄ‡ sÅ‚Ã³w kluczowych tam, gdzie normalnie nie byÅ‚oby to dozwolone. Surowy identyfikator uÅ¼ywasz, poprzedzajÄ…c sÅ‚owo kluczowe `r#`.\n\nNa przykÅ‚ad, `match` jest sÅ‚owem kluczowym. JeÅ›li sprÃ³bujesz skompilowaÄ‡ nastÄ™pujÄ…cÄ… funkcjÄ™, ktÃ³ra uÅ¼ywa `match` jako swojej nazwy:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust,ignore,does_not_compile\nfn match(needle: &str, haystack: &str) -> bool {\n    haystack.contains(needle)\n}\n```\n\notrzymasz nastÄ™pujÄ…cy bÅ‚Ä…d:\n\n```text\nbÅ‚Ä…d: oczekiwano identyfikatora, znaleziono sÅ‚owo kluczowe `match`\n --> src/main.rs:4:4\n  |\n4 | fn match(needle: &str, haystack: &str) -> bool {\n  |    ^^^^^ oczekiwano identyfikatora, znaleziono sÅ‚owo kluczowe\n```\n\nBÅ‚Ä…d pokazuje, Å¼e nie moÅ¼esz uÅ¼yÄ‡ sÅ‚owa kluczowego `match` jako identyfikatora funkcji. Aby uÅ¼yÄ‡ `match` jako nazwy funkcji, musisz uÅ¼yÄ‡ skÅ‚adni surowego identyfikatora, tak jak tutaj:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust\nfn r#match(needle: &str, haystack: &str) -> bool {\n    haystack.contains(needle)\n}\n\nfn main() {\n    assert!(r#match(\"foo\", \"foobar\"));\n}\n```\n\nTen kod skompiluje siÄ™ bez Å¼adnych bÅ‚Ä™dÃ³w. ZwrÃ³Ä‡ uwagÄ™ na prefiks `r#` w nazwie funkcji w jej definicji, a takÅ¼e tam, gdzie funkcja jest wywoÅ‚ywana w `main`.\n\nSurowe identyfikatory pozwalajÄ… uÅ¼ywaÄ‡ dowolnego sÅ‚owa jako identyfikatora, nawet jeÅ›li to sÅ‚owo jest zarezerwowanym sÅ‚owem kluczowym. Daje to nam wiÄ™kszÄ… swobodÄ™ w wyborze nazw identyfikatorÃ³w, a takÅ¼e umoÅ¼liwia integracjÄ™ z programami napisanymi w jÄ™zyku, w ktÃ³rym te sÅ‚owa nie sÄ… sÅ‚owami kluczowymi. Ponadto, surowe identyfikatory pozwalajÄ… uÅ¼ywaÄ‡ bibliotek napisanych w innej edycji Rust niÅ¼ ta, ktÃ³rej uÅ¼ywa twoja skrzynka. Na przykÅ‚ad, `try` nie jest sÅ‚owem kluczowym w edycji 2015, ale jest w edycjach 2018, 2021 i 2024. JeÅ›li zaleÅ¼y Ci na bibliotece napisanej w edycji 2015 i ma ona funkcjÄ™ `try`, bÄ™dziesz musiaÅ‚ uÅ¼yÄ‡ skÅ‚adni surowego identyfikatora, w tym przypadku `r#try`, aby wywoÅ‚aÄ‡ tÄ™ funkcjÄ™ z kodu w pÃ³Åºniejszych edycjach. WiÄ™cej informacji na temat edycji znajdziesz w [Dodatku E][appendix-e]<!-- ignore -->.\n\n[appendix-e]: appendix-05-editions.html\n",
        "chapter_title": "A - SÅ‚owa kluczowe"
    },
    {
        "file_path": "appendix-02-operators.md",
        "content": "## Dodatek B: Operatory i symbole\n\nTen dodatek zawiera sÅ‚ownik skÅ‚adni Rust, w tym operatory i inne symbole, ktÃ³re pojawiajÄ… siÄ™ samodzielnie lub w kontekÅ›cie Å›cieÅ¼ek, typÃ³w generycznych, ograniczeÅ„ cech, makr, atrybutÃ³w, komentarzy, krotek i nawiasÃ³w.\n\n### Operatory\n\nTabela B-1 zawiera operatory w Rust, przykÅ‚ad, jak operator pojawiÅ‚by siÄ™ w kontekÅ›cie, krÃ³tkie wyjaÅ›nienie i informacjÄ™, czy operator jest przeciÄ…Å¼alny. JeÅ›li operator jest przeciÄ…Å¼alny, wymieniona jest odpowiednia cecha do uÅ¼ycia w celu przeciÄ…Å¼enia tego operatora.\n\n<span class=\"caption\">Tabela B-1: Operatory</span>\n\n| Operator                  | PrzykÅ‚ad                                                 | WyjaÅ›nienie                                                           | PrzeciÄ…Å¼alny?  |\n| ------------------------- | ------------------------------------------------------- | --------------------------------------------------------------------- | -------------- |\n| `!`                       | `ident!(...)`, `ident!{...}`, `ident![...]`             | RozwiniÄ™cie makra                                                     |                |\n| `!`                       | `!expr`                                                 | Bitowa lub logiczna negacja                                           | `Not`          |\n| `!=`                      | `expr != expr`                                          | PorÃ³wnanie nierÃ³wnoÅ›ci                                                | `PartialEq`    |\n| `%`                       | `expr % expr`                                           | Reszta z dzielenia arytmetycznego                                     | `Rem`          |\n| `%=`                      | `var %= expr`                                           | Reszta z dzielenia arytmetycznego i przypisanie                       | `RemAssign`    |\n| `&`                       | `&expr`, `&mut expr`                                    | PoÅ¼yczenie                                                            |                |\n| `&`                       | `&type`, `&mut type`, `&'a type`, `&'a mut type`        | Typ wskaÅºnika poÅ¼yczonego                                             |                |\n| `&`                       | `expr & expr`                                           | Bitowe AND                                                            | `BitAnd`       |\n| `&=`                      | `var &= expr`                                           | Bitowe AND i przypisanie                                              | `BitAndAssign` |\n| `&&`                      | `expr && expr`                                          | KrÃ³tkookresowe logiczne AND                                           |                |\n| `*`                       | `expr * expr`                                           | MnoÅ¼enie arytmetyczne                                                 | `Mul`          |\n| `*=`                      | `var *= expr`                                           | MnoÅ¼enie arytmetyczne i przypisanie                                   | `MulAssign`    |\n| `*`                       | `*expr`                                                 | Dereferencja                                                          | `Deref`        |\n| `*`                       | `*const type`, `*mut type`                              | Surowy wskaÅºnik                                                       |                |\n| `+`                       | `trait + trait`, `'a + trait`                           | Ograniczenie typu zÅ‚oÅ¼onego                                           |                |\n| `+`                       | `expr + expr`                                           | Dodawanie arytmetyczne                                                | `Add`          |\n| `+=`                      | `var += expr`                                           | Dodawanie arytmetyczne i przypisanie                                  | `AddAssign`    |\n| `,`                       | `expr, expr`                                            | Separator argumentÃ³w i elementÃ³w                                      |                |\n| `-`                       | `- expr`                                                | Negacja arytmetyczna                                                  | `Neg`          |\n| `-`                       | `expr - expr`                                           | Odejmowanie arytmetyczne                                              | `Sub`          |\n| `-=`                      | `var -= expr`                                           | Odejmowanie arytmetyczne i przypisanie                                | `SubAssign`    |\n| `->`                      | `fn(...) -> type`, <code>&vert;...&vert; -> type</code> | Typ zwracany funkcji i zamkniÄ™cia                                     |                |\n| `.`                       | `expr.ident`                                            | DostÄ™p do pola                                                        |                |\n| `.`                       | `expr.ident(expr, ...)`                                 | WywoÅ‚anie metody                                                      |                |\n| `.`                       | `expr.0`, `expr.1`, i tak dalej                         | Indeksowanie krotek                                                   |                |\n| `..`                      | `..`, `expr..`, `..expr`, `expr..expr`                  | LiteraÅ‚ zakresu wyÅ‚Ä…czajÄ…cego prawÄ… stronÄ™                            | `PartialOrd`   |\n| `..=`                     | `..=expr`, `expr..=expr`                                | LiteraÅ‚ zakresu wÅ‚Ä…czajÄ…cego prawÄ… stronÄ™                             | `PartialOrd`   |\n| `..`                      | `..expr`                                                | SkÅ‚adnia aktualizacji literaÅ‚u struktury                              |                |\n| `..`                      | `variant(x, ..)`, `struct_type { x, .. }`               | WiÄ…zanie wzorca â€i resztaâ€                                            |                |\n| `...`                     | `expr...expr`                                           | (PrzestarzaÅ‚e, uÅ¼yj `..=` zamiast) We wzorcu: wzorzec zakresu wÅ‚Ä…czajÄ…cego |                |\n| `/`                       | `expr / expr`                                           | Dzielenie arytmetyczne                                                | `Div`          |\n| `/=`                      | `var /= expr`                                           | Dzielenie arytmetyczne i przypisanie                                  | `DivAssign`    |\n| `:`                       | `pat: type`, `ident: type`                              | Ograniczenia                                                          |                |\n| `:`                       | `ident: expr`                                           | Inicjalizator pola struktury                                          |                |\n| `:`                       | `'a: loop {...}`                                        | Etykieta pÄ™tli                                                        |                |\n| `;`                       | `expr;`                                                 | Terminator instrukcji i elementu                                      |                |\n| `;`                       | `[...; len]`                                            | CzÄ™Å›Ä‡ skÅ‚adni tablicy o staÅ‚ym rozmiarze                              |                |\n| `<<`                      | `expr << expr`                                          | PrzesuniÄ™cie w lewo                                                    | `Shl`          |\n| `<<=`                     | `var <<= expr`                                          | PrzesuniÄ™cie w lewo i przypisanie                                     | `ShlAssign`    |\n| `<`                       | `expr < expr`                                           | PorÃ³wnanie â€mniejsze niÅ¼â€                                             | `PartialOrd`   |\n| `<=`                      | `expr <= expr`                                          | PorÃ³wnanie â€mniejsze niÅ¼ lub rÃ³wneâ€                                   | `PartialOrd`   |\n| `=`                       | `var = expr`, `ident = type`                            | Przypisanie/rÃ³wnowaÅ¼noÅ›Ä‡                                              |                |\n| `==`                      | `expr == expr`                                          | PorÃ³wnanie rÃ³wnoÅ›ci                                                   | `PartialEq`    |\n| `=>`                      | `pat => expr`                                           | CzÄ™Å›Ä‡ skÅ‚adni ramienia dopasowania                                    |                |\n| `>`                       | `expr > expr`                                           | PorÃ³wnanie â€wiÄ™ksze niÅ¼â€                                              | `PartialOrd`   |\n| `>=`                      | `expr >= expr`                                          | PorÃ³wnanie â€wiÄ™ksze niÅ¼ lub rÃ³wneâ€                                   | `PartialOrd`   |\n| `>>`                      | `expr >> expr`                                          | PrzesuniÄ™cie w prawo                                                  | `Shr`          |\n| `>>=`                     | `var >>= expr`                                          | PrzesuniÄ™cie w prawo i przypisanie                                    | `ShrAssign`    |\n| `@`                       | `ident @ pat`                                           | WiÄ…zanie wzorca                                                       |                |\n| `^`                       | `expr ^ expr`                                           | Bitowe OR wyÅ‚Ä…czne                                                    | `BitXor`       |\n| `^=`                      | `var ^= expr`                                           | Bitowe OR wyÅ‚Ä…czne i przypisanie                                      | `BitXorAssign` |\n| <code>&vert;</code>       | <code>pat &vert; pat</code>                             | Alternatywy wzorcÃ³w                                                   |                |\n| <code>&vert;</code>       | <code>expr &vert; expr</code>                           | Bitowe OR                                                             | `BitOr`        |\n| <code>&vert;=</code>      | <code>var &vert;= expr</code>                           | Bitowe OR i przypisanie                                               | `BitOrAssign`  |\n| <code>&vert;&vert;</code> | <code>expr &vert;&vert; expr</code>                     | KrÃ³tkookresowe logiczne OR                                            |                |\n| `?`                       | `expr?`                                                 | Propagacja bÅ‚Ä™du                                                      |                |\n\n### Symbole niebÄ™dÄ…ce operatorami\n\nPoniÅ¼sze tabele zawierajÄ… wszystkie symbole, ktÃ³re nie peÅ‚niÄ… funkcji operatorÃ³w; to znaczy, nie zachowujÄ… siÄ™ jak wywoÅ‚anie funkcji lub metody.\n\nTabela B-2 przedstawia symbole, ktÃ³re wystÄ™pujÄ… samodzielnie i sÄ… waÅ¼ne w rÃ³Å¼nych miejscach.\n\n<span class=\"caption\">Tabela B-2: SkÅ‚adnia samodzielna</span>\n\n| Symbol                                                                 | WyjaÅ›nienie                                                            |\n| ---------------------------------------------------------------------- | ---------------------------------------------------------------------- |\n| `'ident`                                                               | Nazwane Å¼ycie lub etykieta pÄ™tli                                       |\n| Cyfry natychmiastowo poprzedzone `u8`, `i32`, `f64`, `usize` itd.      | LiteraÅ‚ numeryczny okreÅ›lonego typu                                    |\n| `\"...\"`                                                                | LiteraÅ‚ ciÄ…gu znakÃ³w                                                   |\n| `r\"...\"`, `r#\"...\"#`, `r##\"...\"##` itd.                               | Surowy literaÅ‚ ciÄ…gu znakÃ³w; znaki ucieczki nie sÄ… przetwarzane        |\n| `b\"...\"`                                                               | LiteraÅ‚ ciÄ…gu bajtÃ³w; konstruuje tablicÄ™ bajtÃ³w zamiast ciÄ…gu znakÃ³w   |\n| `br\"...\"`, `br#\"...\"#`, `br##\"...\"##` itd.                             | Surowy literaÅ‚ ciÄ…gu bajtÃ³w; poÅ‚Ä…czenie surowego i bajtowego literaÅ‚u |\n| `'...'`                                                                | LiteraÅ‚ znaku                                                          |\n| `b'...'`                                                               | LiteraÅ‚ bajtu ASCII                                                    |\n| <code>&vert;...&vert; expr</code>                                      | ZamkniÄ™cie (closure)                                                   |\n| `!`                                                                    | Zawsze pusty typ dolny dla funkcji rozbieÅ¼nych                         |\n| `_`                                                                    | WiÄ…zanie wzorca â€ignorowaneâ€; uÅ¼ywane rÃ³wnieÅ¼ do czytelnoÅ›ci literaÅ‚Ã³w caÅ‚kowitych |\n\nTabela B-3 przedstawia symbole, ktÃ³re pojawiajÄ… siÄ™ w kontekÅ›cie Å›cieÅ¼ki przez hierarchiÄ™ moduÅ‚Ã³w do elementu.\n\n<span class=\"caption\">Tabela B-3: SkÅ‚adnia zwiÄ…zana ze Å›cieÅ¼kami</span>\n\n| Symbol                                  | WyjaÅ›nienie                                                                                                  |\n| --------------------------------------- | -------------------------------------------------------------------------------------------------------------|\n| `ident::ident`                          | ÅšcieÅ¼ka przestrzeni nazw                                                                                     |\n| `::path`                                | ÅšcieÅ¼ka wzglÄ™dna do katalogu gÅ‚Ã³wnego skrzynki (tj. jawnie Å›cieÅ¼ka bezwzglÄ™dna)                             |\n| `self::path`                            | ÅšcieÅ¼ka wzglÄ™dna do bieÅ¼Ä…cego moduÅ‚u (tj. jawnie Å›cieÅ¼ka wzglÄ™dna)                                          |\n| `super::path`                           | ÅšcieÅ¼ka wzglÄ™dna do nadrzÄ™dnego moduÅ‚u bieÅ¼Ä…cego moduÅ‚u                                                     |\n| `type::ident`, `<type as trait>::ident` | Stowarzyszone staÅ‚e, funkcje i typy                                                                          |\n| `<type>::...`                           | Stowarzyszony element dla typu, ktÃ³rego nie moÅ¼na bezpoÅ›rednio nazwaÄ‡ (na przykÅ‚ad `<&T>::...`, `<[T]>::...` itd.) |\n| `trait::method(...)`                    | RozrÃ³Å¼nianie wywoÅ‚ania metody przez nazwanie cechy, ktÃ³ra jÄ… definiuje                                      |\n| `type::method(...)`                     | RozrÃ³Å¼nianie wywoÅ‚ania metody przez nazwanie typu, dla ktÃ³rego jest zdefiniowana                            |\n| `<type as trait>::method(...)`          | RozrÃ³Å¼nianie wywoÅ‚ania metody przez nazwanie cechy i typu                                                    |\n\nTabela B-4 przedstawia symbole, ktÃ³re pojawiajÄ… siÄ™ w kontekÅ›cie uÅ¼ywania generycznych parametrÃ³w typu.\n\n<span class=\"caption\">Tabela B-4: Typy generyczne</span>\n\n| Symbol                         | WyjaÅ›nienie                                                                                                                                         |\n| ------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `path<...>`                    | OkreÅ›la parametry dla typu generycznego w typie (np. `Vec<u8>`)                                                                                     |\n| `path::<...>`, `method::<...>` | OkreÅ›la parametry dla typu, funkcji lub metody generycznej w wyraÅ¼eniu; czÄ™sto okreÅ›lane jako _turbofish_ (np. `\"42\".parse::<i32>()`)             |\n| `fn ident<...> ...`            | Definiuje funkcjÄ™ generycznÄ…                                                                                                                        |\n| `struct ident<...> ...`        | Definiuje strukturÄ™ generycznÄ…                                                                                                                      |\n| `enum ident<...> ...`          | Definiuje wyliczenie generyczne                                                                                                                     |\n| `impl<...> ...`                | Definiuje implementacjÄ™ generycznÄ…                                                                                                                  |\n| `for<...> type`                | Ograniczenia czasu Å¼ycia wyÅ¼szego rzÄ™du                                                                                                             |\n| `type<ident=type>`             | Typ generyczny, w ktÃ³rym jeden lub wiÄ™cej stowarzyszonych typÃ³w ma okreÅ›lone przypisania (np. `Iterator<Item=T>`)                              |\n\nTabela B-5 przedstawia symbole, ktÃ³re pojawiajÄ… siÄ™ w kontekÅ›cie ograniczania generycznych parametrÃ³w typu za pomocÄ… ograniczeÅ„ cech.\n\n<span class=\"caption\">Tabela B-5: Ograniczenia cech</span>\n\n| Symbol                        | WyjaÅ›nienie                                                                                                                                |\n| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |\n| `T: U`                        | Parametr generyczny `T` ograniczony do typÃ³w, ktÃ³re implementujÄ… `U`                                                                       |\n| `T: 'a`                       | Typ generyczny `T` musi przetrwaÄ‡ czas Å¼ycia `'a` (co oznacza, Å¼e typ nie moÅ¼e przejÅ›ciowo zawieraÄ‡ Å¼adnych referencji o krÃ³tszych czasach Å¼ycia niÅ¼ `'a`) |\n| `T: 'static`                  | Typ generyczny `T` nie zawiera Å¼adnych poÅ¼yczonych referencji innych niÅ¼ te `'static`                                                      |\n| `'b: 'a`                      | Generyczny czas Å¼ycia `'b` musi przetrwaÄ‡ czas Å¼ycia `'a`                                                                                 |\n| `T: ?Sized`                   | Zezwala parametrowi typu generycznego na bycie typem o dynamicznym rozmiarze                                                              |\n| `'a + trait`, `trait + trait` | Ograniczenie typu zÅ‚oÅ¼onego                                                                                                                |\n\nTabela B-6 przedstawia symbole, ktÃ³re pojawiajÄ… siÄ™ w kontekÅ›cie wywoÅ‚ywania lub definiowania makr oraz okreÅ›lania atrybutÃ³w dla elementu.\n\n<span class=\"caption\">Tabela B-6: Makra i atrybuty</span>\n\n| Symbol                                      | WyjaÅ›nienie        |\n| ------------------------------------------- | ------------------ |\n| `#[meta]`                                   | Atrybut zewnÄ™trzny |\n| `#![meta]`                                  | Atrybut wewnÄ™trzny |\n| `$ident`                                    | Podstawienie makra |\n| `$ident:kind`                               | Metazmienna makra  |\n| `$(...)...`                                 | PowtÃ³rzenie makra  |\n| `ident!(...)`, `ident!{...}`, `ident![...]` | WywoÅ‚anie makra    |\n\nTabela B-7 przedstawia symbole tworzÄ…ce komentarze.\n\n<span class=\"caption\">Tabela B-7: Komentarze</span>\n\n| Symbol     | WyjaÅ›nienie             |\n| ---------- | ----------------------- |\n| `//`       | Komentarz liniowy       |\n| `//!`      | WewnÄ™trzny komentarz doc. liniowy |\n| `///`      | ZewnÄ™trzny komentarz doc. liniowy |\n| `/*...*/`  | Komentarz blokowy       |\n| `/*!...*/` | WewnÄ™trzny komentarz doc. blokowy |\n| `/**...*/` | ZewnÄ™trzny komentarz doc. blokowy |\n\nTabela B-8 przedstawia konteksty, w ktÃ³rych uÅ¼ywane sÄ… nawiasy.\n\n<span class=\"caption\">Tabela B-8: Nawiasy</span>\n\n| Symbol                   | WyjaÅ›nienie                                                                                 |\n| ------------------------ | ------------------------------------------------------------------------------------------- |\n| `()`                     | Pusta krotka (aka jednostka), zarÃ³wno literaÅ‚, jak i typ                                    |\n| `(expr)`                 | WyraÅ¼enie w nawiasach                                                                       |\n| `(expr,)`                | WyraÅ¼enie krotki z jednym elementem                                                         |\n| `(type,)`                | Typ krotki z jednym elementem                                                               |\n| `(expr, ...)`            | WyraÅ¼enie krotki                                                                            |\n| `(type, ...)`            | Typ krotki                                                                                  |\n| `expr(expr, ...)`        | WyraÅ¼enie wywoÅ‚ania funkcji; uÅ¼ywane rÃ³wnieÅ¼ do inicjalizacji struktur krotek i wariantÃ³w enum krotek |\n\nTabela B-9 przedstawia konteksty, w ktÃ³rych uÅ¼ywane sÄ… nawiasy klamrowe.\n\n<span class=\"caption\">Tabela B-9: Nawiasy klamrowe</span>\n\n| Kontekst      | WyjaÅ›nienie      |\n| ------------ | ---------------- |\n| `{...}`      | WyraÅ¼enie bloku  |\n| `Type {...}` | LiteraÅ‚ struktury |\n\nTabela B-10 przedstawia konteksty, w ktÃ³rych uÅ¼ywane sÄ… nawiasy kwadratowe.\n\n<span class=\"caption\">Tabela B-10: Nawiasy kwadratowe</span>\n\n| Kontekst                                            | WyjaÅ›nienie                                                                                                                   |\n| -------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------- |\n| `[...]`                                            | LiteraÅ‚ tablicy                                                                                                               |\n| `[expr; len]`                                      | LiteraÅ‚ tablicy zawierajÄ…cy `len` kopii `expr`                                                                                |\n| `[type; len]`                                      | Typ tablicy zawierajÄ…cy `len` instancji `type`                                                                                |\n| `expr[expr]`                                       | Indeksowanie kolekcji; przeciÄ…Å¼alne (`Index`, `IndexMut`)                                                                     |\n| `expr[..]`, `expr[a..]`, `expr[..b]`, `expr[a..b]` | Indeksowanie kolekcji udajÄ…ce wycinanie kolekcji, uÅ¼ywajÄ…ce `Range`, `RangeFrom`, `RangeTo` lub `RangeFull` jako â€indeksuâ€ |\n",
        "chapter_title": "B - Operatory i symbole"
    },
    {
        "file_path": "appendix-03-derivable-traits.md",
        "content": "## Dodatek C: Cechy dziedziczne (Derivable Traits)\n\nW rÃ³Å¼nych miejscach w ksiÄ…Å¼ce omawialiÅ›my atrybut `derive`, ktÃ³ry moÅ¼na zastosowaÄ‡ do definicji struktury lub wyliczenia. Atrybut `derive` generuje kod, ktÃ³ry zaimplementuje cechÄ™ z wÅ‚asnÄ… domyÅ›lnÄ… implementacjÄ… dla typu, ktÃ³ry opatrzyÅ‚eÅ› skÅ‚adniÄ… `derive`.\n\nW tym dodatku przedstawiamy odniesienie do wszystkich cech w bibliotece standardowej, ktÃ³rych moÅ¼esz uÅ¼ywaÄ‡ z `derive`. KaÅ¼da sekcja obejmuje:\n\n- Jakie operatory i metody umoÅ¼liwi dziedziczenie tej cechy.\n- Co robi implementacja cechy dostarczana przez `derive`.\n- Co implementacja cechy oznacza dla typu.\n- Warunki, w ktÃ³rych dozwolone lub niedozwolone jest implementowanie cechy.\n- PrzykÅ‚ady operacji, ktÃ³re wymagajÄ… tej cechy.\n\nJeÅ›li chcesz innego zachowania niÅ¼ to, ktÃ³re zapewnia atrybut `derive`, zapoznaj siÄ™ z [dokumentacjÄ… biblioteki standardowej](../std/index.html)<!-- ignore --> dla kaÅ¼dej cechy, aby uzyskaÄ‡ szczegÃ³Å‚owe informacje na temat rÄ™cznej ich implementacji.\n\nCechy wymienione tutaj sÄ… jedynymi zdefiniowanymi przez bibliotekÄ™ standardowÄ…, ktÃ³re mogÄ… byÄ‡ implementowane na twoich typach za pomocÄ… `derive`. Inne cechy zdefiniowane w bibliotece standardowej nie majÄ… sensownego domyÅ›lnego zachowania, wiÄ™c to od ciebie zaleÅ¼y, jak je zaimplementujesz, aby miaÅ‚y sens dla tego, co prÃ³bujesz osiÄ…gnÄ…Ä‡.\n\nPrzykÅ‚adem cechy, ktÃ³rej nie moÅ¼na dziedziczyÄ‡, jest `Display`, ktÃ³ra obsÅ‚uguje formatowanie dla uÅ¼ytkownikÃ³w koÅ„cowych. Zawsze powinieneÅ› rozwaÅ¼yÄ‡ odpowiedni sposÃ³b wyÅ›wietlania typu uÅ¼ytkownikowi koÅ„cowemu. Jakie czÄ™Å›ci typu powinny byÄ‡ widoczne dla uÅ¼ytkownika koÅ„cowego? Jakie czÄ™Å›ci byÅ‚yby dla nich istotne? Jaki format danych byÅ‚by dla nich najbardziej istotny? Kompilator Rusta nie ma tej wiedzy, wiÄ™c nie moÅ¼e zapewniÄ‡ odpowiedniego domyÅ›lnego zachowania.\n\nLista cech dziedzicznych podana w tym dodatku nie jest wyczerpujÄ…ca: biblioteki mogÄ… implementowaÄ‡ `derive` dla wÅ‚asnych cech, co sprawia, Å¼e lista cech, z ktÃ³rymi moÅ¼na uÅ¼ywaÄ‡ `derive`, jest naprawdÄ™ otwarta. Implementacja `derive` wiÄ…Å¼e siÄ™ z uÅ¼yciem makra proceduralnego, co zostaÅ‚o omÃ³wione w sekcji [â€Niestandardowe makra `derive`â€][custom-derive-macros]<!-- ignore --> w Rozdziale 20.\n\n### `Debug` dla wyjÅ›cia programisty\n\nCecha `Debug` umoÅ¼liwia formatowanie debugowania w ciÄ…gach formatujÄ…cych, co sygnalizujesz, dodajÄ…c `:?` wewnÄ…trz symboli zastÄ™pczych `{}`.\n\nCecha `Debug` pozwala na drukowanie instancji typu w celach debugowania, dziÄ™ki czemu ty i inni programiÅ›ci uÅ¼ywajÄ…cy twojego typu moÅ¼ecie sprawdziÄ‡ instancjÄ™ w okreÅ›lonym punkcie wykonania programu.\n\nCecha `Debug` jest wymagana, na przykÅ‚ad, przy uÅ¼yciu makra `assert_eq!`. To makro drukuje wartoÅ›ci instancji podanych jako argumenty, jeÅ›li twierdzenie o rÃ³wnoÅ›ci zawiedzie, tak aby programiÅ›ci mogli zobaczyÄ‡, dlaczego dwie instancje nie byÅ‚y rÃ³wne.\n\n### `PartialEq` i `Eq` dla porÃ³wnaÅ„ rÃ³wnoÅ›ci\n\nCecha `PartialEq` pozwala porÃ³wnywaÄ‡ instancje typu pod kÄ…tem rÃ³wnoÅ›ci i umoÅ¼liwia uÅ¼ycie operatorÃ³w `==` i `!=`.\n\nDziedziczenie `PartialEq` implementuje metodÄ™ `eq`. Gdy `PartialEq` jest dziedziczone w strukturach, dwie instancje sÄ… rÃ³wne tylko wtedy, gdy _wszystkie_ pola sÄ… rÃ³wne, i nie sÄ… rÃ³wne, jeÅ›li _ktÃ³rekolwiek_ pola nie sÄ… rÃ³wne. Gdy dziedziczone w wyliczeniach, kaÅ¼dy wariant jest rÃ³wny sam sobie i nierÃ³wny innym wariantom.\n\nCecha `PartialEq` jest wymagana, na przykÅ‚ad, przy uÅ¼yciu makra `assert_eq!`, ktÃ³re musi byÄ‡ w stanie porÃ³wnaÄ‡ dwie instancje typu pod kÄ…tem rÃ³wnoÅ›ci.\n\nCecha `Eq` nie ma Å¼adnych metod. Jej celem jest sygnalizowanie, Å¼e dla kaÅ¼dej wartoÅ›ci typu oznaczonego, wartoÅ›Ä‡ jest rÃ³wna sobie. Cecha `Eq` moÅ¼e byÄ‡ zastosowana tylko do typÃ³w, ktÃ³re rÃ³wnieÅ¼ implementujÄ… `PartialEq`, chociaÅ¼ nie wszystkie typy, ktÃ³re implementujÄ… `PartialEq`, mogÄ… implementowaÄ‡ `Eq`. Jednym z przykÅ‚adÃ³w sÄ… typy liczb zmiennoprzecinkowych: implementacja liczb zmiennoprzecinkowych mÃ³wi, Å¼e dwie instancje wartoÅ›ci not-a-number (`NaN`) nie sÄ… sobie rÃ³wne.\n\nPrzykÅ‚adem, kiedy wymagana jest cecha `Eq`, jest uÅ¼ycie kluczy w `HashMap<K, V>`, aby `HashMap<K, V>` mogÅ‚o stwierdziÄ‡, czy dwa klucze sÄ… takie same.\n\n### `PartialOrd` i `Ord` dla porÃ³wnaÅ„ porzÄ…dkowania\n\nCecha `PartialOrd` pozwala porÃ³wnywaÄ‡ instancje typu w celach sortowania. Typ, ktÃ³ry implementuje `PartialOrd`, moÅ¼e byÄ‡ uÅ¼ywany z operatorami `<`, `>`, `<=`, i `>=`. CechÄ™ `PartialOrd` moÅ¼na zastosowaÄ‡ tylko do typÃ³w, ktÃ³re rÃ³wnieÅ¼ implementujÄ… `PartialEq`.\n\nDziedziczenie `PartialOrd` implementuje metodÄ™ `partial_cmp`, ktÃ³ra zwraca `Option<Ordering>`, ktÃ³ra bÄ™dzie `None`, gdy podane wartoÅ›ci nie dajÄ… porzÄ…dku. PrzykÅ‚adem wartoÅ›ci, ktÃ³ra nie daje porzÄ…dku, nawet jeÅ›li wiÄ™kszoÅ›Ä‡ wartoÅ›ci tego typu moÅ¼na porÃ³wnaÄ‡, jest wartoÅ›Ä‡ zmiennoprzecinkowa `NaN`. WywoÅ‚anie `partial_cmp` z dowolnÄ… liczbÄ… zmiennoprzecinkowÄ… i wartoÅ›ciÄ… zmiennoprzecinkowÄ… `NaN` zwrÃ³ci `None`.\n\nDziedziczÄ…c w strukturach, `PartialOrd` porÃ³wnuje dwie instancje, porÃ³wnujÄ…c wartoÅ›Ä‡ w kaÅ¼dym polu w kolejnoÅ›ci, w jakiej pola pojawiajÄ… siÄ™ w definicji struktury. DziedziczÄ…c w wyliczeniach, warianty wyliczenia zadeklarowane wczeÅ›niej w definicji wyliczenia sÄ… uwaÅ¼ane za mniejsze niÅ¼ warianty wymienione pÃ³Åºniej.\n\nCecha `PartialOrd` jest wymagana, na przykÅ‚ad, dla metody `gen_range` z crate `rand`, ktÃ³ra generuje losowÄ… wartoÅ›Ä‡ w zakresie okreÅ›lonym przez wyraÅ¼enie zakresowe.\n\nCecha `Ord` pozwala wiedzieÄ‡, Å¼e dla dowolnych dwÃ³ch wartoÅ›ci typu opisanego adnotacjÄ…, zawsze bÄ™dzie istniaÅ‚o prawidÅ‚owe uporzÄ…dkowanie. Cecha `Ord` implementuje metodÄ™ `cmp`, ktÃ³ra zwraca `Ordering` zamiast `Option<Ordering>`, poniewaÅ¼ prawidÅ‚owe uporzÄ…dkowanie zawsze bÄ™dzie moÅ¼liwe. CechÄ™ `Ord` moÅ¼na zastosowaÄ‡ tylko do typÃ³w, ktÃ³re rÃ³wnieÅ¼ implementujÄ… `PartialOrd` i `Eq` (a `Eq` wymaga `PartialEq`). DziedziczÄ…c w strukturach i wyliczeniach, `cmp` zachowuje siÄ™ tak samo jak zaimplementowane `partial_cmp` w `PartialOrd`.\n\nPrzykÅ‚adem, kiedy wymagana jest cecha `Ord`, jest przechowywanie wartoÅ›ci w `BTreeSet<T>`, strukturze danych, ktÃ³ra przechowuje dane na podstawie kolejnoÅ›ci sortowania wartoÅ›ci.\n\n### `Clone` i `Copy` do duplikowania wartoÅ›ci\n\nCecha `Clone` pozwala jawnie utworzyÄ‡ gÅ‚Ä™bokÄ… kopiÄ™ wartoÅ›ci, a proces duplikacji moÅ¼e obejmowaÄ‡ uruchomienie dowolnego kodu i kopiowanie danych na stercie. Aby uzyskaÄ‡ wiÄ™cej informacji na temat `Clone`, zobacz sekcjÄ™ [â€Zmienne i dane wspÃ³Å‚dziaÅ‚ajÄ…ce z Cloneâ€][variables-and-data-interacting-with-clone]<!-- ignore --> w Rozdziale 4.\n\nDziedziczenie `Clone` implementuje metodÄ™ `clone`, ktÃ³ra, zaimplementowana dla caÅ‚ego typu, wywoÅ‚uje `clone` na kaÅ¼dej z czÄ™Å›ci typu. Oznacza to, Å¼e wszystkie pola lub wartoÅ›ci w typie muszÄ… rÃ³wnieÅ¼ implementowaÄ‡ `Clone`, aby dziedziczyÄ‡ `Clone`.\n\nPrzykÅ‚adem, kiedy wymagana jest cecha `Clone`, jest wywoÅ‚anie metody `to_vec` na wycinku. Wycinek nie jest wÅ‚aÅ›cicielem instancji typÃ³w, ktÃ³re zawiera, ale wektor zwrÃ³cony z `to_vec` bÄ™dzie musiaÅ‚ byÄ‡ wÅ‚aÅ›cicielem swoich instancji, wiÄ™c `to_vec` wywoÅ‚uje `clone` na kaÅ¼dym elemencie. W ten sposÃ³b typ przechowywany w wycinku musi implementowaÄ‡ `Clone`.\n\nCecha `Copy` pozwala duplikowaÄ‡ wartoÅ›Ä‡ tylko poprzez kopiowanie bitÃ³w przechowywanych na stosie; nie jest potrzebny Å¼aden arbitralny kod. WiÄ™cej informacji na temat `Copy` znajdziesz w sekcji [â€Dane tylko na stosie: Copyâ€][stack-only-data-copy]<!-- ignore --> w Rozdziale 4.\n\nCecha `Copy` nie definiuje Å¼adnych metod, aby zapobiec przeciÄ…Å¼aniu tych metod przez programistÃ³w i naruszaniu zaÅ‚oÅ¼enia, Å¼e Å¼aden arbitralny kod nie jest wykonywany. W ten sposÃ³b wszyscy programiÅ›ci mogÄ… zakÅ‚adaÄ‡, Å¼e kopiowanie wartoÅ›ci bÄ™dzie bardzo szybkie.\n\nMoÅ¼esz dziedziczyÄ‡ `Copy` na dowolnym typie, ktÃ³rego wszystkie czÄ™Å›ci implementujÄ… `Copy`. Typ, ktÃ³ry implementuje `Copy`, musi rÃ³wnieÅ¼ implementowaÄ‡ `Clone`, poniewaÅ¼ typ, ktÃ³ry implementuje `Copy`, ma trywialnÄ… implementacjÄ™ `Clone`, ktÃ³ra wykonuje to samo zadanie co `Copy`.\n\nCecha `Copy` jest rzadko wymagana; typy, ktÃ³re implementujÄ… `Copy`, majÄ… dostÄ™pne optymalizacje, co oznacza, Å¼e nie musisz wywoÅ‚ywaÄ‡ `clone`, co sprawia, Å¼e kod jest bardziej zwiÄ™zÅ‚y.\n\nWszystko, co jest moÅ¼liwe z `Copy`, moÅ¼na rÃ³wnieÅ¼ osiÄ…gnÄ…Ä‡ z `Clone`, ale kod moÅ¼e byÄ‡ wolniejszy lub musi uÅ¼ywaÄ‡ `clone` w niektÃ³rych miejscach.\n\n### `Hash` do mapowania wartoÅ›ci na wartoÅ›Ä‡ o staÅ‚ym rozmiarze\n\nCecha `Hash` pozwala na pobranie instancji typu o dowolnym rozmiarze i zmapowanie jej na wartoÅ›Ä‡ o staÅ‚ym rozmiarze za pomocÄ… funkcji haszujÄ…cej. Dziedziczenie `Hash` implementuje metodÄ™ `hash`. Zaimplementowana metoda `hash` Å‚Ä…czy wynik wywoÅ‚ania `hash` na kaÅ¼dej z czÄ™Å›ci typu, co oznacza, Å¼e wszystkie pola lub wartoÅ›ci muszÄ… rÃ³wnieÅ¼ implementowaÄ‡ `Hash`, aby dziedziczyÄ‡ `Hash`.\n\nPrzykÅ‚adem, kiedy wymagana jest cecha `Hash`, jest przechowywanie kluczy w `HashMap<K, V>` w celu efektywnego przechowywania danych.\n\n### `Default` dla wartoÅ›ci domyÅ›lnych\n\nCecha `Default` pozwala utworzyÄ‡ domyÅ›lnÄ… wartoÅ›Ä‡ dla typu. Dziedziczenie `Default` implementuje funkcjÄ™ `default`. Dziedziczona implementacja funkcji `default` wywoÅ‚uje funkcjÄ™ `default` dla kaÅ¼dej czÄ™Å›ci typu, co oznacza, Å¼e wszystkie pola lub wartoÅ›ci w typie muszÄ… rÃ³wnieÅ¼ implementowaÄ‡ `Default`, aby dziedziczyÄ‡ `Default`.\n\nFunkcja `Default::default` jest powszechnie uÅ¼ywana w poÅ‚Ä…czeniu ze skÅ‚adniÄ… aktualizacji struktury omÃ³wionÄ… w sekcji [â€Tworzenie instancji z innych instancji za pomocÄ… skÅ‚adni aktualizacji strukturâ€][creating-instances-from-other-instances-with-struct-update-syntax]<!-- ignore --> w Rozdziale 5. MoÅ¼esz dostosowaÄ‡ kilka pÃ³l struktury, a nastÄ™pnie ustawiÄ‡ i uÅ¼yÄ‡ domyÅ›lnej wartoÅ›ci dla pozostaÅ‚ych pÃ³l, uÅ¼ywajÄ…c `..Default::default()`.\n\nCecha `Default` jest wymagana, gdy uÅ¼ywasz metody `unwrap_or_default` na instancjach `Option<T>`, na przykÅ‚ad. JeÅ›li `Option<T>` jest `None`, metoda `unwrap_or_default` zwrÃ³ci wynik `Default::default` dla typu `T` przechowywanego w `Option<T>`.\n\n[creating-instances-from-other-instances-with-struct-update-syntax]: ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax\n[stack-only-data-copy]: ch04-01-what-is-ownership.html#stack-only-data-copy\n[variables-and-data-interacting-with-clone]: ch04-01-what-is-ownership.html#variables-and-data-interacting-with-clone\n[custom-derive-macros]: ch20-05-macros.html#custom-derive-macros\n",
        "chapter_title": "C - Cechy dziedziczne"
    },
    {
        "file_path": "appendix-04-useful-development-tools.md",
        "content": "## Dodatek D: Przydatne narzÄ™dzia deweloperskie\n\nW tym dodatku omÃ³wimy kilka przydatnych narzÄ™dzi deweloperskich, ktÃ³re udostÄ™pnia projekt Rust. Przyjrzymy siÄ™ automatycznemu formatowaniu, szybkim sposobom stosowania poprawek ostrzeÅ¼eÅ„, linterowi oraz integracji z IDE.\n\n### Automatyczne formatowanie z `rustfmt`\n\nNarzÄ™dzie `rustfmt` formatuje twÃ³j kod zgodnie ze spoÅ‚ecznoÅ›ciowym stylem kodu. Wiele projektÃ³w wspÃ³Å‚pracujÄ…cych uÅ¼ywa `rustfmt`, aby zapobiec sporom o to, jaki styl zastosowaÄ‡ podczas pisania w Rust: kaÅ¼dy formatuje swÃ³j kod za pomocÄ… narzÄ™dzia.\n\nInstalacje Rust domyÅ›lnie zawierajÄ… `rustfmt`, wiÄ™c powinieneÅ› juÅ¼ mieÄ‡ programy `rustfmt` i `cargo-fmt` w swoim systemie. Te dwa polecenia sÄ… analogiczne do `rustc` i `cargo` w tym sensie, Å¼e `rustfmt` pozwala na bardziej szczegÃ³Å‚owÄ… kontrolÄ™, a `cargo-fmt` rozumie konwencje projektu uÅ¼ywajÄ…cego Cargo. Aby sformatowaÄ‡ dowolny projekt Cargo, wpisz nastÄ™pujÄ…ce polecenie:\n\n```console\n$ cargo fmt\n```\n\nUruchomienie tego polecenia formatuje caÅ‚y kod Rust w bieÅ¼Ä…cej skrzynce. Powinno to zmieniÄ‡ tylko styl kodu, a nie semantykÄ™ kodu. Aby uzyskaÄ‡ wiÄ™cej informacji o `rustfmt`, zobacz [jego dokumentacjÄ™][rustfmt].\n\n### Napraw swÃ³j kod za pomocÄ… `rustfix`\n\nNarzÄ™dzie `rustfix` jest doÅ‚Ä…czone do instalacji Rust i moÅ¼e automatycznie naprawiaÄ‡ ostrzeÅ¼enia kompilatora, ktÃ³re majÄ… jasny sposÃ³b rozwiÄ…zania problemu, ktÃ³ry jest prawdopodobnie tym, czego chcesz. Prawdopodobnie widziaÅ‚eÅ› juÅ¼ ostrzeÅ¼enia kompilatora. Na przykÅ‚ad, rozwaÅ¼ ten kod:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust\nfn main() {\n    let mut x = 42;\n    println!(\"{x}\");\n}\n```\n\nTutaj definiujemy zmiennÄ… `x` jako zmiennÄ…, ale nigdy jej faktycznie nie modyfikujemy. Rust ostrzega nas o tym:\n\n```console\n$ cargo build\n   Kompilowanie myprogram v0.1.0 (file:///projects/myprogram)\nwarning: zmienna nie musi byÄ‡ mutowalna\n --> src/main.rs:2:9\n  |\n2 |     let mut x = 0;\n  |         ----^\n  |         |\n  |         pomoc: usuÅ„ to `mut`\n  |\n  = note: `#[warn(unused_mut)]` domyÅ›lnie wÅ‚Ä…czone\n```\n\nOstrzeÅ¼enie sugeruje, aby usunÄ…Ä‡ sÅ‚owo kluczowe `mut`. MoÅ¼emy automatycznie zastosowaÄ‡ tÄ™ sugestiÄ™ za pomocÄ… narzÄ™dzia `rustfix`, uruchamiajÄ…c polecenie `cargo fix`:\n\n```console\n$ cargo fix\n    Sprawdzanie myprogram v0.1.0 (file:///projects/myprogram)\n      Naprawianie src/main.rs (1 poprawka)\n    ZakoÅ„czono dev [nieoptymalny + debuginfo] cel(e) w 0.59s\n```\n\nKiedy ponownie spojrzymy na _src/main.rs_, zobaczymy, Å¼e `cargo fix` zmieniÅ‚ kod:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n```rust\nfn main() {\n    let x = 42;\n    println!(\"{x}\");\n}\n```\n\nZmienna `x` jest teraz niezmienna, a ostrzeÅ¼enie juÅ¼ siÄ™ nie pojawia.\n\nMoÅ¼esz rÃ³wnieÅ¼ uÅ¼yÄ‡ polecenia `cargo fix`, aby przetransformowaÄ‡ swÃ³j kod miÄ™dzy rÃ³Å¼nymi edycjami Rust. Edycje sÄ… omÃ³wione w [Dodatku E][editions]<!-- ignore -->.\n\n### WiÄ™cej lintÃ³w z Clippy\n\nNarzÄ™dzie Clippy to zbiÃ³r lintÃ³w do analizowania kodu, dziÄ™ki czemu moÅ¼esz wyÅ‚apaÄ‡ typowe bÅ‚Ä™dy i ulepszyÄ‡ swÃ³j kod w Rust. Clippy jest doÅ‚Ä…czone do standardowych instalacji Rust.\n\nAby uruchomiÄ‡ lintery Clippy w dowolnym projekcie Cargo, wpisz nastÄ™pujÄ…ce polecenie:\n\n```console\n$ cargo clippy\n```\n\nNa przykÅ‚ad, powiedzmy, Å¼e piszesz program, ktÃ³ry uÅ¼ywa przybliÅ¼enia staÅ‚ej matematycznej, takiej jak pi, jak ten program:\n\n<Listing file-name=\"src/main.rs\">\n\n```rust\nfn main() {\n    let x = 3.1415;\n    let r = 8.0;\n    println!(\"powierzchnia koÅ‚a wynosi {}\", x * r * r);\n}\n```\n\n</Listing>\n\nUruchomienie `cargo clippy` w tym projekcie powoduje nastÄ™pujÄ…cy bÅ‚Ä…d:\n\n```text\nbÅ‚Ä…d: znaleziono przybliÅ¼onÄ… wartoÅ›Ä‡ `f{32, 64}::consts::PI`\n --> src/main.rs:2:13\n  |\n2 |     let x = 3.1415;\n  |             ^^^^^^\n  |\n  = note: `#[deny(clippy::approx_constant)]` domyÅ›lnie wÅ‚Ä…czone\n  = help: rozwaÅ¼ uÅ¼ycie staÅ‚ej bezpoÅ›rednio\n  = help: wiÄ™cej informacji znajdziesz na https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant\n```\n\nTen bÅ‚Ä…d informuje, Å¼e Rust ma juÅ¼ zdefiniowanÄ… bardziej precyzyjnÄ… staÅ‚Ä… `PI`, i Å¼e twÃ³j program byÅ‚by bardziej poprawny, gdybyÅ› zamiast tego uÅ¼yÅ‚ tej staÅ‚ej. NastÄ™pnie zmieniÅ‚byÅ› swÃ³j kod, aby uÅ¼ywaÄ‡ staÅ‚ej `PI`.\n\nPoniÅ¼szy kod nie powoduje Å¼adnych bÅ‚Ä™dÃ³w ani ostrzeÅ¼eÅ„ z Clippy:\n\n<Listing file-name=\"src/main.rs\">\n\n```rust\nfn main() {\n    let x = std::f64::consts::PI;\n    let r = 8.0;\n    println!(\"powierzchnia koÅ‚a wynosi {}\", x * r * r);\n}\n```\n\n</Listing>\n\nAby uzyskaÄ‡ wiÄ™cej informacji o Clippy, zobacz [jego dokumentacjÄ™][clippy].\n\n### Integracja z IDE za pomocÄ… `rust-analyzer`\n\nAby pomÃ³c w integracji z IDE, spoÅ‚ecznoÅ›Ä‡ Rust zaleca uÅ¼ywanie [`rust-analyzer`][rust-analyzer]<!-- ignore -->. To narzÄ™dzie to zestaw narzÄ™dzi zorientowanych na kompilator, ktÃ³re komunikujÄ… siÄ™ za pomocÄ… [Language Server Protocol][lsp]<!-- ignore -->, czyli specyfikacji komunikacji miÄ™dzy IDE a jÄ™zykami programowania. RÃ³Å¼ni klienci mogÄ… uÅ¼ywaÄ‡ `rust-analyzer`, np. [wtyczka Rust analyzer dla Visual Studio Code][vscode].\n\nOdwiedÅº [stronÄ™ gÅ‚Ã³wnÄ…][rust-analyzer]<!-- ignore --> projektu `rust-analyzer`, aby zapoznaÄ‡ siÄ™ z instrukcjami instalacji, a nastÄ™pnie zainstaluj obsÅ‚ugÄ™ serwera jÄ™zyka w swoim IDE. Twoje IDE zyska takie moÅ¼liwoÅ›ci jak autouzupeÅ‚nianie, skok do definicji i wbudowane bÅ‚Ä™dy.\n\n[rustfmt]: https://github.com/rust-lang/rustfmt\n[editions]: appendix-05-editions.md\n[clippy]: https://github.com/rust-lang/rust-clippy\n[rust-analyzer]: https://rust-analyzer.github.io\n[lsp]: http://langserver.org/\n[vscode]: https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer\n",
        "chapter_title": "D - Przydatne narzÄ™dzia deweloperskie"
    },
    {
        "file_path": "appendix-05-editions.md",
        "content": "## Dodatek E: Edycje\n\nW Rozdziale 1 widziaÅ‚eÅ›, Å¼e `cargo new` dodaje nieco metadanych do pliku _Cargo.toml_ dotyczÄ…cych edycji. Ten dodatek opowiada o tym, co to oznacza!\n\nJÄ™zyk i kompilator Rust majÄ… szeÅ›ciotygodniowy cykl wydawniczy, co oznacza, Å¼e uÅ¼ytkownicy otrzymujÄ… staÅ‚y strumieÅ„ nowych funkcji. Inne jÄ™zyki programowania rzadziej wydajÄ… wiÄ™ksze zmiany; Rust czÄ™Å›ciej wydaje mniejsze aktualizacje. Po pewnym czasie wszystkie te drobne zmiany sumujÄ… siÄ™. Ale z wydania na wydanie trudno jest spojrzeÄ‡ wstecz i powiedzieÄ‡: â€Wow, miÄ™dzy Rustem 1.10 a Rustem 1.31 Rust bardzo siÄ™ zmieniÅ‚!â€\n\nCo okoÅ‚o trzy lata zespÃ³Å‚ Rust tworzy nowÄ… _edycjÄ™_ Rust. KaÅ¼da edycja Å‚Ä…czy funkcje, ktÃ³re wylÄ…dowaÅ‚y, w przejrzysty pakiet z w peÅ‚ni zaktualizowanÄ… dokumentacjÄ… i narzÄ™dziami. Nowe edycje sÄ… dostarczane w ramach zwykÅ‚ego szeÅ›ciotygodniowego procesu wydawniczego.\n\nEdycje sÅ‚uÅ¼Ä… rÃ³Å¼nym celom dla rÃ³Å¼nych ludzi:\n\n- Dla aktywnych uÅ¼ytkownikÃ³w Rusta, nowa edycja Å‚Ä…czy stopniowe zmiany w Å‚atwy do zrozumienia pakiet.\n- Dla nie-uÅ¼ytkownikÃ³w, nowa edycja sygnalizuje, Å¼e nastÄ…piÅ‚y pewne powaÅ¼ne postÄ™py, co moÅ¼e sprawiÄ‡, Å¼e Rust bÄ™dzie wart ponownego rozwaÅ¼enia.\n- Dla tych, ktÃ³rzy rozwijajÄ… Rusta, nowa edycja stanowi punkt zborny dla caÅ‚ego projektu.\n\nW chwili pisania tego tekstu dostÄ™pne sÄ… cztery edycje Rusta: Rust 2015, Rust 2018, Rust 2021 i Rust 2024. Ta ksiÄ…Å¼ka jest napisana z uÅ¼yciem idiomÃ³w edycji Rust 2024.\n\nKlucz `edition` w _Cargo.toml_ wskazuje, ktÃ³rej edycji kompilator powinien uÅ¼ywaÄ‡ dla twojego kodu. JeÅ›li klucz nie istnieje, Rust uÅ¼ywa `2015` jako wartoÅ›ci edycji z powodu kompatybilnoÅ›ci wstecznej.\n\nKaÅ¼dy projekt moÅ¼e zdecydowaÄ‡ siÄ™ na edycjÄ™ innÄ… niÅ¼ domyÅ›lna edycja 2015. Edycje mogÄ… zawieraÄ‡ niekompatybilne zmiany, takie jak wÅ‚Ä…czenie nowego sÅ‚owa kluczowego, ktÃ³re koliduje z identyfikatorami w kodzie. Jednak, jeÅ›li nie zdecydujesz siÄ™ na te zmiany, twÃ³j kod bÄ™dzie nadal kompilowaÄ‡ siÄ™, nawet jeÅ›li zaktualizujesz wersjÄ™ kompilatora Rust, ktÃ³rej uÅ¼ywasz.\n\nWszystkie wersje kompilatora Rust obsÅ‚ugujÄ… kaÅ¼dÄ… edycjÄ™, ktÃ³ra istniaÅ‚a przed wydaniem tego kompilatora, i mogÄ… Å‚Ä…czyÄ‡ skrzynki z dowolnych obsÅ‚ugiwanych edycji. Zmiany edycji wpÅ‚ywajÄ… tylko na sposÃ³b, w jaki kompilator poczÄ…tkowo parsuje kod. Dlatego, jeÅ›li uÅ¼ywasz Rust 2015, a jedna z twoich zaleÅ¼noÅ›ci uÅ¼ywa Rust 2018, twÃ³j projekt skompiluje siÄ™ i bÄ™dzie mÃ³gÅ‚ uÅ¼ywaÄ‡ tej zaleÅ¼noÅ›ci. Sytuacja odwrotna, w ktÃ³rej twÃ³j projekt uÅ¼ywa Rust 2018, a zaleÅ¼noÅ›Ä‡ uÅ¼ywa Rust 2015, rÃ³wnieÅ¼ dziaÅ‚a.\n\nAby byÅ‚o jasne: wiÄ™kszoÅ›Ä‡ funkcji bÄ™dzie dostÄ™pna we wszystkich edycjach. ProgramiÅ›ci uÅ¼ywajÄ…cy dowolnej edycji Rust nadal bÄ™dÄ… widzieÄ‡ ulepszenia w miarÄ™ pojawiania siÄ™ nowych stabilnych wydaÅ„. Jednak w niektÃ³rych przypadkach, gÅ‚Ã³wnie gdy dodawane sÄ… nowe sÅ‚owa kluczowe, niektÃ³re nowe funkcje mogÄ… byÄ‡ dostÄ™pne tylko w pÃ³Åºniejszych edycjach. BÄ™dziesz musiaÅ‚ zmieniÄ‡ edycjÄ™, jeÅ›li chcesz skorzystaÄ‡ z takich funkcji.\n\nWiÄ™cej szczegÃ³Å‚Ã³w znajdziesz w [_Przewodniku po Edycjach Rust_][edition-guide]. Jest to kompletna ksiÄ…Å¼ka, ktÃ³ra wylicza rÃ³Å¼nice miÄ™dzy edycjami i wyjaÅ›nia, jak automatycznie zaktualizowaÄ‡ kod do nowej edycji za pomocÄ… `cargo fix`.\n\n[edition-guide]: https://doc.rust-lang.org/stable/edition-guide\n",
        "chapter_title": "E - Edycje"
    },
    {
        "file_path": "appendix-06-translation.md",
        "content": "## Dodatek F: TÅ‚umaczenia ksiÄ…Å¼ki\n\nDla zasobÃ³w w jÄ™zykach innych niÅ¼ angielski. WiÄ™kszoÅ›Ä‡ z nich jest nadal w toku; zobacz [etykietÄ™ TÅ‚umaczenia][label], aby pomÃ³c lub daÄ‡ nam znaÄ‡ o nowym tÅ‚umaczeniu!\n\n[label]: https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations\n\n- [PortuguÃªs](https://github.com/rust-br/rust-book-pt-br) (BR)\n- [PortuguÃªs](https://github.com/nunojesus/rust-book-pt-pt) (PT)\n- ç®€ä½“ä¸­æ–‡: [KaiserY/trpl-zh-cn](https://github.com/KaiserY/trpl-zh-cn), [gnu4cn/rust-lang-Zh_CN](https://github.com/gnu4cn/rust-lang-Zh_CN)\n- [æ­£é«”ä¸­æ–‡](https://github.com/rust-tw/book-tw)\n- [Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ°](https://rust-lang-ua.github.io/rustbook_ukrainian)\n- [EspaÃ±ol](https://github.com/thecodix/book), [alternatywna](https://github.com/ManRR/rust-book-es), [EspaÃ±ol by RustLangES](https://github.com/RustLangES/rust-book-es)\n- [Ğ ÑƒÑÑĞºĞ¸Ğ¹](https://github.com/rust-lang-ru/book)\n- [í•œêµ­ì–´](https://github.com/rust-kr/doc.rust-kr.org)\n- [æ—¥æœ¬èª](https://github.com/rust-lang-ja/book-ja)\n- [FranÃ§ais](https://github.com/Jimskapt/rust-book-fr)\n- [Polski](https://github.com/paytchoo/book-pl)\n- [Cebuano](https://github.com/agentzero1/book)\n- [Tagalog](https://github.com/josephace135/book)\n- [Esperanto](https://github.com/psychoslave/Rust-libro)\n- [ÎµÎ»Î»Î·Î½Î¹ÎºÎ®](https://github.com/TChatzigiannakis/rust-book-greek)\n- [Svenska](https://github.com/sebras/book)\n- [Farsi](https://github.com/RustFarsi/book), [Persian (FA)](https://github.com/persian-rust/book)\n- [Deutsch](https://github.com/rust-lang-de/rustbook-de)\n- [à¤¹à¤¿à¤‚à¤¦à¥€](https://github.com/venkatarun95/rust-book-hindi)\n- [à¹„à¸—à¸¢](https://github.com/rust-lang-th/book-th)\n- [Danske](https://github.com/DanKHansen/book-dk)\n- [O'zbek](https://github.com/rust-lang-uz/book)\n- [Tiáº¿ng Viá»‡t](https://github.com/tuanemdev/rust-book-vn)\n- [Italiano](https://nixxo.github.io/rust-lang-book-it/)\n- [à¦¬à¦¾à¦‚à¦²à¦¾](https://github.com/IsmailHosenIsmailJames/rust-book-bn)\n",
        "chapter_title": "F - TÅ‚umaczenia ksiÄ…Å¼ki"
    },
    {
        "file_path": "appendix-07-nightly-rust.md",
        "content": "## Dodatek G - Jak powstaje Rust i â€Nightly Rustâ€\n\nTen dodatek opisuje, jak powstaje Rust i jak to wpÅ‚ywa na Ciebie jako dewelopera Rust.\n\n### StabilnoÅ›Ä‡ bez stagnacji\n\nJako jÄ™zyk, Rust _bardzo_ dba o stabilnoÅ›Ä‡ Twojego kodu. Chcemy, aby Rust byÅ‚ solidnym fundamentem, na ktÃ³rym moÅ¼esz budowaÄ‡, a gdyby rzeczy ciÄ…gle siÄ™ zmieniaÅ‚y, byÅ‚oby to niemoÅ¼liwe. JednoczeÅ›nie, jeÅ›li nie bÄ™dziemy mogli eksperymentowaÄ‡ z nowymi funkcjami, moÅ¼emy nie odkryÄ‡ waÅ¼nych wad aÅ¼ do momentu ich wydania, kiedy to nie bÄ™dziemy juÅ¼ w stanie nic zmieniÄ‡.\n\nNaszym rozwiÄ…zaniem tego problemu jest to, co nazywamy â€stabilnoÅ›ciÄ… bez stagnacjiâ€, a nasza przewodnia zasada brzmi: nigdy nie powinieneÅ› obawiaÄ‡ siÄ™ aktualizacji do nowej wersji stabilnego Rusta. KaÅ¼da aktualizacja powinna byÄ‡ bezbolesna, ale takÅ¼e przynosiÄ‡ nowe funkcje, mniej bÅ‚Ä™dÃ³w i szybszy czas kompilacji.\n\n### Ciuch, ciuch! KanaÅ‚y wydaÅ„ i jazda pociÄ…gami\n\nRozwÃ³j Rusta odbywa siÄ™ wedÅ‚ug _rozkÅ‚adu jazdy pociÄ…gÃ³w_. Oznacza to, Å¼e caÅ‚y rozwÃ³j odbywa siÄ™ w gÅ‚Ã³wnej gaÅ‚Ä™zi repozytorium Rusta. Wydania sÄ… zgodne z modelem pociÄ…gu wydaÅ„ oprogramowania, ktÃ³ry byÅ‚ uÅ¼ywany przez Cisco IOS i inne projekty. IstniejÄ… trzy _kanaÅ‚y wydaÅ„_ Rusta:\n\n- Nightly\n- Beta\n- Stabilny\n\nWiÄ™kszoÅ›Ä‡ deweloperÃ³w Rusta uÅ¼ywa gÅ‚Ã³wnie kanaÅ‚u stabilnego, ale ci, ktÃ³rzy chcÄ… wyprÃ³bowaÄ‡ eksperymentalne nowe funkcje, mogÄ… uÅ¼ywaÄ‡ nightly lub beta.\n\nOto przykÅ‚ad, jak dziaÅ‚a proces rozwoju i wydawania: zaÅ‚Ã³Å¼my, Å¼e zespÃ³Å‚ Rusta pracuje nad wydaniem Rust 1.5. To wydanie miaÅ‚o miejsce w grudniu 2015 roku, ale dostarczy nam realistycznych numerÃ³w wersji. Do Rusta dodawana jest nowa funkcja: nowy commit lÄ…duje w gÅ‚Ã³wnej gaÅ‚Ä™zi. KaÅ¼dej nocy tworzona jest nowa wersja nightly Rusta. KaÅ¼dy dzieÅ„ jest dniem wydania, a te wydania sÄ… tworzone automatycznie przez naszÄ… infrastrukturÄ™ wydawniczÄ…. Tak wiÄ™c z biegiem czasu nasze wydania wyglÄ…dajÄ… tak, raz na noc:\n\n```text\nnightly: * - - * - - *\n```\n\nCo szeÅ›Ä‡ tygodni nadchodzi czas na przygotowanie nowego wydania! GaÅ‚Ä…Åº `beta` repozytorium Rusta rozgaÅ‚Ä™zia siÄ™ od gÅ‚Ã³wnej gaÅ‚Ä™zi uÅ¼ywanej przez nightly. Teraz istniejÄ… dwa wydania:\n\n```text\nnightly: * - - * - - *\n                     |\nbeta:                *\n```\n\nWiÄ™kszoÅ›Ä‡ uÅ¼ytkownikÃ³w Rusta nie uÅ¼ywa aktywnie wydaÅ„ beta, ale testuje je w swoich systemach CI, aby pomÃ³c Rustowi odkryÄ‡ moÅ¼liwe regresje. W miÄ™dzyczasie, kaÅ¼dej nocy nadal pojawia siÄ™ wydanie nightly:\n\n```text\nnightly: * - - * - - * - - * - - *\n                     |\nbeta:                *\n```\n\nPowiedzmy, Å¼e znaleziono regresjÄ™. Dobrze, Å¼e mieliÅ›my trochÄ™ czasu na przetestowanie wydania beta, zanim regresja wkradÅ‚a siÄ™ do stabilnego wydania! Poprawka jest stosowana do gÅ‚Ã³wnej gaÅ‚Ä™zi, tak aby nightly zostaÅ‚o naprawione, a nastÄ™pnie poprawka jest przenoszona do gaÅ‚Ä™zi `beta`, i tworzone jest nowe wydanie beta:\n\n```text\nnightly: * - - * - - * - - * - - * - - *\n                     |\nbeta:                * - - - - - - - - *\n```\n\nSzeÅ›Ä‡ tygodni po stworzeniu pierwszej bety, nadszedÅ‚ czas na stabilne wydanie! GaÅ‚Ä…Åº `stable` jest tworzona z gaÅ‚Ä™zi `beta`:\n\n```text\nnightly: * - - * - - * - - * - - * - - * - * - *\n                     |\nbeta:                * - - - - - - - - *\n                                       |\nstable:                                *\n```\n\nHura! Rust 1.5 jest gotowy! ZapomnieliÅ›my jednak o jednej rzeczy: poniewaÅ¼ minÄ™Å‚o szeÅ›Ä‡ tygodni, potrzebujemy rÃ³wnieÅ¼ nowej bety _nastÄ™pnej_ wersji Rusta, 1.6. Tak wiÄ™c po tym, jak `stable` rozgaÅ‚Ä™zia siÄ™ od `beta`, nastÄ™pna wersja `beta` ponownie rozgaÅ‚Ä™zia siÄ™ od `nightly`:\n\n```text\nnightly: * - - * - - * - - * - - * - - * - * - *\n                     |                         |\nbeta:                * - - - - - - - - *       *\n                                       |\nstable:                                *\n```\n\nNazywa siÄ™ to â€modelem pociÄ…guâ€, poniewaÅ¼ co szeÅ›Ä‡ tygodni wydanie â€opuszcza stacjÄ™â€, ale nadal musi odbyÄ‡ podrÃ³Å¼ przez kanaÅ‚ beta, zanim dotrze jako stabilne wydanie.\n\nRust wydaje siÄ™ co szeÅ›Ä‡ tygodni, jak w zegarku. JeÅ›li znasz datÄ™ jednego wydania Rusta, moÅ¼esz poznaÄ‡ datÄ™ nastÄ™pnego: to szeÅ›Ä‡ tygodni pÃ³Åºniej. MiÅ‚ym aspektem harmonogramu wydaÅ„ co szeÅ›Ä‡ tygodni jest to, Å¼e nastÄ™pny pociÄ…g nadjedzie wkrÃ³tce. JeÅ›li jakaÅ› funkcja przypadkowo ominie konkretne wydanie, nie ma powodu do obaw: kolejne pojawi siÄ™ w krÃ³tkim czasie! Pomaga to zmniejszyÄ‡ presjÄ™ na dodawanie niedopracowanych funkcji tuÅ¼ przed terminem wydania.\n\nDziÄ™ki temu procesowi zawsze moÅ¼esz sprawdziÄ‡ nastÄ™pnÄ… kompilacjÄ™ Rusta i samodzielnie zweryfikowaÄ‡, Å¼e Å‚atwo jest jÄ… zaktualizowaÄ‡: jeÅ›li wydanie beta nie dziaÅ‚a zgodnie z oczekiwaniami, moÅ¼esz zgÅ‚osiÄ‡ to zespoÅ‚owi i uzyskaÄ‡ poprawkÄ™ przed wydaniem kolejnej stabilnej wersji! Awarie w wydaniu beta sÄ… stosunkowo rzadkie, ale `rustc` to nadal oprogramowanie, i bÅ‚Ä™dy istniejÄ….\n\n### Czas wsparcia\n\nProjekt Rust wspiera najnowszÄ… stabilnÄ… wersjÄ™. Gdy nowa stabilna wersja zostanie wydana, stara wersja osiÄ…ga koniec swojego Å¼ycia (EOL). Oznacza to, Å¼e kaÅ¼da wersja jest wspierana przez szeÅ›Ä‡ tygodni.\n\n### Funkcje niestabilne\n\nW tym modelu wydaÅ„ jest jeszcze jedna kwestia: funkcje niestabilne. Rust uÅ¼ywa techniki zwanej â€flagami funkcjiâ€ do okreÅ›lania, ktÃ³re funkcje sÄ… wÅ‚Ä…czone w danym wydaniu. JeÅ›li nowa funkcja jest w trakcie aktywnego rozwoju, trafia ona do gÅ‚Ã³wnej gaÅ‚Ä™zi, a zatem do nightly, ale za _flagÄ… funkcji_. JeÅ›li jako uÅ¼ytkownik chcesz wyprÃ³bowaÄ‡ funkcjÄ™ bÄ™dÄ…cÄ… w fazie rozwoju, moÅ¼esz to zrobiÄ‡, ale musisz uÅ¼ywaÄ‡ wydania nightly Rusta i opatrzyÄ‡ swÃ³j kod ÅºrÃ³dÅ‚owy odpowiedniÄ… flagÄ…, aby jÄ… wÅ‚Ä…czyÄ‡.\n\nJeÅ›li uÅ¼ywasz wydania beta lub stabilnego Rusta, nie moÅ¼esz uÅ¼ywaÄ‡ Å¼adnych flag funkcji. To jest klucz, ktÃ³ry pozwala nam praktycznie korzystaÄ‡ z nowych funkcji, zanim ogÅ‚osimy je na zawsze stabilnymi. Ci, ktÃ³rzy chcÄ… wyprÃ³bowaÄ‡ najnowsze rozwiÄ…zania, mogÄ… to zrobiÄ‡, a ci, ktÃ³rzy chcÄ… solidnego doÅ›wiadczenia, mogÄ… pozostaÄ‡ przy stabilnej wersji i wiedzieÄ‡, Å¼e ich kod nie zostanie zepsuty. StabilnoÅ›Ä‡ bez stagnacji.\n\nTa ksiÄ…Å¼ka zawiera informacje wyÅ‚Ä…cznie o stabilnych funkcjach, poniewaÅ¼ funkcje w trakcie rozwoju wciÄ…Å¼ siÄ™ zmieniajÄ…, i z pewnoÅ›ciÄ… bÄ™dÄ… siÄ™ rÃ³Å¼niÄ‡ miÄ™dzy czasem, gdy ta ksiÄ…Å¼ka zostaÅ‚a napisana, a momentem, gdy zostanÄ… wÅ‚Ä…czone w stabilnych kompilacjach. DokumentacjÄ™ funkcji dostÄ™pnych tylko w nightly moÅ¼na znaleÅºÄ‡ online.\n\n### Rustup i rola Rust Nightly\n\nRustup uÅ‚atwia przeÅ‚Ä…czanie siÄ™ miÄ™dzy rÃ³Å¼nymi kanaÅ‚ami wydaÅ„ Rusta, globalnie lub na zasadzie projektu. DomyÅ›lnie bÄ™dziesz mieÄ‡ zainstalowanego stabilnego Rusta. Aby zainstalowaÄ‡ nightly, na przykÅ‚ad:\n\n```console\n$ rustup toolchain install nightly\n```\n\nMoÅ¼esz rÃ³wnieÅ¼ zobaczyÄ‡ wszystkie _Å‚aÅ„cuchy narzÄ™dzi_ (wydania Rusta i powiÄ…zane komponenty), ktÃ³re zainstalowaÅ‚eÅ› za pomocÄ… `rustup`. Oto przykÅ‚ad na komputerze z systemem Windows jednego z autorÃ³w:\n\n```powershell\n> rustup toolchain list\nstable-x86_64-pc-windows-msvc (default)\nbeta-x86_64-pc-windows-msvc\nnightly-x86_64-pc-windows-msvc\n```\n\nJak widaÄ‡, stabilny Å‚aÅ„cuch narzÄ™dzi jest domyÅ›lny. WiÄ™kszoÅ›Ä‡ uÅ¼ytkownikÃ³w Rusta uÅ¼ywa stabilnej wersji przez wiÄ™kszoÅ›Ä‡ czasu. MoÅ¼esz chcieÄ‡ uÅ¼ywaÄ‡ stabilnej wersji przez wiÄ™kszoÅ›Ä‡ czasu, ale uÅ¼ywaÄ‡ nightly w konkretnym projekcie, poniewaÅ¼ zaleÅ¼y Ci na najnowszej funkcji. Aby to zrobiÄ‡, moÅ¼esz uÅ¼yÄ‡ `rustup override` w katalogu tego projektu, aby ustawiÄ‡ Å‚aÅ„cuch narzÄ™dzi nightly jako ten, ktÃ³rego `rustup` powinien uÅ¼ywaÄ‡, gdy znajdujesz siÄ™ w tym katalogu:\n\n```console\n$ cd ~/projects/needs-nightly\n$ rustup override set nightly\n```\n\nTeraz, za kaÅ¼dym razem, gdy wywoÅ‚asz `rustc` lub `cargo` w katalogu _~/projects/needs-nightly_, `rustup` upewni siÄ™, Å¼e uÅ¼ywasz Rusta nightly, zamiast domyÅ›lnego stabilnego Rusta. Jest to przydatne, gdy masz wiele projektÃ³w Rust!\n\n### Proces RFC i zespoÅ‚y\n\nJak wiÄ™c dowiedzieÄ‡ siÄ™ o tych nowych funkcjach? Model rozwoju Rusta opiera siÄ™ na _procesie Request For Comments (RFC)_. JeÅ›li chcesz wprowadziÄ‡ ulepszenie w Rust, moÅ¼esz napisaÄ‡ propozycjÄ™, zwanÄ… RFC.\n\nKaÅ¼dy moÅ¼e pisaÄ‡ RFC, aby ulepszyÄ‡ Rusta, a propozycje sÄ… recenzowane i dyskutowane przez zespÃ³Å‚ Rusta, ktÃ³ry skÅ‚ada siÄ™ z wielu podzespoÅ‚Ã³w tematycznych. PeÅ‚nÄ… listÄ™ zespoÅ‚Ã³w moÅ¼na znaleÅºÄ‡ [na stronie Rusta](https://www.rust-lang.org/governance), ktÃ³ra obejmuje zespoÅ‚y dla kaÅ¼dego obszaru projektu: projektowanie jÄ™zyka, implementacja kompilatora, infrastruktura, dokumentacja i wiele innych. Odpowiedni zespÃ³Å‚ czyta propozycjÄ™ i komentarze, pisze wÅ‚asne komentarze, a ostatecznie osiÄ…ga siÄ™ konsensus w sprawie zaakceptowania lub odrzucenia funkcji.\n\nJeÅ›li funkcja zostanie zaakceptowana, otwierane jest zgÅ‚oszenie w repozytorium Rusta i ktoÅ› moÅ¼e jÄ… zaimplementowaÄ‡. Osoba, ktÃ³ra jÄ… zaimplementuje, bardzo dobrze moÅ¼e nie byÄ‡ osobÄ…, ktÃ³ra pierwotnie zaproponowaÅ‚a tÄ™ funkcjÄ™! Kiedy implementacja jest gotowa, trafia do gÅ‚Ã³wnej gaÅ‚Ä™zi za bramÄ… funkcji, tak jak omÃ³wiliÅ›my w sekcji [â€Funkcje niestabilneâ€](#unstable-features)<!-- ignore -->.\n\nPo pewnym czasie, gdy deweloperzy Rusta korzystajÄ…cy z wydaÅ„ nightly bÄ™dÄ… mogli wyprÃ³bowaÄ‡ nowÄ… funkcjÄ™, czÅ‚onkowie zespoÅ‚u przedyskutujÄ… tÄ™ funkcjÄ™, jak sprawdziÅ‚a siÄ™ w nightly, i zdecydujÄ…, czy powinna trafiÄ‡ do stabilnego Rusta, czy nie. JeÅ›li decyzja zostanie podjÄ™ta o kontynuowaniu, brama funkcji zostaje usuniÄ™ta, a funkcja jest teraz uwaÅ¼ana za stabilnÄ…! Trafia ona pociÄ…gami do nowego stabilnego wydania Rusta.\n",
        "chapter_title": "G - Jak powstaje Rust i â€Nightly Rustâ€"
    },
    {
        "file_path": "ch02-00-guessing-game-tutorial.md",
        "content": "# Programowanie gry w zgadywanie\n\nZanurzmy siÄ™ w Rust, realizujÄ…c wspÃ³lnie praktyczny projekt! Ten rozdziaÅ‚\nwprowadza ciÄ™ w kilka popularnych koncepcji Rusta, pokazujÄ…c, jak uÅ¼ywaÄ‡ ich\nw prawdziwym programie. Dowiesz siÄ™ o `let`, `match`, metodach, funkcjach\nskojarzonych, zewnÄ™trznych \"crate'ach\" i wielu innych! W kolejnych\nrozdziaÅ‚ach bÄ™dziemy badaÄ‡ te idee bardziej szczegÃ³Å‚owo. W tym rozdziale\nbÄ™dziesz Ä‡wiczyÄ‡ tylko podstawy.\n\nZaimplementujemy klasyczny problem programistyczny dla poczÄ…tkujÄ…cych: grÄ™ w\nzgadywanie. DziaÅ‚a to tak: program wygeneruje losowÄ… liczbÄ™ caÅ‚kowitÄ… od 1 do\n100. NastÄ™pnie poprosi gracza o podanie strzaÅ‚u. Po wprowadzeniu strzaÅ‚u,\nprogram wskaÅ¼e, czy strzaÅ‚ jest za niski, czy za wysoki. JeÅ›li strzaÅ‚ jest\nprawidÅ‚owy, gra wyÅ›wietli komunikat gratulacyjny i zakoÅ„czy siÄ™.\n\n## Konfiguracja nowego projektu\n\nAby skonfigurowaÄ‡ nowy projekt, przejdÅº do katalogu *projects*, ktÃ³ry utworzyÅ‚eÅ›\nw Rozdziale 1, i utwÃ³rz nowy projekt za pomocÄ… Cargo, w nastÄ™pujÄ…cy sposÃ³b:\n\n````console\n$ cargo new guessing_game\n$ cd guessing_game\n````\n\nPierwsze polecenie, `cargo new`, przyjmuje nazwÄ™ projektu (`guessing_game`) jako\npierwszy argument. Drugie polecenie zmienia katalog na katalog nowego projektu.\n\nSpÃ³jrz na wygenerowany plik *Cargo.toml*:\n\n<!-- manual-regeneration\ncd listings/ch02-guessing-game-tutorial\nrm -rf no-listing-01-cargo-new\ncargo new no-listing-01-cargo-new --name guessing_game\ncd no-listing-01-cargo-new\ncargo run > output.txt 2>&1\ncd ../../..\n-->\n\n<span class=\"filename\">Nazwa pliku: Cargo.toml</span>\n\n````toml\n[package]\nname = \"guessing_game\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\n````\n\nJak widziaÅ‚eÅ› w Rozdziale 1, `cargo new` generuje program \"Hello, world!\" dla\nCiebie. SprawdÅº plik *src/main.rs*:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n````rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n````\n\nTeraz skompilujmy ten program \"Hello, world!\" i uruchommy go w tym samym kroku,\nuÅ¼ywajÄ…c polecenia `cargo run`:\n\n````console\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s\n     Running `target/debug/guessing_game`\nHello, world!\n````\n\nPolecenie `run` przydaje siÄ™, gdy trzeba szybko iterowaÄ‡ nad projektem, tak\njak bÄ™dziemy to robiÄ‡ w tej grze, szybko testujÄ…c kaÅ¼dÄ… iteracjÄ™, zanim\nprzejdziemy do nastÄ™pnej.\n\nOtwÃ³rz ponownie plik *src/main.rs*. CaÅ‚y kod bÄ™dziesz pisaÄ‡ w tym pliku.\n\n## Przetwarzanie strzaÅ‚u\n\nPierwsza czÄ™Å›Ä‡ programu do zgadywania liczb poprosi o dane wejÅ›ciowe od\nuÅ¼ytkownika, przetworzy je i sprawdzi, czy dane sÄ… w oczekiwanej formie. Na\npoczÄ…tek pozwolimy graczowi wprowadziÄ‡ strzaÅ‚. WprowadÅº kod z Listingu 2-1 do\n*src/main.rs*.\n\n<figure class=\"listing\" id=\"listing-2-1\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore\nuse std::io;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    println!(\"Please input your guess.\");\n\n    let mut guess = String::new();\n\n    io::stdin()\n        .read_line(&mut guess)\n        .expect(\"Failed to read line\");\n\n    println!(\"You guessed: {guess}\");\n}\n````\n\n<figcaption><a href=\"#listing-2-1\">Listing 2-1</a>: Kod, ktÃ³ry pobiera strzaÅ‚ od uÅ¼ytkownika i go wyÅ›wietla</figcaption>\n</figure>\n\nTen kod zawiera wiele informacji, wiÄ™c przeanalizujmy go linia po linii. Aby\npobraÄ‡ dane od uÅ¼ytkownika, a nastÄ™pnie wyÅ›wietliÄ‡ wynik, musimy wprowadziÄ‡\nbibliotekÄ™ wejÅ›cia/wyjÅ›cia `io` do zakresu. Biblioteka `io` pochodzi ze\nstandardowej biblioteki, znanej jako `std`:\n\n````rust,ignore\nuse std::io;\n# \n# fn main() {\n#     println!(\"Guess the number!\");\n# \n#     println!(\"Please input your guess.\");\n# \n#     let mut guess = String::new();\n# \n#     io::stdin()\n#         .read_line(&mut guess)\n#         .expect(\"Failed to read line\");\n# \n#     println!(\"You guessed: {guess}\");\n# }\n````\n\nDomyÅ›lnie Rust ma zestaw elementÃ³w zdefiniowanych w standardowej bibliotece,\nktÃ³re sÄ… wprowadzane do zakresu kaÅ¼dego programu. Ten zestaw nazywa siÄ™\n*preludium*, a wszystko w nim moÅ¼esz zobaczyÄ‡ [w dokumentacji biblioteki\nstandardowej][prelude].\n\nJeÅ›li typ, ktÃ³rego chcesz uÅ¼yÄ‡, nie znajduje siÄ™ w preludium, musisz\nexplicitnie wprowadziÄ‡ ten typ do zakresu za pomocÄ… instrukcji `use`. UÅ¼ycie\nbiblioteki `std::io` zapewnia wiele przydatnych funkcji, w tym moÅ¼liwoÅ›Ä‡\nprzyjmowania danych wejÅ›ciowych od uÅ¼ytkownika.\n\nJak widziaÅ‚eÅ› w Rozdziale 1, funkcja `main` jest punktem wejÅ›cia do programu:\n\n````rust,ignore\n# use std::io;\n# \nfn main() {\n#     println!(\"Guess the number!\");\n# \n#     println!(\"Please input your guess.\");\n# \n#     let mut guess = String::new();\n# \n#     io::stdin()\n#         .read_line(&mut guess)\n#         .expect(\"Failed to read line\");\n# \n#     println!(\"You guessed: {guess}\");\n# }\n````\n\nSkÅ‚adnia `fn` deklaruje nowÄ… funkcjÄ™; nawiasy `()` wskazujÄ…, Å¼e nie ma\nparametrÃ³w; a nawias klamrowy `{` rozpoczyna ciaÅ‚o funkcji.\n\nJak rÃ³wnieÅ¼ dowiedziaÅ‚eÅ› siÄ™ w Rozdziale 1, `println!` to makro, ktÃ³re\nwyÅ›wietla ciÄ…g znakÃ³w na ekranie:\n\n````rust,ignore\n# use std::io;\n# \n# fn main() {\n    println!(\"Guess the number!\");\n\n    println!(\"Please input your guess.\");\n# \n#     let mut guess = String::new();\n# \n#     io::stdin()\n#         .read_line(&mut guess)\n#         .expect(\"Failed to read line\");\n# \n#     println!(\"You guessed: {guess}\");\n# }\n````\n\nTen kod wyÅ›wietla komunikat informujÄ…cy, czym jest gra, i prosi uÅ¼ytkownika\no wprowadzenie danych.\n\n### Przechowywanie wartoÅ›ci w zmiennych\n\nNastÄ™pnie utworzymy *zmiennÄ…* do przechowywania danych wprowadzonych przez\nuÅ¼ytkownika, w ten sposÃ³b:\n\n````rust,ignore\n# use std::io;\n# \n# fn main() {\n#     println!(\"Guess the number!\");\n# \n#     println!(\"Please input your guess.\");\n# \n    let mut guess = String::new();\n# \n#     io::stdin()\n#         .read_line(&mut guess)\n#         .expect(\"Failed to read line\");\n# \n#     println!(\"You guessed: {guess}\");\n# }\n````\n\nTeraz program staje siÄ™ ciekawszy! W tej krÃ³tkiej linii dzieje siÄ™ duÅ¼o. UÅ¼ywamy\ninstrukcji `let` do utworzenia zmiennej. Oto inny przykÅ‚ad:\n\n````rust,ignore\nlet apples = 5;\n````\n\nTa linia tworzy nowÄ… zmiennÄ… o nazwie `apples` i wiÄ…Å¼e jÄ… z wartoÅ›ciÄ… `5`.\nW Rust zmienne sÄ… domyÅ›lnie niezmienne, co oznacza, Å¼e gdy raz nadamy\nzmiennej wartoÅ›Ä‡, wartoÅ›Ä‡ ta nie ulegnie zmianie. OmÃ³wimy tÄ™ koncepcjÄ™\nszczegÃ³Å‚owo w sekcji [â€Zmienne i mutowalnoÅ›Ä‡â€][variables-and-mutability]\n<!-- ignore --> w Rozdziale 3. Aby zmienna byÅ‚a mutowalna, dodajemy `mut` przed\nnazwÄ… zmiennej:\n\n````rust,ignore\nlet apples = 5; // niezmienna\nlet mut bananas = 5; // mutowalna\n````\n\n<section class=\"note\" aria-role=\"note\">\n\n\n\nUwaga: SkÅ‚adnia `//` rozpoczyna komentarz, ktÃ³ry trwa do koÅ„ca linii. Rust\nignoruje wszystko, co znajduje siÄ™ w komentarzach. OmÃ³wimy komentarze\nszczegÃ³Å‚owo w [Rozdziale 3][comments]<!-- ignore -->.\n\n</section>\n\nWracajÄ…c do programu gry w zgadywanie, wiesz juÅ¼, Å¼e `let mut guess` wprowadzi\nmutowalnÄ… zmiennÄ… o nazwie `guess`. Znak rÃ³wnoÅ›ci (`=`) mÃ³wi Rustowi, Å¼e\nchcemy teraz powiÄ…zaÄ‡ coÅ› ze zmiennÄ…. Po prawej stronie znaku rÃ³wnoÅ›ci\nznajduje siÄ™ wartoÅ›Ä‡, z ktÃ³rÄ… `guess` jest powiÄ…zane, czyli wynik wywoÅ‚ania\n`String::new`, funkcji, ktÃ³ra zwraca nowÄ… instancjÄ™ typu `String`.\n[`String`][string]<!-- ignore --> to typ ciÄ…gu znakÃ³w dostarczony przez\nstandardowÄ… bibliotekÄ™, ktÃ³ry jest rozszerzalnym, kodowanym UTF-8 fragmentem\ntekstu.\n\nSkÅ‚adnia `::` w linii `::new` wskazuje, Å¼e `new` jest funkcjÄ… skojarzonÄ… z\ntypem `String`. *Funkcja skojarzona* to funkcja zaimplementowana dla danego\ntypu, w tym przypadku `String`. Ta funkcja `new` tworzy nowy, pusty ciÄ…g\nznakÃ³w. FunkcjÄ™ `new` znajdziesz na wielu typach, poniewaÅ¼ jest to\npowszechna nazwa dla funkcji, ktÃ³ra tworzy nowÄ… wartoÅ›Ä‡ jakiegoÅ› rodzaju.\n\nPodsumowujÄ…c, linia `let mut guess = String::new();` utworzyÅ‚a mutowalnÄ…\nzmiennÄ…, ktÃ³ra jest obecnie powiÄ…zana z nowÄ…, pustÄ… instancjÄ… `String`. Uff!\n\n### Odbieranie danych od uÅ¼ytkownika\n\nPrzypomnijmy, Å¼e na poczÄ…tku programu doÅ‚Ä…czyliÅ›my funkcjonalnoÅ›Ä‡ wejÅ›cia/\nwyjÅ›cia ze standardowej biblioteki za pomocÄ… `use std::io;`. Teraz wywoÅ‚amy\nfunkcjÄ™ `stdin` z moduÅ‚u `io`, co pozwoli nam obsÅ‚ugiwaÄ‡ dane wejÅ›ciowe od\nuÅ¼ytkownika:\n\n````rust,ignore\n# use std::io;\n# \n# fn main() {\n#     println!(\"Guess the number!\");\n# \n#     println!(\"Please input your guess.\");\n# \n#     let mut guess = String::new();\n# \n    io::stdin()\n        .read_line(&mut guess)\n#         .expect(\"Failed to read line\");\n# \n#     println!(\"You guessed: {guess}\");\n# }\n````\n\nGdybyÅ›my nie zaimportowali moduÅ‚u `io` za pomocÄ… `use std::io;` na poczÄ…tku\nprogramu, nadal moglibyÅ›my uÅ¼yÄ‡ funkcji, piszÄ…c wywoÅ‚anie funkcji jako\n`std::io::stdin`. Funkcja `stdin` zwraca instancjÄ™\n[`std::io::Stdin`][iostdin]<!-- ignore -->, ktÃ³ra jest typem\nreprezentujÄ…cym uchwyt do standardowego wejÅ›cia dla Twojego terminala.\n\nNastÄ™pnie, linia `.read_line(&mut guess)` wywoÅ‚uje metodÄ™\n[`read_line`][read_line]<!-- ignore --> na uchwycie standardowego wejÅ›cia\nw celu pobrania danych od uÅ¼ytkownika. Przekazujemy rÃ³wnieÅ¼ `&mut guess` jako\nargument do `read_line`, aby powiedzieÄ‡ jej, w ktÃ³rym ciÄ…gu znakÃ³w ma\nprzechowywaÄ‡ dane wejÅ›ciowe od uÅ¼ytkownika. PeÅ‚nym zadaniem `read_line` jest\npobranie wszystkiego, co uÅ¼ytkownik wpisze do standardowego wejÅ›cia, i\ndodanie tego do ciÄ…gu znakÃ³w (bez nadpisywania jego zawartoÅ›ci), dlatego\nprzekazujemy ten ciÄ…g znakÃ³w jako argument. Argument ciÄ…gu znakÃ³w musi byÄ‡\nmutowalny, aby metoda mogÅ‚a zmieniaÄ‡ zawartoÅ›Ä‡ ciÄ…gu znakÃ³w.\n\nZnak `&` wskazuje, Å¼e ten argument jest *referencjÄ…*, co pozwala wielu\nczÄ™Å›ciom Twojego kodu uzyskaÄ‡ dostÄ™p do jednego fragmentu danych bez\nkoniecznoÅ›ci wielokrotnego kopiowania tych danych do pamiÄ™ci. Referencje sÄ…\nzÅ‚oÅ¼onÄ… funkcjÄ…, a jednÄ… z gÅ‚Ã³wnych zalet Rusta jest to, jak bezpieczne i\nÅ‚atwe jest uÅ¼ywanie referencji. Nie musisz znaÄ‡ wielu z tych szczegÃ³Å‚Ã³w, aby\nzakoÅ„czyÄ‡ ten program. Na razie wystarczy wiedzieÄ‡, Å¼e podobnie jak zmienne,\nreferencje sÄ… domyÅ›lnie niezmienne. Dlatego musisz napisaÄ‡ `&mut guess` zamiast\n`&guess`, aby uczyniÄ‡ jÄ… mutowalnÄ…. (RozdziaÅ‚ 4 wyjaÅ›ni referencje bardziej\ndokÅ‚adnie).\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"handling-potential-failure-with-the-result-type\"></a>\n\n### ObsÅ‚uga potencjalnych bÅ‚Ä™dÃ³w za pomocÄ… `Result`\n\nNadal pracujemy nad tÄ… liniÄ… kodu. Teraz omawiamy trzeciÄ… liniÄ™ tekstu,\nale zwrÃ³Ä‡ uwagÄ™, Å¼e jest to nadal czÄ™Å›Ä‡ jednej logicznej linii kodu. NastÄ™pna\nczÄ™Å›Ä‡ to ta metoda:\n\n````rust,ignore\n# use std::io;\n# \n# fn main() {\n#     println!(\"Guess the number!\");\n# \n#     println!(\"Please input your guess.\");\n# \n#     let mut guess = String::new();\n# \n#     io::stdin()\n#         .read_line(&mut guess)\n        .expect(\"Failed to read line\");\n# \n#     println!(\"You guessed: {guess}\");\n# }\n````\n\nTen kod mogliÅ›my napisaÄ‡ jako:\n\n````rust,ignore\nio::stdin().read_line(&mut guess).expect(\"Failed to read line\");\n````\n\nJednak jedna dÅ‚uga linia jest trudna do odczytania, wiÄ™c najlepiej jest jÄ…\npodzieliÄ‡. CzÄ™sto rozsÄ…dne jest wprowadzenie nowej linii i innych biaÅ‚ych\nznakÃ³w, aby uÅ‚atwiÄ‡ czytanie dÅ‚ugich linii, gdy wywoÅ‚ujesz metodÄ™ za pomocÄ…\nskÅ‚adni `.method_name()`. Teraz omÃ³wmy, co ta linia robi.\n\nJak wspomniano wczeÅ›niej, `read_line` umieszcza wszystko, co uÅ¼ytkownik\nwprowadzi, w przekazanym jej ciÄ…gu znakÃ³w, ale zwraca rÃ³wnieÅ¼ wartoÅ›Ä‡ `Result`.\n[`Result`][result]<!-- ignore --> to *wyliczenie* [enums]<!-- ignore -->,\nczÄ™sto nazywane *enum*, ktÃ³re jest typem mogÄ…cym przyjmowaÄ‡ jeden z wielu\nmoÅ¼liwych stanÃ³w. KaÅ¼dy moÅ¼liwy stan nazywamy *wariantem*.\n\n[RozdziaÅ‚ 6][enums]<!-- ignore --> omÃ³wi szczegÃ³Å‚owo enums. Celem tych\ntypÃ³w `Result` jest kodowanie informacji o obsÅ‚udze bÅ‚Ä™dÃ³w.\n\nWariantami `Result` sÄ… `Ok` i `Err`. Wariant `Ok` wskazuje, Å¼e operacja\nzakoÅ„czyÅ‚a siÄ™ sukcesem i zawiera pomyÅ›lnie wygenerowanÄ… wartoÅ›Ä‡. Wariant `Err`\noznacza, Å¼e operacja zakoÅ„czyÅ‚a siÄ™ niepowodzeniem i zawiera informacje o tym,\njak lub dlaczego operacja siÄ™ nie powiodÅ‚a.\n\nWartoÅ›ci typu `Result`, podobnie jak wartoÅ›ci kaÅ¼dego typu, majÄ… zdefiniowane\nna nich metody. Instancja `Result` ma metodÄ™ [`expect`][expect]<!-- ignore -->,\nktÃ³rÄ… moÅ¼esz wywoÅ‚aÄ‡. JeÅ›li ta instancja `Result` jest wartoÅ›ciÄ… `Err`,\n`expect` spowoduje awariÄ™ programu i wyÅ›wietli komunikat, ktÃ³ry przekazaÅ‚eÅ›\njako argument do `expect`. JeÅ›li metoda `read_line` zwrÃ³ci `Err`, bÄ™dzie to\nprawdopodobnie wynikiem bÅ‚Ä™du pochodzÄ…cego z bazowego systemu operacyjnego.\nJeÅ›li ta instancja `Result` jest wartoÅ›ciÄ… `Ok`, `expect` pobierze wartoÅ›Ä‡\nzwracanÄ…, ktÃ³rÄ… przechowuje `Ok`, i zwrÃ³ci ci tylko tÄ™ wartoÅ›Ä‡, abyÅ› mÃ³gÅ‚ jej\nuÅ¼yÄ‡. W tym przypadku ta wartoÅ›Ä‡ to liczba bajtÃ³w w danych wejÅ›ciowych\nuÅ¼ytkownika.\n\nJeÅ›li nie wywoÅ‚asz `expect`, program skompiluje siÄ™, ale otrzymasz ostrzeÅ¼enie:\n\n````console\n$ cargo build\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\nwarning: unused `Result` that must be used\n  --> src/main.rs:10:5\n   |\n10 |     io::stdin().read_line(&mut guess);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\n   = note: `#[warn(unused_must_use)]` on by default\nhelp: use `let _ = ...` to ignore the resulting value\n   |\n10 |     let _ = io::stdin().read_line(&mut guess);\n   |     +++++++\n\nwarning: `guessing_game` (bin \"guessing_game\") generated 1 warning\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s\n````\n\nRust ostrzega, Å¼e nie uÅ¼yÅ‚eÅ› wartoÅ›ci `Result` zwrÃ³conej z `read_line`,\nwskazujÄ…c, Å¼e program nie obsÅ‚uÅ¼yÅ‚ moÅ¼liwego bÅ‚Ä™du.\n\nWÅ‚aÅ›ciwym sposobem na stÅ‚umienie ostrzeÅ¼enia jest faktyczne napisanie kodu\ndo obsÅ‚ugi bÅ‚Ä™dÃ³w, ale w naszym przypadku chcemy po prostu, aby ten program\nulegÅ‚ awarii, gdy wystÄ…pi problem, wiÄ™c moÅ¼emy uÅ¼yÄ‡ `expect`. Dowiesz siÄ™ o\nrecoverowaniu z bÅ‚Ä™dÃ³w w [Rozdziale 9][recover]<!-- ignore -->.\n\n### WyÅ›wietlanie wartoÅ›ci za pomocÄ… znacznikÃ³w `println!`\n\nPoza koÅ„cowym nawiasem klamrowym, pozostaÅ‚a tylko jedna linia do omÃ³wienia w\ndotychczasowym kodzie:\n\n````rust,ignore\n# use std::io;\n# \n# fn main() {\n#     println!(\"Guess the number!\");\n# \n#     println!(\"Please input your guess.\");\n# \n#     let mut guess = String::new();\n# \n#     io::stdin()\n#         .read_line(&mut guess)\n#         .expect(\"Failed to read line\");\n# \n    println!(\"You guessed: {guess}\");\n# }\n````\n\nTa linia wyÅ›wietla ciÄ…g znakÃ³w, ktÃ³ry teraz zawiera dane wejÅ›ciowe\nuÅ¼ytkownika. Zestaw nawiasÃ³w klamrowych `{}` to znacznik miejsca:\nWyobraÅº sobie `{}` jako maÅ‚e szczypce kraba, ktÃ³re trzymajÄ… wartoÅ›Ä‡ na miejscu.\nPodczas wyÅ›wietlania wartoÅ›ci zmiennej nazwa zmiennej moÅ¼e znajdowaÄ‡ siÄ™ w\nÅ›rodku nawiasÃ³w klamrowych. Podczas wyÅ›wietlania wyniku oceny wyraÅ¼enia,\numieÅ›Ä‡ puste nawiasy klamrowe w ciÄ…gu formatujÄ…cym, a nastÄ™pnie po ciÄ…gu\nformatujÄ…cym umieÅ›Ä‡ listÄ™ wyraÅ¼eÅ„ oddzielonych przecinkami, ktÃ³re majÄ… byÄ‡\nwyÅ›wietlone w kaÅ¼dym pustym znaczniku miejsca w tej samej kolejnoÅ›ci.\nWyÅ›wietlanie zmiennej i wyniku wyraÅ¼enia w jednym wywoÅ‚aniu `println!`\nwyglÄ…daÅ‚oby tak:\n\n````rust\nlet x = 5;\nlet y = 10;\n\nprintln!(\"x = {x} and y + 2 = {}\", y + 2);\n````\n\nTen kod wydrukowaÅ‚by `x = 5 and y + 2 = 12`.\n\n### Testowanie pierwszej czÄ™Å›ci\n\nPrzetestujmy pierwszÄ… czÄ™Å›Ä‡ gry w zgadywanie. Uruchom jÄ… za pomocÄ… `cargo run`:\n\n<!-- manual-regeneration\ncd listings/ch02-guessing-game-tutorial/listing-02-01/\ncargo clean\ncargo run\ninput 6 -->\n\n````console\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 6.44s\n     Running `target/debug/guessing_game`\nGuess the number!\nPlease input your guess.\n6\nYou guessed: 6\n````\n\nW tym momencie pierwsza czÄ™Å›Ä‡ gry jest gotowa: pobieramy dane z klawiatury,\na nastÄ™pnie je wyÅ›wietlamy.\n\n## Generowanie tajnej liczby\n\nNastÄ™pnie musimy wygenerowaÄ‡ tajnÄ… liczbÄ™, ktÃ³rÄ… uÅ¼ytkownik bÄ™dzie prÃ³bowaÅ‚\nzgadnÄ…Ä‡. Tajna liczba powinna byÄ‡ inna za kaÅ¼dym razem, aby gra byÅ‚a zabawna\ndo wielokrotnego grania. UÅ¼yjemy losowej liczby od 1 do 100, aby gra nie byÅ‚a\nzbyt trudna. Rust nie zawiera jeszcze funkcji do generowania liczb losowych w\nstandardowej bibliotece. Jednak zespÃ³Å‚ Rusta udostÄ™pnia pakiet [`rand`\ncrate][randcrate] z tÄ… funkcjonalnoÅ›ciÄ….\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"using-a-crate-to-get-more-functionality\"></a>\n\n### ZwiÄ™kszanie funkcjonalnoÅ›ci za pomocÄ… pakietu\n\nPamiÄ™taj, Å¼e *crate* to zbiÃ³r plikÃ³w ÅºrÃ³dÅ‚owych Rusta. Projekt, ktÃ³ry budujemy,\njest *binary crate*, czyli plikiem wykonywalnym. *Crate* `rand` to *library\ncrate*, ktÃ³ry zawiera kod przeznaczony do uÅ¼ycia w innych programach i nie moÅ¼e\nbyÄ‡ wykonywany samodzielnie.\n\nKoordynacja zewnÄ™trznych `crate'Ã³w` przez Cargo to miejsce, w ktÃ³rym Cargo\nnaprawdÄ™ bÅ‚yszczy. Zanim bÄ™dziemy mogli napisaÄ‡ kod, ktÃ³ry uÅ¼ywa `rand`,\nmusimy zmodyfikowaÄ‡ plik *Cargo.toml*, aby dodaÄ‡ `rand` jako zaleÅ¼noÅ›Ä‡.\nOtwÃ³rz ten plik teraz i dodaj nastÄ™pujÄ…cÄ… liniÄ™ na dole, pod nagÅ‚Ã³wkiem\nsekcji `[dependencies]`, ktÃ³ry Cargo dla Ciebie utworzyÅ‚. Upewnij siÄ™, Å¼e\nokreÅ›lasz `rand` dokÅ‚adnie tak, jak tutaj, z tym numerem wersji, w przeciwnym\nrazie przykÅ‚ady kodu w tym samouczku mogÄ… nie dziaÅ‚aÄ‡:\n\n<!-- When updating the version of `rand` used, also update the version of\n`rand` used in these files so they all match:\n* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md\n* ch14-03-cargo-workspaces.md\n-->\n\n<span class=\"filename\">Nazwa pliku: Cargo.toml</span>\n\n````toml\n[dependencies]\nrand = \"0.8.5\"\n````\n\nW pliku *Cargo.toml* wszystko, co nastÄ™puje po nagÅ‚Ã³wku, jest czÄ™Å›ciÄ… tej\nsekcji, ktÃ³ra trwa, dopÃ³ki nie rozpocznie siÄ™ inna sekcja. W `[dependencies]`\ninformujesz Cargo, od ktÃ³rych zewnÄ™trznych pakietÃ³w zaleÅ¼y TwÃ³j projekt i\nktÃ³rych wersji tych pakietÃ³w potrzebujesz. W tym przypadku okreÅ›lamy pakiet\n`rand` ze specyfikatorem wersji semantycznej `0.8.5`. Cargo rozumie [Semantic\nVersioning][semver]<!-- ignore --> (czasami nazywane *SemVer*), ktÃ³ry jest\nstandardem zapisu numerÃ³w wersji. Specyfikator `0.8.5` jest w rzeczywistoÅ›ci\nskrÃ³tem od `^0.8.5`, co oznacza dowolnÄ… wersjÄ™ co najmniej 0.8.5, ale\npadajÄ…cÄ… poniÅ¼ej 0.9.0.\n\nCargo uwaÅ¼a, Å¼e te wersje majÄ… publiczne API kompatybilne z wersjÄ… 0.8.5, a ta\nspecyfikacja gwarantuje, Å¼e otrzymasz najnowszÄ… wersjÄ™ poprawki, ktÃ³ra nadal\nbÄ™dzie kompilowaÄ‡ siÄ™ z kodem w tym rozdziale. Å»adna wersja 0.9.0 lub\nwiÄ™ksza nie gwarantuje tego samego API, co w poniÅ¼szych przykÅ‚adach.\n\nTeraz, bez zmiany kodu, zbudujmy projekt, jak pokazano w Listingu 2-2.\n\n<!-- manual-regeneration\ncd listings/ch02-guessing-game-tutorial/listing-02-02/\nrm Cargo.lock\ncargo clean\ncargo build -->\n\n<figure class=\"listing\" id=\"listing-2-2\">\n\n````console\n$ cargo build\n  Updating crates.io index\n   Locking 15 packages to latest Rust 1.85.0 compatible versions\n    Adding rand v0.8.5 (available: v0.9.0)\n Compiling proc-macro2 v1.0.93\n Compiling unicode-ident v1.0.17\n Compiling libc v0.2.170\n Compiling cfg-if v1.0.0\n Compiling byteorder v1.5.0\n Compiling getrandom v0.2.15\n Compiling rand_core v0.6.4\n Compiling quote v1.0.38\n Compiling syn v2.0.98\n Compiling zerocopy-derive v0.7.35\n Compiling zerocopy v0.7.35\n Compiling ppv-lite86 v0.2.20\n Compiling rand_chacha v0.3.1\n Compiling rand v0.8.5\n Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.48s\n````\n\n<figcaption><a href=\"#listing-2-2\">Listing 2-2</a>: Wynik uruchomienia <code>cargo build</code> po dodaniu <code>rand</code> jako zaleÅ¼noÅ›ci</figcaption>\n</figure>\n\nMoÅ¼esz zobaczyÄ‡ rÃ³Å¼ne numery wersji (ale wszystkie bÄ™dÄ… kompatybilne z kodem,\ndziÄ™ki SemVer!) i rÃ³Å¼ne linie (w zaleÅ¼noÅ›ci od systemu operacyjnego), a linie\nmogÄ… byÄ‡ w innej kolejnoÅ›ci.\n\nGdy doÅ‚Ä…czamy zewnÄ™trznÄ… zaleÅ¼noÅ›Ä‡, Cargo pobiera najnowsze wersje wszystkiego,\nczego ta zaleÅ¼noÅ›Ä‡ potrzebuje, z *rejestru*, ktÃ³ry jest kopiÄ… danych z\n[Crates.io][cratesio]. Crates.io to miejsce, w ktÃ³rym ludzie w ekosystemie\nRusta publikujÄ… swoje projekty Rust open source, aby inni mogli z nich\nkorzystaÄ‡.\n\nPo zaktualizowaniu rejestru Cargo sprawdza sekcjÄ™ `[dependencies]` i pobiera\nwszystkie wymienione pakiety, ktÃ³re nie zostaÅ‚y jeszcze pobrane. W tym\nprzypadku, choÄ‡ wymieniliÅ›my tylko `rand` jako zaleÅ¼noÅ›Ä‡, Cargo pobraÅ‚ rÃ³wnieÅ¼\ninne pakiety, od ktÃ³rych zaleÅ¼y `rand`, aby dziaÅ‚aÅ‚. Po pobraniu pakietÃ³w\nRust kompiluje je, a nastÄ™pnie kompiluje projekt z dostÄ™pnymi zaleÅ¼noÅ›ciami.\n\nJeÅ›li natychmiast ponownie uruchomisz `cargo build` bez wprowadzania Å¼adnych\nzmian, nie otrzymasz Å¼adnych danych wyjÅ›ciowych poza liniÄ… `Finished`.\nCargo wie, Å¼e juÅ¼ pobraÅ‚ i skompilowaÅ‚ zaleÅ¼noÅ›ci, a Ty nie zmieniÅ‚eÅ› nic\nw pliku *Cargo.toml*. Cargo wie rÃ³wnieÅ¼, Å¼e nie zmieniÅ‚eÅ› nic w swoim kodzie,\nwiÄ™c nie kompiluje go ponownie. Nie majÄ…c nic do zrobienia, po prostu\nkoÅ„czy dziaÅ‚anie.\n\nJeÅ›li otworzysz plik *src/main.rs*, dokonasz trywialnej zmiany, a nastÄ™pnie\nzapiszesz go i ponownie zbudujesz, zobaczysz tylko dwie linie danych\nwyjÅ›ciowych:\n\n<!-- manual-regeneration\ncd listings/ch02-guessing-game-tutorial/listing-02-02/\ntouch src/main.rs\ncargo build -->\n\n````console\n$ cargo build\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s\n````\n\nTe linie pokazujÄ…, Å¼e Cargo aktualizuje kompilacjÄ™ tylko o TwojÄ… drobnÄ… zmianÄ™\nw pliku *src/main.rs*. Twoje zaleÅ¼noÅ›ci nie ulegÅ‚y zmianie, wiÄ™c Cargo wie,\nÅ¼e moÅ¼e ponownie wykorzystaÄ‡ to, co juÅ¼ pobraÅ‚ i skompilowaÅ‚ dla nich.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"ensuring-reproducible-builds-with-the-cargo-lock-file\"></a>\n\n#### Zapewnianie powtarzalnych kompilacji za pomocÄ… pliku Cargo.lock\n\nCargo posiada mechanizm, ktÃ³ry zapewnia, Å¼e moÅ¼esz odbudowaÄ‡ ten sam artefakt\nza kaÅ¼dym razem, gdy Ty lub ktokolwiek inny buduje TwÃ³j kod: Cargo bÄ™dzie uÅ¼ywaÄ‡\ntylko tych wersji zaleÅ¼noÅ›ci, ktÃ³re okreÅ›liÅ‚eÅ›, chyba Å¼e wskaÅ¼esz inaczej. Na\nprzykÅ‚ad, powiedzmy, Å¼e w przyszÅ‚ym tygodniu zostanie wydana wersja 0.8.6 pakietu\n`rand`, a ta wersja zawiera waÅ¼nÄ… poprawkÄ™ bÅ‚Ä™du, ale zawiera rÃ³wnieÅ¼ regresjÄ™,\nktÃ³ra zepsuje TwÃ³j kod. Aby temu zaradziÄ‡, Rust tworzy plik *Cargo.lock* za\npierwszym razem, gdy uruchamiasz `cargo build`, wiÄ™c teraz mamy go w katalogu\n*guessing_game*.\n\nKiedy budujesz projekt po raz pierwszy, Cargo ustala wszystkie wersje\nzaleÅ¼noÅ›ci, ktÃ³re speÅ‚niajÄ… kryteria, a nastÄ™pnie zapisuje je do pliku\n*Cargo.lock*. Kiedy budujesz swÃ³j projekt w przyszÅ‚oÅ›ci, Cargo zobaczy, Å¼e plik\n*Cargo.lock* istnieje i uÅ¼yje tam okreÅ›lonych wersji, zamiast ponownie wykonywaÄ‡\ncaÅ‚ej pracy zwiÄ…zanej z ustalaniem wersji. Pozwala to na automatyczne\npowtarzalne budowanie. Innymi sÅ‚owy, TwÃ³j projekt pozostanie w wersji 0.8.5,\ndopÃ³ki wyraÅºnie go nie zaktualizujesz, dziÄ™ki plikowi *Cargo.lock*. PoniewaÅ¼\nplik *Cargo.lock* jest waÅ¼ny dla powtarzalnych kompilacji, czÄ™sto jest\ndodawany do kontroli wersji wraz z resztÄ… kodu w Twoim projekcie.\n\n#### Aktualizacja \"crate'a\", aby uzyskaÄ‡ nowÄ… wersjÄ™\n\nKiedy *chcesz* zaktualizowaÄ‡ pakiet, Cargo udostÄ™pnia polecenie `update`, ktÃ³re\nzignoruje plik *Cargo.lock* i ustali wszystkie najnowsze wersje, ktÃ³re pasujÄ…\ndo twoich specyfikacji w *Cargo.toml*. Cargo nastÄ™pnie zapisze te wersje do\npliku *Cargo.lock*. W przeciwnym razie, domyÅ›lnie, Cargo bÄ™dzie szukaÄ‡ tylko\nwersji wiÄ™kszych niÅ¼ 0.8.5 i mniejszych niÅ¼ 0.9.0. JeÅ›li pakiet `rand` wydaÅ‚\ndwie nowe wersje 0.8.6 i 0.999.0, zobaczyÅ‚byÅ› nastÄ™pujÄ…ce, gdybyÅ› uruchomiÅ‚\n`cargo update`:\n\n<!-- manual-regeneration\ncd listings/ch02-guessing-game-tutorial/listing-02-02/\ncargo update\nassuming there is a new 0.8.x version of rand; otherwise use another update\nas a guide to creating the hypothetical output shown here -->\n\n````console\n$ cargo update\n    Updating crates.io index\n     Locking 1 package to latest Rust 1.85.0 compatible version\n    Updating rand v0.8.5 -> v0.8.6 (available: v0.999.0)\n````\n\nCargo ignoruje wydanie 0.999.0. W tym momencie zauwaÅ¼yÅ‚byÅ› rÃ³wnieÅ¼ zmianÄ™ w\npliku *Cargo.lock*, wskazujÄ…cÄ…, Å¼e wersja pakietu `rand`, ktÃ³rej teraz uÅ¼ywasz,\nto 0.8.6. Aby uÅ¼yÄ‡ wersji `rand` 0.999.0 lub dowolnej wersji z serii 0.999.*x*,\nmusiaÅ‚byÅ› zamiast tego zaktualizowaÄ‡ plik *Cargo.toml*, aby wyglÄ…daÅ‚ tak (nie\nwprowadzaj tej zmiany, poniewaÅ¼ poniÅ¼sze przykÅ‚ady zakÅ‚adajÄ…, Å¼e uÅ¼ywasz `rand`\n0.8):\n\n````toml\n[dependencies]\nrand = \"0.999.0\"\n````\n\nNastÄ™pnym razem, gdy uruchomisz `cargo build`, Cargo zaktualizuje rejestr\ndostÄ™pnych pakietÃ³w i ponownie oceni Twoje wymagania dotyczÄ…ce `rand` zgodnie z\nnowÄ… wersjÄ…, ktÃ³rÄ… okreÅ›liÅ‚eÅ›.\n\nWiele jest do powiedzenia na temat [Cargo][doccargo]<!-- ignore --> i [jego\nekosystemu][doccratesio]<!-- ignore -->, ktÃ³re omÃ³wimy w Rozdziale 14, ale na\nrazie to wszystko, co musisz wiedzieÄ‡. Cargo bardzo uÅ‚atwia ponowne uÅ¼ywanie\nbibliotek, wiÄ™c Rustowcy mogÄ… pisaÄ‡ mniejsze projekty, ktÃ³re sÄ… montowane z\nwielu pakietÃ³w.\n\n### Generowanie liczby losowej\n\nZacznijmy uÅ¼ywaÄ‡ `rand` do generowania liczby do zgadniÄ™cia. NastÄ™pnym krokiem\njest aktualizacja *src/main.rs*, jak pokazano w Listingu 2-3.\n\n<figure class=\"listing\" id=\"listing-2-3\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore\nuse std::io;\n\nuse rand::Rng;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    let secret_number = rand::thread_rng().gen_range(1..=100);\n\n    println!(\"The secret number is: {secret_number}\");\n\n    println!(\"Please input your guess.\");\n\n    let mut guess = String::new();\n\n    io::stdin()\n        .read_line(&mut guess)\n        .expect(\"Failed to read line\");\n\n    println!(\"You guessed: {guess}\");\n}\n````\n\n<figcaption><a href=\"#listing-2-3\">Listing 2-3</a>: Dodawanie kodu do generowania liczby losowej</figcaption>\n</figure>\n\nNajpierw dodajemy liniÄ™ `use rand::Rng;`. Cecha `Rng` definiuje metody,\nktÃ³re implementujÄ… generatory liczb losowych, i ta cecha musi byÄ‡ w zakresie,\nabyÅ›my mogli uÅ¼ywaÄ‡ tych metod. RozdziaÅ‚ 10 szczegÃ³Å‚owo omÃ³wi cechy.\n\nNastÄ™pnie dodajemy dwie linie w Å›rodku. W pierwszej linii wywoÅ‚ujemy funkcjÄ™\n`rand::thread_rng`, ktÃ³ra daje nam konkretny generator liczb losowych, ktÃ³rego\nbÄ™dziemy uÅ¼ywaÄ‡: taki, ktÃ³ry jest lokalny dla bieÅ¼Ä…cego wÄ…tku wykonawczego\ni jest inicjowany przez system operacyjny. NastÄ™pnie wywoÅ‚ujemy metodÄ™\n`gen_range` na generatorze liczb losowych. Ta metoda jest zdefiniowana przez\ncechÄ™ `Rng`, ktÃ³rÄ… wprowadziliÅ›my do zakresu za pomocÄ… instrukcji\n`use rand::Rng;`. Metoda `gen_range` przyjmuje wyraÅ¼enie zakresu jako argument\ni generuje liczbÄ™ losowÄ… w tym zakresie. Rodzaj wyraÅ¼enia zakresu, ktÃ³rego tu\nuÅ¼ywamy, ma postaÄ‡ `start..=end` i jest inkluzywny na dolnej i gÃ³rnej granicy,\nwiÄ™c musimy okreÅ›liÄ‡ `1..=100`, aby zaÅ¼Ä…daÄ‡ liczby od 1 do 100.\n\n<section class=\"note\" aria-role=\"note\">\n\n\n\nUwaga: Nie bÄ™dziesz po prostu wiedziaÅ‚, ktÃ³rych cech uÅ¼ywaÄ‡ i ktÃ³re metody\ni funkcje wywoÅ‚ywaÄ‡ z \"crate'a\", wiÄ™c kaÅ¼dy \"crate\" ma dokumentacjÄ™ z\ninstrukcjami jego uÅ¼ywania. InnÄ… fajnÄ… funkcjÄ… Cargo jest to, Å¼e uruchomienie\npolecenia `cargo doc --open` zbuduje dokumentacjÄ™ dostarczonÄ… przez wszystkie\nTwoje zaleÅ¼noÅ›ci lokalnie i otworzy jÄ… w Twojej przeglÄ…darce. JeÅ›li interesuje\nCiÄ™ inna funkcjonalnoÅ›Ä‡ w \"crate'cie\" `rand`, na przykÅ‚ad, uruchom\n`cargo doc --open` i kliknij `rand` na pasku bocznym po lewej stronie.\n\n</section>\n\nDruga nowa linia wyÅ›wietla tajnÄ… liczbÄ™. Jest to przydatne podczas\nopracowywania programu, aby mÃ³c go przetestowaÄ‡, ale usuniemy jÄ… z ostatecznej\nwersji. Nie ma sensu graÄ‡, jeÅ›li program wyÅ›wietla odpowiedÅº zaraz po\nuruchomieniu!\n\nSprÃ³buj uruchomiÄ‡ program kilka razy:\n\n<!-- manual-regeneration\ncd listings/ch02-guessing-game-tutorial/listing-02-03/\ncargo run\n4\ncargo run\n5\n-->\n\n````console\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s\n     Running `target/debug/guessing_game`\nGuess the number!\nThe secret number is: 7\nPlease input your guess.\n4\nYou guessed: 4\n\n$ cargo run\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s\n     Running `target/debug/guessing_game`\nGuess the number!\nThe secret number is: 83\nPlease input your guess.\n5\nYou guessed: 5\n````\n\nPowinieneÅ› otrzymaÄ‡ rÃ³Å¼ne liczby losowe, i wszystkie powinny byÄ‡ liczbami\npomiÄ™dzy 1 a 100. Åšwietna robota!\n\n## PorÃ³wnywanie strzaÅ‚u z tajnÄ… liczbÄ…\n\nTeraz, gdy mamy dane wejÅ›ciowe od uÅ¼ytkownika i liczbÄ™ losowÄ…, moÅ¼emy je\nporÃ³wnaÄ‡. Ten krok jest pokazany w Listingu 2-4. ZauwaÅ¼, Å¼e ten kod na razie\nsiÄ™ nie skompiluje, co wyjaÅ›nimy.\n\n<figure class=\"listing\" id=\"listing-2-4\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore,does_not_compile\nuse std::cmp::Ordering;\nuse std::io;\n\nuse rand::Rng;\n\nfn main() {\n    // --snip--\n#     println!(\"Guess the number!\");\n# \n#     let secret_number = rand::thread_rng().gen_range(1..=100);\n# \n#     println!(\"The secret number is: {secret_number}\");\n# \n#     println!(\"Please input your guess.\");\n# \n#     let mut guess = String::new();\n# \n#     io::stdin()\n#         .read_line(&mut guess)\n#         .expect(\"Failed to read line\");\n\n    println!(\"You guessed: {guess}\");\n\n    match guess.cmp(&secret_number) {\n        Ordering::Less => println!(\"Too small!\"),\n        Ordering::Greater => println!(\"Too big!\"),\n        Ordering::Equal => println!(\"You win!\"),\n    }\n}\n````\n\n<figcaption><a href=\"#listing-2-4\">Listing 2-4</a>: ObsÅ‚uga moÅ¼liwych wartoÅ›ci zwracanych przez porÃ³wnywanie dwÃ³ch liczb</figcaption>\n</figure>\n\nNajpierw dodajemy kolejnÄ… instrukcjÄ™ `use`, wprowadzajÄ…c typ o nazwie\n`std::cmp::Ordering` do zakresu ze standardowej biblioteki. Typ `Ordering` to\nkolejne wyliczenie (`enum`) i ma warianty `Less`, `Greater` i `Equal`. SÄ… to\ntrzy moÅ¼liwe wyniki porÃ³wnania dwÃ³ch wartoÅ›ci.\n\nNastÄ™pnie dodajemy piÄ™Ä‡ nowych linii na dole, ktÃ³re uÅ¼ywajÄ… typu `Ordering`.\nMetoda `cmp` porÃ³wnuje dwie wartoÅ›ci i moÅ¼e byÄ‡ wywoÅ‚ana na wszystkim, co\nmoÅ¼na porÃ³wnaÄ‡. Przyjmuje referencjÄ™ do tego, z czym chcesz porÃ³wnaÄ‡: tutaj\nporÃ³wnuje `guess` z `secret_number`. NastÄ™pnie zwraca wariant wyliczenia\n`Ordering`, ktÃ³re wprowadziliÅ›my do zakresu za pomocÄ… instrukcji `use`.\nUÅ¼ywamy wyraÅ¼enia [`match`][match]<!-- ignore -->, aby zdecydowaÄ‡, co zrobiÄ‡\ndalej, w oparciu o to, ktÃ³ry wariant `Ordering` zostaÅ‚ zwrÃ³cony z wywoÅ‚ania\n`cmp` z wartoÅ›ciami w `guess` i `secret_number`.\n\nWyraÅ¼enie `match` skÅ‚ada siÄ™ z *ramion*. RamiÄ™ skÅ‚ada siÄ™ z *wzorca*, z ktÃ³rym\nma byÄ‡ dopasowywana wartoÅ›Ä‡, oraz kodu, ktÃ³ry powinien zostaÄ‡ uruchomiony, jeÅ›li\nwartoÅ›Ä‡ podana do `match` pasuje do wzorca tego ramienia. Rust pobiera wartoÅ›Ä‡\npodanÄ… do `match` i kolejno przeglÄ…da wzorce kaÅ¼dego ramienia. Patrzy na\nwzorzec pierwszego ramienia, `Ordering::Less`, i widzi, Å¼e wartoÅ›Ä‡\n`Ordering::Greater` nie pasuje do `Ordering::Less`, wiÄ™c ignoruje kod w tym\nramieniu i przechodzi do nastÄ™pnego ramienia. Wzorzec nastÄ™pnego ramienia to\n`Ordering::Greater`, ktÃ³ry *pasuje* do `Ordering::Greater`! PowiÄ…zany kod w\ntym ramieniu zostanie wykonany i wyÅ›wietli na ekranie `Too big!`. WyraÅ¼enie\n`match` koÅ„czy siÄ™ po pierwszym udanym dopasowaniu, wiÄ™c w tym scenariuszu\nnie bÄ™dzie patrzeÄ‡ na ostatnie ramiÄ™.\n\nJednak kod w Listingu 2-4 jeszcze siÄ™ nie skompiluje. SprÃ³bujmy:\n\n<!--\nThe error numbers in this output should be that of the code **WITHOUT** the\nanchor or snip comments\n-->\n\n````console\n$ cargo build\n   Compiling libc v0.2.86\n   Compiling getrandom v0.2.2\n   Compiling cfg-if v1.0.0\n   Compiling ppv-lite86 v0.2.10\n   Compiling rand_core v0.6.2\n   Compiling rand_chacha v0.3.0\n   Compiling rand v0.8.5\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\nerror[E0308]: mismatched types\n  --> src/main.rs:23:21\n   |\n23 |     match guess.cmp(&secret_number) {\n   |                 --- ^^^^^^^^^^^^^^ expected `&String`, found `&{integer}`\n   |                 |\n   |                 arguments to this method are incorrect\n   |\n   = note: expected reference `&String`\n              found reference `&{integer}`\nnote: method defined here\n  --> /rustc/1159e78c4747b02ef996e55082b704c09b970588/library/core/src/cmp.rs:979:8\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `guessing_game` (bin \"guessing_game\") due to 1 previous error\n````\n\nRdzeÅ„ bÅ‚Ä™du stwierdza, Å¼e wystÄ™pujÄ… *niezgodne typy*. Rust ma silny, statyczny\nsystem typÃ³w. Jednak ma rÃ³wnieÅ¼ inferencjÄ™ typÃ³w. Kiedy napisaliÅ›my\n`let mut guess = String::new()`, Rust byÅ‚ w stanie wywnioskowaÄ‡, Å¼e `guess`\npowinno byÄ‡ `String` i nie kazaÅ‚ nam pisaÄ‡ tego typu. `secret_number` natomiast\njest typem liczbowym. Kilka typÃ³w liczbowych Rusta moÅ¼e mieÄ‡ wartoÅ›Ä‡ pomiÄ™dzy\n1 a 100: `i32`, liczba 32-bitowa; `u32`, niepodpisana liczba 32-bitowa; `i64`,\nliczba 64-bitowa; oraz inne. O ile nie okreÅ›lono inaczej, Rust domyÅ›lnie uÅ¼ywa\n`i32`, ktÃ³ry jest typem `secret_number`, chyba Å¼e dodasz informacje o typie w\ninnym miejscu, co spowodowaÅ‚oby, Å¼e Rust wywnioskowaÅ‚by inny typ liczbowy.\nPowodem bÅ‚Ä™du jest to, Å¼e Rust nie moÅ¼e porÃ³wnywaÄ‡ ciÄ…gu znakÃ³w i typu\nliczbowego.\n\nOstatecznie chcemy przekonwertowaÄ‡ `String`, ktÃ³rÄ… program odczytuje jako dane\nwejÅ›ciowe, na typ liczbowy, abyÅ›my mogli porÃ³wnaÄ‡ jÄ… numerycznie z tajnÄ…\nliczbÄ…. Robimy to, dodajÄ…c tÄ™ liniÄ™ do ciaÅ‚a funkcji `main`:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore\n# use std::cmp::Ordering;\n# use std::io;\n# \n# use rand::Rng;\n# \n# fn main() {\n#     println!(\"Guess the number!\");\n# \n#     let secret_number = rand::thread_rng().gen_range(1..=100);\n# \n#     println!(\"The secret number is: {secret_number}\");\n# \n#     println!(\"Please input your guess.\");\n# \n    // --snip--\n\n    let mut guess = String::new();\n\n    io::stdin()\n        .read_line(&mut guess)\n        .expect(\"Failed to read line\");\n\n    let guess: u32 = guess.trim().parse().expect(\"Please type a number!\");\n\n    println!(\"You guessed: {guess}\");\n\n    match guess.cmp(&secret_number) {\n        Ordering::Less => println!(\"Too small!\"),\n        Ordering::Greater => println!(\"Too big!\"),\n        Ordering::Equal => println!(\"You win!\"),\n    }\n# }\n````\n\nLinia to:\n\n````rust,ignore\nlet guess: u32 = guess.trim().parse().expect(\"Please type a number!\");\n````\n\nTworzymy zmiennÄ… o nazwie `guess`. Ale chwila, czy program nie ma juÅ¼ zmiennej\no nazwie `guess`? Tak, ale Rust pozwala nam w korzystny sposÃ³b zacieniÄ‡\npoprzedniÄ… wartoÅ›Ä‡ `guess` nowÄ…. *Zacienianie* pozwala nam ponownie uÅ¼yÄ‡ nazwy\nzmiennej `guess`, zamiast zmuszaÄ‡ nas do tworzenia dwÃ³ch unikalnych zmiennych,\ntakich jak `guess_str` i `guess`, na przykÅ‚ad. OmÃ³wimy to szczegÃ³Å‚owo w\n[Rozdziale 3][shadowing]<!-- ignore -->, ale na razie wiedz, Å¼e ta funkcja jest\nczÄ™sto uÅ¼ywana, gdy chcesz przekonwertowaÄ‡ wartoÅ›Ä‡ z jednego typu na inny.\n\nWiÄ…zamy tÄ™ nowÄ… zmiennÄ… z wyraÅ¼eniem `guess.trim().parse()`. `guess` w\nwyraÅ¼eniu odnosi siÄ™ do oryginalnej zmiennej `guess`, ktÃ³ra zawieraÅ‚a dane\nwejÅ›ciowe jako ciÄ…g znakÃ³w. Metoda `trim` na instancji `String` usunie\nwszelkie biaÅ‚e znaki na poczÄ…tku i na koÅ„cu, co musimy zrobiÄ‡, zanim\nprzekonwertujemy ciÄ…g znakÃ³w na `u32`, ktÃ³ry moÅ¼e zawieraÄ‡ tylko dane\nliczbowe. UÅ¼ytkownik musi nacisnÄ…Ä‡ <kbd>enter</kbd>, aby zadowoliÄ‡ `read_line` i\nwprowadziÄ‡ swÃ³j strzaÅ‚, co dodaje znak nowej linii do ciÄ…gu znakÃ³w. Na\nprzykÅ‚ad, jeÅ›li uÅ¼ytkownik wpisze <kbd>5</kbd> i naciÅ›nie <kbd>enter</kbd>, `guess`\nbÄ™dzie wyglÄ…daÅ‚o tak: `5\\n`. `\\n` oznacza \"nowÄ… liniÄ™\". (W systemie Windows\nnaciÅ›niÄ™cie <kbd>enter</kbd> powoduje powrÃ³t karetki i nowÄ… liniÄ™, `\\r\\n`.) Metoda\n`trim` usuwa `\\n` lub `\\r\\n`, pozostawiajÄ…c tylko `5`.\n\nMetoda [`parse` na ciÄ…gach znakÃ³w][parse]<!-- ignore --> konwertuje ciÄ…g\nznakÃ³w na inny typ. Tutaj uÅ¼ywamy jej do konwersji z ciÄ…gu znakÃ³w na liczbÄ™.\nMusimy powiedzieÄ‡ Rustowi dokÅ‚adny typ liczbowy, ktÃ³rego chcemy, uÅ¼ywajÄ…c\n`let guess: u32`. Dwukropek (`:`) po `guess` mÃ³wi Rustowi, Å¼e bÄ™dziemy\nanotowaÄ‡ typ zmiennej. Rust ma kilka wbudowanych typÃ³w liczbowych; `u32`\nwidziane tutaj to niepodpisana, 32-bitowa liczba caÅ‚kowita. Jest to dobry\ndomyÅ›lny wybÃ³r dla maÅ‚ej liczby dodatniej. O innych typach liczbowych dowiesz\nsiÄ™ w [Rozdziale 3][integers]<!-- ignore -->.\n\nDodatkowo, adnotacja `u32` w tym przykÅ‚adzie programu i porÃ³wnanie z\n`secret_number` oznacza, Å¼e Rust wywnioskuje, iÅ¼ `secret_number` rÃ³wnieÅ¼\npowinno byÄ‡ `u32`. Tak wiÄ™c, teraz porÃ³wnanie bÄ™dzie dotyczyÅ‚o dwÃ³ch wartoÅ›ci\ntego samego typu!\n\nMetoda `parse` bÄ™dzie dziaÅ‚aÄ‡ tylko na znakach, ktÃ³re moÅ¼na logicznie\nprzeksztaÅ‚ciÄ‡ na liczby i dlatego moÅ¼e Å‚atwo powodowaÄ‡ bÅ‚Ä™dy. Gdyby, na\nprzykÅ‚ad, ciÄ…g znakÃ³w zawieraÅ‚ `AğŸ‘%`, nie byÅ‚oby sposobu na przeksztaÅ‚cenie\ntego na liczbÄ™. PoniewaÅ¼ moÅ¼e to zakoÅ„czyÄ‡ siÄ™ niepowodzeniem, metoda `parse`\nzwraca typ `Result`, podobnie jak metoda `read_line` (omÃ³wiona wczeÅ›niej w\nsekcji [â€ObsÅ‚uga potencjalnych bÅ‚Ä™dÃ³w za pomocÄ… `Result`â€](#handling-potential-failure-with-the-result-type)<!-- ignore -->).\nBÄ™dziemy traktowaÄ‡ ten `Result` w ten sam sposÃ³b, ponownie uÅ¼ywajÄ…c metody\n`expect`. JeÅ›li `parse` zwrÃ³ci wariant `Err` `Result`, poniewaÅ¼ nie udaÅ‚o siÄ™\nutworzyÄ‡ liczby z ciÄ…gu znakÃ³w, wywoÅ‚anie `expect` spowoduje awariÄ™ gry i\nwyÅ›wietli komunikat, ktÃ³ry mu podamy. JeÅ›li `parse` z powodzeniem przekonwertuje\nciÄ…g znakÃ³w na liczbÄ™, zwrÃ³ci wariant `Ok` `Result`, a `expect` zwrÃ³ci liczbÄ™,\nktÃ³rej chcemy z wartoÅ›ci `Ok`.\n\nUruchommy teraz program:\n\n<!-- manual-regeneration\ncd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/\ntouch src/main.rs\ncargo run\n  76\n-->\n\n````console\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.26s\n     Running `target/debug/guessing_game`\nGuess the number!\nThe secret number is: 58\nPlease input your guess.\n  76\nYou guessed: 76\nToo big!\n````\n\nÅšwietnie! Mimo Å¼e przed zgadywanÄ… liczbÄ… dodano spacje, program nadal\nrozpoznaÅ‚, Å¼e uÅ¼ytkownik zgadÅ‚ 76. Uruchom program kilka razy, aby sprawdziÄ‡\nrÃ³Å¼ne zachowania z rÃ³Å¼nymi rodzajami danych wejÅ›ciowych: zgadnij liczbÄ™\npoprawnie, zgadnij liczbÄ™, ktÃ³ra jest za wysoka, i zgadnij liczbÄ™, ktÃ³ra jest\nza niska.\n\nMamy juÅ¼ wiÄ™kszoÅ›Ä‡ gry dziaÅ‚ajÄ…cÄ…, ale uÅ¼ytkownik moÅ¼e wykonaÄ‡ tylko jeden\nstrzaÅ‚. ZmieÅ„my to, dodajÄ…c pÄ™tlÄ™!\n\n## Zezwalanie na wielokrotne zgadywanie za pomocÄ… pÄ™tli\n\nSÅ‚owo kluczowe `loop` tworzy nieskoÅ„czonÄ… pÄ™tlÄ™. Dodamy pÄ™tlÄ™, aby daÄ‡\nuÅ¼ytkownikom wiÄ™cej szans na odgadniÄ™cie liczby:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore\n# use std::cmp::Ordering;\n# use std::io;\n# \n# use rand::Rng;\n# \n# fn main() {\n#     println!(\"Guess the number!\");\n# \n#     let secret_number = rand::thread_rng().gen_range(1..=100);\n# \n    // --snip--\n\n    println!(\"The secret number is: {secret_number}\");\n\n    loop {\n        println!(\"Please input your guess.\");\n\n        // --snip--\n\n# \n#         let mut guess = String::new();\n# \n#         io::stdin()\n#             .read_line(&mut guess)\n#             .expect(\"Failed to read line\");\n# \n#         let guess: u32 = guess.trim().parse().expect(\"Please type a number!\");\n# \n#         println!(\"You guessed: {guess}\");\n# \n        match guess.cmp(&secret_number) {\n            Ordering::Less => println!(\"Too small!\"),\n            Ordering::Greater => println!(\"Too big!\"),\n            Ordering::Equal => println!(\"You win!\"),\n        }\n    }\n}\n````\n\nJak widaÄ‡, przenieÅ›liÅ›my wszystko od monitu o wprowadzenie zgadywanej liczby\ndalej do pÄ™tli. Upewnij siÄ™, Å¼e wciÅ›niesz kaÅ¼dÄ… liniÄ™ wewnÄ…trz pÄ™tli o kolejne\ncztery spacje i ponownie uruchom program. Program bÄ™dzie teraz prosiÅ‚ o kolejny\nstrzaÅ‚ w nieskoÅ„czonoÅ›Ä‡, co wprowadza nowy problem. WyglÄ…da na to, Å¼e\nuÅ¼ytkownik nie moÅ¼e wyjÅ›Ä‡!\n\nUÅ¼ytkownik zawsze mÃ³gÅ‚ przerwaÄ‡ program za pomocÄ… skrÃ³tu klawiaturowego\n<kbd>ctrl</kbd>-<kbd>C</kbd>. Ale jest inny sposÃ³b na ucieczkÄ™ przed tym\nnienasyconym potworem, jak wspomniano w dyskusji o `parse` w sekcji\n[â€PorÃ³wnywanie strzaÅ‚u z tajnÄ… liczbÄ…â€](#comparing-the-guess-to-the-secret-number)<!-- ignore -->: jeÅ›li uÅ¼ytkownik wprowadzi\ndane nieliczbowe, program ulegnie awarii. MoÅ¼emy to wykorzystaÄ‡, aby pozwoliÄ‡\nuÅ¼ytkownikowi wyjÅ›Ä‡, jak pokazano tutaj:\n\n<!-- manual-regeneration\ncd listings/ch02-guessing-game-tutorial/no-listing-04-looping/\ntouch src/main.rs\ncargo run\n(too small guess)\n(too big guess)\n(correct guess)\nquit\n-->\n\n````console\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s\n     Running `target/debug/guessing_game`\nGuess the number!\nThe secret number is: 59\nPlease input your guess.\n45\nYou guessed: 45\nToo small!\nPlease input your guess.\n60\nYou guessed: 60\nToo big!\nPlease input your guess.\n59\nYou guessed: 59\nYou win!\nPlease input your guess.\nquit\n\nthread 'main' panicked at src/main.rs:28:47:\nPlease type a number!: ParseIntError { kind: InvalidDigit }\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n````\n\nWpisanie `quit` spowoduje wyjÅ›cie z gry, ale jak zauwaÅ¼ysz, tak samo zadziaÅ‚a\nwprowadzenie dowolnych innych danych nieliczbowych. Jest to, delikatnie mÃ³wiÄ…c,\nnieoptymalne; chcemy, aby gra zatrzymywaÅ‚a siÄ™ rÃ³wnieÅ¼ po odgadniÄ™ciu\nprawidÅ‚owej liczby.\n\n### ZakoÅ„czenie po prawidÅ‚owym strzale\n\nZaprogramujmy grÄ™ tak, aby koÅ„czyÅ‚a siÄ™, gdy uÅ¼ytkownik wygra, dodajÄ…c instrukcjÄ™\n`break`:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore\n# use std::cmp::Ordering;\n# use std::io;\n# \n# use rand::Rng;\n# \n# fn main() {\n#     println!(\"Guess the number!\");\n# \n#     let secret_number = rand::thread_rng().gen_range(1..=100);\n# \n#     println!(\"The secret number is: {secret_number}\");\n# \n#     loop {\n#         println!(\"Please input your guess.\");\n# \n#         let mut guess = String::new();\n# \n#         io::stdin()\n#             .read_line(&mut guess)\n#             .expect(\"Failed to read line\");\n# \n#         let guess: u32 = guess.trim().parse().expect(\"Please type a number!\");\n# \n#         println!(\"You guessed: {guess}\");\n# \n        // --snip--\n\n        match guess.cmp(&secret_number) {\n            Ordering::Less => println!(\"Too small!\"),\n            Ordering::Greater => println!(\"Too big!\"),\n            Ordering::Equal => {\n                println!(\"You win!\");\n                break;\n            }\n        }\n    }\n}\n````\n\nDodanie linii `break` po `You win!` powoduje, Å¼e program wychodzi z pÄ™tli, gdy\nuÅ¼ytkownik poprawnie odgadnie tajnÄ… liczbÄ™. WyjÅ›cie z pÄ™tli oznacza rÃ³wnieÅ¼\nwyjÅ›cie z programu, poniewaÅ¼ pÄ™tla jest ostatniÄ… czÄ™Å›ciÄ… `main`.\n\n### ObsÅ‚uga nieprawidÅ‚owych danych wejÅ›ciowych\n\nAby jeszcze bardziej dopracowaÄ‡ zachowanie gry, zamiast zawieszaÄ‡ program,\ngdy uÅ¼ytkownik wprowadzi dane nieliczbowe, niech gra ignoruje takie dane,\numoÅ¼liwiajÄ…c uÅ¼ytkownikowi dalsze zgadywanie. MoÅ¼emy to zrobiÄ‡, zmieniajÄ…c\nliniÄ™, w ktÃ³rej `guess` jest konwertowane z `String` na `u32`, jak pokazano\nw Listingu 2-5.\n\n<figure class=\"listing\" id=\"listing-2-5\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore\n# use std::cmp::Ordering;\n# use std::io;\n# \n# use rand::Rng;\n# \n# fn main() {\n#     println!(\"Guess the number!\");\n# \n#     let secret_number = rand::thread_rng().gen_range(1..=100);\n# \n#     println!(\"The secret number is: {secret_number}\");\n# \n#     loop {\n#         println!(\"Please input your guess.\");\n# \n#         let mut guess = String::new();\n# \n        // --snip--\n\n        io::stdin()\n            .read_line(&mut guess)\n            .expect(\"Failed to read line\");\n\n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n\n        println!(\"You guessed: {guess}\");\n\n        // --snip--\n# \n#         match guess.cmp(&secret_number) {\n#             Ordering::Less => println!(\"Too small!\"),\n#             Ordering::Greater => println!(\"Too big!\"),\n#             Ordering::Equal => {\n#                 println!(\"You win!\");\n#                 break;\n#             }\n#         }\n#     }\n# }\n````\n\n<figcaption><a href=\"#listing-2-5\">Listing 2-5</a>: Ignorowanie zgadywanej liczby nieliczbowej i proÅ›ba o kolejnÄ… zgadywanÄ… liczbÄ™ zamiast zawieszenia programu</figcaption>\n</figure>\n\nZmieniamy wywoÅ‚anie `expect` na wyraÅ¼enie `match`, aby zamiast zawieszenia\nw przypadku bÅ‚Ä™du, obsÅ‚uÅ¼yÄ‡ bÅ‚Ä…d. PamiÄ™taj, Å¼e `parse` zwraca typ `Result`,\na `Result` jest wyliczeniem, ktÃ³re ma warianty `Ok` i `Err`. UÅ¼ywamy tutaj\nwyraÅ¼enia `match`, tak jak to robiliÅ›my z wynikiem `Ordering` metody `cmp`.\n\nJeÅ›li `parse` jest w stanie pomyÅ›lnie przeksztaÅ‚ciÄ‡ ciÄ…g znakÃ³w w liczbÄ™,\nzwrÃ³ci wartoÅ›Ä‡ `Ok`, ktÃ³ra bÄ™dzie zawieraÄ‡ wynikowÄ… liczbÄ™. Ta wartoÅ›Ä‡ `Ok`\nbÄ™dzie pasowaÄ‡ do wzorca pierwszego ramienia, a wyraÅ¼enie `match` po prostu\nzwrÃ³ci wartoÅ›Ä‡ `num`, ktÃ³rÄ… `parse` wyprodukowaÅ‚o i umieÅ›ciÅ‚o w wartoÅ›ci `Ok`.\nTa liczba trafi dokÅ‚adnie tam, gdzie chcemy, do nowej zmiennej `guess`, ktÃ³rÄ…\ntworzymy.\n\nJeÅ›li `parse` *nie* jest w stanie przeksztaÅ‚ciÄ‡ ciÄ…gu znakÃ³w w liczbÄ™,\nzwrÃ³ci wartoÅ›Ä‡ `Err`, ktÃ³ra zawiera wiÄ™cej informacji o bÅ‚Ä™dzie. WartoÅ›Ä‡ `Err`\nnie pasuje do wzorca `Ok(num)` w pierwszym ramieniu `match`, ale pasuje do\nwzorca `Err(_)` w drugim ramieniu. PodkreÅ›lnik `_` to wartoÅ›Ä‡\nâ€chwyÄ‡-wszystkoâ€; w tym przykÅ‚adzie mÃ³wimy, Å¼e chcemy dopasowaÄ‡ wszystkie\nwartoÅ›ci `Err`, niezaleÅ¼nie od tego, jakie informacje zawierajÄ…. Zatem program\nwykona kod drugiego ramienia, `continue`, co nakazuje programowi przejÅ›Ä‡ do\nnastÄ™pnej iteracji `loop` i poprosiÄ‡ o kolejny strzaÅ‚. Tak wiÄ™c, efektywnie,\nprogram ignoruje wszystkie bÅ‚Ä™dy, jakie `parse` moÅ¼e napotkaÄ‡!\n\nTeraz wszystko w programie powinno dziaÅ‚aÄ‡ zgodnie z oczekiwaniami. SprÃ³bujmy:\n\n<!-- manual-regeneration\ncd listings/ch02-guessing-game-tutorial/listing-02-05/\ncargo run\n(too small guess)\n(too big guess)\nfoo\n(correct guess)\n-->\n\n````console\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s\n     Running `target/debug/guessing_game`\nGuess the number!\nThe secret number is: 61\nPlease input your guess.\n10\nYou guessed: 10\nToo small!\nPlease input your guess.\n99\nYou guessed: 99\nToo big!\nPlease input your guess.\nfoo\nPlease input your guess.\n61\nYou guessed: 61\nYou win!\n````\n\nCudownie! Z drobnÄ…, ostatniÄ… poprawkÄ…, zakoÅ„czymy grÄ™ w zgadywanie. Przypomnij\nsobie, Å¼e program nadal wyÅ›wietla tajnÄ… liczbÄ™. To dobrze dziaÅ‚aÅ‚o podczas\ntestowania, ale psuje grÄ™. UsuÅ„my `println!`, ktÃ³re wyÅ›wietla tajnÄ… liczbÄ™.\nListing 2-6 pokazuje ostateczny kod.\n\n<figure class=\"listing\" id=\"listing-2-6\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore\nuse std::cmp::Ordering;\nuse std::io;\n\nuse rand::Rng;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    let secret_number = rand::thread_rng().gen_range(1..=100);\n\n    loop {\n        println!(\"Please input your guess.\");\n\n        let mut guess = String::new();\n\n        io::stdin()\n            .read_line(&mut guess)\n            .expect(\"Failed to read line\");\n\n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n\n        println!(\"You guessed: {guess}\");\n\n        match guess.cmp(&secret_number) {\n            Ordering::Less => println!(\"Too small!\"),\n            Ordering::Greater => println!(\"Too big!\"),\n            Ordering::Equal => {\n                println!(\"You win!\");\n                break;\n            }\n        }\n    }\n}\n````\n\n<figcaption><a href=\"#listing-2-6\">Listing 2-6</a>: Kompletny kod gry w zgadywanie</figcaption>\n</figure>\n\nW tym momencie pomyÅ›lnie zbudowaÅ‚eÅ› grÄ™ w zgadywanie. Gratulacje!\n\n## Podsumowanie\n\nTen projekt byÅ‚ praktycznym sposobem na wprowadzenie ciÄ™ w wiele nowych\nkoncepcji Rusta: `let`, `match`, funkcje, uÅ¼ycie zewnÄ™trznych pakietÃ³w i\nwiele innych. W kolejnych rozdziaÅ‚ach dowiesz siÄ™ o tych koncepcjach bardziej\nszczegÃ³Å‚owo. RozdziaÅ‚ 3 obejmuje koncepcje, ktÃ³re posiadajÄ… wiÄ™kszoÅ›Ä‡ jÄ™zykÃ³w\nprogramowania, takie jak zmienne, typy danych i funkcje, i pokazuje, jak ich\nuÅ¼ywaÄ‡ w RuÅ›cie. RozdziaÅ‚ 4 bada wÅ‚asnoÅ›Ä‡, cechÄ™, ktÃ³ra odrÃ³Å¼nia Rusta od\ninnych jÄ™zykÃ³w. RozdziaÅ‚ 5 omawia struktury i skÅ‚adniÄ™ metod, a RozdziaÅ‚ 6\nwyjaÅ›nia, jak dziaÅ‚ajÄ… wyliczenia (enums).\n\n[prelude]: ../std/prelude/index.html\n[variables-and-mutability]: ch03-01-variables-and-mutability.html#variables-and-mutability\n[comments]: ch03-04-comments.html\n[string]: ../std/string/struct.String.html\n[iostdin]: ../std/io/struct.Stdin.html\n[read_line]: ../std/io/struct.Stdin.html#method.read_line\n[result]: ../std/result/enum.Result.html\n[enums]: ch06-00-enums.html\n[expect]: ../std/result/enum.Result.html#method.expect\n[recover]: ch09-02-recoverable-errors-with-result.html\n[randcrate]: https://crates.io/crates/rand\n[semver]: http://semver.org\n[cratesio]: https://crates.io/\n[doccargo]: https://doc.rust-lang.org/cargo/\n[doccratesio]: https://doc.rust-lang.org/cargo/reference/publishing.html\n[match]: ch06-02-match.html\n[shadowing]: ch03-01-variables-and-mutability.html#shadowing\n[parse]: ../std/primitive.str.html#method.parse\n[integers]: ch03-02-data-types.html#integer-types",
        "chapter_title": "Programowanie gry w zgadywanie"
    },
    {
        "file_path": "ch03-02-data-types.md",
        "content": "## Typy danych\n\nKaÅ¼da wartoÅ›Ä‡ w RuÅ›cie ma okreÅ›lony *typ danych*, ktÃ³ry informuje Rusta, jaki\nrodzaj danych jest okreÅ›lany, aby wiedziaÅ‚, jak z nimi pracowaÄ‡. Przyjrzymy siÄ™\ndwÃ³m podzbiorom typÃ³w danych: skalarnym i zÅ‚oÅ¼onym.\n\nPamiÄ™taj, Å¼e Rust jest jÄ™zykiem *statycznie typowanym*, co oznacza, Å¼e musi\nznaÄ‡ typy wszystkich zmiennych w czasie kompilacji. Kompilator zazwyczaj moÅ¼e\nwywnioskowaÄ‡, jakiego typu chcemy uÅ¼yÄ‡, na podstawie wartoÅ›ci i sposobu jej\nuÅ¼ycia. W przypadkach, gdy moÅ¼liwych jest wiele typÃ³w, np. gdy konwertowaliÅ›my\n`String` na typ numeryczny za pomocÄ… `parse` w sekcji [â€PorÃ³wnywanie strzaÅ‚u z\ntajnÄ… liczbÄ…â€][comparing-the-guess-to-the-secret-number]<!-- ignore -->\nw Rozdziale 2, musimy dodaÄ‡ adnotacjÄ™ typu, takÄ… jak ta:\n\n````rust\nlet guess: u32 = \"42\".parse().expect(\"Not a number!\");\n````\n\nJeÅ›li nie dodamy adnotacji typu `: u32` pokazanej w poprzednim kodzie, Rust\nwyÅ›wietli nastÄ™pujÄ…cy bÅ‚Ä…d, co oznacza, Å¼e kompilator potrzebuje od nas wiÄ™cej\ninformacji, aby wiedzieÄ‡, jakiego typu chcemy uÅ¼yÄ‡:\n\n````console\n$ cargo build\n   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)\nerror[E0284]: type annotations needed\n --> src/main.rs:2:9\n  |\n2 |     let guess = \"42\".parse().expect(\"Not a number!\");\n  |         ^^^^^        ----- type must be known at this point\n  |\n  = note: cannot satisfy `<_ as FromStr>::Err == _`\nhelp: consider giving `guess` an explicit type\n  |\n2 |     let guess: /* Type */ = \"42\".parse().expect(\"Not a number!\");\n  |              ++++++++++++\n\nFor more information about this error, try `rustc --explain E0284`.\nerror: could not compile `no_type_annotations` (bin \"no_type_annotations\") due to 1 previous error\n````\n\nZobaczysz rÃ³Å¼ne adnotacje typÃ³w dla innych typÃ³w danych.\n\n### Typy skalarne\n\nTyp *skalarny* reprezentuje pojedynczÄ… wartoÅ›Ä‡. Rust ma cztery gÅ‚Ã³wne typy\nskalarne: liczby caÅ‚kowite, liczby zmiennoprzecinkowe, wartoÅ›ci boolowskie i\nznaki. MoÅ¼esz je rozpoznaÄ‡ z innych jÄ™zykÃ³w programowania. PrzejdÅºmy do tego,\njak dziaÅ‚ajÄ… w Rust.\n\n#### Typy caÅ‚kowite\n\n*Liczba caÅ‚kowita* to liczba bez czÄ™Å›ci uÅ‚amkowej. UÅ¼yliÅ›my jednego typu\ncaÅ‚kowitego w Rozdziale 2, typu `u32`. Ta deklaracja typu wskazuje, Å¼e wartoÅ›Ä‡,\nz ktÃ³rÄ… jest skojarzona, powinna byÄ‡ niepodpisanÄ… liczbÄ… caÅ‚kowitÄ… (typy\ncaÅ‚kowite ze znakiem zaczynajÄ… siÄ™ od `i` zamiast `u`), ktÃ³ra zajmuje 32 bity\npamiÄ™ci. Tabela 3-1 pokazuje wbudowane typy caÅ‚kowite w Rust. MoÅ¼emy uÅ¼yÄ‡\ndowolnego z tych wariantÃ³w do zadeklarowania typu wartoÅ›ci caÅ‚kowitej.\n\n<span class=\"caption\">Tabela 3-1: Typy caÅ‚kowite w Rust</span>\n\n|DÅ‚ugoÅ›Ä‡|Ze znakiem|Bez znaku|\n|------|------|--------|\n|8-bitÃ³w|`i8`|`u8`|\n|16-bitÃ³w|`i16`|`u16`|\n|32-bitÃ³w|`i32`|`u32`|\n|64-bitÃ³w|`i64`|`u64`|\n|128-bitÃ³w|`i128`|`u128`|\n|ZaleÅ¼ne od architektury|`isize`|`usize`|\n\nKaÅ¼dy wariant moÅ¼e byÄ‡ ze znakiem lub bez znaku i ma wyraÅºny rozmiar.\n*Ze znakiem* i *bez znaku* odnoszÄ… siÄ™ do tego, czy liczba moÅ¼e byÄ‡ ujemna â€“\ninaczej mÃ³wiÄ…c, czy liczba musi mieÄ‡ znak (ze znakiem), czy zawsze bÄ™dzie\ndodatnia i dlatego moÅ¼e byÄ‡ reprezentowana bez znaku (bez znaku). To jak\npisanie liczb na papierze: gdy znak ma znaczenie, liczba jest pokazywana ze\nznakiem plus lub minus; jednak, gdy moÅ¼na bezpiecznie zaÅ‚oÅ¼yÄ‡, Å¼e liczba jest\ndodatnia, jest pokazywana bez znaku. Liczby ze znakiem sÄ… przechowywane za\npomocÄ… reprezentacji [dopeÅ‚nienia do dwÃ³ch][twos-complement]<!-- ignore -->.\n\nKaÅ¼dy wariant ze znakiem moÅ¼e przechowywaÄ‡ liczby od âˆ’(2<sup>n âˆ’ 1</sup>) do\n2<sup>n âˆ’ 1</sup> âˆ’ 1 wÅ‚Ä…cznie, gdzie *n* to liczba bitÃ³w, ktÃ³re uÅ¼ywa ten wariant.\nTak wiÄ™c `i8` moÅ¼e przechowywaÄ‡ liczby od âˆ’(2<sup>7</sup>) do 2<sup>7</sup> âˆ’ 1,\nco rÃ³wna siÄ™ âˆ’128 do 127. Warianty bez znaku mogÄ… przechowywaÄ‡ liczby od 0 do\n2<sup>n</sup> âˆ’ 1, wiÄ™c `u8` moÅ¼e przechowywaÄ‡ liczby od 0 do 2<sup>8</sup> âˆ’ 1,\nco rÃ³wna siÄ™ 0 do 255.\n\nDodatkowo, typy `isize` i `usize` zaleÅ¼Ä… od architektury komputera, na ktÃ³rym\ndziaÅ‚a TwÃ³j program: 64 bity, jeÅ›li jesteÅ› na architekturze 64-bitowej, i 32\nbity, jeÅ›li jesteÅ› na architekturze 32-bitowej.\n\nLiteraÅ‚y caÅ‚kowite moÅ¼na zapisywaÄ‡ w dowolnej z form pokazanych w tabeli 3-2.\nZauwaÅ¼, Å¼e literaÅ‚y liczbowe, ktÃ³re mogÄ… byÄ‡ wieloma typami numerycznymi,\ndopuszczajÄ… sufiks typu, taki jak `57u8`, do okreÅ›lenia typu. LiteraÅ‚y\nliczbowe mogÄ… rÃ³wnieÅ¼ uÅ¼ywaÄ‡ `_` jako wizualnego separatora, aby uÅ‚atwiÄ‡\nodczytanie liczby, np. `1_000`, ktÃ³ra bÄ™dzie miaÅ‚a takÄ… samÄ… wartoÅ›Ä‡, jakbyÅ›\nokreÅ›liÅ‚ `1000`.\n\n<span class=\"caption\">Tabela 3-2: LiteraÅ‚y caÅ‚kowite w Rust</span>\n\n|LiteraÅ‚y liczbowe|PrzykÅ‚ad|\n|---------------|-------|\n|DziesiÄ™tne|`98_222`|\n|Szesnastkowe|`0xff`|\n|Ã“semkowe|`0o77`|\n|Binarne|`0b1111_0000`|\n|Bajtowe (tylko `u8`)|`b'A'`|\n\nWiÄ™c skÄ…d wiesz, jakiego typu liczby caÅ‚kowitej uÅ¼yÄ‡? JeÅ›li nie jesteÅ› pewien,\ndomyÅ›lne ustawienia Rusta sÄ… zazwyczaj dobrym punktem wyjÅ›cia: typy caÅ‚kowite\ndomyÅ›lnie przyjmujÄ… `i32`. GÅ‚Ã³wna sytuacja, w ktÃ³rej uÅ¼yÅ‚byÅ› `isize` lub\n`usize`, to indeksowanie jakiegoÅ› rodzaju kolekcji.\n\n<section class=\"note\" aria-role=\"note\">\n\n\n\n##### PrzepeÅ‚nienie liczby caÅ‚kowitej\n\nZaÅ‚Ã³Å¼my, Å¼e masz zmiennÄ… typu `u8`, ktÃ³ra moÅ¼e przechowywaÄ‡ wartoÅ›ci od 0 do\n255. JeÅ›li sprÃ³bujesz zmieniÄ‡ zmiennÄ… na wartoÅ›Ä‡ spoza tego zakresu, takÄ… jak\n256, nastÄ…pi *przepeÅ‚nienie liczby caÅ‚kowitej*, co moÅ¼e skutkowaÄ‡ jednym z\ndwÃ³ch zachowaÅ„. Podczas kompilacji w trybie debugowania Rust zawiera\nsprawdzenia przepeÅ‚nienia liczby caÅ‚kowitej, ktÃ³re powodujÄ…, Å¼e program\n*panikuje* w czasie wykonywania, jeÅ›li wystÄ…pi takie zachowanie. Rust uÅ¼ywa\nterminu *panicking*, gdy program koÅ„czy dziaÅ‚anie z bÅ‚Ä™dem; omÃ³wimy paniki\nbardziej szczegÃ³Å‚owo w sekcji [â€BÅ‚Ä™dy nie do odzyskania za pomocÄ…\n`panic!`â€][unrecoverable-errors-with-panic]<!-- ignore --> w Rozdziale 9.\n\nPodczas kompilacji w trybie wydania z flagÄ… `--release`, Rust *nie* zawiera\nsprawdzeÅ„ przepeÅ‚nienia liczby caÅ‚kowitej, ktÃ³re powodujÄ… paniki. Zamiast\ntego, jeÅ›li wystÄ…pi przepeÅ‚nienie, Rust wykonuje *zawijanie dopeÅ‚nienia do\ndwÃ³ch*. KrÃ³tko mÃ³wiÄ…c, wartoÅ›ci wiÄ™ksze niÅ¼ maksymalna wartoÅ›Ä‡, jakÄ… moÅ¼e\nprzechowywaÄ‡ typ, â€zawijajÄ… siÄ™â€ do minimalnej wartoÅ›ci, jakÄ… moÅ¼e przechowywaÄ‡\ntyp. W przypadku `u8`, wartoÅ›Ä‡ 256 staje siÄ™ 0, wartoÅ›Ä‡ 257 staje siÄ™ 1 i tak\ndalej. Program nie bÄ™dzie panikowaÅ‚, ale zmienna bÄ™dzie miaÅ‚a wartoÅ›Ä‡, ktÃ³ra\nprawdopodobnie nie jest tym, czego siÄ™ spodziewaÅ‚eÅ›. Opieranie siÄ™ na zachowaniu\nzawijania przepeÅ‚nienia liczby caÅ‚kowitej jest uwaÅ¼ane za bÅ‚Ä…d.\n\nAby jawnie obsÅ‚uÅ¼yÄ‡ moÅ¼liwoÅ›Ä‡ przepeÅ‚nienia, moÅ¼esz uÅ¼yÄ‡ tych rodzin metod\ndostarczanych przez standardowÄ… bibliotekÄ™ dla prymitywnych typÃ³w liczbowych:\n\n* Zawijaj we wszystkich trybach za pomocÄ… metod `wrapping_*`, takich jak\n  `wrapping_add`.\n* Zwracaj wartoÅ›Ä‡ `None`, jeÅ›li wystÄ…pi przepeÅ‚nienie, za pomocÄ… metod\n  `checked_*`.\n* Zwracaj wartoÅ›Ä‡ i wartoÅ›Ä‡ boolowskÄ… wskazujÄ…cÄ…, czy wystÄ…piÅ‚o\n  przepeÅ‚nienie, za pomocÄ… metod `overflowing_*`.\n* Saturuj przy minimalnych lub maksymalnych wartoÅ›ciach typu za pomocÄ… metod\n  `saturating_*`.\n\n</section>\n\n#### Typy zmiennoprzecinkowe\n\nRust ma rÃ³wnieÅ¼ dwa prymitywne typy dla *liczb zmiennoprzecinkowych*, ktÃ³re sÄ…\nliczbami z punktami dziesiÄ™tnymi. Typy zmiennoprzecinkowe Rusta to `f32` i `f64`,\nktÃ³re majÄ… odpowiednio 32 i 64 bity. DomyÅ›lnym typem jest `f64`, poniewaÅ¼ na\nnowoczesnych procesorach ma on w przybliÅ¼eniu takÄ… samÄ… prÄ™dkoÅ›Ä‡ jak `f32`,\nale jest w stanie zapewniÄ‡ wiÄ™kszÄ… precyzjÄ™. Wszystkie typy zmiennoprzecinkowe\nsÄ… ze znakiem.\n\nOto przykÅ‚ad, ktÃ³ry pokazuje liczby zmiennoprzecinkowe w akcji:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n````rust\nfn main() {\n    let x = 2.0; // f64\n\n    let y: f32 = 3.0; // f32\n}\n````\n\nLiczby zmiennoprzecinkowe sÄ… reprezentowane zgodnie ze standardem IEEE-754.\n\n#### Operacje numeryczne\n\nRust obsÅ‚uguje podstawowe operacje matematyczne, ktÃ³rych moÅ¼na oczekiwaÄ‡ dla\nwszystkich typÃ³w liczbowych: dodawanie, odejmowanie, mnoÅ¼enie, dzielenie i\nreszta z dzielenia. Dzielenie caÅ‚kowite obcina w kierunku zera do\nnajbliÅ¼szej liczby caÅ‚kowitej. PoniÅ¼szy kod pokazuje, jak uÅ¼yÄ‡ kaÅ¼dej operacji\nnumerycznej w instrukcji `let`:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n````rust\nfn main() {\n    // dodawanie\n    let sum = 5 + 10;\n\n    // odejmowanie\n    let difference = 95.5 - 4.3;\n\n    // mnoÅ¼enie\n    let product = 4 * 30;\n\n    // dzielenie\n    let quotient = 56.7 / 32.2;\n    let truncated = -5 / 3; // Wynosi -1\n\n    // reszta z dzielenia\n    let remainder = 43 % 5;\n}\n````\n\nKaÅ¼de wyraÅ¼enie w tych instrukcjach uÅ¼ywa operatora matematycznego i ocenia\nsiÄ™ do pojedynczej wartoÅ›ci, ktÃ³ra nastÄ™pnie jest wiÄ…zana ze zmiennÄ…. [Dodatek\nB][appendix_b]<!-- ignore --> zawiera listÄ™ wszystkich operatorÃ³w,\ndostarczanych przez Rusta.\n\n#### Typ boolowski\n\nPodobnie jak w wiÄ™kszoÅ›ci innych jÄ™zykÃ³w programowania, typ boolowski w Rust\nma dwie moÅ¼liwe wartoÅ›ci: `true` i `false`. WartoÅ›ci boolowskie majÄ… rozmiar\njednego bajta. Typ boolowski w Rust jest okreÅ›lany za pomocÄ… `bool`. Na\nprzykÅ‚ad:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n````rust\nfn main() {\n    let t = true;\n\n    let f: bool = false; // z jawnÄ… adnotacjÄ… typu\n}\n````\n\nGÅ‚Ã³wnym sposobem uÅ¼ywania wartoÅ›ci boolowskich jest poprzez warunki, takie jak\nwyraÅ¼enie `if`. OmÃ³wimy, jak dziaÅ‚ajÄ… wyraÅ¼enia `if` w Rust w sekcji [â€Sterowanie\nprzepÅ‚ywemâ€][control-flow]<!-- ignore -->.\n\n#### Typ znakowy\n\nTyp `char` w Rust jest najbardziej prymitywnym typem alfabetycznym jÄ™zyka.\nOto kilka przykÅ‚adÃ³w deklarowania wartoÅ›ci `char`:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n````rust\nfn main() {\n    let c = 'z';\n    let z: char = 'â„¤'; // z jawnÄ… adnotacjÄ… typu\n    let heart_eyed_cat = 'ğŸ˜»';\n}\n````\n\nZwrÃ³Ä‡ uwagÄ™, Å¼e literaÅ‚y `char` okreÅ›lamy pojedynczymi cudzysÅ‚owami, w\nprzeciwieÅ„stwie do literaÅ‚Ã³w stringowych, ktÃ³re uÅ¼ywajÄ… podwÃ³jnych cudzysÅ‚owÃ³w.\nTyp `char` w Rust ma rozmiar 4 bajtÃ³w i reprezentuje skalarnÄ… wartoÅ›Ä‡ Unicode,\nco oznacza, Å¼e moÅ¼e reprezentowaÄ‡ znacznie wiÄ™cej niÅ¼ tylko ASCII. Litery\nakcentowane; znaki chiÅ„skie, japoÅ„skie i koreaÅ„skie; emotikony; oraz spacje o\nzerowej szerokoÅ›ci sÄ… w RuÅ›cie prawidÅ‚owymi wartoÅ›ciami `char`. Skalarne\nwartoÅ›ci Unicode mieszczÄ… siÄ™ w zakresie od `U+0000` do `U+D7FF` oraz od `U+E000`\ndo `U+10FFFF` wÅ‚Ä…cznie. Jednak â€znakâ€ nie jest tak naprawdÄ™ koncepcjÄ… w Unicode,\nwiÄ™c Twoja ludzka intuicja co do tego, czym jest â€znakâ€, moÅ¼e nie pasowaÄ‡ do\ntego, czym jest `char` w Rust. OmÃ³wimy ten temat szczegÃ³Å‚owo w sekcji\n[â€Przechowywanie tekstu kodowanego UTF-8 za pomocÄ… ciÄ…gÃ³w\nznakÃ³wâ€][strings]<!-- ignore --> w Rozdziale 8.\n\n### Typy zÅ‚oÅ¼one\n\n*Typy zÅ‚oÅ¼one* mogÄ… grupowaÄ‡ wiele wartoÅ›ci w jeden typ. Rust ma dwa\nprymitywne typy zÅ‚oÅ¼one: krotki i tablice.\n\n#### Typ krotki\n\n*Krotka* to ogÃ³lny sposÃ³b grupowania wielu wartoÅ›ci o rÃ³Å¼nych typach w jeden\ntyp zÅ‚oÅ¼ony. Krotki majÄ… staÅ‚Ä… dÅ‚ugoÅ›Ä‡: po zadeklarowaniu nie mogÄ… rosnÄ…Ä‡ ani\nkurczyÄ‡ siÄ™. \n\nTworzymy krotkÄ™, piszÄ…c listÄ™ wartoÅ›ci oddzielonych przecinkami w nawiasach.\nKaÅ¼da pozycja w krotce ma typ, a typy rÃ³Å¼nych wartoÅ›ci w krotce nie muszÄ… byÄ‡\ntakie same. W tym przykÅ‚adzie dodaliÅ›my opcjonalne adnotacje typÃ³w:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n````rust\nfn main() {\n    let tup: (i32, f64, u8) = (500, 6.4, 1);\n}\n````\n\nZmienna `tup` wiÄ…Å¼e siÄ™ z caÅ‚Ä… krotkÄ…, poniewaÅ¼ krotka jest traktowana jako\npojedynczy element zÅ‚oÅ¼ony. Aby uzyskaÄ‡ poszczegÃ³lne wartoÅ›ci z krotki, moÅ¼emy\nuÅ¼yÄ‡ dopasowania wzorcÃ³w do dekonstrukcji wartoÅ›ci krotki, w ten sposÃ³b:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n````rust\nfn main() {\n    let tup = (500, 6.4, 1);\n\n    let (x, y, z) = tup;\n\n    println!(\"The value of y is: {y}\");\n}\n````\n\nTen program najpierw tworzy krotkÄ™ i wiÄ…Å¼e jÄ… ze zmiennÄ… `tup`. NastÄ™pnie uÅ¼ywa\nwzorca z `let`, aby wziÄ…Ä‡ `tup` i zamieniÄ‡ jÄ… w trzy oddzielne zmienne: `x`, `y`\ni `z`. Nazywa siÄ™ to *dekonstrukcjÄ…*, poniewaÅ¼ rozbija pojedynczÄ… krotkÄ™ na\ntrzy czÄ™Å›ci. Na koniec program wypisuje wartoÅ›Ä‡ `y`, ktÃ³ra wynosi `6.4`.\n\nMoÅ¼emy rÃ³wnieÅ¼ uzyskaÄ‡ dostÄ™p do elementu krotki bezpoÅ›rednio, uÅ¼ywajÄ…c kropki\n(`.`) nastÄ™pujÄ…cej po indeksie wartoÅ›ci, do ktÃ³rej chcemy uzyskaÄ‡ dostÄ™p. Na\nprzykÅ‚ad:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n````rust\nfn main() {\n    let x: (i32, f64, u8) = (500, 6.4, 1);\n\n    let five_hundred = x.0;\n\n    let six_point_four = x.1;\n\n    let one = x.2;\n}\n````\n\nTen program tworzy krotkÄ™ `x`, a nastÄ™pnie uzyskuje dostÄ™p do kaÅ¼dego elementu\nkrotki za pomocÄ… ich odpowiednich indeksÃ³w. Podobnie jak w wiÄ™kszoÅ›ci jÄ™zykÃ³w\nprogramowania, pierwszy indeks w krotce to 0.\n\nKrotka bez Å¼adnych wartoÅ›ci ma specjalnÄ… nazwÄ™, *jednostka*. Ta wartoÅ›Ä‡ i jej\nodpowiedni typ sÄ… zapisywane jako `()` i reprezentujÄ… pustÄ… wartoÅ›Ä‡ lub pusty\ntyp zwracany. WyraÅ¼enia niejawnie zwracajÄ… wartoÅ›Ä‡ jednostkowÄ…, jeÅ›li nie\nzwracajÄ… Å¼adnej innej wartoÅ›ci.\n\n#### Typ tablicowy\n\nInnym sposobem posiadania kolekcji wielu wartoÅ›ci jest *tablica*. W przeciwieÅ„stwie\ndo krotki, kaÅ¼dy element tablicy musi mieÄ‡ ten sam typ. W przeciwieÅ„stwie do\ntablic w niektÃ³rych innych jÄ™zykach, tablice w Rust majÄ… staÅ‚Ä… dÅ‚ugoÅ›Ä‡.\n\nWartoÅ›ci w tablicy zapisujemy jako listÄ™ oddzielonÄ… przecinkami w nawiasach\nkwadratowych:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n````rust\nfn main() {\n    let a = [1, 2, 3, 4, 5];\n}\n````\n\nTablice sÄ… przydatne, gdy chcesz, aby dane byÅ‚y alokowane na stosie, tak jak\ninne typy, ktÃ³re widzieliÅ›my do tej pory, a nie na stercie (omÃ³wimy stos i\nsterÄ™ dokÅ‚adniej w [Rozdziale 4][stack-and-heap]<!-- ignore -->) lub gdy\nchcesz zapewniÄ‡, Å¼e zawsze bÄ™dziesz mieÄ‡ staÅ‚Ä… liczbÄ™ elementÃ³w. Tablica nie\njest jednak tak elastyczna jak typ wektora. Wektor to podobny typ kolekcji\ndostarczany przez standardowÄ… bibliotekÄ™, ktÃ³ry *moÅ¼e* rosnÄ…Ä‡ lub kurczyÄ‡ siÄ™\nw rozmiarze, poniewaÅ¼ jego zawartoÅ›Ä‡ znajduje siÄ™ na stercie. JeÅ›li nie masz\npewnoÅ›ci, czy uÅ¼yÄ‡ tablicy, czy wektora, prawdopodobnie powinieneÅ› uÅ¼yÄ‡ wektora.\n[RozdziaÅ‚ 8][vectors]<!-- ignore --> omawia wektory bardziej szczegÃ³Å‚owo.\n\nJednak tablice sÄ… bardziej przydatne, gdy wiesz, Å¼e liczba elementÃ³w nie bÄ™dzie\nmusiaÅ‚a siÄ™ zmieniaÄ‡. Na przykÅ‚ad, jeÅ›li uÅ¼ywaÅ‚byÅ› nazw miesiÄ™cy w programie,\nprawdopodobnie uÅ¼yÅ‚byÅ› tablicy, a nie wektora, poniewaÅ¼ wiesz, Å¼e zawsze bÄ™dzie\nzawieraÄ‡ 12 elementÃ³w:\n\n````rust\nlet months = [\"StyczeÅ„\", \"Luty\", \"Marzec\", \"KwiecieÅ„\", \"Maj\", \"Czerwiec\", \"Lipiec\",\n              \"SierpieÅ„\", \"WrzesieÅ„\", \"PaÅºdziernik\", \"Listopad\", \"GrudzieÅ„\"];\n````\n\nTyp tablicy zapisujesz, uÅ¼ywajÄ…c nawiasÃ³w kwadratowych z typem kaÅ¼dego\nelementu, Å›rednika, a nastÄ™pnie liczby elementÃ³w w tablicy, w ten sposÃ³b:\n\n````rust\nlet a: [i32; 5] = [1, 2, 3, 4, 5];\n````\n\nTutaj `i32` jest typem kaÅ¼dego elementu. Po Å›redniku liczba `5` wskazuje, Å¼e\ntablica zawiera piÄ™Ä‡ elementÃ³w.\n\nMoÅ¼esz rÃ³wnieÅ¼ zainicjalizowaÄ‡ tablicÄ™ tak, aby zawieraÅ‚a tÄ™ samÄ… wartoÅ›Ä‡ dla\nkaÅ¼dego elementu, okreÅ›lajÄ…c wartoÅ›Ä‡ poczÄ…tkowÄ…, po ktÃ³rej nastÄ™puje Å›rednik,\na nastÄ™pnie dÅ‚ugoÅ›Ä‡ tablicy w nawiasach kwadratowych, jak pokazano tutaj:\n\n````rust\nlet a = [3; 5];\n````\n\nTablica o nazwie `a` bÄ™dzie zawieraÅ‚a `5` elementÃ³w, z ktÃ³rych wszystkie\npoczÄ…tkowo zostanÄ… ustawione na wartoÅ›Ä‡ `3`. Jest to to samo, co napisanie\n`let a = [3, 3, 3, 3, 3];`, ale w bardziej zwiÄ™zÅ‚y sposÃ³b.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"accessing-array-elements\"></a>\n\n#### DostÄ™p do elementÃ³w tablicy\n\nTablica to pojedynczy blok pamiÄ™ci o znanej, staÅ‚ej wielkoÅ›ci, ktÃ³ry moÅ¼e byÄ‡\nalokowany na stosie. MoÅ¼esz uzyskaÄ‡ dostÄ™p do elementÃ³w tablicy za pomocÄ…\nindeksowania, w ten sposÃ³b:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n````rust\nfn main() {\n    let a = [1, 2, 3, 4, 5];\n\n    let first = a[0];\n    let second = a[1];\n}\n````\n\nW tym przykÅ‚adzie zmienna o nazwie `first` otrzyma wartoÅ›Ä‡ `1`, poniewaÅ¼ jest\nto wartoÅ›Ä‡ pod indeksem `[0]` w tablicy. Zmienna o nazwie `second` otrzyma\nwartoÅ›Ä‡ `2` z indeksu `[1]` w tablicy.\n\n#### NieprawidÅ‚owy dostÄ™p do elementÃ³w tablicy\n\nZobaczmy, co siÄ™ stanie, jeÅ›li sprÃ³bujesz uzyskaÄ‡ dostÄ™p do elementu tablicy,\nktÃ³ry wykracza poza jej koniec. Powiedzmy, Å¼e uruchamiasz ten kod, podobny do\ngry w zgadywanie z RozdziaÅ‚u 2, aby uzyskaÄ‡ indeks tablicy od uÅ¼ytkownika:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore,panics\nuse std::io;\n\nfn main() {\n    let a = [1, 2, 3, 4, 5];\n\n    println!(\"Please enter an array index.\");\n\n    let mut index = String::new();\n\n    io::stdin()\n        .read_line(&mut index)\n        .expect(\"Failed to read line\");\n\n    let index: usize = index\n        .trim()\n        .parse()\n        .expect(\"Index entered was not a number\");\n\n    let element = a[index];\n\n    println!(\"The value of the element at index {index} is: {element}\");\n}\n````\n\nTen kod kompiluje siÄ™ pomyÅ›lnie. JeÅ›li uruchomisz ten kod za pomocÄ…\n`cargo run` i wprowadzisz `0`, `1`, `2`, `3` lub `4`, program wyÅ›wietli\nodpowiedniÄ… wartoÅ›Ä‡ pod tym indeksem w tablicy. JeÅ›li zamiast tego wprowadzisz\nliczbÄ™ wykraczajÄ…cÄ… poza koniec tablicy, takÄ… jak `10`, zobaczysz dane wyjÅ›ciowe\npodobne do tego:\n\n<!-- manual-regeneration\ncd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access\ncargo run\n10\n-->\n\n````console\nthread 'main' panicked at src/main.rs:19:19:\nindex out of bounds: the len is 5 but the index is 10\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n````\n\nProgram spowodowaÅ‚ bÅ‚Ä…d wykonawczy w momencie uÅ¼ycia nieprawidÅ‚owej wartoÅ›ci w\noperacji indeksowania. Program zakoÅ„czyÅ‚ dziaÅ‚anie z komunikatem o bÅ‚Ä™dzie i\nnie wykonaÅ‚ koÅ„cowej instrukcji `println!`. Kiedy prÃ³bujesz uzyskaÄ‡ dostÄ™p do\nelementu za pomocÄ… indeksowania, Rust sprawdzi, czy podany indeks jest mniejszy\nniÅ¼ dÅ‚ugoÅ›Ä‡ tablicy. JeÅ›li indeks jest wiÄ™kszy lub rÃ³wny dÅ‚ugoÅ›ci, Rust\nspanikuje. To sprawdzenie musi nastÄ…piÄ‡ w czasie wykonania, szczegÃ³lnie w tym\nprzypadku, poniewaÅ¼ kompilator nie jest w stanie wiedzieÄ‡, jakÄ… wartoÅ›Ä‡\nuÅ¼ytkownik wprowadzi, gdy uruchomi kod pÃ³Åºniej.\n\nJest to przykÅ‚ad dziaÅ‚ania zasad bezpieczeÅ„stwa pamiÄ™ci Rusta. W wielu\nniskopoziomowych jÄ™zykach ten rodzaj sprawdzenia nie jest wykonywany, a gdy\npodasz nieprawidÅ‚owy indeks, moÅ¼na uzyskaÄ‡ dostÄ™p do nieprawidÅ‚owej pamiÄ™ci.\nRust chroni CiÄ™ przed tego rodzaju bÅ‚Ä™dami, natychmiast koÅ„czÄ…c dziaÅ‚anie,\nzamiast pozwalaÄ‡ na dostÄ™p do pamiÄ™ci i kontynuowaÄ‡. RozdziaÅ‚ 9 omawia wiÄ™cej\no obsÅ‚udze bÅ‚Ä™dÃ³w w Rust i o tym, jak pisaÄ‡ czytelny, bezpieczny kod, ktÃ³ry ani\nnie panikuje, ani nie pozwala na dostÄ™p do nieprawidÅ‚owej pamiÄ™ci.\n\n[comparing-the-guess-to-the-secret-number]: ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number\n[twos-complement]: https://en.wikipedia.org/wiki/Two%27s_complement\n[unrecoverable-errors-with-panic]: ch09-01-unrecoverable-errors-with-panic.html\n[appendix_b]: appendix-02-operators.md\n[control-flow]: ch03-05-control-flow.html#control-flow\n[strings]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings\n[stack-and-heap]: ch04-01-what-is-ownership.html#the-stack-and-the-heap\n[vectors]: ch08-01-vectors.html",
        "chapter_title": "Typy danych"
    },
    {
        "file_path": "ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md",
        "content": "## ÅšcieÅ¼ki do odwoÅ‚ywania siÄ™ do elementu w drzewie moduÅ‚Ã³w\n\nAby wskazaÄ‡ Rustowi, gdzie znaleÅºÄ‡ element w drzewie moduÅ‚Ã³w, uÅ¼ywamy Å›cieÅ¼ki\nw taki sam sposÃ³b, jak uÅ¼ywamy Å›cieÅ¼ki podczas nawigowania po systemie plikÃ³w.\nAby wywoÅ‚aÄ‡ funkcjÄ™, musimy znaÄ‡ jej Å›cieÅ¼kÄ™.\n\nÅšcieÅ¼ka moÅ¼e przyjmowaÄ‡ dwie formy:\n\n* *ÅšcieÅ¼ka absolutna* to peÅ‚na Å›cieÅ¼ka zaczynajÄ…ca siÄ™ od korzenia pakietu;\ndla kodu z zewnÄ™trznego pakietu Å›cieÅ¼ka absolutna zaczyna siÄ™ od nazwy\npakietu, a dla kodu z bieÅ¼Ä…cego pakietu zaczyna siÄ™ od literaÅ‚u `crate`.\n* *ÅšcieÅ¼ka wzglÄ™dna* zaczyna siÄ™ od bieÅ¼Ä…cego moduÅ‚u i uÅ¼ywa `self`, `super`\nlub identyfikatora w bieÅ¼Ä…cym module.\n\nZarÃ³wno Å›cieÅ¼ki absolutne, jak i wzglÄ™dne sÄ… poprzedzone jednym lub wiÄ™kszÄ…\nliczbÄ… identyfikatorÃ³w oddzielonych podwÃ³jnymi dwukropkami (`::`).\n\nWracajÄ…c do Listingu 7-1, powiedzmy, Å¼e chcemy wywoÅ‚aÄ‡ funkcjÄ™\n`add_to_waitlist`. To samo, co zapytaÄ‡: Jaka jest Å›cieÅ¼ka do funkcji\n`add_to_waitlist`? Listing 7-3 zawiera Listing 7-1 z usuniÄ™tymi niektÃ³rymi\nmoduÅ‚ami i funkcjami.\n\nPokaÅ¼emy dwa sposoby wywoÅ‚ania funkcji `add_to_waitlist` z nowej funkcji,\n`eat_at_restaurant`, zdefiniowanej w korzeniu pakietu. Te Å›cieÅ¼ki sÄ… poprawne,\nale pozostaje jeszcze jeden problem, ktÃ³ry uniemoÅ¼liwi kompilacjÄ™ tego\nprzykÅ‚adu w obecnej postaci. WyjaÅ›nimy dlaczego za chwilÄ™.\n\nFunkcja `eat_at_restaurant` jest czÄ™Å›ciÄ… publicznego API naszego pakietu\nbibliotecznego, dlatego oznaczamy jÄ… sÅ‚owem kluczowym `pub`. W sekcji\n[â€UdostÄ™pnianie Å›cieÅ¼ek za pomocÄ… sÅ‚owa kluczowego\n`pub`â€][pub]<!-- ignore --> omÃ³wimy `pub` bardziej szczegÃ³Å‚owo.\n\n<figure class=\"listing\" id=\"listing-7-3\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,ignore,does_not_compile\nmod front_of_house {\n    mod hosting {\n        fn add_to_waitlist() {}\n    }\n}\n\npub fn eat_at_restaurant() {\n    // ÅšcieÅ¼ka absolutna\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // ÅšcieÅ¼ka wzglÄ™dna\n    front_of_house::hosting::add_to_waitlist();\n}\n````\n\n<figcaption><a href=\"#listing-7-3\">Listing 7-3</a>: WywoÅ‚ywanie funkcji <code>add_to_waitlist</code> za pomocÄ… Å›cieÅ¼ek absolutnych i wzglÄ™dnych</figcaption>\n</figure>\n\nZa pierwszym razem, gdy wywoÅ‚ujemy funkcjÄ™ `add_to_waitlist` w\n`eat_at_restaurant`, uÅ¼ywamy Å›cieÅ¼ki absolutnej. Funkcja `add_to_waitlist` jest\nzdefiniowana w tym samym pakiecie co `eat_at_restaurant`, co oznacza, Å¼e moÅ¼emy\nuÅ¼yÄ‡ sÅ‚owa kluczowego `crate` do rozpoczÄ™cia Å›cieÅ¼ki absolutnej. NastÄ™pnie\ndoÅ‚Ä…czamy kaÅ¼dy kolejny moduÅ‚, aÅ¼ dotrzemy do `add_to_waitlist`. MoÅ¼na sobie\nwyobraziÄ‡ system plikÃ³w o tej samej strukturze: okreÅ›lilibyÅ›my Å›cieÅ¼kÄ™\n`/front_of_house/hosting/add_to_waitlist`, aby uruchomiÄ‡ program\n`add_to_waitlist`; uÅ¼ycie nazwy `crate` do rozpoczÄ™cia od korzenia pakietu jest\npodobne do uÅ¼ycia `/` do rozpoczÄ™cia od korzenia systemu plikÃ³w w Twojej\nshellu.\n\nZa drugim razem, gdy wywoÅ‚ujemy `add_to_waitlist` w `eat_at_restaurant`,\nuÅ¼ywamy Å›cieÅ¼ki wzglÄ™dnej. ÅšcieÅ¼ka zaczyna siÄ™ od `front_of_house`, nazwy\nmoduÅ‚u zdefiniowanego na tym samym poziomie drzewa moduÅ‚Ã³w co\n`eat_at_restaurant`. Tutaj odpowiednikiem w systemie plikÃ³w byÅ‚aby Å›cieÅ¼ka\n`front_of_house/hosting/add_to_waitlist`. RozpoczÄ™cie od nazwy moduÅ‚u oznacza,\nÅ¼e Å›cieÅ¼ka jest wzglÄ™dna.\n\nWybÃ³r miÄ™dzy Å›cieÅ¼kÄ… wzglÄ™dnÄ… a absolutnÄ… to decyzja, ktÃ³rÄ… podejmiesz w\nzaleÅ¼noÅ›ci od projektu i od tego, czy bardziej prawdopodobne jest, Å¼e bÄ™dziesz\nprzenosiÄ‡ kod definicji elementu oddzielnie od kodu, ktÃ³ry go uÅ¼ywa, czy teÅ¼\nrazem z nim. Na przykÅ‚ad, gdybyÅ›my przenieÅ›li moduÅ‚ `front_of_house` i funkcjÄ™\n`eat_at_restaurant` do moduÅ‚u o nazwie `customer_experience`, musielibyÅ›my\nzaktualizowaÄ‡ Å›cieÅ¼kÄ™ absolutnÄ… do `add_to_waitlist`, ale Å›cieÅ¼ka wzglÄ™dna\nnadal byÅ‚aby prawidÅ‚owa. Jednak gdybyÅ›my przenieÅ›li funkcjÄ™\n`eat_at_restaurant` oddzielnie do moduÅ‚u o nazwie `dining`, Å›cieÅ¼ka absolutna\ndo wywoÅ‚ania `add_to_waitlist` pozostaÅ‚aby taka sama, ale Å›cieÅ¼ka wzglÄ™dna\nmusiaÅ‚aby zostaÄ‡ zaktualizowana. OgÃ³lnie preferujemy okreÅ›lanie Å›cieÅ¼ek\nabsolutnych, poniewaÅ¼ bardziej prawdopodobne jest, Å¼e bÄ™dziemy chcieli\nprzenosiÄ‡ definicje kodu i wywoÅ‚ania elementÃ³w niezaleÅ¼nie od siebie.\n\nSprÃ³bujmy skompilowaÄ‡ Listing 7-3 i dowiedzmy siÄ™, dlaczego jeszcze siÄ™ nie\nskompiluje! BÅ‚Ä™dy, ktÃ³re otrzymujemy, sÄ… pokazane w Listingu 7-4.\n\n<figure class=\"listing\" id=\"listing-7-4\">\n\n````console\n$ cargo build\n   Compiling restaurant v0.1.0 (file:///projects/restaurant)\nerror[E0603]: module `hosting` is private\n --> src/lib.rs:9:28\n  |\n9 |     crate::front_of_house::hosting::add_to_waitlist();\n  |                            ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported\n  |                            |\n  |                            private module\n  |\nnote: the module `hosting` is defined here\n --> src/lib.rs:2:5\n  |\n2 |     mod hosting {\n  |     ^^^^^^^^^^^\n\nerror[E0603]: module `hosting` is private\n  --> src/lib.rs:12:21\n   |\n12 |     front_of_house::hosting::add_to_waitlist();\n   |                     ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported\n   |                     |\n   |                     private module\n   |\nnote: the module `hosting` is defined here\n  --> src/lib.rs:2:5\n   |\n 2 |     mod hosting {\n   |     ^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0603`.\nerror: could not compile `restaurant` (lib) due to 2 previous errors\n````\n\n<figcaption><a href=\"#listing-7-4\">Listing 7-4</a>: BÅ‚Ä™dy kompilatora podczas budowania kodu z Listingu 7-3</figcaption>\n</figure>\n\nKomunikaty o bÅ‚Ä™dach mÃ³wiÄ…, Å¼e moduÅ‚ `hosting` jest prywatny. Innymi sÅ‚owy,\nmamy poprawne Å›cieÅ¼ki do moduÅ‚u `hosting` i funkcji `add_to_waitlist`, ale\nRust nie pozwala nam ich uÅ¼ywaÄ‡, poniewaÅ¼ nie ma dostÄ™pu do prywatnych sekcji.\nW Rust wszystkie elementy (funkcje, metody, struktury, wyliczenia, moduÅ‚y\ni staÅ‚e) sÄ… domyÅ›lnie prywatne dla moduÅ‚Ã³w nadrzÄ™dnych. JeÅ›li chcesz\nuczyniÄ‡ element, taki jak funkcja lub struktura, prywatnym, umieszczasz go\nw module.\n\nElementy w module nadrzÄ™dnym nie mogÄ… uÅ¼ywaÄ‡ prywatnych elementÃ³w w moduÅ‚ach\npodrzÄ™dnych, ale elementy w moduÅ‚ach podrzÄ™dnych mogÄ… uÅ¼ywaÄ‡ elementÃ³w w\nmoduÅ‚ach nadrzÄ™dnych. Dzieje siÄ™ tak, poniewaÅ¼ moduÅ‚y podrzÄ™dne opakowujÄ… i\nukrywajÄ… swoje szczegÃ³Å‚y implementacji, ale moduÅ‚y podrzÄ™dne mogÄ… widzieÄ‡\nkontekst, w ktÃ³rym sÄ… zdefiniowane. Aby kontynuowaÄ‡ naszÄ… metaforÄ™, pomyÅ›l o\nzasadach prywatnoÅ›ci jako o zapleczu restauracji: to, co siÄ™ tam dzieje, jest\nprywatne dla klientÃ³w restauracji, ale menedÅ¼erowie biura mogÄ… widzieÄ‡ i robiÄ‡\nwszystko w restauracji, ktÃ³rÄ… prowadzÄ….\n\nRust zdecydowaÅ‚, aby system moduÅ‚Ã³w dziaÅ‚aÅ‚ w ten sposÃ³b, aby domyÅ›lnie ukrywaÄ‡\nwewnÄ™trzne szczegÃ³Å‚y implementacji. W ten sposÃ³b wiesz, ktÃ³re czÄ™Å›ci kodu\nwewnÄ™trznego moÅ¼esz zmieniÄ‡ bez uszkadzania kodu zewnÄ™trznego. Jednak Rust\ndaje moÅ¼liwoÅ›Ä‡ udostÄ™pniania wewnÄ™trznych czÄ™Å›ci kodu moduÅ‚Ã³w podrzÄ™dnych\nmoduÅ‚om nadrzÄ™dnym za pomocÄ… sÅ‚owa kluczowego `pub`, aby uczyniÄ‡ element\npublicznym.\n\n### UdostÄ™pnianie Å›cieÅ¼ek za pomocÄ… sÅ‚owa kluczowego `pub`\n\nWrÃ³Ä‡my do bÅ‚Ä™du z Listingu 7-4, ktÃ³ry informowaÅ‚ nas, Å¼e moduÅ‚ `hosting` jest\nprywatny. Chcemy, aby funkcja `eat_at_restaurant` w module nadrzÄ™dnym miaÅ‚a\ndostÄ™p do funkcji `add_to_waitlist` w module potomnym, wiÄ™c oznaczamy moduÅ‚\n`hosting` sÅ‚owem kluczowym `pub`, jak pokazano w Listingu 7-5.\n\n<figure class=\"listing\" id=\"listing-7-5\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,ignore,does_not_compile\nmod front_of_house {\n    pub mod hosting {\n        fn add_to_waitlist() {}\n    }\n}\n\n// -- snip --\n# pub fn eat_at_restaurant() {\n#     // Absolute path\n#     crate::front_of_house::hosting::add_to_waitlist();\n# \n#     // Relative path\n#     front_of_house::hosting::add_to_waitlist();\n# }\n````\n\n<figcaption><a href=\"#listing-7-5\">Listing 7-5</a>: Deklarowanie moduÅ‚u <code>hosting</code> jako <code>pub</code> w celu uÅ¼ycia go z <code>eat_at_restaurant</code></figcaption>\n</figure>\n\nNiestety, kod w Listingu 7-5 nadal skutkuje bÅ‚Ä™dami kompilatora, jak pokazano w\nListingu 7-6.\n\n<figure class=\"listing\" id=\"listing-7-6\">\n\n````console\n$ cargo build\n   Compiling restaurant v0.1.0 (file:///projects/restaurant)\nerror[E0603]: function `add_to_waitlist` is private\n  --> src/lib.rs:10:37\n   |\n10 |     crate::front_of_house::hosting::add_to_waitlist();\n   |                                     ^^^^^^^^^^^^^^^ private function\n   |\nnote: the function `add_to_waitlist` is defined here\n  --> src/lib.rs:3:9\n   |\n 3 |         fn add_to_waitlist() {}\n   |         ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0603]: function `add_to_waitlist` is private\n  --> src/lib.rs:13:30\n   |\n13 |     front_of_house::hosting::add_to_waitlist();\n   |                              ^^^^^^^^^^^^^^^ private function\n   |\nnote: the function `add_to_waitlist` is defined here\n  --> src/lib.rs:3:9\n   |\n 3 |         fn add_to_waitlist() {}\n   |         ^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0603`.\nerror: could not compile `restaurant` (lib) due to 2 previous errors\n````\n\n<figcaption><a href=\"#listing-7-6\">Listing 7-6</a>: BÅ‚Ä™dy kompilatora podczas budowania kodu z Listingu 7-5</figcaption>\n</figure>\n\nCo siÄ™ staÅ‚o? Dodanie sÅ‚owa kluczowego `pub` przed `mod hosting` sprawia, Å¼e\nmoduÅ‚ staje siÄ™ publiczny. DziÄ™ki tej zmianie, jeÅ›li mamy dostÄ™p do\n`front_of_house`, moÅ¼emy uzyskaÄ‡ dostÄ™p do `hosting`. Ale *zawartoÅ›Ä‡* `hosting`\njest nadal prywatna; uczynienie moduÅ‚u publicznym nie sprawia, Å¼e jego\nzawartoÅ›Ä‡ staje siÄ™ publiczna. SÅ‚owo kluczowe `pub` na module pozwala tylko\nkodowi w jego moduÅ‚ach nadrzÄ™dnych odwoÅ‚ywaÄ‡ siÄ™ do niego, a nie uzyskiwaÄ‡\ndostÄ™pu do jego wewnÄ™trznego kodu. PoniewaÅ¼ moduÅ‚y sÄ… kontenerami, nie moÅ¼emy\nwiele zdziaÅ‚aÄ‡, jedynie upubliczniajÄ…c moduÅ‚; musimy pÃ³jÅ›Ä‡ dalej i\nzdecydowaÄ‡ siÄ™ na upublicznienie jednego lub wiÄ™cej elementÃ³w w module.\n\nBÅ‚Ä™dy w Listingu 7-6 mÃ³wiÄ…, Å¼e funkcja `add_to_waitlist` jest prywatna.\nZasady prywatnoÅ›ci dotyczÄ… rÃ³wnieÅ¼ struktur, wyliczeÅ„, funkcji i metod, a takÅ¼e\nmoduÅ‚Ã³w.\n\nUpublicznijmy rÃ³wnieÅ¼ funkcjÄ™ `add_to_waitlist`, dodajÄ…c sÅ‚owo kluczowe `pub`\nprzed jej definicjÄ…, jak w Listingu 7-7.\n\n<figure class=\"listing\" id=\"listing-7-7\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground,test_harness\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\n// -- snip --\n# pub fn eat_at_restaurant() {\n#     // Absolute path\n#     crate::front_of_house::hosting::add_to_waitlist();\n# \n#     // Relative path\n#     front_of_house::hosting::add_to_waitlist();\n# }\n````\n\n<figcaption><a href=\"#listing-7-7\">Listing 7-7</a>: Dodanie sÅ‚owa kluczowego <code>pub</code> do <code>mod hosting</code> i <code>fn add_to_waitlist</code> pozwala nam wywoÅ‚aÄ‡ funkcjÄ™ z <code>eat_at_restaurant</code>.</figcaption>\n</figure>\n\nTeraz kod siÄ™ skompiluje! Aby zobaczyÄ‡, dlaczego dodanie sÅ‚owa kluczowego `pub`\npozwala nam uÅ¼ywaÄ‡ tych Å›cieÅ¼ek w `eat_at_restaurant` w odniesieniu do zasad\nprywatnoÅ›ci, spÃ³jrzmy na Å›cieÅ¼ki absolutne i wzglÄ™dne.\n\nW Å›cieÅ¼ce absolutnej zaczynamy od `crate`, korzenia drzewa moduÅ‚Ã³w naszego\npakietu. ModuÅ‚ `front_of_house` jest zdefiniowany w korzeniu pakietu. ChociaÅ¼\n`front_of_house` nie jest publiczny, poniewaÅ¼ funkcja `eat_at_restaurant` jest\nzdefiniowana w tym samym module co `front_of_house` (czyli `eat_at_restaurant`\ni `front_of_house` sÄ… rodzeÅ„stwem), moÅ¼emy odwoÅ‚ywaÄ‡ siÄ™ do `front_of_house`\nz `eat_at_restaurant`. NastÄ™pny jest moduÅ‚ `hosting` oznaczony `pub`. Mamy\ndostÄ™p do moduÅ‚u nadrzÄ™dnego `hosting`, wiÄ™c moÅ¼emy uzyskaÄ‡ dostÄ™p do\n`hosting`. Na koniec, funkcja `add_to_waitlist` jest oznaczona `pub`, a my\nmamy dostÄ™p do jej moduÅ‚u nadrzÄ™dnego, wiÄ™c to wywoÅ‚anie funkcji dziaÅ‚a!\n\nW Å›cieÅ¼ce wzglÄ™dnej logika jest taka sama jak w Å›cieÅ¼ce absolutnej, z wyjÄ…tkiem\npierwszego kroku: zamiast zaczynaÄ‡ od korzenia pakietu, Å›cieÅ¼ka zaczyna siÄ™ od\n`front_of_house`. ModuÅ‚ `front_of_house` jest zdefiniowany w tym samym module\nco `eat_at_restaurant`, wiÄ™c Å›cieÅ¼ka wzglÄ™dna zaczynajÄ…ca siÄ™ od moduÅ‚u, w\nktÃ³rym zdefiniowano `eat_at_restaurant`, dziaÅ‚a. NastÄ™pnie, poniewaÅ¼ `hosting`\ni `add_to_waitlist` sÄ… oznaczone jako `pub`, reszta Å›cieÅ¼ki dziaÅ‚a, a to\nwywoÅ‚anie funkcji jest prawidÅ‚owe!\n\nJeÅ›li planujesz udostÄ™pniÄ‡ swÃ³j pakiet biblioteczny, aby inne projekty mogÅ‚y\nuÅ¼ywaÄ‡ Twojego kodu, TwÃ³j publiczny interfejs API jest TwojÄ… umowÄ… z\nuÅ¼ytkownikami Twojego pakietu, ktÃ³ra okreÅ›la, w jaki sposÃ³b mogÄ… wchodziÄ‡ w\ninterakcje z Twoim kodem. Istnieje wiele kwestii zwiÄ…zanych z zarzÄ…dzaniem\nzmianami w Twoim publicznym interfejsie API, aby uÅ‚atwiÄ‡ innym poleganie na\nTwoim pakiecie. Te rozwaÅ¼ania wykraczajÄ… poza zakres tej ksiÄ…Å¼ki; jeÅ›li\ninteresuje CiÄ™ ten temat, zobacz [Rust API Guidelines][api-guidelines].\n\n<section class=\"note\" aria-role=\"note\">\n\n\n\n#### Najlepsze praktyki dla pakietÃ³w z binarnym i bibliotecznym\n\nWspomnieliÅ›my, Å¼e pakiet moÅ¼e zawieraÄ‡ zarÃ³wno korzeÅ„ pakietu binarnego\n*src/main.rs*, jak i korzeÅ„ pakietu bibliotecznego *src/lib.rs*, a oba\npakiety bÄ™dÄ… domyÅ›lnie miaÅ‚y nazwÄ™ pakietu. Zazwyczaj pakiety z takim\npatternem, zawierajÄ…ce zarÃ³wno bibliotekÄ™, jak i pakiet binarny, bÄ™dÄ… miaÅ‚y\nw pakiecie binarnym wystarczajÄ…co duÅ¼o kodu, aby uruchomiÄ‡ plik\nwykonywalny, ktÃ³ry wywoÅ‚uje kod zdefiniowany w pakiecie bibliotecznym. Pozwala\nto innym projektom korzystaÄ‡ z wiÄ™kszoÅ›ci funkcjonalnoÅ›ci, ktÃ³rÄ… pakiet\nzapewnia, poniewaÅ¼ kod pakietu bibliotecznego moÅ¼e byÄ‡ wspÃ³Å‚dzielony.\n\nDrzewo moduÅ‚Ã³w powinno byÄ‡ zdefiniowane w *src/lib.rs*. NastÄ™pnie wszelkie\npubliczne elementy mogÄ… byÄ‡ uÅ¼ywane w pakiecie binarnym, zaczynajÄ…c Å›cieÅ¼ki od\nnazwy pakietu. Pakiet binarny staje siÄ™ uÅ¼ytkownikiem pakietu bibliotecznego,\ntak jak caÅ‚kowicie zewnÄ™trzny pakiet uÅ¼ywaÅ‚by pakietu bibliotecznego: moÅ¼e\nuÅ¼ywaÄ‡ tylko publicznego API. Pomaga to zaprojektowaÄ‡ dobre API; jesteÅ› nie\ntylko autorem, ale takÅ¼e klientem!\n\nW [Rozdziale 12][ch12]<!-- ignore --> zademonstrujemy tÄ™ praktykÄ™\norganizacyjnÄ… za pomocÄ… programu wiersza poleceÅ„, ktÃ³ry bÄ™dzie zawieraÅ‚\nzarÃ³wno pakiet binarny, jak i pakiet biblioteczny.\n\n</section>\n\n### Rozpoczynanie Å›cieÅ¼ek wzglÄ™dnych za pomocÄ… `super`\n\nMoÅ¼emy konstruowaÄ‡ Å›cieÅ¼ki wzglÄ™dne, ktÃ³re zaczynajÄ… siÄ™ w module nadrzÄ™dnym,\na nie w bieÅ¼Ä…cym module lub korzeniu pakietu, uÅ¼ywajÄ…c `super` na poczÄ…tku\nÅ›cieÅ¼ki. Jest to podobne do rozpoczynania Å›cieÅ¼ki systemu plikÃ³w skÅ‚adniÄ… `..`,\nktÃ³ra oznacza przejÅ›cie do katalogu nadrzÄ™dnego. UÅ¼ycie `super` pozwala nam\nodwoÅ‚aÄ‡ siÄ™ do elementu, o ktÃ³rym wiemy, Å¼e znajduje siÄ™ w module nadrzÄ™dnym,\nco moÅ¼e uÅ‚atwiÄ‡ reorganizacjÄ™ drzewa moduÅ‚Ã³w, gdy moduÅ‚ jest Å›ciÅ›le powiÄ…zany z\nnadrzÄ™dnym, ale rodzic moÅ¼e zostaÄ‡ kiedyÅ› przeniesiony w inne miejsce w\ndrzewie moduÅ‚Ã³w.\n\nRozwaÅ¼my kod w Listingu 7-8, ktÃ³ry modeluje sytuacjÄ™, w ktÃ³rej szef kuchni\npoprawia nieprawidÅ‚owe zamÃ³wienie i osobiÅ›cie dostarcza je klientowi. Funkcja\n`fix_incorrect_order` zdefiniowana w module `back_of_house` wywoÅ‚uje funkcjÄ™\n`deliver_order` zdefiniowanÄ… w module nadrzÄ™dnym, okreÅ›lajÄ…c Å›cieÅ¼kÄ™ do\n`deliver_order`, zaczynajÄ…c od `super`.\n\n<figure class=\"listing\" id=\"listing-7-8\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground,test_harness\nfn deliver_order() {}\n\nmod back_of_house {\n    fn fix_incorrect_order() {\n        cook_order();\n        super::deliver_order();\n    }\n\n    fn cook_order() {}\n}\n````\n\n<figcaption><a href=\"#listing-7-8\">Listing 7-8</a>: WywoÅ‚ywanie funkcji za pomocÄ… Å›cieÅ¼ki wzglÄ™dnej zaczynajÄ…cej siÄ™ od <code>super</code></figcaption>\n</figure>\n\nFunkcja `fix_incorrect_order` znajduje siÄ™ w module `back_of_house`, wiÄ™c\nmoÅ¼emy uÅ¼yÄ‡ `super`, aby przejÅ›Ä‡ do moduÅ‚u nadrzÄ™dnego `back_of_house`, ktÃ³ry\nw tym przypadku jest `crate`, czyli korzeÅ„. StamtÄ…d szukamy `deliver_order`\ni znajdujemy jÄ…. Sukces! UwaÅ¼amy, Å¼e moduÅ‚ `back_of_house` i funkcja\n`deliver_order` prawdopodobnie pozostanÄ… w tej samej relacji do siebie i\nzostanÄ… przeniesione razem, jeÅ›li zdecydujemy siÄ™ na reorganizacjÄ™ drzewa\nmoduÅ‚Ã³w pakietu. Dlatego uÅ¼yliÅ›my `super`, aby w przyszÅ‚oÅ›ci, w przypadku\nprzeniesienia tego kodu do innego moduÅ‚u, byÅ‚o mniej miejsc do aktualizacji\nkodu.\n\n### Upublicznianie struktur i wyliczeÅ„\n\nMoÅ¼emy rÃ³wnieÅ¼ uÅ¼yÄ‡ `pub` do oznaczenia struktur i wyliczeÅ„ jako publicznych,\nale istnieje kilka dodatkowych szczegÃ³Å‚Ã³w dotyczÄ…cych uÅ¼ycia `pub` ze\nstrukturami i wyliczeniami. JeÅ›li uÅ¼yjemy `pub` przed definicjÄ… struktury,\nuczynimy jÄ… publicznÄ…, ale pola struktury nadal bÄ™dÄ… prywatne. MoÅ¼emy\nuczyniÄ‡ kaÅ¼de pole publicznym lub nie, w zaleÅ¼noÅ›ci od przypadku. W Listingu\n7-9 zdefiniowaliÅ›my publicznÄ… strukturÄ™ `back_of_house::Breakfast` z\npublicznym polem `toast`, ale prywatnym polem `seasonal_fruit`. To\nmodeluje sytuacjÄ™ w restauracji, gdzie klient moÅ¼e wybraÄ‡ rodzaj pieczywa,\nktÃ³re jest podawane do posiÅ‚ku, ale szef kuchni decyduje, jakie owoce\ntowarzyszÄ… posiÅ‚kowi, w zaleÅ¼noÅ›ci od sezonu i dostÄ™pnoÅ›ci w magazynie.\nDostÄ™pne owoce szybko siÄ™ zmieniajÄ…, wiÄ™c klienci nie mogÄ… wybieraÄ‡ owocÃ³w\nani nawet widzieÄ‡, jakie owoce otrzymajÄ….\n\n<figure class=\"listing\" id=\"listing-7-9\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\nmod back_of_house {\n    pub struct Breakfast {\n        pub toast: String,\n        seasonal_fruit: String,\n    }\n\n    impl Breakfast {\n        pub fn summer(toast: &str) -> Breakfast {\n            Breakfast {\n                toast: String::from(toast),\n                seasonal_fruit: String::from(\"peaches\"),\n            }\n        }\n    }\n}\n\npub fn eat_at_restaurant() {\n    // ZamÃ³w Å›niadanie latem z tostami Å¼ytnimi.\n    let mut meal = back_of_house::Breakfast::summer(\"Rye\");\n    // Zmieniamy zdanie co do rodzaju pieczywa.\n    meal.toast = String::from(\"Wheat\");\n    println!(\"PoproszÄ™ tost {} \", meal.toast);\n\n    // NastÄ™pna linia siÄ™ nie skompiluje, jeÅ›li jÄ… odkomentujemy; nie moÅ¼emy\n    // zobaczyÄ‡ ani modyfikowaÄ‡ sezonowych owocÃ³w, ktÃ³re sÄ… podawane do posiÅ‚ku.\n    // meal.seasonal_fruit = String::from(\"blueberries\");\n}\n````\n\n<figcaption><a href=\"#listing-7-9\">Listing 7-9</a>: Struktura z niektÃ³rymi publicznymi i niektÃ³rymi prywatnymi polami</figcaption>\n</figure>\n\nPoniewaÅ¼ pole `toast` w strukturze `back_of_house::Breakfast` jest publiczne,\nw `eat_at_restaurant` moÅ¼emy zapisywaÄ‡ i odczytywaÄ‡ do pola `toast` uÅ¼ywajÄ…c\nnotacji kropkowej. ZauwaÅ¼, Å¼e nie moÅ¼emy uÅ¼yÄ‡ pola `seasonal_fruit` w\n`eat_at_restaurant`, poniewaÅ¼ `seasonal_fruit` jest prywatne. SprÃ³buj\nodkomentowaÄ‡ liniÄ™ modyfikujÄ…cÄ… wartoÅ›Ä‡ pola `seasonal_fruit`, aby zobaczyÄ‡,\njaki bÅ‚Ä…d otrzymasz!\n\nNaleÅ¼y rÃ³wnieÅ¼ zauwaÅ¼yÄ‡, Å¼e poniewaÅ¼ `back_of_house::Breakfast` ma prywatne\npole, struktura musi udostÄ™pniaÄ‡ publicznÄ… funkcjÄ™ skojarzonÄ…, ktÃ³ra\nkonstruuje instancjÄ™ `Breakfast` (nazwaliÅ›my jÄ… tutaj `summer`). Gdyby\n`Breakfast` nie miaÅ‚a takiej funkcji, nie moglibyÅ›my utworzyÄ‡ instancji\n`Breakfast` w `eat_at_restaurant`, poniewaÅ¼ nie moglibyÅ›my ustawiÄ‡ wartoÅ›ci\nprywatnego pola `seasonal_fruit` w `eat_at_restaurant`.\n\nW przeciwieÅ„stwie do tego, jeÅ›li upublicznimy wyliczenie, wszystkie jego\nwarianty stajÄ… siÄ™ publiczne. Potrzebujemy tylko `pub` przed sÅ‚owem kluczowym\n`enum`, jak pokazano w Listingu 7-10.\n\n<figure class=\"listing\" id=\"listing-7-10\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\nmod back_of_house {\n    pub enum Appetizer {\n        Soup,\n        Salad,\n    }\n}\n\npub fn eat_at_restaurant() {\n    let order1 = back_of_house::Appetizer::Soup;\n    let order2 = back_of_house::Appetizer::Salad;\n}\n````\n\n<figcaption><a href=\"#listing-7-10\">Listing 7-10</a>: Upublicznienie wyliczenia sprawia, Å¼e wszystkie jego warianty stajÄ… siÄ™ publiczne.</figcaption>\n</figure>\n\nPoniewaÅ¼ upubliczniliÅ›my wyliczenie `Appetizer`, moÅ¼emy uÅ¼ywaÄ‡ wariantÃ³w `Soup`\ni `Salad` w `eat_at_restaurant`.\n\nWyliczenia nie sÄ… zbyt uÅ¼yteczne, chyba Å¼e ich warianty sÄ… publiczne; byÅ‚oby\nuciÄ…Å¼liwe, gdybyÅ›my musieli annotowaÄ‡ wszystkie warianty wyliczeÅ„ za pomocÄ…\n`pub` w kaÅ¼dym przypadku, dlatego domyÅ›lnie warianty wyliczeÅ„ sÄ… publiczne.\nStruktury sÄ… czÄ™sto uÅ¼yteczne bez publicznych pÃ³l, wiÄ™c pola struktur\npodlegajÄ… ogÃ³lnej zasadzie, Å¼e wszystko jest domyÅ›lnie prywatne, chyba Å¼e jest\nanotowane za pomocÄ… `pub`.\n\nIstnieje jeszcze jedna sytuacja zwiÄ…zana z `pub`, ktÃ³rej nie omÃ³wiliÅ›my, i jest\nto nasza ostatnia funkcja systemu moduÅ‚Ã³w: sÅ‚owo kluczowe `use`. Najpierw\nomÃ³wimy `use` samo w sobie, a nastÄ™pnie pokaÅ¼emy, jak Å‚Ä…czyÄ‡ `pub` i `use`.\n\n[pub]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword\n[api-guidelines]: https://rust-lang.github.io/api-guidelines/\n[ch12]: ch12-00-an-io-project.html",
        "chapter_title": "ÅšcieÅ¼ki do odwoÅ‚ywania siÄ™ do elementu w drzewie moduÅ‚Ã³w"
    },
    {
        "file_path": "ch11-01-writing-tests.md",
        "content": "## Jak pisaÄ‡ testy\n\n*Testy* to funkcje Rusta, ktÃ³re weryfikujÄ…, czy kod poza testami dziaÅ‚a zgodnie\nz oczekiwaniami. CiaÅ‚a funkcji testowych zazwyczaj wykonujÄ… trzy dziaÅ‚ania:\n\n* Przygotowanie potrzebnych danych lub stanu.\n* Uruchomienie kodu, ktÃ³ry chcesz przetestowaÄ‡.\n* Sprawdzenie, czy wyniki sÄ… zgodne z oczekiwaniami.\n\nPrzyjrzyjmy siÄ™ funkcjom, ktÃ³re Rust dostarcza specjalnie do pisania testÃ³w\nwykonujÄ…cych te dziaÅ‚ania, w tym atrybutowi `test`, kilku makrom i atrybutowi\n`should_panic`.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"the-anatomy-of-a-test-function\"></a>\n\n### Struktura funkcji testowych\n\nNajproÅ›ciej rzecz ujmujÄ…c, test w Rust to funkcja opatrzona atrybutem `test`.\nAtrybuty to metadane dotyczÄ…ce fragmentÃ³w kodu Rust; jednym z przykÅ‚adÃ³w jest\natrybut `derive`, ktÃ³rego uÅ¼ywaliÅ›my ze strukturami w Rozdziale 5. Aby\nzmieniÄ‡ funkcjÄ™ w funkcjÄ™ testowÄ…, dodaj `#[test]` w linii przed `fn`. Kiedy\nuruchamiasz testy za pomocÄ… polecenia `cargo test`, Rust buduje binarny\nrunner testÃ³w, ktÃ³ry uruchamia adnotowane funkcje i raportuje, czy kaÅ¼da\nfunkcja testowa przeszÅ‚a, czy nie powiodÅ‚a siÄ™.\n\nIlekroÄ‡ tworzymy nowy projekt biblioteczny za pomocÄ… Cargo, automatycznie\ngenerowany jest dla nas moduÅ‚ testowy z funkcjÄ… testowÄ…. ModuÅ‚ ten\nudostÄ™pnia szablon do pisania testÃ³w, dziÄ™ki czemu nie musisz za kaÅ¼dym\nrazem, gdy zaczynasz nowy projekt, szukaÄ‡ dokÅ‚adnej struktury i skÅ‚adni. MoÅ¼esz\ndodaÄ‡ tyle dodatkowych funkcji testowych i moduÅ‚Ã³w testowych, ile tylko\nchcesz!\n\nPrzeanalizujemy niektÃ³re aspekty dziaÅ‚ania testÃ³w, eksperymentujÄ…c z\nszablonowym testem, zanim faktycznie przetestujemy jakikolwiek kod. NastÄ™pnie\nnapiszemy kilka rzeczywistych testÃ³w, ktÃ³re wywoÅ‚ajÄ… napisany przez nas kod i\nsprawdzÄ…, czy jego zachowanie jest prawidÅ‚owe.\n\nStwÃ³rzmy nowy projekt biblioteczny o nazwie `adder`, ktÃ³ry bÄ™dzie dodawaÅ‚\ndwie liczby:\n\n````console\n$ cargo new adder --lib\n     Created library `adder` project\n$ cd adder\n````\n\nZawartoÅ›Ä‡ pliku *src/lib.rs* w Twojej bibliotece `adder` powinna wyglÄ…daÄ‡ jak\nListing 11-1.\n\n<figure class=\"listing\" id=\"listing-11-1\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n<!-- manual-regeneration\ncd listings/ch11-writing-automated-tests\nrm -rf listing-11-01\ncargo new listing-11-01 --lib --name adder\ncd listing-11-01\necho \"$ cargo test\" > output.txt\nRUSTFLAGS=\"-A unused_variables -A dead_code\" RUST_TEST_THREADS=1 cargo test >> output.txt 2>&1\ngit diff output.txt # commit any relevant changes; discard irrelevant ones\ncd ../../..\n-->\n\n````rust,noplayground\npub fn add(left: u64, right: u64) -> u64 {\n    left + right\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_works() {\n        let result = add(2, 2);\n        assert_eq!(result, 4);\n    }\n}\n````\n\n<figcaption><a href=\"#listing-11-1\">Listing 11-1</a>: Kod wygenerowany automatycznie przez <code>cargo new</code></figcaption>\n</figure>\n\nPlik zaczyna siÄ™ od przykÅ‚adowej funkcji `add`, abyÅ›my mieli coÅ› do\ntestowania.\n\nNa razie skupmy siÄ™ wyÅ‚Ä…cznie na funkcji `it_works`. ZwrÃ³Ä‡ uwagÄ™ na adnotacjÄ™\n`#[test]`: Ten atrybut wskazuje, Å¼e jest to funkcja testowa, wiÄ™c\nprogram uruchamiajÄ…cy testy wie, aby traktowaÄ‡ tÄ™ funkcjÄ™ jako test. MoÅ¼emy\nrÃ³wnieÅ¼ mieÄ‡ funkcje nietestowe w module `tests`, aby pomÃ³c w\nkonfigurowaniu typowych scenariuszy lub wykonywaniu typowych operacji, wiÄ™c\nzawsze musimy wskazywaÄ‡, ktÃ³re funkcje sÄ… testami.\n\nPrzykÅ‚adowe ciaÅ‚o funkcji uÅ¼ywa makra `assert_eq!`, aby sprawdziÄ‡, czy\n`result`, ktÃ³re zawiera wynik wywoÅ‚ania `add` z argumentami 2 i 2, jest rÃ³wne\n4. To twierdzenie sÅ‚uÅ¼y jako przykÅ‚ad formatu typowego testu. Uruchommy je,\naby zobaczyÄ‡, Å¼e ten test przechodzi.\n\nPolecenie `cargo test` uruchamia wszystkie testy w naszym projekcie, jak\npokazano w Listingu 11-2.\n\n<figure class=\"listing\" id=\"listing-11-2\">\n\n````console\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.57s\n     Running unittests src/lib.rs (target/debug/deps/adder-01ad14159ff659ab)\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n````\n\n<figcaption><a href=\"#listing-11-2\">Listing 11-2</a>: Wynik uruchomienia automatycznie wygenerowanego testu</figcaption>\n</figure>\n\nCargo skompilowaÅ‚ i uruchomiÅ‚ test. Widzimy liniÄ™ `running 1 test`. NastÄ™pna\nlinia pokazuje nazwÄ™ wygenerowanej funkcji testowej, nazwanej\n`tests::it_works`, oraz Å¼e wynik uruchomienia tego testu to `ok`. OgÃ³lne\npodsumowanie `test result: ok.` oznacza, Å¼e wszystkie testy przeszÅ‚y, a czÄ™Å›Ä‡\n`1 passed; 0 failed` sumuje liczbÄ™ testÃ³w, ktÃ³re przeszÅ‚y lub nie powiodÅ‚y siÄ™.\n\nMoÅ¼na oznaczyÄ‡ test jako zignorowany, aby nie byÅ‚ uruchamiany w konkretnej\ninstancji; omÃ³wimy to w sekcji [â€Ignorowanie testÃ³w, chyba Å¼e sÄ…\nspecjalnie Å¼Ä…daneâ€][ignoring]<!-- ignore --> pÃ³Åºniej w tym rozdziale. PoniewaÅ¼\ntego tutaj nie zrobiliÅ›my, podsumowanie pokazuje `0 ignored`. MoÅ¼emy rÃ³wnieÅ¼\nprzekazaÄ‡ argument do polecenia `cargo test`, aby uruchomiÄ‡ tylko te testy,\nktÃ³rych nazwa pasuje do ciÄ…gu znakÃ³w; nazywa siÄ™ to *filtrowaniem*,\ni omÃ³wimy to w sekcji [â€Uruchamianie podzbioru testÃ³w wedÅ‚ug\nnazwyâ€][subset]<!-- ignore -->. Tutaj nie filtrowaliÅ›my uruchamianych testÃ³w,\nwiÄ™c na koÅ„cu podsumowania wyÅ›wietla siÄ™ `0 filtered out`.\n\nStatystyka `0 measured` dotyczy testÃ³w wydajnoÅ›ciowych, ktÃ³re mierzÄ…\nwydajnoÅ›Ä‡. Testy wydajnoÅ›ciowe, w chwili pisania tego tekstu, sÄ… dostÄ™pne tylko\nw nightly Rust. WiÄ™cej informacji znajdziesz w [dokumentacji testÃ³w\nwydajnoÅ›ciowych][bench].\n\nNastÄ™pna czÄ™Å›Ä‡ danych wyjÅ›ciowych testu, zaczynajÄ…ca siÄ™ od `Doc-tests adder`,\ndotyczy wynikÃ³w wszelkich testÃ³w dokumentacyjnych. Nie mamy jeszcze Å¼adnych\ntestÃ³w dokumentacyjnych, ale Rust moÅ¼e kompilowaÄ‡ wszelkie przykÅ‚ady kodu,\nktÃ³re pojawiajÄ… siÄ™ w naszej dokumentacji API. Ta funkcja pomaga utrzymaÄ‡\ndokumentacjÄ™ i kod w synchronizacji! OmÃ³wimy, jak pisaÄ‡ testy dokumentacyjne w\nsekcji [â€Komentarze dokumentacyjne jako testyâ€][doc-comments]<!-- ignore -->\nRozdziaÅ‚u 14. Na razie zignorujemy dane wyjÅ›ciowe `Doc-tests`.\n\nZacznijmy dostosowywaÄ‡ test do naszych wÅ‚asnych potrzeb. Najpierw zmieÅ„ nazwÄ™\nfunkcji `it_works` na innÄ…, takÄ… jak `exploration`, w ten sposÃ³b:\n\n<span class=\"filename\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\npub fn add(left: u64, right: u64) -> u64 {\n    left + right\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn exploration() {\n        let result = add(2, 2);\n        assert_eq!(result, 4);\n    }\n}\n````\n\nNastÄ™pnie ponownie uruchom `cargo test`. Wynik pokazuje teraz `exploration`\nzamiast `it_works`:\n\n````console\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.59s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::exploration ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n````\n\nTeraz dodamy kolejny test, ale tym razem stworzymy test, ktÃ³ry zawiedzie! Testy\nzawodzÄ…, gdy coÅ› w funkcji testowej panikuje. KaÅ¼dy test jest uruchamiany w\nnowym wÄ…tku, a gdy gÅ‚Ã³wny wÄ…tek widzi, Å¼e wÄ…tek testowy umarÅ‚, test jest\noznaczany jako nieudany. W Rozdziale 9 rozmawialiÅ›my o tym, Å¼e najprostszym\nsposobem na panikÄ™ jest wywoÅ‚anie makra `panic!`. WprowadÅº nowy test jako\nfunkcjÄ™ o nazwie `another`, tak aby TwÃ³j plik *src/lib.rs* wyglÄ…daÅ‚ jak Listing\n11-3.\n\n<figure class=\"listing\" id=\"listing-11-3\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,panics,noplayground\npub fn add(left: u64, right: u64) -> u64 {\n    left + right\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn exploration() {\n        let result = add(2, 2);\n        assert_eq!(result, 4);\n    }\n\n    #[test]\n    fn another() {\n        panic!(\"Make this test fail\");\n    }\n}\n````\n\n<figcaption><a href=\"#listing-11-3\">Listing 11-3</a>: Dodawanie drugiego testu, ktÃ³ry zakoÅ„czy siÄ™ niepowodzeniem, poniewaÅ¼ wywoÅ‚ujemy makro <code>panic!</code></figcaption>\n</figure>\n\nUruchom testy ponownie za pomocÄ… `cargo test`. Wynik powinien wyglÄ…daÄ‡ jak\nListing 11-4, ktÃ³ry pokazuje, Å¼e nasz test `exploration` przeszedÅ‚, a `another`\nzakoÅ„czyÅ‚ siÄ™ niepowodzeniem.\n\n<figure class=\"listing\" id=\"listing-11-4\">\n\n````console\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.72s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 2 tests\ntest tests::another ... FAILED\ntest tests::exploration ... ok\n\nfailures:\n\n---- tests::another stdout ----\n\nthread 'tests::another' panicked at src/lib.rs:17:9:\nMake this test fail\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::another\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n````\n\n<figcaption><a href=\"#listing-11-4\">Listing 11-4</a>: Wyniki testÃ³w, gdy jeden test przechodzi, a jeden koÅ„czy siÄ™ niepowodzeniem</figcaption>\n</figure>\n\n<!-- manual-regeneration\nrg panicked listings/ch11-writing-automated-tests/listing-11-03/output.txt\ncheck the line number of the panic matches the line number in the following paragraph\n -->\n\nZamiast `ok`, linia `test tests::another` pokazuje `FAILED`. PojawiajÄ… siÄ™\ndwie nowe sekcje miÄ™dzy indywidualnymi wynikami a podsumowaniem: Pierwsza\nwyÅ›wietla szczegÃ³Å‚owy powÃ³d kaÅ¼dego niepowodzenia testu. W tym przypadku\ndostajemy szczegÃ³Å‚y, Å¼e `tests::another` zawiÃ³dÅ‚, poniewaÅ¼ spanikowaÅ‚ z\nwiadomoÅ›ciÄ… `Make this test fail` w linii 17 w pliku *src/lib.rs*. NastÄ™pna\nsekcja zawiera tylko nazwy wszystkich nieudanych testÃ³w, co jest przydatne,\ngdy jest duÅ¼o testÃ³w i duÅ¼o szczegÃ³Å‚owych danych wyjÅ›ciowych nieudanych\ntestÃ³w. MoÅ¼emy uÅ¼yÄ‡ nazwy nieudanego testu, aby uruchomiÄ‡ tylko ten test,\naby Å‚atwiej go debugowaÄ‡; wiÄ™cej na temat sposobÃ³w uruchamiania testÃ³w\nopowiemy w sekcji [â€Kontrolowanie sposobu uruchamiania\ntestÃ³wâ€][controlling-how-tests-are-run]<!-- ignore -->.\n\nNa koniec wyÅ›wietla siÄ™ linia podsumowujÄ…ca: OgÃ³lnie, nasz wynik testÃ³w to\n`FAILED`. Jeden test przeszedÅ‚, a jeden zawiÃ³dÅ‚.\n\nTeraz, gdy widziaÅ‚eÅ›, jak wyglÄ…dajÄ… wyniki testÃ³w w rÃ³Å¼nych scenariuszach,\nprzyjrzyjmy siÄ™ innym makrom niÅ¼ `panic!`, ktÃ³re sÄ… przydatne w testach.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"checking-results-with-the-assert-macro\"></a>\n\n### Sprawdzanie wynikÃ³w za pomocÄ… makra `assert!`\n\nMakro `assert!`, dostarczane przez standardowÄ… bibliotekÄ™, jest przydatne,\ngdy chcesz upewniÄ‡ siÄ™, Å¼e jakiÅ› warunek w teÅ›cie ocenia siÄ™ jako `true`.\nPodajemy makru `assert!` argument, ktÃ³ry ocenia siÄ™ do wartoÅ›ci boolowskiej.\nJeÅ›li wartoÅ›Ä‡ jest `true`, nic siÄ™ nie dzieje i test przechodzi. JeÅ›li wartoÅ›Ä‡\njest `false`, makro `assert!` wywoÅ‚uje `panic!`, aby spowodowaÄ‡ niepowodzenie\ntestu. UÅ¼ycie makra `assert!` pomaga nam sprawdziÄ‡, czy nasz kod dziaÅ‚a w\nsposÃ³b, w jaki zamierzamy.\n\nW Rozdziale 5, Listing 5-15, uÅ¼yliÅ›my struktury `Rectangle` i metody\n`can_hold`, ktÃ³re sÄ… powtÃ³rzone tutaj w Listingu 11-5. UmieÅ›Ä‡my ten kod w\npliku *src/lib.rs*, a nastÄ™pnie napiszmy dla niego kilka testÃ³w za pomocÄ…\nmakra `assert!`.\n\n<figure class=\"listing\" id=\"listing-11-5\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn can_hold(&self, other: &Rectangle) -> bool {\n        self.width > other.width && self.height > other.height\n    }\n}\n````\n\n<figcaption><a href=\"#listing-11-5\">Listing 11-5</a>: Struktura <code>Rectangle</code> i jej metoda <code>can_hold</code> z RozdziaÅ‚u 5</figcaption>\n</figure>\n\nMetoda `can_hold` zwraca wartoÅ›Ä‡ boolowskÄ…, co oznacza, Å¼e jest idealnym\nprzypadkiem uÅ¼ycia dla makra `assert!`. W Listingu 11-6 piszemy test, ktÃ³ry\nwykorzystuje metodÄ™ `can_hold`, tworzÄ…c instancjÄ™ `Rectangle` o szerokoÅ›ci 8\ni wysokoÅ›ci 7 i twierdzÄ…c, Å¼e moÅ¼e ona pomieÅ›ciÄ‡ innÄ… instancjÄ™ `Rectangle`\no szerokoÅ›ci 5 i wysokoÅ›ci 1.\n\n<figure class=\"listing\" id=\"listing-11-6\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\n# #[derive(Debug)]\n# struct Rectangle {\n#     width: u32,\n#     height: u32,\n# }\n# \n# impl Rectangle {\n#     fn can_hold(&self, other: &Rectangle) -> bool {\n#         self.width > other.width && self.height > other.height\n#     }\n# }\n# \n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn larger_can_hold_smaller() {\n        let larger = Rectangle {\n            width: 8,\n            height: 7,\n        };\n        let smaller = Rectangle {\n            width: 5,\n            height: 1,\n        };\n\n        assert!(larger.can_hold(&smaller));\n    }\n}\n````\n\n<figcaption><a href=\"#listing-11-6\">Listing 11-6</a>: Test dla <code>can_hold</code>, ktÃ³ry sprawdza, czy wiÄ™kszy prostokÄ…t moÅ¼e rzeczywiÅ›cie pomieÅ›ciÄ‡ mniejszy prostokÄ…t</figcaption>\n</figure>\n\nZwrÃ³Ä‡ uwagÄ™ na liniÄ™ `use super::*;` w module `tests`. ModuÅ‚ `tests` to\nzwykÅ‚y moduÅ‚, ktÃ³ry podlega zwykÅ‚ym zasadom widocznoÅ›ci, ktÃ³re omÃ³wiliÅ›my w\nRozdziale 7 w sekcji [â€ÅšcieÅ¼ki do odwoÅ‚ywania siÄ™ do elementu w drzewie\nmoduÅ‚Ã³wâ€][paths-for-referring-to-an-item-in-the-module-tree]<!-- ignore -->.\nPoniewaÅ¼ moduÅ‚ `tests` jest moduÅ‚em wewnÄ™trznym, musimy wprowadziÄ‡ kod poddawany\ntestom z moduÅ‚u zewnÄ™trznego do zakresu moduÅ‚u wewnÄ™trznego. UÅ¼ywamy tutaj\ngloba, wiÄ™c wszystko, co zdefiniujemy w module zewnÄ™trznym, jest dostÄ™pne dla\ntego moduÅ‚u `tests`.\n\nNazwaliÅ›my nasz test `larger_can_hold_smaller` i utworzyliÅ›my dwie\ninstancje `Rectangle`, ktÃ³rych potrzebujemy. NastÄ™pnie wywoÅ‚aliÅ›my makro\n`assert!` i przekazaliÅ›my mu wynik wywoÅ‚ania `larger.can_hold(&smaller)`.\nTo wyraÅ¼enie powinno zwrÃ³ciÄ‡ `true`, wiÄ™c nasz test powinien przejÅ›Ä‡.\nSprawdÅºmy!\n\n````console\n$ cargo test\n   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s\n     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)\n\nrunning 1 test\ntest tests::larger_can_hold_smaller ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests rectangle\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n````\n\nPrzechodzi! Dodajmy kolejny test, tym razem sprawdzajÄ…cy, czy mniejszy\nprostokÄ…t nie moÅ¼e pomieÅ›ciÄ‡ wiÄ™kszego prostokÄ…ta:\n\n<span class=\"filename\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\n# #[derive(Debug)]\n# struct Rectangle {\n#     width: u32,\n#     height: u32,\n# }\n# \n# impl Rectangle {\n#     fn can_hold(&self, other: &Rectangle) -> bool {\n#         self.width > other.width && self.height > other.height\n#     }\n# }\n# \n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn larger_can_hold_smaller() {\n        // --snip--\n#         let larger = Rectangle {\n#             width: 8,\n#             height: 7,\n#         };\n#         let smaller = Rectangle {\n#             width: 5,\n#             height: 1,\n#         };\n# \n#         assert!(larger.can_hold(&smaller));\n    }\n\n    #[test]\n    fn smaller_cannot_hold_larger() {\n        let larger = Rectangle {\n            width: 8,\n            height: 7,\n        };\n        let smaller = Rectangle {\n            width: 5,\n            height: 1,\n        };\n\n        assert!(!smaller.can_hold(&larger));\n    }\n}\n````\n\nPoniewaÅ¼ poprawny wynik funkcji `can_hold` w tym przypadku to `false`, musimy\nzanegowaÄ‡ ten wynik, zanim przekaÅ¼emy go do makra `assert!`. W rezultacie nasz\ntest przejdzie, jeÅ›li `can_hold` zwrÃ³ci `false`:\n\n````console\n$ cargo test\n   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s\n     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)\n\nrunning 2 tests\ntest tests::larger_can_hold_smaller ... ok\ntest tests::smaller_cannot_hold_larger ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests rectangle\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n````\n\nDwa testy, ktÃ³re przeszÅ‚y! Zobaczmy teraz, co siÄ™ stanie z wynikami naszych\ntestÃ³w, gdy wprowadzimy bÅ‚Ä…d do naszego kodu. Zmienimy implementacjÄ™ metody\n`can_hold`, zastÄ™pujÄ…c znak â€wiÄ™ksze niÅ¼â€ (`>`) znakiem â€mniejsze niÅ¼â€ (`<`),\ngdy porÃ³wnuje szerokoÅ›ci:\n\n````rust,not_desired_behavior,noplayground\n# #[derive(Debug)]\n# struct Rectangle {\n#     width: u32,\n#     height: u32,\n# }\n# \n// --snip--\nimpl Rectangle {\n    fn can_hold(&self, other: &Rectangle) -> bool {\n        self.width < other.width && self.height > other.height\n    }\n}\n# \n# #[cfg(test)]\n# mod tests {\n#     use super::*;\n# \n#     #[test]\n#     fn larger_can_hold_smaller() {\n#         let larger = Rectangle {\n#             width: 8,\n#             height: 7,\n#         };\n#         let smaller = Rectangle {\n#             width: 5,\n#             height: 1,\n#         };\n# \n#         assert!(larger.can_hold(&smaller));\n#     }\n# \n#     #[test]\n#     fn smaller_cannot_hold_larger() {\n#         let larger = Rectangle {\n#             width: 8,\n#             height: 7,\n#         };\n#         let smaller = Rectangle {\n#             width: 5,\n#             height: 1,\n#         };\n# \n#         assert!(!smaller.can_hold(&larger));\n#     }\n# }\n````\n\nUruchomienie testÃ³w teraz daje nastÄ™pujÄ…ce wyniki:\n\n````console\n$ cargo test\n   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s\n     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)\n\nrunning 2 tests\ntest tests::larger_can_hold_smaller ... FAILED\ntest tests::smaller_cannot_hold_larger ... ok\n\nfailures:\n\n---- tests::larger_can_hold_smaller stdout ----\n\nthread 'tests::larger_can_hold_smaller' panicked at src/lib.rs:28:9:\nassertion failed: larger.can_hold(&smaller)\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::larger_can_hold_smaller\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n````\n\nNasze testy wykryÅ‚y bÅ‚Ä…d! PoniewaÅ¼ `larger.width` wynosi `8`, a `smaller.width`\nwynosi `5`, porÃ³wnanie szerokoÅ›ci w `can_hold` zwraca teraz `false`: 8 nie jest\nmniejsze niÅ¼ 5.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"testing-equality-with-the-assert_eq-and-assert_ne-macros\"></a>\n\n### Testowanie rÃ³wnoÅ›ci za pomocÄ… makr `assert_eq!` i `assert_ne!`\n\nPowszechnym sposobem weryfikacji funkcjonalnoÅ›ci jest testowanie rÃ³wnoÅ›ci miÄ™dzy\nwynikiem kodu poddanego testom a wartoÅ›ciÄ…, ktÃ³rÄ… kod powinien zwrÃ³ciÄ‡. MoÅ¼na\nto zrobiÄ‡, uÅ¼ywajÄ…c makra `assert!` i przekazujÄ…c mu wyraÅ¼enie uÅ¼ywajÄ…ce\noperatora `==`. Jest to jednak tak powszechny test, Å¼e standardowa biblioteka\ndostarcza parÄ™ makr â€” `assert_eq!` i `assert_ne!` â€” aby wygodniej\nwykonaÄ‡ ten test. Makra te porÃ³wnujÄ… dwa argumenty pod kÄ…tem rÃ³wnoÅ›ci lub\nnierÃ³wnoÅ›ci. WyÅ›wietlajÄ… rÃ³wnieÅ¼ dwie wartoÅ›ci, jeÅ›li asercja zawiedzie, co\nuÅ‚atwia zrozumienie, *dlaczego* test zawiÃ³dÅ‚; z kolei makro `assert!`\nwskazuje tylko, Å¼e otrzymaÅ‚o wartoÅ›Ä‡ `false` dla wyraÅ¼enia `==`, nie\nwyÅ›wietlajÄ…c wartoÅ›ci, ktÃ³re doprowadziÅ‚y do wartoÅ›ci `false`.\n\nW Listingu 11-7 piszemy funkcjÄ™ o nazwie `add_two`, ktÃ³ra dodaje `2` do swego\nparametru, a nastÄ™pnie testujemy tÄ™ funkcjÄ™ za pomocÄ… makra `assert_eq!`.\n\n<figure class=\"listing\" id=\"listing-11-7\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\npub fn add_two(a: u64) -> u64 {\n    a + 2\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_adds_two() {\n        let result = add_two(2);\n        assert_eq!(result, 4);\n    }\n}\n````\n\n<figcaption><a href=\"#listing-11-7\">Listing 11-7</a>: Testowanie funkcji <code>add_two</code> za pomocÄ… makra <code>assert_eq!</code></figcaption>\n</figure>\n\nSprawdÅºmy, czy przechodzi!\n\n````console\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::it_adds_two ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n````\n\nTworzymy zmiennÄ… o nazwie `result`, ktÃ³ra przechowuje wynik wywoÅ‚ania\n`add_two(2)`. NastÄ™pnie przekazujemy `result` i `4` jako argumenty do makra\n`assert_eq!`. Linia wyjÅ›ciowa dla tego testu to `test tests::it_adds_two ... ok`,\na tekst `ok` wskazuje, Å¼e nasz test przeszedÅ‚!\n\nWprowadÅºmy bÅ‚Ä…d do naszego kodu, aby zobaczyÄ‡, jak wyglÄ…da `assert_eq!`, gdy\nzawodzi. ZmieÅ„ implementacjÄ™ funkcji `add_two`, aby zamiast tego dodawaÅ‚a `3`:\n\n````rust,not_desired_behavior,noplayground\npub fn add_two(a: u64) -> u64 {\n    a + 3\n}\n# \n# #[cfg(test)]\n# mod tests {\n#     use super::*;\n# \n#     #[test]\n#     fn it_adds_two() {\n#         let result = add_two(2);\n#         assert_eq!(result, 4);\n#     }\n# }\n````\n\nUruchom testy ponownie:\n\n````console\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::it_adds_two ... FAILED\n\nfailures:\n\n---- tests::it_adds_two stdout ----\n\nthread 'tests::it_adds_two' panicked at src/lib.rs:12:9:\nassertion `left == right` failed\n  left: 5\n right: 4\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::it_adds_two\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n````\n\nNasz test wykryÅ‚ bÅ‚Ä…d! Test `tests::it_adds_two` nie powiÃ³dÅ‚ siÄ™, a komunikat\ninformuje nas, Å¼e asercja, ktÃ³ra zawiodÅ‚a, to `left == right` oraz jakie sÄ…\nwartoÅ›ci `left` i `right`. Ten komunikat pomaga nam rozpoczÄ…Ä‡ debugowanie:\nargument `left`, gdzie mieliÅ›my wynik wywoÅ‚ania `add_two(2)`, wynosiÅ‚ `5`, ale\nargument `right` wynosiÅ‚ `4`. MoÅ¼na sobie wyobraziÄ‡, Å¼e byÅ‚oby to szczegÃ³lnie\npomocne, gdybyÅ›my mieli wiele testÃ³w.\n\nZauwaÅ¼, Å¼e w niektÃ³rych jÄ™zykach i frameworkach testowych parametry funkcji\nasercji rÃ³wnoÅ›ci nazywane sÄ… `expected` i `actual`, a kolejnoÅ›Ä‡, w jakiej\nokreÅ›lamy argumenty, ma znaczenie. Jednak w Rust nazywajÄ… siÄ™ `left` i\n`right`, a kolejnoÅ›Ä‡, w jakiej okreÅ›lamy wartoÅ›Ä‡, ktÃ³rej oczekujemy, i\nwartoÅ›Ä‡, ktÃ³rÄ… produkuje kod, nie ma znaczenia. MoglibyÅ›my napisaÄ‡ asercjÄ™\nw tym teÅ›cie jako `assert_eq!(4, result)`, co spowodowaÅ‚oby ten sam komunikat\no bÅ‚Ä™dzie, ktÃ³ry wyÅ›wietla ``assertion `left == right` failed``.\n\nMakro `assert_ne!` przejdzie, jeÅ›li dwie podane mu wartoÅ›ci nie sÄ… sobie rÃ³wne,\na zawiedzie, jeÅ›li sÄ… rÃ³wne. To makro jest najbardziej przydatne w przypadkach,\ngdy nie jesteÅ›my pewni, jaka *bÄ™dzie* wartoÅ›Ä‡, ale wiemy, jaka wartoÅ›Ä‡\nzdecydowanie *nie powinna* byÄ‡. Na przykÅ‚ad, jeÅ›li testujemy funkcjÄ™, ktÃ³ra ma\ngwarantowaÄ‡ zmianÄ™ jej danych wejÅ›ciowych w jakiÅ› sposÃ³b, ale sposÃ³b zmiany\ndanych wejÅ›ciowych zaleÅ¼y od dnia tygodnia, w ktÃ³rym uruchamiamy nasze testy,\nnajlepiej byÅ‚oby sprawdziÄ‡, czy wynik funkcji nie jest rÃ³wny danym\nwejÅ›ciowym.\n\nPod powierzchniÄ…, makra `assert_eq!` i `assert_ne!` uÅ¼ywajÄ… odpowiednio\noperatorÃ³w `==` i `!=`. Kiedy asercje zawiodÄ…, te makra wypisujÄ… swoje\nargumenty za pomocÄ… formatowania debuggowania, co oznacza, Å¼e porÃ³wnywane\nwartoÅ›ci muszÄ… implementowaÄ‡ cechy `PartialEq` i `Debug`. Wszystkie typy\nprymitywne i wiÄ™kszoÅ›Ä‡ typÃ³w standardowej biblioteki implementujÄ… te cechy.\nDla struktur i wyliczeÅ„, ktÃ³re sam definiujesz, bÄ™dziesz musiaÅ‚ zaimplementowaÄ‡\n`PartialEq`, aby sprawdziÄ‡ rÃ³wnoÅ›Ä‡ tych typÃ³w. BÄ™dziesz rÃ³wnieÅ¼ musiaÅ‚\nzaimplementowaÄ‡ `Debug`, aby wyÅ›wietliÄ‡ wartoÅ›ci, gdy asercja zawiedzie.\nPoniewaÅ¼ obie cechy sÄ… cechami, ktÃ³re moÅ¼na wyprowadziÄ‡, jak wspomniano w\nListingu 5-12 w Rozdziale 5, jest to zazwyczaj tak proste, jak dodanie\nanotacji `#[derive(PartialEq, Debug)]` do definicji struktury lub wyliczenia.\nWiÄ™cej szczegÃ³Å‚Ã³w na temat tych i innych cech, ktÃ³re moÅ¼na wyprowadziÄ‡,\nznajdziesz w Dodatku C, [â€Cechy, ktÃ³re moÅ¼na\nwyprowadziÄ‡â€][derivable-traits]<!-- ignore -->.\n\n### Dodawanie niestandardowych komunikatÃ³w o bÅ‚Ä™dach\n\nMoÅ¼esz rÃ³wnieÅ¼ dodaÄ‡ niestandardowy komunikat do wydrukowania wraz z\nkomunikatem o bÅ‚Ä™dzie jako opcjonalne argumenty do makr `assert!`, `assert_eq!`\ni `assert_ne!`. Wszelkie argumenty okreÅ›lone po wymaganych argumentach sÄ…\nprzekazywane do makra `format!` (omÃ³wionego w [â€ÅÄ…czenie za pomocÄ… `+` lub\n`format!`â€][concatenating]<!-- ignore --> w Rozdziale 8), wiÄ™c moÅ¼esz\nprzekazaÄ‡ ciÄ…g formatujÄ…cy, ktÃ³ry zawiera znaczniki `{}` i wartoÅ›ci, ktÃ³re majÄ…\nbyÄ‡ umieszczone w tych znacznikach. Niestandardowe komunikaty sÄ… przydatne do\ndokumentowania, co oznacza asercja; gdy test zawiedzie, bÄ™dziesz miaÅ‚ lepsze\npojÄ™cie o tym, na czym polega problem z kodem.\n\nNa przykÅ‚ad, powiedzmy, Å¼e mamy funkcjÄ™, ktÃ³ra wita ludzi po imieniu, i chcemy\nprzetestowaÄ‡, czy imiÄ™, ktÃ³re przekazujemy do funkcji, pojawia siÄ™ w danych\nwyjÅ›ciowych:\n\n<span class=\"filename\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\npub fn greeting(name: &str) -> String {\n    format!(\"Hello {name}!\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn greeting_contains_name() {\n        let result = greeting(\"Carol\");\n        assert!(result.contains(\"Carol\"));\n    }\n}\n````\n\nWymagania dla tego programu nie zostaÅ‚y jeszcze uzgodnione, a my jesteÅ›my\nraczej pewni, Å¼e tekst â€Helloâ€ na poczÄ…tku pozdrowienia zmieni siÄ™. PostanowiliÅ›my,\nÅ¼e nie chcemy aktualizowaÄ‡ testu, gdy wymagania siÄ™ zmieniÄ…, wiÄ™c zamiast\nsprawdzaÄ‡ dokÅ‚adnÄ… rÃ³wnoÅ›Ä‡ z wartoÅ›ciÄ… zwrÃ³conÄ… przez funkcjÄ™ `greeting`,\nbÄ™dziemy tylko sprawdzaÄ‡, czy wynik zawiera tekst parametru wejÅ›ciowego.\n\nTeraz wprowadÅºmy bÅ‚Ä…d do tego kodu, zmieniajÄ…c `greeting` tak, aby wykluczaÅ‚o\n`name`, aby zobaczyÄ‡, jak wyglÄ…da domyÅ›lne niepowodzenie testu:\n\n````rust,not_desired_behavior,noplayground\npub fn greeting(name: &str) -> String {\n    String::from(\"Hello!\")\n}\n# \n# #[cfg(test)]\n# mod tests {\n#     use super::*;\n# \n#     #[test]\n#     fn greeting_contains_name() {\n#         let result = greeting(\"Carol\");\n#         assert!(result.contains(\"Carol\"));\n#     }\n# }\n````\n\nUruchomienie tego testu daje nastÄ™pujÄ…ce wyniki:\n\n````console\n$ cargo test\n   Compiling greeter v0.1.0 (file:///projects/greeter)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s\n     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)\n\nrunning 1 test\ntest tests::greeting_contains_name ... FAILED\n\nfailures:\n\n---- tests::greeting_contains_name stdout ----\n\nthread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:\nassertion failed: result.contains(\"Carol\")\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::greeting_contains_name\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n````\n\nTen wynik wskazuje tylko, Å¼e asercja nie powiodÅ‚a siÄ™ i w ktÃ³rej linii siÄ™\nznajduje. Bardziej uÅ¼yteczny komunikat o bÅ‚Ä™dzie wyÅ›wietliÅ‚by wartoÅ›Ä‡ z funkcji\n`greeting`. Dodajmy niestandardowy komunikat o bÅ‚Ä™dzie skÅ‚adajÄ…cy siÄ™ z ciÄ…gu\nformatujÄ…cego z znacznikiem miejsca wypeÅ‚nionym rzeczywistÄ… wartoÅ›ciÄ…, ktÃ³rÄ…\notrzymaliÅ›my z funkcji `greeting`:\n\n````rust,ignore\n# pub fn greeting(name: &str) -> String {\n#     String::from(\"Hello!\")\n# }\n# \n# #[cfg(test)]\n# mod tests {\n#     use super::*;\n# \n    #[test]\n    fn greeting_contains_name() {\n        let result = greeting(\"Carol\");\n        assert!(\n            result.contains(\"Carol\"),\n            \"Greeting did not contain name, value was `{result}`\"\n        );\n    }\n# }\n````\n\nTeraz, gdy uruchomimy test, otrzymamy bardziej informacyjny komunikat o bÅ‚Ä™dzie:\n\n````console\n$ cargo test\n   Compiling greeter v0.1.0 (file:///projects/greeter)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.93s\n     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)\n\nrunning 1 test\ntest tests::greeting_contains_name ... FAILED\n\nfailures:\n\n---- tests::greeting_contains_name stdout ----\n\nthread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:\nGreeting did not contain name, value was `Hello!`\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::greeting_contains_name\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n````\n\nMoÅ¼emy zobaczyÄ‡ rzeczywistÄ… wartoÅ›Ä‡, ktÃ³rÄ… otrzymaliÅ›my w wynikach testu, co\npomogÅ‚oby nam debugowaÄ‡, co siÄ™ staÅ‚o, zamiast tego, czego siÄ™ spodziewaliÅ›my.\n\n### Sprawdzanie paniki za pomocÄ… `should_panic`\n\nOprÃ³cz sprawdzania wartoÅ›ci zwracanych, waÅ¼ne jest sprawdzenie, czy nasz kod\nobsÅ‚uguje warunki bÅ‚Ä™dÃ³w zgodnie z oczekiwaniami. Na przykÅ‚ad, rozwaÅ¼ typ\n`Guess`, ktÃ³ry utworzyliÅ›my w Rozdziale 9, Listing 9-13. Inny kod, ktÃ³ry\nuÅ¼ywa `Guess`, zaleÅ¼y od gwarancji, Å¼e instancje `Guess` bÄ™dÄ… zawieraÄ‡ tylko\nwartoÅ›ci od 1 do 100. MoÅ¼emy napisaÄ‡ test, ktÃ³ry zapewni, Å¼e prÃ³ba utworzenia\ninstancji `Guess` z wartoÅ›ciÄ… spoza tego zakresu spowoduje panikÄ™.\n\nRobimy to, dodajÄ…c atrybut `should_panic` do naszej funkcji testowej. Test\nprzechodzi, jeÅ›li kod wewnÄ…trz funkcji panikuje; test koÅ„czy siÄ™ niepowodzeniem,\njeÅ›li kod wewnÄ…trz funkcji nie panikuje.\n\nListing 11-8 przedstawia test, ktÃ³ry sprawdza, czy warunki bÅ‚Ä™du funkcji\n`Guess::new` wystÄ™pujÄ…, gdy tego oczekujemy.\n\n<figure class=\"listing\" id=\"listing-11-8\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\npub struct Guess {\n    value: i32,\n}\n\nimpl Guess {\n    pub fn new(value: i32) -> Guess {\n        if value < 1 || value > 100 {\n            panic!(\"Guess value must be between 1 and 100, got {value}.\");\n        }\n\n        Guess { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn greater_than_100() {\n        Guess::new(200);\n    }\n}\n````\n\n<figcaption><a href=\"#listing-11-8\">Listing 11-8</a>: Testowanie, czy warunek spowoduje <code>panic!</code></figcaption>\n</figure>\n\nUmieszczamy atrybut `#[should_panic]` po atrybucie `#[test]` i przed funkcjÄ…\ntestowÄ…, ktÃ³rej dotyczy. SpÃ³jrzmy na wynik, gdy ten test przejdzie:\n\n````console\n$ cargo test\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s\n     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)\n\nrunning 1 test\ntest tests::greater_than_100 - should panic ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests guessing_game\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n````\n\nWyglÄ…da dobrze! Teraz wprowadÅºmy bÅ‚Ä…d do naszego kodu, usuwajÄ…c warunek, Å¼e\nfunkcja `new` spanikuje, jeÅ›li wartoÅ›Ä‡ jest wiÄ™ksza niÅ¼ 100:\n\n````rust,not_desired_behavior,noplayground\n# pub struct Guess {\n#     value: i32,\n# }\n# \n// --snip--\nimpl Guess {\n    pub fn new(value: i32) -> Guess {\n        if value < 1 {\n            panic!(\"Guess value must be between 1 and 100, got {value}.\");\n        }\n\n        Guess { value }\n    }\n}\n# \n# #[cfg(test)]\n# mod tests {\n#     use super::*;\n# \n#     #[test]\n#     #[should_panic]\n#     fn greater_than_100() {\n#         Guess::new(200);\n#     }\n# }\n````\n\nKiedy uruchomimy test w Listingu 11-8, zakoÅ„czy siÄ™ on niepowodzeniem:\n\n````console\n$ cargo test\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s\n     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)\n\nrunning 1 test\ntest tests::greater_than_100 - should panic ... FAILED\n\nfailures:\n\n---- tests::greater_than_100 stdout ----\nnote: test did not panic as expected at src/lib.rs:21:8\n\nfailures:\n    tests::greater_than_100\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n````\n\nW tym przypadku nie otrzymujemy zbyt pomocnego komunikatu, ale patrzÄ…c na\nfunkcjÄ™ testowÄ…, widzimy, Å¼e jest ona opatrzona adnotacjÄ…\n`#[should_panic]`. Otrzymany bÅ‚Ä…d oznacza, Å¼e kod w funkcji testowej nie\nspowodowaÅ‚ paniki.\n\nTesty wykorzystujÄ…ce `should_panic` mogÄ… byÄ‡ niedokÅ‚adne. Test `should_panic`\nprzeszedÅ‚by nawet wtedy, gdyby test panikowaÅ‚ z innego powodu niÅ¼ ten, ktÃ³rego\nsiÄ™ spodziewaliÅ›my. Aby testy `should_panic` byÅ‚y bardziej precyzyjne,\nmoÅ¼emy dodaÄ‡ opcjonalny parametr `expected` do atrybutu `should_panic`. Test\nframework zapewni, Å¼e komunikat o bÅ‚Ä™dzie bÄ™dzie zawieraÅ‚ podany tekst. Na\nprzykÅ‚ad, rozwaÅ¼ zmodyfikowany kod dla `Guess` w Listingu 11-9, gdzie funkcja\n`new` panikuje z rÃ³Å¼nymi komunikatami w zaleÅ¼noÅ›ci od tego, czy wartoÅ›Ä‡ jest\nza maÅ‚a, czy za duÅ¼a.\n\n<figure class=\"listing\" id=\"listing-11-9\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\npub struct Guess {\n    value: i32,\n}\n\nimpl Guess {\n    pub fn new(value: i32) -> Guess {\n        if value < 1 {\n            panic!(\n                \"Guess value must be greater than or equal to 1, got {value}.\"\n            );\n        } else if value > 100 {\n            panic!(\n                \"Guess value must be less than or equal to 100, got {value}.\"\n            );\n        }\n\n        Guess { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic(expected = \"less than or equal to 100\")]\n    fn greater_than_100() {\n        Guess::new(200);\n    }\n}\n````\n\n<figcaption><a href=\"#listing-11-9\">Listing 11-9</a>: Testowanie <code>panic!</code> z komunikatem paniki zawierajÄ…cym okreÅ›lony podciÄ…g</figcaption>\n</figure>\n\nTen test przejdzie, poniewaÅ¼ wartoÅ›Ä‡, ktÃ³rÄ… umieÅ›ciliÅ›my w parametrze\n`expected` atrybutu `should_panic`, jest podciÄ…giem komunikatu, z ktÃ³rym\nfunkcja `Guess::new` panikuje. MogliÅ›my okreÅ›liÄ‡ caÅ‚y oczekiwany komunikat\npaniki, ktÃ³ry w tym przypadku brzmiaÅ‚by `Guess value must be less than or equal to 100, got 200`. To, co zdecydujesz siÄ™ okreÅ›liÄ‡, zaleÅ¼y od tego, jak\nwiele z komunikatu paniki jest unikalne lub dynamiczne i jak precyzyjny chcesz,\naby byÅ‚ TwÃ³j test. W tym przypadku podciÄ…g komunikatu paniki jest wystarczajÄ…cy,\naby upewniÄ‡ siÄ™, Å¼e kod w funkcji testowej wykonuje przypadek\n`else if value > 100`.\n\nAby zobaczyÄ‡, co siÄ™ stanie, gdy test `should_panic` z komunikatem `expected`\nzawiedzie, ponownie wprowadÅºmy bÅ‚Ä…d do naszego kodu, zamieniajÄ…c ciaÅ‚a blokÃ³w\n`if value < 1` i `else if value > 100`:\n\n````rust,ignore,not_desired_behavior\n# pub struct Guess {\n#     value: i32,\n# }\n# \n# impl Guess {\n#     pub fn new(value: i32) -> Guess {\n        if value < 1 {\n            panic!(\n                \"Guess value must be less than or equal to 100, got {value}.\"\n            );\n        } else if value > 100 {\n            panic!(\n                \"Guess value must be greater than or equal to 1, got {value}.\"\n            );\n        }\n# \n#         Guess { value }\n#     }\n# }\n# \n# #[cfg(test)]\n# mod tests {\n#     use super::*;\n# \n#     #[test]\n#     #[should_panic(expected = \"less than or equal to 100\")]\n#     fn greater_than_100() {\n#         Guess::new(200);\n#     }\n# }\n````\n\nTym razem, gdy uruchomimy test `should_panic`, zakoÅ„czy siÄ™ on niepowodzeniem:\n\n````console\n$ cargo test\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s\n     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)\n\nrunning 1 test\ntest tests::greater_than_100 - should panic ... FAILED\n\nfailures:\n\n---- tests::greater_than_100 stdout ----\n\nthread 'tests::greater_than_100' panicked at src/lib.rs:12:13:\nGuess value must be greater than or equal to 1, got 200.\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nnote: panic did not contain expected string\n      panic message: \"Guess value must be greater than or equal to 1, got 200.\"\n expected substring: \"less than or equal to 100\"\n\nfailures:\n    tests::greater_than_100\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n````\n\nKomunikat o bÅ‚Ä™dzie wskazuje, Å¼e ten test rzeczywiÅ›cie panikowaÅ‚, jak siÄ™\nspodziewaliÅ›my, ale komunikat paniki nie zawieraÅ‚ oczekiwanego ciÄ…gu znakÃ³w\n`less than or equal to 100`. Komunikat paniki, ktÃ³ry otrzymaliÅ›my w tym\nprzypadku, brzmiaÅ‚ `Guess value must be greater than or equal to 1, got 200`.\nTeraz moÅ¼emy zaczÄ…Ä‡ szukaÄ‡ naszego bÅ‚Ä™du!\n\n### UÅ¼ywanie `Result<T, E>` w testach\n\nWszystkie nasze dotychczasowe testy panikujÄ…, gdy zawiodÄ…. MoÅ¼emy rÃ³wnieÅ¼\npisaÄ‡ testy, ktÃ³re uÅ¼ywajÄ… `Result<T, E>`! Oto test z Listingu 11-1,\nprzepisany tak, aby uÅ¼ywaÅ‚ `Result<T, E>` i zwracaÅ‚ `Err` zamiast panikowaÄ‡:\n\n````rust,noplayground\n# pub fn add(left: u64, right: u64) -> u64 {\n#     left + right\n# }\n# \n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_works() -> Result<(), String> {\n        let result = add(2, 2);\n\n        if result == 4 {\n            Ok(())\n        } else {\n            Err(String::from(\"two plus two does not equal four\"))\n        }\n    }\n}\n````\n\nFunkcja `it_works` ma teraz typ zwracany `Result<(), String>`. W ciele\nfunkcji, zamiast wywoÅ‚ywaÄ‡ makro `assert_eq!`, zwracamy `Ok(())`, gdy test\nprzejdzie, i `Err` z `String` w Å›rodku, gdy test zawiedzie.\n\nPisanie testÃ³w w taki sposÃ³b, aby zwracaÅ‚y `Result<T, E>`, pozwala na\nuÅ¼ywanie operatora znaku zapytania w ciele testÃ³w, co moÅ¼e byÄ‡ wygodnym\nsposobem pisania testÃ³w, ktÃ³re powinny zakoÅ„czyÄ‡ siÄ™ niepowodzeniem, jeÅ›li\njakakolwiek operacja w ich obrÄ™bie zwrÃ³ci wariant `Err`.\n\nNie moÅ¼esz uÅ¼ywaÄ‡ adnotacji `#[should_panic]` w testach, ktÃ³re uÅ¼ywajÄ…\n`Result<T, E>`. Aby potwierdziÄ‡, Å¼e operacja zwraca wariant `Err`, *nie* uÅ¼ywaj\noperatora znaku zapytania na wartoÅ›ci `Result<T, E>`. Zamiast tego uÅ¼yj\n`assert!(value.is_err())`.\n\nTeraz, gdy znasz kilka sposobÃ³w pisania testÃ³w, przyjrzyjmy siÄ™, co dzieje siÄ™,\ngdy uruchamiamy nasze testy i zbadajmy rÃ³Å¼ne opcje, ktÃ³rych moÅ¼emy uÅ¼yÄ‡ z\n`cargo test`.\n\n[ignoring]: ch11-02-running-tests.html#ignoring-tests-unless-specifically-requested\n[subset]: ch11-02-running-tests.html#running-a-subset-of-tests-by-name\n[bench]: ../unstable-book/library-features/test.html\n[doc-comments]: ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests\n[controlling-how-tests-are-run]: ch11-02-running-tests.html#controlling-how-tests-are-run\n[paths-for-referring-to-an-item-in-the-module-tree]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html\n[derivable-traits]: appendix-03-derivable-traits.html\n[concatenating]: ch08-02-strings.html#concatenating-with--or-format",
        "chapter_title": "Jak pisaÄ‡ testy"
    },
    {
        "file_path": "ch12-03-improving-error-handling-and-modularity.md",
        "content": "## Refaktoryzacja w celu poprawy moduÅ‚owoÅ›ci i obsÅ‚ugi bÅ‚Ä™dÃ³w\n\nAby ulepszyÄ‡ nasz program, naprawimy cztery problemy zwiÄ…zane ze strukturÄ…\nprogramu i sposobem obsÅ‚ugi potencjalnych bÅ‚Ä™dÃ³w. Po pierwsze, nasza funkcja\n`main` wykonuje teraz dwa zadania: parsuje argumenty i odczytuje pliki. W\nmiarÄ™ rozwoju programu liczba oddzielnych zadaÅ„, ktÃ³re obsÅ‚uguje funkcja\n`main`, bÄ™dzie rosÅ‚a. Gdy funkcja zyskuje nowe obowiÄ…zki, staje siÄ™ trudniejsza\ndo zrozumienia, trudniejsza do testowania i trudniejsza do zmiany bez\nuszkodzenia jednej z jej czÄ™Å›ci. Najlepiej jest oddzieliÄ‡ funkcjonalnoÅ›Ä‡,\ntak aby kaÅ¼da funkcja byÅ‚a odpowiedzialna za jedno zadanie.\n\nTen problem wiÄ…Å¼e siÄ™ rÃ³wnieÅ¼ z drugim problemem: chociaÅ¼ `query` i\n`file_path` sÄ… zmiennymi konfiguracyjnymi naszego programu, zmienne takie jak\n`contents` sÄ… uÅ¼ywane do wykonywania logiki programu. Im dÅ‚uÅ¼szy staje siÄ™\n`main`, tym wiÄ™cej zmiennych bÄ™dziemy musieli wprowadziÄ‡ do zakresu; im wiÄ™cej\nzmiennych mamy w zakresie, tym trudniej bÄ™dzie Å›ledziÄ‡ cel kaÅ¼dej z nich.\nNajlepiej jest pogrupowaÄ‡ zmienne konfiguracyjne w jednÄ… strukturÄ™, aby ich cel\nbyÅ‚ jasny.\n\nTrzeci problem polega na tym, Å¼e uÅ¼yliÅ›my `expect` do wyÅ›wietlenia\nkomunikatu o bÅ‚Ä™dzie, gdy odczyt pliku nie powiÃ³dÅ‚ siÄ™, ale komunikat o\nbÅ‚Ä™dzie po prostu wyÅ›wietla `Should have been able to read the file`. Odczyt\npliku moÅ¼e zakoÅ„czyÄ‡ siÄ™ niepowodzeniem na wiele sposobÃ³w: na przykÅ‚ad plik\nmoÅ¼e brakowaÄ‡ lub moÅ¼emy nie mieÄ‡ uprawnieÅ„ do jego otwarcia. Obecnie,\nniezaleÅ¼nie od sytuacji, wyÅ›wietlalibyÅ›my ten sam komunikat o bÅ‚Ä™dzie dla\nwszystkiego, co nie dostarczyÅ‚oby uÅ¼ytkownikowi Å¼adnych informacji!\n\nPo czwarte, uÅ¼ywamy `expect` do obsÅ‚ugi bÅ‚Ä™du, a jeÅ›li uÅ¼ytkownik uruchomi nasz\nprogram bez podania wystarczajÄ…cej liczby argumentÃ³w, otrzyma bÅ‚Ä…d `index out\nof bounds` z Rusta, ktÃ³ry nie wyjaÅ›nia jasno problemu. ByÅ‚oby najlepiej,\ngdyby caÅ‚y kod obsÅ‚ugi bÅ‚Ä™dÃ³w znajdowaÅ‚ siÄ™ w jednym miejscu, tak aby przyszli\nutrzymujÄ…cy mieli tylko jedno miejsce do konsultowania kodu, jeÅ›li logika\nobsÅ‚ugi bÅ‚Ä™dÃ³w wymagaÅ‚aby zmiany. Posiadanie caÅ‚ego kodu obsÅ‚ugi bÅ‚Ä™dÃ³w w\njednym miejscu zapewni rÃ³wnieÅ¼, Å¼e wyÅ›wietlamy komunikaty, ktÃ³re bÄ™dÄ…\nzrozumiaÅ‚e dla naszych uÅ¼ytkownikÃ³w koÅ„cowych.\n\nRozwiÄ…Å¼emy te cztery problemy, refaktoryzujÄ…c nasz projekt.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"separation-of-concerns-for-binary-projects\"></a>\n\n### Rozdzielanie odpowiedzialnoÅ›ci w projektach binarnych\n\nProblem organizacyjny polegajÄ…cy na przypisywaniu funkcji `main`\n odpowiedzialnoÅ›ci za wiele zadaÅ„ jest powszechny w wielu projektach\n binarnych. W rezultacie wielu programistÃ³w Rust uwaÅ¼a za przydatne\n rozdzielenie rÃ³Å¼nych aspektÃ³w programu binarnego, gdy funkcja `main` staje\n siÄ™ zbyt duÅ¼a. Proces ten obejmuje nastÄ™pujÄ…ce kroki:\n\n* Podziel program na pliki *main.rs* i *lib.rs* i przenieÅ› logikÄ™ programu\n  do *lib.rs*.\n* DopÃ³ki logika parsowania wiersza poleceÅ„ jest maÅ‚a, moÅ¼e pozostaÄ‡ w\n  funkcji `main`.\n* Kiedy logika parsowania wiersza poleceÅ„ zaczyna siÄ™ komplikowaÄ‡, wyodrÄ™bnij\n  jÄ… z funkcji `main` do innych funkcji lub typÃ³w.\n\nObowiÄ…zki, ktÃ³re pozostajÄ… w funkcji `main` po tym procesie, powinny byÄ‡\nograniczone do nastÄ™pujÄ…cych:\n\n* WywoÅ‚anie logiki parsowania wiersza poleceÅ„ z wartoÅ›ciami argumentÃ³w\n* Ustawienie wszelkich innych konfiguracji\n* WywoÅ‚anie funkcji `run` w *lib.rs*\n* ObsÅ‚uga bÅ‚Ä™du, jeÅ›li `run` zwrÃ³ci bÅ‚Ä…d\n\nTen wzorzec polega na rozdzieleniu odpowiedzialnoÅ›ci: *main.rs* zajmuje siÄ™\nuruchamianiem programu, a *lib.rs* obsÅ‚uguje caÅ‚Ä… logikÄ™ bieÅ¼Ä…cego zadania.\nPoniewaÅ¼ nie moÅ¼na bezpoÅ›rednio testowaÄ‡ funkcji `main`, ta struktura pozwala\ntestowaÄ‡ caÅ‚Ä… logikÄ™ programu, przenoszÄ…c jÄ… poza funkcjÄ™ `main`. Kod,\nktÃ³ry pozostaje w funkcji `main`, bÄ™dzie wystarczajÄ…co maÅ‚y, aby zweryfikowaÄ‡\njego poprawnoÅ›Ä‡ poprzez odczytanie. PrzerÃ³bmy nasz program, postÄ™pujÄ…c\nzgodnie z tym procesem.\n\n#### WyodrÄ™bnianie parsera argumentÃ³w\n\nWyodrÄ™bnimy funkcjonalnoÅ›Ä‡ parsowania argumentÃ³w do funkcji, ktÃ³rÄ… wywoÅ‚a `main`.\nListing 12-5 pokazuje nowy poczÄ…tek funkcji `main`, ktÃ³ra wywoÅ‚uje nowÄ… funkcjÄ™\n`parse_config`, ktÃ³rÄ… zdefiniujemy w *src/main.rs*.\n\n<figure class=\"listing\" id=\"listing-12-5\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore\n# use std::env;\n# use std::fs;\n# \nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let (query, file_path) = parse_config(&args);\n\n    // --snip--\n# \n#     println!(\"Searching for {query}\");\n#     println!(\"In file {file_path}\");\n# \n#     let contents = fs::read_to_string(file_path)\n#         .expect(\"Should have been able to read the file\");\n# \n#     println!(\"With text:\\n{contents}\");\n}\n\nfn parse_config(args: &[String]) -> (&str, &str) {\n    let query = &args[1];\n    let file_path = &args[2];\n\n    (query, file_path)\n}\n````\n\n<figcaption><a href=\"#listing-12-5\">Listing 12-5</a>: WyodrÄ™bnianie funkcji <code>parse_config</code> z <code>main</code></figcaption>\n</figure>\n\nNadal zbieramy argumenty wiersza poleceÅ„ do wektora, ale zamiast przypisywaÄ‡\nwartoÅ›Ä‡ argumentu pod indeksem 1 do zmiennej `query` i wartoÅ›Ä‡ argumentu pod\nindeksem 2 do zmiennej `file_path` w funkcji `main`, przekazujemy caÅ‚y wektor\ndo funkcji `parse_config`. Funkcja `parse_config` zawiera nastÄ™pnie logikÄ™,\nktÃ³ra okreÅ›la, ktÃ³ry argument trafia do ktÃ³rej zmiennej i przekazuje wartoÅ›ci\nz powrotem do `main`. Nadal tworzymy zmienne `query` i `file_path` w `main`,\nale `main` nie jest juÅ¼ odpowiedzialny za okreÅ›lanie, jak argumenty wiersza\npoleceÅ„ i zmienne odpowiadajÄ… sobie.\n\nTa przerÃ³bka moÅ¼e wydawaÄ‡ siÄ™ przesadna dla naszego maÅ‚ego programu, ale\nrefaktoryzujemy jÄ… maÅ‚ymi, przyrostowymi krokami. Po dokonaniu tej zmiany,\nuruchom program ponownie, aby sprawdziÄ‡, czy parsowanie argumentÃ³w nadal\ndziaÅ‚a. Dobrze jest czÄ™sto sprawdzaÄ‡ postÄ™py, aby pomÃ³c zidentyfikowaÄ‡ przyczynÄ™\nproblemÃ³w, gdy siÄ™ pojawiÄ….\n\n#### Grupowanie wartoÅ›ci konfiguracyjnych\n\nMoÅ¼emy podjÄ…Ä‡ kolejny maÅ‚y krok, aby jeszcze bardziej ulepszyÄ‡ funkcjÄ™\n`parse_config`. W tej chwili zwracamy krotkÄ™, ale natychmiast rozbijamy tÄ™\nkrotkÄ™ ponownie na pojedyncze czÄ™Å›ci. Jest to znak, Å¼e byÄ‡ moÅ¼e nie mamy\njeszcze odpowiedniej abstrakcji.\n\nInny wskaÅºnik, ktÃ³ry pokazuje, Å¼e jest miejsce na ulepszenia, to czÄ™Å›Ä‡ `config`\nw `parse_config`, co implikuje, Å¼e dwie zwracane wartoÅ›ci sÄ… powiÄ…zane i obie\nsÄ… czÄ™Å›ciÄ… jednej wartoÅ›ci konfiguracyjnej. Obecnie nie przekazujemy tego\nznaczenia w strukturze danych inaczej niÅ¼ poprzez grupowanie dwÃ³ch wartoÅ›ci w\nkrotkÄ™; zamiast tego umieÅ›cimy dwie wartoÅ›ci w jednej strukturze i nadamy\nkaÅ¼demu z pÃ³l struktury znaczÄ…cÄ… nazwÄ™. Zrobienie tego uÅ‚atwi przyszÅ‚ym\nutrzymujÄ…cym ten kod zrozumienie, jak rÃ³Å¼ne wartoÅ›ci sÄ… ze sobÄ… powiÄ…zane i\njaki jest ich cel.\n\nListing 12-6 pokazuje ulepszenia funkcji `parse_config`.\n\n<figure class=\"listing\" id=\"listing-12-6\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,should_panic,noplayground\n# use std::env;\n# use std::fs;\n# \nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let config = parse_config(&args);\n\n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    let contents = fs::read_to_string(config.file_path)\n        .expect(\"Should have been able to read the file\");\n\n    // --snip--\n# \n#     println!(\"With text:\\n{contents}\");\n}\n\nstruct Config {\n    query: String,\n    file_path: String,\n}\n\nfn parse_config(args: &[String]) -> Config {\n    let query = args[1].clone();\n    let file_path = args[2].clone();\n\n    Config { query, file_path }\n}\n````\n\n<figcaption><a href=\"#listing-12-6\">Listing 12-6</a>: Refaktoryzacja <code>parse_config</code> w celu zwrÃ³cenia instancji struktury <code>Config</code></figcaption>\n</figure>\n\nDodaliÅ›my strukturÄ™ o nazwie `Config` z polami `query` i `file_path`. Sygnatura\n`parse_config` wskazuje teraz, Å¼e zwraca wartoÅ›Ä‡ `Config`. W ciele `parse_config`,\ngdzie wczeÅ›niej zwracaliÅ›my wycinki stringÃ³w, ktÃ³re odwoÅ‚ywaÅ‚y siÄ™ do wartoÅ›ci\n`String` w `args`, teraz definiujemy `Config` tak, aby zawieraÅ‚ wÅ‚asne wartoÅ›ci\n`String`. Zmienna `args` w `main` jest wÅ‚aÅ›cicielem wartoÅ›ci argumentÃ³w i tylko\npozwala funkcji `parse_config` je poÅ¼yczyÄ‡, co oznacza, Å¼e naruszylibyÅ›my zasady\npoÅ¼yczania Rusta, gdyby `Config` prÃ³bowaÅ‚o przejÄ…Ä‡ wÅ‚asnoÅ›Ä‡ wartoÅ›ci w `args`.\n\nIstnieje wiele sposobÃ³w zarzÄ…dzania danymi `String`; najÅ‚atwiejsza, choÄ‡\nnieco nieefektywna, droga to wywoÅ‚anie metody `clone` na wartoÅ›ciach. Spowoduje\nto peÅ‚nÄ… kopiÄ™ danych dla instancji `Config`, co zajmuje wiÄ™cej czasu i pamiÄ™ci\nniÅ¼ przechowywanie referencji do danych ciÄ…gu znakÃ³w. Jednak klonowanie danych\nrÃ³wnieÅ¼ sprawia, Å¼e nasz kod jest bardzo prosty, poniewaÅ¼ nie musimy\nzarzÄ…dzaÄ‡ czasami Å¼ycia referencji; w tych okolicznoÅ›ciach, rezygnacja z\nnieco wydajnoÅ›ci na rzecz prostoty jest opÅ‚acalnym kompromisem.\n\n<section class=\"note\" aria-role=\"note\">\n\n\n\n### Kompromisy zwiÄ…zane z uÅ¼ywaniem `clone`\n\nWielu programistÃ³w Rusta ma tendencjÄ™ do unikania uÅ¼ywania `clone` do\nnaprawiania problemÃ³w z wÅ‚asnoÅ›ciÄ… ze wzglÄ™du na jego koszt wykonawczy.\nW [Rozdziale 13][ch13]<!-- ignore --> dowiesz siÄ™, jak uÅ¼ywaÄ‡ bardziej\nefektywnych metod w tego typu sytuacjach. Ale na razie w porzÄ…dku jest\nkopiowanie kilku ciÄ…gÃ³w znakÃ³w, aby kontynuowaÄ‡ postÄ™p, poniewaÅ¼ te kopie\nzrobisz tylko raz, a Å›cieÅ¼ka pliku i ciÄ…g zapytania sÄ… bardzo maÅ‚e. Lepiej\nmieÄ‡ dziaÅ‚ajÄ…cy program, ktÃ³ry jest nieco nieefektywny, niÅ¼ prÃ³bowaÄ‡\nhiperoptymalizowaÄ‡ kod za pierwszym razem. W miarÄ™ zdobywania doÅ›wiadczenia\nz Rustem, Å‚atwiej bÄ™dzie zaczÄ…Ä‡ od najbardziej efektywnego rozwiÄ…zania, ale na\nrazie, uÅ¼ywanie `clone` jest caÅ‚kowicie akceptowalne.\n\n</section>\n\nZaktualizowaliÅ›my `main` tak, aby umieszczaÅ‚ instancjÄ™ `Config` zwrÃ³conÄ… przez\n`parse_config` w zmiennej o nazwie `config`, i zaktualizowaliÅ›my kod, ktÃ³ry\nwczeÅ›niej uÅ¼ywaÅ‚ oddzielnych zmiennych `query` i `file_path`, tak aby teraz\nuÅ¼ywaÅ‚ pÃ³l struktury `Config`.\n\nTeraz nasz kod jaÅ›niej przekazuje, Å¼e `query` i `file_path` sÄ… ze sobÄ…\npowiÄ…zane i Å¼e ich celem jest konfigurowanie dziaÅ‚ania programu. KaÅ¼dy kod,\nktÃ³ry uÅ¼ywa tych wartoÅ›ci, wie, Å¼e znajdzie je w instancji `config` w polach\nnazwanych zgodnie z ich przeznaczeniem.\n\n#### Tworzenie konstruktora dla `Config`\n\nDo tej pory wyodrÄ™bniliÅ›my logikÄ™ odpowiedzialnÄ… za parsowanie argumentÃ³w\nwiersza poleceÅ„ z `main` i umieÅ›ciliÅ›my jÄ… w funkcji `parse_config`. DziÄ™ki\ntemu zauwaÅ¼yliÅ›my, Å¼e wartoÅ›ci `query` i `file_path` byÅ‚y ze sobÄ… powiÄ…zane,\ni ten zwiÄ…zek powinien byÄ‡ przekazany w naszym kodzie. NastÄ™pnie dodaliÅ›my\nstrukturÄ™ `Config`, aby nazwaÄ‡ powiÄ…zane przeznaczenie `query` i `file_path`\noraz mÃ³c zwracaÄ‡ nazwy wartoÅ›ci jako nazwy pÃ³l struktury z funkcji\n`parse_config`.\n\nSkoro teraz celem funkcji `parse_config` jest stworzenie instancji `Config`,\nmoÅ¼emy zmieniÄ‡ `parse_config` z prostej funkcji na funkcjÄ™ o nazwie `new`,\nktÃ³ra jest skojarzona ze strukturÄ… `Config`. Ta zmiana sprawi, Å¼e kod bÄ™dzie\nbardziej idiomatyczny. MoÅ¼emy tworzyÄ‡ instancje typÃ³w w standardowej bibliotece,\ntakich jak `String`, wywoÅ‚ujÄ…c `String::new`. Podobnie, zmieniajÄ…c\n`parse_config` na funkcjÄ™ `new` skojarzonÄ… z `Config`, bÄ™dziemy mogli tworzyÄ‡\ninstancje `Config`, wywoÅ‚ujÄ…c `Config::new`. Listing 12-7 pokazuje zmiany, ktÃ³re\nmusimy wprowadziÄ‡.\n\n<figure class=\"listing\" id=\"listing-12-7\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,should_panic,noplayground\n# use std::env;\n# use std::fs;\n# \nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let config = Config::new(&args);\n# \n#     println!(\"Searching for {}\", config.query);\n#     println!(\"In file {}\", config.file_path);\n# \n#     let contents = fs::read_to_string(config.file_path)\n#         .expect(\"Should have been able to read the file\");\n# \n#     println!(\"With text:\\n{contents}\");\n\n    // --snip--\n}\n\n// --snip--\n\n# struct Config {\n#     query: String,\n#     file_path: String,\n# }\n# \nimpl Config {\n    fn new(args: &[String]) -> Config {\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Config { query, file_path }\n    }\n}\n````\n\n<figcaption><a href=\"#listing-12-7\">Listing 12-7</a>: Zmiana <code>parse_config</code> na <code>Config::new</code></figcaption>\n</figure>\n\nZaktualizowaliÅ›my `main`, gdzie wywoÅ‚ywaliÅ›my `parse_config`, aby zamiast tego\nwywoÅ‚ywaÄ‡ `Config::new`. ZmieniliÅ›my nazwÄ™ `parse_config` na `new` i przenieÅ›liÅ›my\njÄ… do bloku `impl`, co wiÄ…Å¼e funkcjÄ™ `new` z `Config`. SprÃ³buj ponownie\nskompilowaÄ‡ ten kod, aby upewniÄ‡ siÄ™, Å¼e dziaÅ‚a.\n\n### Naprawa obsÅ‚ugi bÅ‚Ä™dÃ³w\n\nTeraz zajmiemy siÄ™ naprawÄ… obsÅ‚ugi bÅ‚Ä™dÃ³w. Przypomnijmy, Å¼e prÃ³ba uzyskania\ndostÄ™pu do wartoÅ›ci w wektorze `args` pod indeksem 1 lub 2 spowoduje panikÄ™\nprogramu, jeÅ›li wektor zawiera mniej niÅ¼ trzy elementy. SprÃ³buj uruchomiÄ‡\nprogram bez Å¼adnych argumentÃ³w; bÄ™dzie to wyglÄ…daÅ‚o tak:\n\n````console\n$ cargo run\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep`\n\nthread 'main' panicked at src/main.rs:27:21:\nindex out of bounds: the len is 1 but the index is 1\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n````\n\nLinia `index out of bounds: the len is 1 but the index is 1` to komunikat o\nbÅ‚Ä™dzie przeznaczony dla programistÃ³w. Nie pomoÅ¼e on naszym uÅ¼ytkownikom\nkoÅ„cowym zrozumieÄ‡, co powinni zrobiÄ‡ zamiast tego. Naprawmy to teraz.\n\n#### Ulepszanie komunikatu o bÅ‚Ä™dzie\n\nW Listingu 12-8 dodajemy w funkcji `new` sprawdzenie, czy wycinek jest\nwystarczajÄ…co dÅ‚ugi, zanim uzyska dostÄ™p do indeksu 1 i 2. JeÅ›li wycinek nie\njest wystarczajÄ…co dÅ‚ugi, program panikuje i wyÅ›wietla lepszy komunikat o bÅ‚Ä™dzie.\n\n<figure class=\"listing\" id=\"listing-12-8\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore\n# use std::env;\n# use std::fs;\n# \n# fn main() {\n#     let args: Vec<String> = env::args().collect();\n# \n#     let config = Config::new(&args);\n# \n#     println!(\"Searching for {}\", config.query);\n#     println!(\"In file {}\", config.file_path);\n# \n#     let contents = fs::read_to_string(config.file_path)\n#         .expect(\"Should have been able to read the file\");\n# \n#     println!(\"With text:\\n{contents}\");\n# }\n# \n# struct Config {\n#     query: String,\n#     file_path: String,\n# }\n# \n# impl Config {\n    // --snip--\n    fn new(args: &[String]) -> Config {\n        if args.len() < 3 {\n            panic!(\"not enough arguments\");\n        }\n        // --snip--\n# \n#         let query = args[1].clone();\n#         let file_path = args[2].clone();\n# \n#         Config { query, file_path }\n#     }\n# }\n````\n\n<figcaption><a href=\"#listing-12-8\">Listing 12-8</a>: Dodawanie sprawdzenia liczby argumentÃ³w</figcaption>\n</figure>\n\nTen kod jest podobny do [funkcji `Guess::new`, ktÃ³rÄ… napisaliÅ›my w Listingu\n9-13][ch9-custom-types]<!-- ignore -->, gdzie wywoÅ‚aliÅ›my `panic!`, gdy\nargument `value` byÅ‚ poza zakresem prawidÅ‚owych wartoÅ›ci. Zamiast sprawdzaÄ‡\nzakres wartoÅ›ci tutaj, sprawdzamy, czy dÅ‚ugoÅ›Ä‡ `args` wynosi co najmniej `3`,\na reszta funkcji moÅ¼e dziaÅ‚aÄ‡, zakÅ‚adajÄ…c, Å¼e ten warunek zostaÅ‚ speÅ‚niony.\nJeÅ›li `args` ma mniej niÅ¼ trzy elementy, ten warunek bÄ™dzie `true` i wywoÅ‚amy\nmakro `panic!`, aby natychmiast zakoÅ„czyÄ‡ program.\n\nZ tymi dodatkowymi kilkoma liniami kodu w `new`, uruchommy program ponownie bez\nÅ¼adnych argumentÃ³w, aby zobaczyÄ‡, jak teraz wyglÄ…da bÅ‚Ä…d:\n\n````console\n$ cargo run\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep`\n\nthread 'main' panicked at src/main.rs:26:13:\nnot enough arguments\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n````\n\nTen wynik jest lepszy: mamy teraz rozsÄ…dny komunikat o bÅ‚Ä™dzie. Mamy jednak\ntakÅ¼e zbÄ™dne informacje, ktÃ³rych nie chcemy przekazywaÄ‡ naszym uÅ¼ytkownikom.\nByÄ‡ moÅ¼e technika, ktÃ³rej uÅ¼yliÅ›my w Listingu 9-13, nie jest tutaj najlepsza:\nwywoÅ‚anie `panic!` jest bardziej odpowiednie dla problemu programistycznego niÅ¼\nproblemu z uÅ¼yciem, [jak omÃ³wiono w Rozdziale\n9][ch9-error-guidelines]<!-- ignore -->. Zamiast tego, uÅ¼yjemy innej\ntechniki, o ktÃ³rej dowiedziaÅ‚eÅ› siÄ™ w Rozdziale 9 â€“ [zwracania\n`Result`][ch9-result]<!-- ignore -->, ktÃ³ry wskazuje na sukces lub bÅ‚Ä…d.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"returning-a-result-from-new-instead-of-calling-panic\"></a>\n\n#### Zwracanie `Result` zamiast wywoÅ‚ywania `panic!`\n\nZamiast tego moÅ¼emy zwrÃ³ciÄ‡ wartoÅ›Ä‡ `Result`, ktÃ³ra bÄ™dzie zawieraÅ‚a instancjÄ™\n`Config` w przypadku sukcesu i bÄ™dzie opisywaÄ‡ problem w przypadku bÅ‚Ä™du.\nZmienimy rÃ³wnieÅ¼ nazwÄ™ funkcji z `new` na `build`, poniewaÅ¼ wielu\nprogramistÃ³w oczekuje, Å¼e funkcje `new` nigdy nie zawiodÄ…. Kiedy `Config::build`\nkomunikuje siÄ™ z `main`, moÅ¼emy uÅ¼yÄ‡ typu `Result`, aby zasygnalizowaÄ‡,\nÅ¼e wystÄ…piÅ‚ problem. NastÄ™pnie moÅ¼emy zmieniÄ‡ `main`, aby przeksztaÅ‚ciÄ‡\nwariant `Err` w bardziej praktyczny bÅ‚Ä…d dla naszych uÅ¼ytkownikÃ³w, bez\notaczajÄ…cego tekstu o `thread 'main'` i `RUST_BACKTRACE`, ktÃ³re powoduje\nwywoÅ‚anie `panic!`.\n\nListing 12-9 pokazuje zmiany, ktÃ³re musimy wprowadziÄ‡ w wartoÅ›ci zwracanej\nfunkcji, ktÃ³rÄ… teraz nazywamy `Config::build`, oraz w ciele funkcji\npotrzebnym do zwrÃ³cenia `Result`. ZauwaÅ¼, Å¼e to siÄ™ nie skompiluje, dopÃ³ki nie\nzaktualizujemy rÃ³wnieÅ¼ `main`, co zrobimy w nastÄ™pnym listingu.\n\n<figure class=\"listing\" id=\"listing-12-9\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore,does_not_compile\n# use std::env;\n# use std::fs;\n# \n# fn main() {\n#     let args: Vec<String> = env::args().collect();\n# \n#     let config = Config::new(&args);\n# \n#     println!(\"Searching for {}\", config.query);\n#     println!(\"In file {}\", config.file_path);\n# \n#     let contents = fs::read_to_string(config.file_path)\n#         .expect(\"Should have been able to read the file\");\n# \n#     println!(\"With text:\\n{contents}\");\n# }\n# \n# struct Config {\n#     query: String,\n#     file_path: String,\n# }\n# \nimpl Config {\n    fn build(args: &[String]) -> Result<Config, &'static str> {\n        if args.len() < 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Ok(Config { query, file_path })\n    }\n}\n````\n\n<figcaption><a href=\"#listing-12-9\">Listing 12-9</a>: Zwracanie <code>Result</code> z <code>Config::build</code></figcaption>\n</figure>\n\nNasza funkcja `build` zwraca `Result` z instancjÄ… `Config` w przypadku\npomyÅ›lnoÅ›ci i literaÅ‚em ciÄ…gu znakÃ³w w przypadku bÅ‚Ä™du. Nasze wartoÅ›ci bÅ‚Ä™dÃ³w\nbÄ™dÄ… zawsze literaÅ‚ami ciÄ…gu znakÃ³w, ktÃ³re majÄ… czas Å¼ycia `'static`.\n\nDokonaliÅ›my dwÃ³ch zmian w ciele funkcji: zamiast wywoÅ‚ywaÄ‡ `panic!` gdy\nuÅ¼ytkownik nie przekaÅ¼e wystarczajÄ…cej liczby argumentÃ³w, teraz zwracamy\nwartoÅ›Ä‡ `Err`, a wartoÅ›Ä‡ zwracanÄ… `Config` opakowaliÅ›my w `Ok`. Te zmiany\nsprawiajÄ…, Å¼e funkcja jest zgodna z nowym podpisem typu.\n\nZwracanie wartoÅ›ci `Err` z `Config::build` pozwala funkcji `main` obsÅ‚uÅ¼yÄ‡\nwartoÅ›Ä‡ `Result` zwrÃ³conÄ… z funkcji `build` i czysto zakoÅ„czyÄ‡ proces w\nprzypadku bÅ‚Ä™du.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"calling-confignew-and-handling-errors\"></a>\n\n#### WywoÅ‚ywanie `Config::build` i obsÅ‚uga bÅ‚Ä™dÃ³w\n\nAby obsÅ‚uÅ¼yÄ‡ przypadek bÅ‚Ä™du i wyÅ›wietliÄ‡ komunikat zrozumiaÅ‚y dla uÅ¼ytkownika,\nmusimy zaktualizowaÄ‡ `main` w celu obsÅ‚ugi `Result` zwracanego przez\n`Config::build`, jak pokazano w Listingu 12-10. Przejmiemy rÃ³wnieÅ¼\nodpowiedzialnoÅ›Ä‡ za zakoÅ„czenie narzÄ™dzia wiersza poleceÅ„ z niezerowym kodem\nbÅ‚Ä™du zamiast `panic!` i zaimplementujemy to rÄ™cznie. Niezerowy status\nwyjÅ›cia jest konwencjÄ… sygnalizujÄ…cÄ… procesowi, ktÃ³ry wywoÅ‚aÅ‚ nasz program, Å¼e\nprogram zakoÅ„czyÅ‚ dziaÅ‚anie ze stanem bÅ‚Ä™du.\n\n<figure class=\"listing\" id=\"listing-12-10\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore\n# use std::env;\n# use std::fs;\nuse std::process;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let config = Config::build(&args).unwrap_or_else(|err| {\n        println!(\"Problem parsing arguments: {err}\");\n        process::exit(1);\n    });\n\n    // --snip--\n# \n#     println!(\"Searching for {}\", config.query);\n#     println!(\"In file {}\", config.file_path);\n# \n#     let contents = fs::read_to_string(config.file_path)\n#         .expect(\"Should have been able to read the file\");\n# \n#     println!(\"With text:\\n{contents}\");\n# }\n# \n# struct Config {\n#     query: String,\n#     file_path: String,\n# }\n# \n# impl Config {\n#     fn build(args: &[String]) -> Result<Config, &'static str> {\n#         if args.len() < 3 {\n#             return Err(\"not enough arguments\");\n#         }\n# \n#         let query = args[1].clone();\n#         let file_path = args[2].clone();\n# \n#         Ok(Config { query, file_path })\n#     }\n# }\n````\n\n<figcaption><a href=\"#listing-12-10\">Listing 12-10</a>: WyjÅ›cie z kodem bÅ‚Ä™du, jeÅ›li budowanie <code>Config</code> zawiedzie</figcaption>\n</figure>\n\nW tym listingu uÅ¼yliÅ›my metody, ktÃ³rej jeszcze szczegÃ³Å‚owo nie omÃ³wiliÅ›my:\n`unwrap_or_else`, ktÃ³ra jest zdefiniowana w `Result<T, E>` przez standardowÄ…\nbibliotekÄ™. UÅ¼ycie `unwrap_or_else` pozwala nam zdefiniowaÄ‡ niestandardowÄ…,\nnie-`panic!` obsÅ‚ugÄ™ bÅ‚Ä™dÃ³w. JeÅ›li `Result` jest wartoÅ›ciÄ… `Ok`, zachowanie\ntej metody jest podobne do `unwrap`: zwraca wewnÄ™trznÄ… wartoÅ›Ä‡, ktÃ³rÄ… opakowuje\n`Ok`. Jednak jeÅ›li wartoÅ›Ä‡ jest wartoÅ›ciÄ… `Err`, ta metoda wywoÅ‚uje kod w\nzamkniÄ™ciu, ktÃ³re jest anonimowÄ… funkcjÄ…, ktÃ³rÄ… definiujemy i przekazujemy jako\nargument do `unwrap_or_else`. ZamkniÄ™cia omÃ³wimy bardziej szczegÃ³Å‚owo w\n[Rozdziale 13][ch13]<!-- ignore -->. Na razie wystarczy wiedzieÄ‡, Å¼e\n`unwrap_or_else` przekaÅ¼e wewnÄ™trznÄ… wartoÅ›Ä‡ `Err`, ktÃ³ra w tym przypadku jest\nstatycznym ciÄ…giem znakÃ³w `\"not enough arguments\"`, ktÃ³ry dodaliÅ›my w Listingu\n12-9, do naszego zamkniÄ™cia w argumencie `err`, ktÃ³ry pojawia siÄ™ miÄ™dzy\npionowymi kreskami. Kod w zamkniÄ™ciu moÅ¼e nastÄ™pnie uÅ¼yÄ‡ wartoÅ›ci `err`, gdy\nbÄ™dzie dziaÅ‚aÅ‚.\n\nDodaliÅ›my nowÄ… liniÄ™ `use`, aby wprowadziÄ‡ `process` ze standardowej biblioteki\ndo zakresu. Kod w zamkniÄ™ciu, ktÃ³ry zostanie uruchomiony w przypadku bÅ‚Ä™du,\nskÅ‚ada siÄ™ tylko z dwÃ³ch linii: wyÅ›wietlamy `err`, a nastÄ™pnie wywoÅ‚ujemy\n`process::exit`. Funkcja `process::exit` natychmiast zatrzyma program i zwrÃ³ci\nliczbÄ™, ktÃ³ra zostaÅ‚a przekazana jako kod statusu wyjÅ›cia. Jest to podobne do\nobsÅ‚ugi opartej na `panic!`, ktÃ³rej uÅ¼yliÅ›my w Listingu 12-8, ale nie\notrzymujemy juÅ¼ wszystkich dodatkowych danych wyjÅ›ciowych. SprÃ³bujmy:\n\n````console\n$ cargo run\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s\n     Running `target/debug/minigrep`\nProblem parsing arguments: not enough arguments\n````\n\nÅšwietnie! Ten wynik jest znacznie bardziej przyjazny dla naszych uÅ¼ytkownikÃ³w.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"extracting-logic-from-the-main-function\"></a>\n\n### WyodrÄ™bnianie logiki z funkcji `main`\n\nTeraz, gdy zakoÅ„czyliÅ›my refaktoryzacjÄ™ parsowania konfiguracji, zajmijmy siÄ™\nlogikÄ… programu. Jak stwierdziliÅ›my w sekcji [â€Rozdzielanie odpowiedzialnoÅ›ci w\nprojektach binarnychâ€](#separation-of-concerns-for-binary-projects)<!--\nignore -->, wyodrÄ™bnimy funkcjÄ™ o nazwie `run`, ktÃ³ra bÄ™dzie zawieraÅ‚a caÅ‚Ä…\nlogikÄ™ znajdujÄ…cÄ… siÄ™ obecnie w funkcji `main`, niezwiÄ…zanÄ… z konfigurowaniem\nani obsÅ‚ugÄ… bÅ‚Ä™dÃ³w. Po zakoÅ„czeniu funkcja `main` bÄ™dzie zwiÄ™zÅ‚a i Å‚atwa do\nweryfikacji poprzez inspekcjÄ™, a my bÄ™dziemy mogli pisaÄ‡ testy dla caÅ‚ej\npPozostaÅ‚ej logiki.\n\nListing 12-11 pokazuje niewielkÄ…, przyrostowÄ… poprawÄ™ w wyodrÄ™bnianiu funkcji\n`run`.\n\n<figure class=\"listing\" id=\"listing-12-11\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore\n# use std::env;\n# use std::fs;\n# use std::process;\n# \nfn main() {\n    // --snip--\n\n#     let args: Vec<String> = env::args().collect();\n# \n#     let config = Config::build(&args).unwrap_or_else(|err| {\n#         println!(\"Problem parsing arguments: {err}\");\n#         process::exit(1);\n#     });\n# \n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    run(config);\n}\n\nfn run(config: Config) {\n    let contents = fs::read_to_string(config.file_path)\n        .expect(\"Should have been able to read the file\");\n\n    println!(\"With text:\\n{contents}\");\n}\n\n// --snip--\n# \n# struct Config {\n#     query: String,\n#     file_path: String,\n# }\n# \n# impl Config {\n#     fn build(args: &[String]) -> Result<Config, &'static str> {\n#         if args.len() < 3 {\n#             return Err(\"not enough arguments\");\n#         }\n# \n#         let query = args[1].clone();\n#         let file_path = args[2].clone();\n# \n#         Ok(Config { query, file_path })\n#     }\n# }\n````\n\n<figcaption><a href=\"#listing-12-11\">Listing 12-11</a>: WyodrÄ™bnianie funkcji <code>run</code> zawierajÄ…cej resztÄ™ logiki programu</figcaption>\n</figure>\n\nFunkcja `run` zawiera teraz caÅ‚Ä… pozostaÅ‚Ä… logikÄ™ z `main`, poczynajÄ…c od\næ¨‘odczytu pliku. Funkcja `run` przyjmuje instancjÄ™ `Config` jako argument.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"returning-errors-from-the-run-function\"></a>\n\n#### Zwracanie bÅ‚Ä™dÃ³w z funkcji `run`\n\nPo oddzieleniu pozostaÅ‚ej logiki programu do funkcji `run`, moÅ¼emy poprawiÄ‡\nobsÅ‚ugÄ™ bÅ‚Ä™dÃ³w, tak jak to zrobiliÅ›my z `Config::build` w Listingu 12-9.\nZamiast pozwalaÄ‡ programowi na panikÄ™ poprzez wywoÅ‚anie `expect`, funkcja\n`run` bÄ™dzie zwracaÄ‡ `Result<T, E>`, gdy coÅ› pÃ³jdzie nie tak. Pozwoli to nam\ndalej skonsolidowaÄ‡ logikÄ™ obsÅ‚ugi bÅ‚Ä™dÃ³w w `main` w sposÃ³b przyjazny dla\nuÅ¼ytkownika. Listing 12-12 pokazuje zmiany, ktÃ³re musimy wprowadziÄ‡ w sygnaturze\ni ciele `run`.\n\n<figure class=\"listing\" id=\"listing-12-12\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore\n# use std::env;\n# use std::fs;\n# use std::process;\nuse std::error::Error;\n\n// --snip--\n\n# \n# fn main() {\n#     let args: Vec<String> = env::args().collect();\n# \n#     let config = Config::build(&args).unwrap_or_else(|err| {\n#         println!(\"Problem parsing arguments: {err}\");\n#         process::exit(1);\n#     });\n# \n#     println!(\"Searching for {}\", config.query);\n#     println!(\"In file {}\", config.file_path);\n# \n#     run(config);\n# }\n# \nfn run(config: Config) -> Result<(), Box<dyn Error>> {\n    let contents = fs::read_to_string(config.file_path)?;\n\n    println!(\"With text:\\n{contents}\");\n\n    Ok(())\n}\n# \n# struct Config {\n#     query: String,\n#     file_path: String,\n# }\n# \n# impl Config {\n#     fn build(args: &[String]) -> Result<Config, &'static str> {\n#         if args.len() < 3 {\n#             return Err(\"not enough arguments\");\n#         }\n# \n#         let query = args[1].clone();\n#         let file_path = args[2].clone();\n# \n#         Ok(Config { query, file_path })\n#     }\n# }\n````\n\n<figcaption><a href=\"#listing-12-12\">Listing 12-12</a>: Zmiana funkcji <code>run</code> na zwracajÄ…cÄ… <code>Result</code></figcaption>\n</figure>\n\nWprowadziliÅ›my tu trzy istotne zmiany. Po pierwsze, zmieniliÅ›my typ zwracany\nfunkcji `run` na `Result<(), Box<dyn Error>>`. Ta funkcja wczeÅ›niej zwracaÅ‚a\ntyp jednostkowy `()`, i zachowujemy to jako wartoÅ›Ä‡ zwracanÄ… w przypadku `Ok`.\n\nJako typ bÅ‚Ä™du uÅ¼yliÅ›my obiektu cechy `Box<dyn Error>` (i wprowadziliÅ›my\n`std::error::Error` do zakresu za pomocÄ… instrukcji `use` na gÃ³rze). Obiekty\ncech omÃ³wimy w [Rozdziale 18][ch18]<!-- ignore -->. Na razie wystarczy wiedzieÄ‡,\nÅ¼e `Box<dyn Error>` oznacza, Å¼e funkcja zwrÃ³ci typ, ktÃ³ry implementuje cechÄ™\n`Error`, ale nie musimy okreÅ›laÄ‡, jaki konkretny typ bÄ™dzie miaÅ‚a wartoÅ›Ä‡\nzwracana. Daje nam to elastycznoÅ›Ä‡ w zwracaniu wartoÅ›ci bÅ‚Ä™dÃ³w, ktÃ³re mogÄ… byÄ‡\nrÃ³Å¼nych typÃ³w w rÃ³Å¼nych przypadkach bÅ‚Ä™dÃ³w. SÅ‚owo kluczowe `dyn` to skrÃ³t od\n*dynamiczny*.\n\nPo drugie, usunÄ™liÅ›my wywoÅ‚anie `expect` na rzecz operatora `?`, o czym\nmÃ³wiliÅ›my w [Rozdziale 9][ch9-question-mark]<!-- ignore -->. Zamiast panikowaÄ‡\nw przypadku bÅ‚Ä™du, `?` zwrÃ³ci wartoÅ›Ä‡ bÅ‚Ä™du z bieÅ¼Ä…cej funkcji, aby wywoÅ‚ujÄ…cy\nmÃ³gÅ‚ jÄ… obsÅ‚uÅ¼yÄ‡.\n\nPo trzecie, funkcja `run` zwraca teraz wartoÅ›Ä‡ `Ok` w przypadku sukcesu.\nZadeklarowaliÅ›my typ sukcesu funkcji `run` jako `()` w sygnaturze, co oznacza,\nÅ¼e musimy opakowaÄ‡ wartoÅ›Ä‡ typu jednostkowego w wartoÅ›Ä‡ `Ok`. Ta skÅ‚adnia\n`Ok(())` moÅ¼e na poczÄ…tku wydawaÄ‡ siÄ™ nieco dziwna. Ale uÅ¼ycie `()` w ten sposÃ³b\njest idiomatycznym sposobem wskazania, Å¼e wywoÅ‚ujemy `run` tylko dla jego\nefektÃ³w ubocznych; nie zwraca on wartoÅ›ci, ktÃ³rej potrzebujemy.\n\nKiedy uruchomisz ten kod, skompiluje siÄ™, ale wyÅ›wietli ostrzeÅ¼enie:\n\n````console\n$ cargo run -- the poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\nwarning: unused `Result` that must be used\n  --> src/main.rs:19:5\n   |\n19 |     run(config);\n   |     ^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\n   = note: `#[warn(unused_must_use)]` on by default\nhelp: use `let _ = ...` to ignore the resulting value\n   |\n19 |     let _ = run(config);\n   |     +++++++\n\nwarning: `minigrep` (bin \"minigrep\") generated 1 warning\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.71s\n     Running `target/debug/minigrep the poem.txt`\nSearching for the\nIn file poem.txt\nWith text:\nI'm nobody! Who are you?\nAre you nobody, too?\nThen there's a pair of us - don't tell!\nThey'd banish us, you know.\n\nHow dreary to be somebody!\nHow public, like a frog\nTo tell your name the livelong day\nTo an admiring bog!\n\n````\n\nRust informuje nas, Å¼e nasz kod zignorowaÅ‚ wartoÅ›Ä‡ `Result` i Å¼e wartoÅ›Ä‡\n`Result` moÅ¼e wskazywaÄ‡ na wystÄ…pienie bÅ‚Ä™du. Ale nie sprawdzamy, czy wystÄ…piÅ‚\nbÅ‚Ä…d, a kompilator przypomina nam, Å¼e prawdopodobnie zamierzaliÅ›my umieÅ›ciÄ‡\ntutaj jakiÅ› kod do obsÅ‚ugi bÅ‚Ä™dÃ³w! Naprawmy ten problem teraz.\n\n#### ObsÅ‚uga bÅ‚Ä™dÃ³w zwracanych przez `run` w `main`\n\nSprawdzimy bÅ‚Ä™dy i obsÅ‚uÅ¼ymy je za pomocÄ… techniki podobnej do tej, ktÃ³rej\nuÅ¼yliÅ›my z `Config::build` w Listingu 12-10, ale z niewielkÄ… rÃ³Å¼nicÄ…:\n\n<span class=\"filename\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore\n# use std::env;\n# use std::error::Error;\n# use std::fs;\n# use std::process;\n# \nfn main() {\n    // --snip--\n\n#     let args: Vec<String> = env::args().collect();\n# \n#     let config = Config::build(&args).unwrap_or_else(|err| {\n#         println!(\"Problem parsing arguments: {err}\");\n#         process::exit(1);\n#     });\n# \n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    if let Err(e) = run(config) {\n        println!(\"Application error: {e}\");\n        process::exit(1);\n    }\n}\n# \n# fn run(config: Config) -> Result<(), Box<dyn Error>> {\n#     let contents = fs::read_to_string(config.file_path)?;\n# \n#     println!(\"With text:\\n{contents}\");\n# \n#     Ok(())\n# }\n# \n# struct Config {\n#     query: String,\n#     file_path: String,\n# }\n# \n# impl Config {\n#     fn build(args: &[String]) -> Result<Config, &'static str> {\n#         if args.len() < 3 {\n#             return Err(\"not enough arguments\");\n#         }\n# \n#         let query = args[1].clone();\n#         let file_path = args[2].clone();\n# \n#         Ok(Config { query, file_path })\n#     }\n# }\n````\n\nUÅ¼ywamy `if let` zamiast `unwrap_or_else`, aby sprawdziÄ‡, czy `run` zwraca\nwartoÅ›Ä‡ `Err`, i aby wywoÅ‚aÄ‡ `process::exit(1)`, jeÅ›li tak. Funkcja `run` nie\nzwraca wartoÅ›ci, ktÃ³rÄ… chcemy `unwrap` w taki sam sposÃ³b, w jaki\n`Config::build` zwraca instancjÄ™ `Config`. PoniewaÅ¼ `run` zwraca `()` w\nprzypadku sukcesu, zaleÅ¼y nam tylko na wykryciu bÅ‚Ä™du, wiÄ™c nie potrzebujemy\n`unwrap_or_else`, aby zwrÃ³ciÄ‡ rozpakowanÄ… wartoÅ›Ä‡, ktÃ³ra byÅ‚aby tylko `()`.\n\nCiaÅ‚a funkcji `if let` i `unwrap_or_else` sÄ… w obu przypadkach takie same:\nwyÅ›wietlamy bÅ‚Ä…d i wychodzimy.\n\n### PodziaÅ‚ kodu na bibliotekÄ™ typu \"crate\"\n\nNasz projekt `minigrep` wyglÄ…da do tej pory dobrze! Teraz podzielimy plik\n*src/main.rs* i umieÅ›cimy czÄ™Å›Ä‡ kodu w pliku *src/lib.rs*. W ten sposÃ³b moÅ¼emy\ntestowaÄ‡ kod i mieÄ‡ plik *src/main.rs* z mniejszÄ… odpowiedzialnoÅ›ciÄ….\n\nZdefiniujmy kod odpowiedzialny za wyszukiwanie tekstu w *src/lib.rs* zamiast w\n*src/main.rs*, co pozwoli nam (lub kaÅ¼demu innemu, kto uÅ¼ywa naszej biblioteki\n`minigrep`) wywoÅ‚aÄ‡ funkcjÄ™ wyszukiwania z wiÄ™kszej liczby kontekstÃ³w niÅ¼ nasz\nplik binarny `minigrep`.\n\nNajpierw zdefiniujmy sygnaturÄ™ funkcji `search` w *src/lib.rs*, jak pokazano w\nListingu 12-13, z ciaÅ‚em, ktÃ³re wywoÅ‚uje makro `unimplemented!`. WyjaÅ›nimy\nsygnaturÄ™ bardziej szczegÃ³Å‚owo, gdy wypeÅ‚nimy implementacjÄ™.\n\n<figure class=\"listing\" id=\"listing-12-13\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,ignore,does_not_compile\npub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n    unimplemented!();\n}\n````\n\n<figcaption><a href=\"#listing-12-13\">Listing 12-13</a>: Definiowanie funkcji <code>search</code> w <em>src/lib.rs</em></figcaption>\n</figure>\n\nUÅ¼yliÅ›my sÅ‚owa kluczowego `pub` w definicji funkcji, aby oznaczyÄ‡ `search` jako\nczÄ™Å›Ä‡ publicznego API naszego pakietu bibliotecznego. Mamy teraz pakiet\nbiblioteczny, ktÃ³rego moÅ¼emy uÅ¼ywaÄ‡ z naszego pakietu binarnego i ktÃ³ry moÅ¼emy\ntestowaÄ‡!\n\nTeraz musimy wprowadziÄ‡ kod zdefiniowany w *src/lib.rs* do zakresu pakietu\nbinarnego w *src/main.rs* i wywoÅ‚aÄ‡ go, jak pokazano w Listingu 12-14.\n\n<figure class=\"listing\" id=\"listing-12-14\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore\n# use std::env;\n# use std::error::Error;\n# use std::fs;\n# use std::process;\n# \n// --snip--\nuse minigrep::search;\n\nfn main() {\n    // --snip--\n#     let args: Vec<String> = env::args().collect();\n# \n#     let config = Config::build(&args).unwrap_or_else(|err| {\n#         println!(\"Problem parsing arguments: {err}\");\n#         process::exit(1);\n#     });\n# \n#     if let Err(e) = run(config) {\n#         println!(\"Application error: {e}\");\n#         process::exit(1);\n#     }\n}\n\n// --snip--\n\n# \n# struct Config {\n#     query: String,\n#     file_path: String,\n# }\n# \n# impl Config {\n#     fn build(args: &[String]) -> Result<Config, &'static str> {\n#         if args.len() < 3 {\n#             return Err(\"not enough arguments\");\n#         }\n# \n#         let query = args[1].clone();\n#         let file_path = args[2].clone();\n# \n#         Ok(Config { query, file_path })\n#     }\n# }\n# \nfn run(config: Config) -> Result<(), Box<dyn Error>> {\n    let contents = fs::read_to_string(config.file_path)?;\n\n    for line in search(&config.query, &contents) {\n        println!(\"{line}\");\n    }\n\n    Ok(())\n}\n````\n\n<figcaption><a href=\"#listing-12-14\">Listing 12-14</a>: UÅ¼ycie funkcji <code>search</code> z biblioteki <code>minigrep</code> w <em>src/main.rs</em></figcaption>\n</figure>\n\nDodajemy liniÄ™ `use minigrep::search`, aby wprowadziÄ‡ funkcjÄ™ `search` z\npakietu bibliotecznego do zakresu pakietu binarnego. NastÄ™pnie, w funkcji `run`,\nzamiast wypisywaÄ‡ zawartoÅ›Ä‡ pliku, wywoÅ‚ujemy funkcjÄ™ `search` i przekazujemy\nwartoÅ›Ä‡ `config.query` oraz `contents` jako argumenty. NastÄ™pnie `run` uÅ¼yje\npÄ™tli `for` do wypisania kaÅ¼dej linii zwrÃ³conej przez `search`, ktÃ³ra\ndopasowaÅ‚a zapytanie. To rÃ³wnieÅ¼ dobry moment na usuniÄ™cie wywoÅ‚aÅ„\n`println!` w funkcji `main`, ktÃ³re wyÅ›wietlaÅ‚y zapytanie i Å›cieÅ¼kÄ™ pliku, tak\naby nasz program wyÅ›wietlaÅ‚ tylko wyniki wyszukiwania (jeÅ›li nie wystÄ…piÅ‚y\nbÅ‚Ä™dy).\n\nZauwaÅ¼, Å¼e funkcja wyszukiwania bÄ™dzie zbieraÄ‡ wszystkie wyniki do zwracanego\nwektora, zanim rozpocznie siÄ™ jakiekolwiek drukowanie. Ta implementacja moÅ¼e\nbyÄ‡ powolna w wyÅ›wietlaniu wynikÃ³w podczas wyszukiwania w duÅ¼ych plikach,\nponiewaÅ¼ wyniki nie sÄ… drukowane w miarÄ™ ich znajdowania; omÃ³wimy moÅ¼liwy\nsposÃ³b rozwiÄ…zania tego problemu za pomocÄ… iteratorÃ³w w Rozdziale 13.\n\nUff! To byÅ‚a ciÄ™Å¼ka praca, ale przygotowaliÅ›my siÄ™ na przyszÅ‚oÅ›Ä‡. Teraz o wiele\nÅ‚atwiej jest obsÅ‚ugiwaÄ‡ bÅ‚Ä™dy, a kod uczyniliÅ›my bardziej moduÅ‚owym.\nPrawie caÅ‚a nasza praca bÄ™dzie wykonywana w *src/lib.rs* od teraz.\n\nWykorzystajmy tÄ™ nowo odkrytÄ… moduÅ‚owoÅ›Ä‡, robiÄ…c coÅ›, co byÅ‚oby trudne ze\nstarym kodem, ale jest Å‚atwe z nowym: napiszemy kilka testÃ³w!\n\n[ch13]: ch13-00-functional-features.html\n[ch9-custom-types]: ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation\n[ch9-error-guidelines]: ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling\n[ch9-result]: ch09-02-recoverable-errors-with-result.html\n[ch18]: ch18-00-oop.html\n[ch9-question-mark]: ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator",
        "chapter_title": "Refaktoryzacja w celu poprawy moduÅ‚owoÅ›ci i obsÅ‚ugi bÅ‚Ä™dÃ³w"
    },
    {
        "file_path": "ch15-01-box.md",
        "content": "## UÅ¼ycie `Box<T>` do wskazywania na dane na stercie\n\nNajprostszym inteligentnym wskaÅºnikiem jest pudeÅ‚ko, ktÃ³rego typ zapisuje siÄ™\njako `Box<T>`. *PudeÅ‚ka* pozwalajÄ… przechowywaÄ‡ dane na stercie zamiast na\nstosie. To, co pozostaje na stosie, to wskaÅºnik do danych na stercie.\nOdwoÅ‚aj siÄ™ do RozdziaÅ‚u 4, aby zapoznaÄ‡ siÄ™ z rÃ³Å¼nicÄ… miÄ™dzy stosem a stertÄ….\n\nPudeÅ‚ka nie majÄ… narzutu wydajnoÅ›ciowego, poza przechowywaniem danych na stercie\nzamiast na stosie. Ale nie majÄ… teÅ¼ wielu dodatkowych moÅ¼liwoÅ›ci. BÄ™dziesz ich\nuÅ¼ywaÄ‡ najczÄ™Å›ciej w nastÄ™pujÄ…cych sytuacjach:\n\n* Kiedy masz typ, ktÃ³rego rozmiar nie moÅ¼e byÄ‡ znany w czasie kompilacji,\ni chcesz uÅ¼yÄ‡ wartoÅ›ci tego typu w kontekÅ›cie, ktÃ³ry wymaga dokÅ‚adnego\n  rozmiaru\n* Kiedy masz duÅ¼Ä… iloÅ›Ä‡ danych i chcesz przenieÅ›Ä‡ wÅ‚asnoÅ›Ä‡, ale upewniÄ‡ siÄ™,\n  Å¼e dane nie zostanÄ… skopiowane, gdy to zrobisz\n* Kiedy chcesz byÄ‡ wÅ‚aÅ›cicielem wartoÅ›ci, a zaleÅ¼y ci tylko na tym, aby byÅ‚a to\n  typ, ktÃ³ry implementuje okreÅ›lonÄ… cechÄ™, zamiast byÄ‡ konkretnym typem\n\nPokaÅ¼emy pierwszÄ… sytuacjÄ™ w sekcji [â€WÅ‚Ä…czanie typÃ³w rekurencyjnych za pomocÄ…\npudeÅ‚ekâ€](#enabling-recursive-types-with-boxes)<!-- ignore -->. W drugim\nprzypadku przeniesienie wÅ‚asnoÅ›ci duÅ¼ej iloÅ›ci danych moÅ¼e zajÄ…Ä‡ duÅ¼o czasu,\nponiewaÅ¼ dane sÄ… kopiowane na stosie. Aby poprawiÄ‡ wydajnoÅ›Ä‡ w tej sytuacji,\nmoÅ¼emy przechowywaÄ‡ duÅ¼Ä… iloÅ›Ä‡ danych na stercie w pudeÅ‚ku. Wtedy tylko maÅ‚a\niloÅ›Ä‡ danych wskaÅºnika jest kopiowana na stosie, podczas gdy dane, do ktÃ³rych\nwskazuje, pozostajÄ… w jednym miejscu na stercie. Trzeci przypadek jest znany\njako *obiekt cechy*, a sekcja [â€UÅ¼ywanie obiektÃ³w cech do abstrakcji nad\nwspÃ³lnym zachowaniemâ€][trait-objects]<!-- ignore --> w Rozdziale 18 jest\npoÅ›wiÄ™cona temu tematowi. WiÄ™c to, czego siÄ™ tutaj nauczysz, zastosujesz\np ponownie w tej sekcji!\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"using-boxt-to-store-data-on-the-heap\"></a>\n\n### Przechowywanie danych na stercie\n\nZanim omÃ³wimy przypadek uÅ¼ycia `Box<T>` do przechowywania na stercie,\npowiemy o skÅ‚adni i sposobie interakcji z wartoÅ›ciami przechowywanymi w `Box<T>`.\n\nListing 15-1 pokazuje, jak uÅ¼yÄ‡ pudeÅ‚ka do przechowywania wartoÅ›ci `i32` na\nstercie.\n\n<figure class=\"listing\" id=\"listing-15-1\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\nfn main() {\n    let b = Box::new(5);\n    println!(\"b = {b}\");\n}\n````\n\n<figcaption><a href=\"#listing-15-1\">Listing 15-1</a>: Przechowywanie wartoÅ›ci <code>i32</code> na stercie za pomocÄ… pudeÅ‚ka</figcaption>\n</figure>\n\nDefiniujemy zmiennÄ… `b` z wartoÅ›ciÄ… `Box`, ktÃ³ra wskazuje na wartoÅ›Ä‡ `5`,\nalokowanÄ… na stercie. Ten program wyÅ›wietli `b = 5`; w tym przypadku moÅ¼emy\ndostÄ™p do danych w pudeÅ‚ku podobnie jak wtedy, gdyby te dane znajdowaÅ‚y siÄ™ na\nstercie. Podobnie jak kaÅ¼da posiadana wartoÅ›Ä‡, gdy pudeÅ‚ko wyjdzie poza\nzakres, tak jak `b` na koÅ„cu `main`, zostanie zdealokowane. Dealokacja\nodbywa siÄ™ zarÃ³wno dla pudeÅ‚ka (przechowywanego na stosie), jak i dla danych,\ndo ktÃ³rych wskazuje (przechowywanych na stercie).\n\nUmieszczenie pojedynczej wartoÅ›ci na stercie nie jest zbyt uÅ¼yteczne, wiÄ™c\nrzadko bÄ™dziesz uÅ¼ywaÄ‡ pudeÅ‚ek w ten sposÃ³b. Posiadanie wartoÅ›ci, takich jak\npojedyncze `i32` na stosie, gdzie sÄ… domyÅ›lnie przechowywane, jest bardziej\nodpowiednie w wiÄ™kszoÅ›ci sytuacji. SpÃ³jrzmy na przypadek, w ktÃ³rym pudeÅ‚ka\npozwalajÄ… nam definiowaÄ‡ typy, ktÃ³rych nie moglibyÅ›my zdefiniowaÄ‡, gdybyÅ›my\nnie mieli pudeÅ‚ek.\n\n### WÅ‚Ä…czanie typÃ³w rekurencyjnych za pomocÄ… pudeÅ‚ek\n\nWartoÅ›Ä‡ *typu rekurencyjnego* moÅ¼e zawieraÄ‡ innÄ… wartoÅ›Ä‡ tego samego typu jako\nswojÄ… czÄ™Å›Ä‡. Typy rekurencyjne stanowiÄ… problem, poniewaÅ¼ Rust musi wiedzieÄ‡\nw czasie kompilacji, ile miejsca zajmuje dany typ. Jednak zagnieÅ¼dÅ¼anie wartoÅ›ci\ntypÃ³w rekurencyjnych mogÅ‚oby teoretycznie trwaÄ‡ w nieskoÅ„czonoÅ›Ä‡, wiÄ™c Rust nie\nmoÅ¼e wiedzieÄ‡, ile miejsca potrzebuje wartoÅ›Ä‡. PoniewaÅ¼ pudeÅ‚ka majÄ… znany\nrozmiar, moÅ¼emy wÅ‚Ä…czyÄ‡ typy rekurencyjne, wstawiajÄ…c pudeÅ‚ko do definicji typu\nrekurencyjnego.\n\nJako przykÅ‚ad typu rekurencyjnego, przeanalizujmy listÄ™ cons. Jest to typ danych\npowszechnie spotykany w jÄ™zykach programowania funkcyjnego. Typ listy cons,\nktÃ³ry zdefiniujemy, jest prosty, z wyjÄ…tkiem rekurencji; dlatego koncepcje w\nprzykÅ‚adzie, z ktÃ³rym bÄ™dziemy pracowaÄ‡, bÄ™dÄ… przydatne zawsze, gdy znajdziesz\nsiÄ™ w bardziej zÅ‚oÅ¼onych sytuacjach zwiÄ…zanych z typami rekurencyjnymi.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"more-information-about-the-cons-list\"></a>\n\n#### Zrozumienie listy cons\n\n*Lista cons* to struktura danych pochodzÄ…ca z jÄ™zyka programowania Lisp i jego\ndialektÃ³w, skÅ‚adajÄ…ca siÄ™ z zagnieÅ¼dÅ¼onych par, i jest lispoÅ„skÄ… wersjÄ… listy\nskÅ‚adajÄ…cej siÄ™ z poÅ‚Ä…czonych elementÃ³w. Jej nazwa pochodzi od funkcji `cons`\n(skrÃ³t od *construct function*) w Lispie, ktÃ³ra konstruuje nowÄ… parÄ™ z dwÃ³ch\nswoich argumentÃ³w. WywoÅ‚ujÄ…c `cons` na parze skÅ‚adajÄ…cej siÄ™ z wartoÅ›ci i innej\npary, moÅ¼emy konstruowaÄ‡ listy cons skÅ‚adajÄ…ce siÄ™ z rekurencyjnych par.\n\nNa przykÅ‚ad, oto pseudokodowa reprezentacja listy cons zawierajÄ…cej listÄ™ `1, 2, 3`,\ngdzie kaÅ¼da para jest w nawiasach:\n\n````text\n(1, (2, (3, Nil)))\n````\n\nKaÅ¼dy element listy cons zawiera dwa elementy: wartoÅ›Ä‡ bieÅ¼Ä…cego elementu i\nnastÄ™pnego elementu. Ostatni element listy zawiera tylko wartoÅ›Ä‡ zwanÄ… `Nil`\nbez nastÄ™pnego elementu. Lista cons jest tworzona przez rekurencyjne\nwywoÅ‚ywanie funkcji `cons`. Kanoniczna nazwa oznaczajÄ…ca przypadek bazowy\nrekurencji to `Nil`. ZauwaÅ¼, Å¼e to nie to samo, co koncepcja â€nullâ€ lub â€nilâ€\nomÃ³wiona w Rozdziale 6, ktÃ³ra oznacza nieprawidÅ‚owÄ… lub brakujÄ…cÄ… wartoÅ›Ä‡.\n\nLista cons nie jest powszechnie uÅ¼ywanÄ… strukturÄ… danych w Rust. W wiÄ™kszoÅ›ci\nprzypadkÃ³w, gdy masz listÄ™ elementÃ³w w Rust, `Vec<T>` jest lepszym wyborem. Inne,\nbardziej zÅ‚oÅ¼one rekurencyjne typy danych *sÄ…* uÅ¼yteczne w rÃ³Å¼nych sytuacjach,\nale zaczynajÄ…c od listy cons w tym rozdziale, moÅ¼emy zbadaÄ‡, jak pudeÅ‚ka\npPozwalajÄ… nam definiowaÄ‡ rekurencyjny typ danych bez zbytniego rozpraszania.\n\nListing 15-2 zawiera definicjÄ™ wyliczenia dla listy cons. ZauwaÅ¼, Å¼e ten kod\njeszcze siÄ™ nie skompiluje, poniewaÅ¼ typ `List` nie ma znanego rozmiaru, co\npokaÅ¼emy.\n\n<figure class=\"listing\" id=\"listing-15-2\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore,does_not_compile\nenum List {\n    Cons(i32, List),\n    Nil,\n}\n# \n# fn main() {}\n````\n\n<figcaption><a href=\"#listing-15-2\">Listing 15-2</a>: Pierwsza prÃ³ba zdefiniowania wyliczenia do reprezentowania struktury danych listy cons z wartoÅ›ciami <code>i32</code></figcaption>\n</figure>\n\n\n<section class=\"note\" aria-role=\"note\">\n\n\nUwaga: Implementujemy listÄ™ cons, ktÃ³ra przechowuje tylko wartoÅ›ci `i32` dla\ncelÃ³w tego przykÅ‚adu. MoglibyÅ›my zaimplementowaÄ‡ jÄ… za pomocÄ… generykÃ³w, jak\nomÃ³wiliÅ›my w Rozdziale 10, aby zdefiniowaÄ‡ typ listy cons, ktÃ³ry mÃ³gÅ‚by\nprzechowywaÄ‡ wartoÅ›ci dowolnego typu.\n\n</section>\n\nUÅ¼ycie typu `List` do przechowywania listy `1, 2, 3` wyglÄ…daÅ‚oby jak kod\nw Listingu 15-3.\n\n<figure class=\"listing\" id=\"listing-15-3\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore,does_not_compile\n# enum List {\n#     Cons(i32, List),\n#     Nil,\n# }\n# \n// --snip--\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let list = Cons(1, Cons(2, Cons(3, Nil)));\n}\n````\n\n<figcaption><a href=\"#listing-15-3\">Listing 15-3</a>: UÅ¼ycie wyliczenia <code>List</code> do przechowywania listy <code>1, 2, 3</code></figcaption>\n</figure>\n\nPierwsza wartoÅ›Ä‡ `Cons` przechowuje `1` i innÄ… wartoÅ›Ä‡ `List`. Ta wartoÅ›Ä‡\n`List` to inna wartoÅ›Ä‡ `Cons`, ktÃ³ra przechowuje `2` i innÄ… wartoÅ›Ä‡ `List`.\nTa wartoÅ›Ä‡ `List` to jeszcze jedna wartoÅ›Ä‡ `Cons`, ktÃ³ra przechowuje `3`\ni wartoÅ›Ä‡ `List`, ktÃ³ra jest w koÅ„cu `Nil`, nierrekurencyjnym wariantem,\nktÃ³ry sygnalizuje koniec listy.\n\nJeÅ›li sprÃ³bujemy skompilowaÄ‡ kod z Listingu 15-3, otrzymamy bÅ‚Ä…d pokazany w\nListingu 15-4.\n\n<figure class=\"listing\" id=\"listing-15-4\">\n\n````console\n$ cargo run\n   Compiling cons-list v0.1.0 (file:///projects/cons-list)\nerror[E0072]: recursive type `List` has infinite size\n --> src/main.rs:1:1\n  |\n1 | enum List {\n  | ^^^^^^^^^\n2 |     Cons(i32, List),\n  |               ---- recursive without indirection\n  |\nhelp: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n  |\n2 |     Cons(i32, Box<List>),\n  |               ++++    +\n\nerror[E0391]: cycle detected when computing when `List` needs drop\n --> src/main.rs:1:1\n  |\n1 | enum List {\n  | ^^^^^^^^^\n  |\n  = note: ...which immediately requires computing when `List` needs drop again\n  = note: cycle used when computing whether `List` needs drop\n  = note: see https://rustc-dev-guide.rust-lang.org/overview.html#queries and https://rustc-dev-guide.rust-lang.org/query.html for more information\n\nSome errors have detailed explanations: E0072, E0391.\nFor more information about an error, try `rustc --explain E0072`.\nerror: could not compile `cons-list` (bin \"cons-list\") due to 2 previous errors\n````\n\n<figcaption><a href=\"#listing-15-4\">Listing 15-4</a>: BÅ‚Ä…d, ktÃ³ry otrzymujemy, prÃ³bujÄ…c zdefiniowaÄ‡ rekurencyjne wyliczenie</figcaption>\n</figure>\n\nBÅ‚Ä…d pokazuje, Å¼e ten typ â€ma nieskoÅ„czony rozmiarâ€. Powodem jest to, Å¼e\nzdefiniowaliÅ›my `List` z wariantem, ktÃ³ry jest rekurencyjny: przechowuje innÄ…\nwartoÅ›Ä‡ siebie bezpoÅ›rednio. W rezultacie Rust nie potrafi okreÅ›liÄ‡, ile miejsca\npotrzebuje do przechowywania wartoÅ›ci `List`. RozÅ‚Ã³Å¼my na czynniki pierwsze,\ndlaczego otrzymujemy ten bÅ‚Ä…d. Najpierw przyjrzymy siÄ™, jak Rust decyduje, ile\nmiejsca potrzebuje do przechowywania wartoÅ›ci typu nierrekurencyjnego.\n\n#### Obliczanie rozmiaru typu nierrekurencyjnego\n\nPrzypomnijmy wyliczenie `Message`, ktÃ³re zdefiniowaliÅ›my w Listingu 6-2,\nkiedy omawialiÅ›my definicje wyliczeÅ„ w Rozdziale 6:\n\n````rust\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n# \n# fn main() {}\n````\n\nAby okreÅ›liÄ‡, ile miejsca naleÅ¼y przeznaczyÄ‡ na wartoÅ›Ä‡ `Message`, Rust\nprzechodzi przez kaÅ¼dy z wariantÃ³w, aby sprawdziÄ‡, ktÃ³ry wariant potrzebuje\nnajwiÄ™cej miejsca. Rust widzi, Å¼e `Message::Quit` nie potrzebuje miejsca,\n`Message::Move` potrzebuje wystarczajÄ…co duÅ¼o miejsca na przechowanie dwÃ³ch\nwartoÅ›ci `i32` i tak dalej. PoniewaÅ¼ uÅ¼ywany bÄ™dzie tylko jeden wariant,\nnajwiÄ™cej miejsca, jakie bÄ™dzie potrzebowaÄ‡ wartoÅ›Ä‡ `Message`, to miejsce\npotrzebne na przechowanie najwiÄ™kszego z jej wariantÃ³w.\n\nPorÃ³wnaj to z tym, co dzieje siÄ™, gdy Rust prÃ³buje okreÅ›liÄ‡, ile miejsca\npotrzebuje rekurencyjny typ, taki jak wyliczenie `List` w Listingu 15-2.\nKompilator zaczyna od wariantu `Cons`, ktÃ³ry przechowuje wartoÅ›Ä‡ typu `i32`\ni wartoÅ›Ä‡ typu `List`. Dlatego `Cons` potrzebuje tyle miejsca, ile wynosi\nrozmiar `i32` plus rozmiar `List`. Aby dowiedzieÄ‡ siÄ™, ile pamiÄ™ci potrzebuje\ntyp `List`, kompilator patrzy na warianty, zaczynajÄ…c od wariantu `Cons`.\nWariant `Cons` przechowuje wartoÅ›Ä‡ typu `i32` i wartoÅ›Ä‡ typu `List`, i ten\nproces trwa w nieskoÅ„czonoÅ›Ä‡, jak pokazano na Rysunku 15-1.\n\n<img alt=\"NieskoÅ„czona lista Cons: prostokÄ…t oznaczony 'Cons' podzielony na dwa mniejsze prostokÄ…ty. Pierwszy mniejszy prostokÄ…t zawiera etykietÄ™ 'i32', a drugi mniejszy prostokÄ…t zawiera etykietÄ™ 'Cons' i mniejszÄ… wersjÄ™ zewnÄ™trznego prostokÄ…ta 'Cons'. ProstokÄ…ty 'Cons' nadal zawierajÄ… coraz mniejsze wersje samych siebie, aÅ¼ najmniejszy, wygodnie rozmiarowy prostokÄ…t zawiera symbol nieskoÅ„czonoÅ›ci, wskazujÄ…c, Å¼e to powtÃ³rzenie trwa wiecznie.\" src=\"img/trpl15-01.svg\" class=\"center\" style=\"width: 50%;\" />\n\n<span class=\"caption\">Rysunek 15-1: NieskoÅ„czona lista `List` skÅ‚adajÄ…ca siÄ™ z nieskoÅ„czonych wariantÃ³w `Cons`</span>\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"using-boxt-to-get-a-recursive-type-with-a-known-size\"></a>\n\n#### Uzyskiwanie rekurencyjnego typu o znanym rozmiarze\n\nPoniewaÅ¼ Rust nie jest w stanie okreÅ›liÄ‡, ile miejsca naleÅ¼y przydzieliÄ‡ dla\nrekurencyjnie zdefiniowanych typÃ³w, kompilator zwraca bÅ‚Ä…d z tÄ… pomocnÄ…\nsugestiÄ…:\n\n<!-- manual-regeneration\nafter doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line\n-->\n\n````text\nhelp: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n  |\n2 |     Cons(i32, Box<List>),\n  |               ++++    +\n````\n\nW tej sugestii *poÅ›rednictwo* oznacza, Å¼e zamiast bezpoÅ›rednio przechowywaÄ‡\nwartoÅ›Ä‡, powinniÅ›my zmieniÄ‡ strukturÄ™ danych, aby przechowywaÄ‡ wartoÅ›Ä‡\npoÅ›rednio, przechowujÄ…c zamiast tego wskaÅºnik do wartoÅ›ci.\n\nPoniewaÅ¼ `Box<T>` jest wskaÅºnikiem, Rust zawsze wie, ile miejsca potrzebuje\n`Box<T>`: rozmiar wskaÅºnika nie zmienia siÄ™ w zaleÅ¼noÅ›ci od iloÅ›ci danych, na\nktÃ³re wskazuje. Oznacza to, Å¼e moÅ¼emy umieÅ›ciÄ‡ `Box<T>` w wariancie `Cons`\nzamiast bezpoÅ›rednio innej wartoÅ›ci `List`. `Box<T>` bÄ™dzie wskazywaÄ‡ na\nkolejnÄ… wartoÅ›Ä‡ `List`, ktÃ³ra bÄ™dzie znajdowaÄ‡ siÄ™ na stercie, a nie wewnÄ…trz\nwariantu `Cons`. Koncepcyjnie, nadal mamy listÄ™, utworzonÄ… z list\nprzechowujÄ…cych inne listy, ale ta implementacja jest teraz bardziej podobna\ndo umieszczania elementÃ³w obok siebie, a nie wewnÄ…trz siebie.\n\nMoÅ¼emy zmieniÄ‡ definicjÄ™ wyliczenia `List` w Listingu 15-2 i uÅ¼ycie `List` w\nListingu 15-3 na kod w Listingu 15-5, ktÃ³ry siÄ™ skompiluje.\n\n<figure class=\"listing\" id=\"listing-15-5\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\nenum List {\n    Cons(i32, Box<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));\n}\n````\n\n<figcaption><a href=\"#listing-15-5\">Listing 15-5</a>: Definicja <code>List</code>, ktÃ³ra uÅ¼ywa <code>Box&lt;T&gt;</code>, aby mieÄ‡ znany rozmiar</figcaption>\n</figure>\n\nWariant `Cons` potrzebuje rozmiaru `i32` plus miejsca na przechowywanie danych\nwskaznika pudeÅ‚ka. Wariant `Nil` nie przechowuje Å¼adnych wartoÅ›ci, wiÄ™c\npotrzebuje mniej miejsca na stosie niÅ¼ wariant `Cons`. Wiemy teraz, Å¼e kaÅ¼da\nwartoÅ›Ä‡ `List` zajmie rozmiar `i32` plus rozmiar danych wskaÅºnika pudeÅ‚ka.\nUÅ¼ywajÄ…c pudeÅ‚ka, przerwaliÅ›my nieskoÅ„czony, rekurencyjny Å‚aÅ„cuch, wiÄ™c\nkompilator moÅ¼e okreÅ›liÄ‡ rozmiar potrzebny do przechowywania wartoÅ›ci `List`.\nRysunek 15-2 pokazuje, jak wyglÄ…da teraz wariant `Cons`.\n\n<img alt=\"ProstokÄ…t oznaczony 'Cons' podzielony na dwa mniejsze prostokÄ…ty. Pierwszy mniejszy prostokÄ…t zawiera etykietÄ™ 'i32', a drugi mniejszy prostokÄ…t zawiera etykietÄ™ 'Box' z jednym wewnÄ™trznym prostokÄ…tem, ktÃ³ry zawiera etykietÄ™ 'usize', reprezentujÄ…cÄ… skoÅ„czony rozmiar wskaÅºnika pudeÅ‚ka.\" src=\"img/trpl15-02.svg\" class=\"center\" />\n\n<span class=\"caption\">Rysunek 15-2: `List`, ktÃ³ra nie ma nieskoÅ„czonego rozmiaru, poniewaÅ¼ `Cons` zawiera `Box`</span>\n\nPudeÅ‚ka zapewniajÄ… jedynie poÅ›rednictwo i alokacjÄ™ na stercie; nie majÄ… Å¼adnych\ninnych specjalnych moÅ¼liwoÅ›ci, takich jak te, ktÃ³re zobaczymy w przypadku\ninnych typÃ³w inteligentnych wskaÅºnikÃ³w. Nie majÄ… rÃ³wnieÅ¼ narzutu\nwydajnoÅ›ciowego, ktÃ³ry wiÄ…Å¼e siÄ™ z tymi specjalnymi moÅ¼liwoÅ›ciami, wiÄ™c mogÄ…\nbyÄ‡ przydatne w przypadkach, takich jak lista cons, gdzie poÅ›rednictwo jest\njedynÄ… potrzebnÄ… nam funkcjÄ…. WiÄ™cej przypadkÃ³w uÅ¼ycia pudeÅ‚ek omÃ³wimy w\nRozdziale 18.\n\nTyp `Box<T>` jest inteligentnym wskaÅºnikiem, poniewaÅ¼ implementuje cechÄ™\n`Deref`, ktÃ³ra pozwala traktowaÄ‡ wartoÅ›ci `Box<T>` jak referencje. Kiedy\nwartoÅ›Ä‡ `Box<T>` wychodzi poza zakres, dane na stercie, na ktÃ³re wskazuje\npudeÅ‚ko, rÃ³wnieÅ¼ sÄ… czyszczone ze wzglÄ™du na implementacjÄ™ cechy `Drop`. Te\ndwie cechy bÄ™dÄ… jeszcze waÅ¼niejsze dla funkcjonalnoÅ›ci zapewnianej przez inne\ntypy inteligentnych wskaÅºnikÃ³w, ktÃ³re omÃ³wimy w pozostaÅ‚ej czÄ™Å›ci tego\nrozdziaÅ‚u. Przeanalizujmy te dwie cechy bardziej szczegÃ³Å‚owo.\n\n[trait-objects]: ch18-02-trait-objects.html#using-trait-objects-to-abstract-over-shared-behavior",
        "chapter_title": "UÅ¼ycie Box<T> do wskazywania na dane na stercie"
    },
    {
        "file_path": "ch17-06-futures-tasks-threads.md",
        "content": "## ÅÄ…czenie wszystkiego w caÅ‚oÅ›Ä‡: Futures, Zadania i WÄ…tki\n\nJak widzieliÅ›my w [Rozdziale 16][ch16]<!-- ignore -->, wÄ…tki stanowiÄ… jedno z podejÅ›Ä‡ do wspÃ³Å‚bieÅ¼noÅ›ci. W tym rozdziale poznaliÅ›my inne podejÅ›cie: uÅ¼ywanie async z futures i strumieniami. JeÅ›li zastanawiasz siÄ™, kiedy wybraÄ‡ jednÄ… metodÄ™ zamiast drugiej, odpowiedÅº brzmi: to zaleÅ¼y! I w wielu przypadkach wyborem nie sÄ… wÄ…tki *lub* async, ale raczej wÄ…tki *i* async.\n\nWiele systemÃ³w operacyjnych od dziesiÄ™cioleci dostarczaÅ‚o modele wspÃ³Å‚bieÅ¼noÅ›ci oparte na wÄ…tkach, a wiele jÄ™zykÃ³w programowania je obsÅ‚uguje. Jednak te modele majÄ… swoje kompromisy. Na wielu systemach operacyjnych zuÅ¼ywajÄ… sporo pamiÄ™ci na kaÅ¼dy wÄ…tek. WÄ…tki sÄ… rÃ³wnieÅ¼ opcjÄ… tylko wtedy, gdy system operacyjny i sprzÄ™t je obsÅ‚ugujÄ…. W przeciwieÅ„stwie do popularnych komputerÃ³w stacjonarnych i mobilnych, niektÃ³re systemy wbudowane w ogÃ³le nie majÄ… systemu operacyjnego, wiÄ™c nie majÄ… teÅ¼ wÄ…tkÃ³w.\n\nModel async zapewnia inny â€“ i ostatecznie uzupeÅ‚niajÄ…cy â€“ zestaw kompromisÃ³w. W modelu async operacje wspÃ³Å‚bieÅ¼ne nie wymagajÄ… wÅ‚asnych wÄ…tkÃ³w. Zamiast tego mogÄ… dziaÅ‚aÄ‡ na zadaniach, tak jak uÅ¼ywaliÅ›my `trpl::spawn_task` do uruchomienia pracy z funkcji synchronicznej w sekcji strumieni. Zadanie jest podobne do wÄ…tku, ale zamiast byÄ‡ zarzÄ…dzanym przez system operacyjny, jest zarzÄ…dzane przez kod na poziomie biblioteki: Å›rodowisko uruchomieniowe.\n\nIstnieje powÃ³d, dla ktÃ³rego API do uruchamiania wÄ…tkÃ³w i uruchamiania zadaÅ„ sÄ… tak podobne. WÄ…tki dziaÅ‚ajÄ… jako granica dla zestawÃ³w operacji synchronicznych; wspÃ³Å‚bieÅ¼noÅ›Ä‡ jest moÅ¼liwa *miÄ™dzy* wÄ…tkami. Zadania dziaÅ‚ajÄ… jako granica dla zestawÃ³w operacji *asynchronicznych*; wspÃ³Å‚bieÅ¼noÅ›Ä‡ jest moÅ¼liwa zarÃ³wno *miÄ™dzy*, jak i *wewnÄ…trz* zadaÅ„, poniewaÅ¼ zadanie moÅ¼e przeÅ‚Ä…czaÄ‡ siÄ™ miÄ™dzy futures w swoim ciele. Wreszcie, futures sÄ… najbardziej szczegÃ³Å‚owÄ… jednostkÄ… wspÃ³Å‚bieÅ¼noÅ›ci w Rust, a kaÅ¼da future moÅ¼e reprezentowaÄ‡ drzewo innych futures. Åšrodowisko uruchomieniowe â€“ a konkretnie jego egzekutor â€“ zarzÄ…dza zadaniami, a zadania zarzÄ…dzajÄ… futures. W tym wzglÄ™dzie zadania sÄ… podobne do lekkich, zarzÄ…dzanych przez Å›rodowisko uruchomieniowe wÄ…tkÃ³w z dodatkowymi moÅ¼liwoÅ›ciami wynikajÄ…cymi z bycia zarzÄ…dzanym przez Å›rodowisko uruchomieniowe, a nie przez system operacyjny.\n\nNie oznacza to, Å¼e zadania async sÄ… zawsze lepsze od wÄ…tkÃ³w (lub odwrotnie). WspÃ³Å‚bieÅ¼noÅ›Ä‡ z wÄ…tkami jest pod pewnymi wzglÄ™dami prostszym modelem programowania niÅ¼ wspÃ³Å‚bieÅ¼noÅ›Ä‡ z `async`. MoÅ¼e to byÄ‡ siÅ‚a lub sÅ‚aboÅ›Ä‡. WÄ…tki sÄ… nieco w stylu â€odpal i zapomnijâ€; nie majÄ… natywnego odpowiednika dla future, wiÄ™c po prostu dziaÅ‚ajÄ… do koÅ„ca, bez przerywania, chyba Å¼e przez sam system operacyjny.\n\nOkazuje siÄ™, Å¼e wÄ…tki i zadania czÄ™sto bardzo dobrze wspÃ³Å‚pracujÄ…, poniewaÅ¼ zadania mogÄ… (przynajmniej w niektÃ³rych Å›rodowiskach uruchomieniowych) byÄ‡ przenoszone miÄ™dzy wÄ…tkami. W rzeczywistoÅ›ci, pod maskÄ…, Å›rodowisko uruchomieniowe, ktÃ³rego uÅ¼ywaliÅ›my â€“ w tym funkcje `spawn_blocking` i `spawn_task` â€“ jest domyÅ›lnie wielowÄ…tkowe! Wiele Å›rodowisk uruchomieniowych stosuje podejÅ›cie zwane *work stealing* (kradzieÅ¼Ä… pracy) do transparentnego przenoszenia zadaÅ„ miÄ™dzy wÄ…tkami, w oparciu o bieÅ¼Ä…ce wykorzystanie wÄ…tkÃ³w, aby poprawiÄ‡ ogÃ³lnÄ… wydajnoÅ›Ä‡ systemu. To podejÅ›cie faktycznie wymaga *wÄ…tkÃ³w* i *zadaÅ„*, a zatem i futures.\n\nZastanawiajÄ…c siÄ™, ktÃ³rÄ… metodÄ™ zastosowaÄ‡, rozwaÅ¼ te zasady:\n\n* JeÅ›li praca jest *bardzo rÃ³wnolegÅ‚a* (czyli CPU-bound), taka jak przetwarzanie duÅ¼ej iloÅ›ci danych, gdzie kaÅ¼da czÄ™Å›Ä‡ moÅ¼e byÄ‡ przetwarzana oddzielnie, wÄ…tki sÄ… lepszym wyborem.\n* JeÅ›li praca jest *bardzo wspÃ³Å‚bieÅ¼na* (czyli I/O-bound), taka jak obsÅ‚uga wiadomoÅ›ci z wielu rÃ³Å¼nych ÅºrÃ³deÅ‚, ktÃ³re mogÄ… przychodziÄ‡ w rÃ³Å¼nych odstÄ™pach czasu lub z rÃ³Å¼nymi prÄ™dkoÅ›ciami, async jest lepszym wyborem.\n\nAJeÅ›li potrzebujesz zarÃ³wno rÃ³wnolegÅ‚oÅ›ci, jak i wspÃ³Å‚bieÅ¼noÅ›ci, nie musisz wybieraÄ‡ miÄ™dzy wÄ…tkami a async. MoÅ¼esz ich swobodnie uÅ¼ywaÄ‡ razem, pozwalajÄ…c kaÅ¼demu odgrywaÄ‡ rolÄ™, w ktÃ³rej jest najlepszy. Na przykÅ‚ad, Lista 17-25 pokazuje doÅ›Ä‡ powszechny przykÅ‚ad tego rodzaju poÅ‚Ä…czenia w rzeczywistym kodzie Rust.\n\n<figure class=\"listing\" id=\"listing-17-25\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\n# extern crate trpl; // for mdbook test\n# \nuse std::{thread, time::Duration};\n\nfn main() {\n    let (tx, mut rx) = trpl::channel();\n\n    thread::spawn(move || {\n        for i in 1..11 {\n            tx.send(i).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    trpl::block_on(async {\n        while let Some(message) = rx.recv().await {\n            println!(\"{message}\");\n        }\n    });\n}\n````\n\n<figcaption><a href=\"#listing-17-25\">Lista 17-25</a>: WysyÅ‚anie wiadomoÅ›ci z blokujÄ…cym kodem w wÄ…tku i oczekiwanie na wiadomoÅ›ci w bloku async</figcaption>\n</figure>\n\nZaczynamy od utworzenia kanaÅ‚u async, a nastÄ™pnie uruchamiamy wÄ…tek, ktÃ³ry przejmuje wÅ‚asnoÅ›Ä‡ strony nadawcy kanaÅ‚u za pomocÄ… sÅ‚owa kluczowego `move`. W wÄ…tku wysyÅ‚amy liczby od 1 do 10, usypiajÄ…c na sekundÄ™ miÄ™dzy kaÅ¼dÄ… z nich. Na koniec uruchamiamy future utworzonÄ… za pomocÄ… bloku async przekazanego do `trpl::block_on`, tak jak robiliÅ›my to w caÅ‚ym rozdziale. W tej future oczekujemy na te wiadomoÅ›ci, tak jak w innych przykÅ‚adach przekazywania wiadomoÅ›ci, ktÃ³re widzieliÅ›my.\n\nPowracajÄ…c do scenariusza, od ktÃ³rego zaczÄ™liÅ›my rozdziaÅ‚, wyobraÅº sobie uruchamianie zestawu zadaÅ„ kodowania wideo przy uÅ¼yciu dedykowanego wÄ…tku (poniewaÅ¼ kodowanie wideo jest obciÄ…Å¼ajÄ…ce dla procesora), ale powiadamianie interfejsu uÅ¼ytkownika o zakoÅ„czeniu tych operacji za pomocÄ… kanaÅ‚u async. IstniejÄ… niezliczone przykÅ‚ady tego rodzaju kombinacji w rzeczywistych przypadkach uÅ¼ycia.\n\n## Podsumowanie\n\nTo nie ostatni raz, kiedy spotkasz siÄ™ ze wspÃ³Å‚bieÅ¼noÅ›ciÄ… w tej ksiÄ…Å¼ce. Projekt w [Rozdziale 21][ch21]<!-- ignore --> zastosuje te koncepcje w bardziej realistycznej sytuacji niÅ¼ prostsze przykÅ‚ady omÃ³wione tutaj i porÃ³wna bezpoÅ›rednio rozwiÄ…zywanie problemÃ³w za pomocÄ… wÄ…tkÃ³w kontra zadaÅ„ i futures.\n\nNiezaleÅ¼nie od tego, ktÃ³re z tych podejÅ›Ä‡ wybierzesz, Rust daje ci narzÄ™dzia potrzebne do pisania bezpiecznego, szybkiego, wspÃ³Å‚bieÅ¼nego kodu â€“ czy to dla serwera WWW o wysokiej przepustowoÅ›ci, czy dla wbudowanego systemu operacyjnego.\n\nNastÄ™pnie omÃ³wimy idiomatyczne sposoby modelowania problemÃ³w i strukturyzowania rozwiÄ…zaÅ„ w miarÄ™ wzrostu programÃ³w Rust. Ponadto omÃ³wimy, jak idiomy Rust odnoszÄ… siÄ™ do tych, ktÃ³re moÅ¼esz znaÄ‡ z programowania zorientowanego obiektowo.\n\n[ch16]: http://localhost:3000/ch16-00-concurrency.html\n[ch21]: ch21-00-final-project-a-web-server.html",
        "chapter_title": "Futures, Zadania i WÄ…tki"
    },
    {
        "file_path": "ch18-00-oop.md",
        "content": "# Cechy Programowania Zorientowanego Obiektowo\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"object-oriented-programming-features-of-rust\"></a>\n\nProgramowanie zorientowane obiektowo (OOP) to sposÃ³b modelowania programÃ³w. Obiekty jako koncepcja programistyczna zostaÅ‚y wprowadzone w jÄ™zyku programowania Simula w latach 60. Te obiekty wpÅ‚ynÄ™Å‚y na architekturÄ™ programistycznÄ… Alana Kaya, w ktÃ³rej obiekty przekazujÄ… sobie wiadomoÅ›ci. Aby opisaÄ‡ tÄ™ architekturÄ™, ukuÅ‚ on termin *programowanie zorientowane obiektowo* w 1967 roku. Wiele konkurujÄ…cych definicji opisuje, czym jest OOP, i wedÅ‚ug niektÃ³rych z tych definicji Rust jest obiektowy, ale wedÅ‚ug innych nie jest. W tym rozdziale zbadamy pewne cechy, ktÃ³re sÄ… powszechnie uwaÅ¼ane za obiektowe i jak te cechy przekÅ‚adajÄ… siÄ™ na idiomatyczny Rust. NastÄ™pnie pokaÅ¼emy, jak zaimplementowaÄ‡ obiektowy wzorzec projektowy w Rust i omÃ³wimy kompromisy zwiÄ…zane z tym w porÃ³wnaniu do implementacji rozwiÄ…zania wykorzystujÄ…cego niektÃ³re mocne strony Rust.",
        "chapter_title": "Cechy Programowania Zorientowanego Obiektowo"
    },
    {
        "file_path": "ch18-01-what-is-oo.md",
        "content": "## Charakterystyka JÄ™zykÃ³w Zorientowanych Obiektowo\n\nW spoÅ‚ecznoÅ›ci programistycznej nie ma zgody co do tego, jakie cechy musi posiadaÄ‡ jÄ™zyk, aby byÅ‚ uwaÅ¼any za zorientowany obiektowo. Rust jest pod wpÅ‚ywem wielu paradygmatÃ³w programowania, w tym OOP; na przykÅ‚ad, zbadaliÅ›my cechy pochodzÄ…ce z programowania funkcyjnego w Rozdziale 13. Prawdopodobnie, jÄ™zyki OOP dzielÄ… pewne wspÃ³lne cechy â€“ a mianowicie obiekty, hermetyzacjÄ™ i dziedziczenie. Przyjrzyjmy siÄ™, co oznacza kaÅ¼da z tych cech i czy Rust je obsÅ‚uguje.\n\n### Obiekty ZawierajÄ… Dane i Zachowanie\n\nKsiÄ…Å¼ka *Wzorce projektowe: Elementy reuÅ¼ywalnego oprogramowania obiektowego* Ericha Gammy, Richarda Helma, Ralpha Johnsona i Johna Vlissidesa (Addison-Wesley, 1994), potocznie nazywana ksiÄ…Å¼kÄ… *Gang of Four*, jest katalogiem obiektowych wzorcÃ³w projektowych. Definiuje OOP w ten sposÃ³b:\n\n>\n> Programy zorientowane obiektowo skÅ‚adajÄ… siÄ™ z obiektÃ³w. **Obiekt** pakuje zarÃ³wno dane, jak i procedury, ktÃ³re operujÄ… na tych danych. Procedury sÄ… zazwyczaj nazywane **metodami** lub **operacjami**.\n\nZgodnie z tÄ… definicjÄ…, Rust jest zorientowany obiektowo: struktury i wyliczenia posiadajÄ… dane, a bloki `impl` dostarczajÄ… metody dla struktur i wyliczeÅ„. Mimo Å¼e struktur i wyliczeÅ„ z metodami nie *nazywa siÄ™* obiektami, zapewniajÄ… one tÄ™ samÄ… funkcjonalnoÅ›Ä‡, zgodnie z definicjÄ… obiektÃ³w wedÅ‚ug Gang of Four.\n\n### Hermetyzacja UkrywajÄ…ca SzczegÃ³Å‚y Implementacji\n\nInnym aspektem powszechnie kojarzonym z OOP jest idea *hermetyzacji*, co oznacza, Å¼e szczegÃ³Å‚y implementacji obiektu nie sÄ… dostÄ™pne dla kodu korzystajÄ…cego z tego obiektu. Dlatego jedynym sposobem interakcji z obiektem jest jego publiczne API; kod uÅ¼ywajÄ…cy obiektu nie powinien byÄ‡ w stanie bezpoÅ›rednio zmieniaÄ‡ wewnÄ™trznych danych ani zachowaÅ„ obiektu. UmoÅ¼liwia to programiÅ›cie zmianÄ™ i refaktoryzacjÄ™ wewnÄ™trznych elementÃ³w obiektu bez koniecznoÅ›ci zmiany kodu, ktÃ³ry go uÅ¼ywa.\n\nOmÃ³wiliÅ›my, jak kontrolowaÄ‡ hermetyzacjÄ™ w Rozdziale 7: MoÅ¼emy uÅ¼yÄ‡ sÅ‚owa kluczowego `pub`, aby zdecydowaÄ‡, ktÃ³re moduÅ‚y, typy, funkcje i metody w naszym kodzie powinny byÄ‡ publiczne, a domyÅ›lnie wszystko inne jest prywatne. Na przykÅ‚ad, moÅ¼emy zdefiniowaÄ‡ strukturÄ™ `AveragedCollection`, ktÃ³ra ma pole zawierajÄ…ce wektor wartoÅ›ci `i32`. Struktura moÅ¼e rÃ³wnieÅ¼ mieÄ‡ pole zawierajÄ…ce Å›redniÄ… wartoÅ›ci w wektorze, co oznacza, Å¼e Å›rednia nie musi byÄ‡ obliczana na Å¼Ä…danie za kaÅ¼dym razem, gdy ktoÅ› jej potrzebuje. Innymi sÅ‚owy, `AveragedCollection` bÄ™dzie dla nas buforowaÄ‡ obliczonÄ… Å›redniÄ…. Lista 18-1 zawiera definicjÄ™ struktury `AveragedCollection`.\n\n<figure class=\"listing\" id=\"listing-18-1\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\npub struct AveragedCollection {\n    list: Vec<i32>,\n    average: f64,\n}\n````\n\n<figcaption><a href=\"#listing-18-1\">Lista 18-1</a>: Struktura <code>AveragedCollection</code>, ktÃ³ra przechowuje listÄ™ liczb caÅ‚kowitych i Å›redniÄ… elementÃ³w w kolekcji</figcaption>\n</figure>\n\nStruktura jest oznaczona jako `pub`, aby inny kod mÃ³gÅ‚ jej uÅ¼ywaÄ‡, ale pola wewnÄ…trz struktury pozostajÄ… prywatne. Jest to waÅ¼ne w tym przypadku, poniewaÅ¼ chcemy zapewniÄ‡, Å¼e za kaÅ¼dym razem, gdy wartoÅ›Ä‡ jest dodawana lub usuwana z listy, Å›rednia jest rÃ³wnieÅ¼ aktualizowana. Robimy to, implementujÄ…c metody `add`, `remove` i `average` dla struktury, jak pokazano na LiÅ›cie 18-2.\n\n<figure class=\"listing\" id=\"listing-18-2\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\n# pub struct AveragedCollection {\n#     list: Vec<i32>,\n#     average: f64,\n# }\n# \nimpl AveragedCollection {\n    pub fn add(&mut self, value: i32) {\n        self.list.push(value);\n        self.update_average();\n    }\n\n    pub fn remove(&mut self) -> Option<i32> {\n        let result = self.list.pop();\n        match result {\n            Some(value) => {\n                self.update_average();\n                Some(value)\n            }\n            None => None,\n        }\n    }\n\n    pub fn average(&self) -> f64 {\n        self.average\n    }\n\n    fn update_average(&mut self) {\n        let total: i32 = self.list.iter().sum();\n        self.average = total as f64 / self.list.len() as f64;\n    }\n}\n````\n\n<figcaption><a href=\"#listing-18-2\">Lista 18-2</a>: Implementacje publicznych metod <code>add</code>, <code>remove</code> i <code>average</code> w <code>AveragedCollection</code></figcaption>\n</figure>\n\nPubliczne metody `add`, `remove` i `average` to jedyne sposoby dostÄ™pu lub modyfikacji danych w instancji `AveragedCollection`. Gdy element jest dodawany do `list` za pomocÄ… metody `add` lub usuwany za pomocÄ… metody `remove`, implementacje obu metod wywoÅ‚ujÄ… prywatnÄ… metodÄ™ `update_average`, ktÃ³ra zajmuje siÄ™ rÃ³wnieÅ¼ aktualizacjÄ… pola `average`.\n\nPozostawiamy pola `list` i `average` prywatne, aby zewnÄ™trzny kod nie mÃ³gÅ‚ bezpoÅ›rednio dodawaÄ‡ ani usuwaÄ‡ elementÃ³w z pola `list`; w przeciwnym razie pole `average` mogÅ‚oby staÄ‡ siÄ™ niespÃ³jne, gdy `list` siÄ™ zmienia. Metoda `average` zwraca wartoÅ›Ä‡ z pola `average`, umoÅ¼liwiajÄ…c zewnÄ™trznemu kodowi odczyt `average`, ale nie jego modyfikacjÄ™.\n\nPoniewaÅ¼ hermetyzowaliÅ›my szczegÃ³Å‚y implementacji struktury `AveragedCollection`, moÅ¼emy w przyszÅ‚oÅ›ci Å‚atwo zmieniaÄ‡ aspekty, takie jak struktura danych. Na przykÅ‚ad, moglibyÅ›my uÅ¼yÄ‡ `HashSet<i32>` zamiast `Vec<i32>` dla pola `list`. DopÃ³ki sygnatury publicznych metod `add`, `remove` i `average` pozostaÅ‚yby takie same, kod uÅ¼ywajÄ…cy `AveragedCollection` nie wymagaÅ‚by zmian. GdybyÅ›my uczynili `list` publicznym, niekoniecznie tak by byÅ‚o: `HashSet<i32>` i `Vec<i32>` majÄ… rÃ³Å¼ne metody dodawania i usuwania elementÃ³w, wiÄ™c kod zewnÄ™trzny prawdopodobnie musiaÅ‚by siÄ™ zmieniÄ‡, gdyby modyfikowaÅ‚ `list` bezpoÅ›rednio.\n\nJeÅ›li hermetyzacja jest wymaganym aspektem, aby jÄ™zyk byÅ‚ uwaÅ¼any za obiektowy, to Rust speÅ‚nia to wymaganie. Opcja uÅ¼ycia `pub` lub nie dla rÃ³Å¼nych czÄ™Å›ci kodu umoÅ¼liwia hermetyzacjÄ™ szczegÃ³Å‚Ã³w implementacji.\n\n### Dziedziczenie jako System TypÃ³w i jako UdostÄ™pnianie Kodu\n\n*Dziedziczenie* to mechanizm, dziÄ™ki ktÃ³remu obiekt moÅ¼e dziedziczyÄ‡ elementy z definicji innego obiektu, uzyskujÄ…c w ten sposÃ³b dane i zachowanie obiektu-rodzica bez koniecznoÅ›ci ponownego ich definiowania.\n\nJeÅ›li jÄ™zyk musi posiadaÄ‡ dziedziczenie, aby byÄ‡ obiektowym, to Rust nie jest takim jÄ™zykiem. Nie ma sposobu, aby zdefiniowaÄ‡ strukturÄ™, ktÃ³ra dziedziczy pola i implementacje metod struktury-rodzica bez uÅ¼ycia makra.\n\nJednakÅ¼e, jeÅ›li jesteÅ› przyzwyczajony do posiadania dziedziczenia w swoim zestawie narzÄ™dzi programistycznych, moÅ¼esz uÅ¼yÄ‡ innych rozwiÄ…zaÅ„ w Rust, w zaleÅ¼noÅ›ci od powodu, dla ktÃ³rego pierwotnie siÄ™gnÄ…Å‚eÅ› po dziedziczenie.\n\nDziedziczenie wybraÅ‚byÅ› z dwÃ³ch gÅ‚Ã³wnych powodÃ³w. Jeden to ponowne wykorzystanie kodu: moÅ¼esz zaimplementowaÄ‡ okreÅ›lone zachowanie dla jednego typu, a dziedziczenie umoÅ¼liwia ponowne wykorzystanie tej implementacji dla innego typu. MoÅ¼esz to zrobiÄ‡ w ograniczony sposÃ³b w kodzie Rust, uÅ¼ywajÄ…c domyÅ›lnych implementacji metod cech, co widziaÅ‚eÅ› na LiÅ›cie 10-14, gdy dodaliÅ›my domyÅ›lnÄ… implementacjÄ™ metody `summarize` do cechy `Summary`. KaÅ¼dy typ implementujÄ…cy cechÄ™ `Summary` miaÅ‚by dostÄ™pnÄ… metodÄ™ `summarize` bez dodatkowego kodu. Jest to podobne do klasy nadrzÄ™dnej posiadajÄ…cej implementacjÄ™ metody i dziedziczÄ…cej klasy podrzÄ™dnej rÃ³wnieÅ¼ posiadajÄ…cej implementacjÄ™ metody. MoÅ¼emy rÃ³wnieÅ¼ nadpisaÄ‡ domyÅ›lnÄ… implementacjÄ™ metody `summarize` podczas implementowania cechy `Summary`, co jest podobne do klasy podrzÄ™dnej nadpisujÄ…cej implementacjÄ™ metody odziedziczonej z klasy nadrzÄ™dnej.\n\nDrugi powÃ³d uÅ¼ycia dziedziczenia dotyczy systemu typÃ³w: aby umoÅ¼liwiÄ‡ uÅ¼ycie typu potomnego w tych samych miejscach co typ nadrzÄ™dny. Nazywa siÄ™ to rÃ³wnieÅ¼ *polimorfizmem*, co oznacza, Å¼e moÅ¼na podstawiaÄ‡ wiele obiektÃ³w jeden za drugi w czasie wykonania, jeÅ›li dzielÄ… one pewne cechy.\n\n<section class=\"note\" aria-role=\"note\">\n\n\n\n### Polimorfizm\n\nDla wielu osÃ³b polimorfizm jest synonimem dziedziczenia. Ale w rzeczywistoÅ›ci jest to bardziej ogÃ³lna koncepcja, ktÃ³ra odnosi siÄ™ do kodu, ktÃ³ry moÅ¼e pracowaÄ‡ z danymi wielu typÃ³w. Dla dziedziczenia te typy sÄ… zazwyczaj podklasami.\n\nRust zamiast tego uÅ¼ywa generykÃ³w do abstrakcji nad rÃ³Å¼nymi moÅ¼liwymi typami i ograniczeÅ„ cech do narzucania ograniczeÅ„ na to, co te typy muszÄ… zapewniaÄ‡. Jest to czasami nazywane *ograniczonym polimorfizmem parametrycznym*.\n\n</section>\n\nRust wybraÅ‚ inny zestaw kompromisÃ³w, nie oferujÄ…c dziedziczenia. Dziedziczenie czÄ™sto grozi wspÃ³Å‚dzieleniem wiÄ™kszej iloÅ›ci kodu niÅ¼ to konieczne. Podklasy nie zawsze powinny dzieliÄ‡ wszystkie cechy swojej klasy nadrzÄ™dnej, ale bÄ™dÄ… to robiÄ‡ w przypadku dziedziczenia. MoÅ¼e to sprawiÄ‡, Å¼e projekt programu bÄ™dzie mniej elastyczny. Wprowadza to rÃ³wnieÅ¼ moÅ¼liwoÅ›Ä‡ wywoÅ‚ywania metod w podklasach, ktÃ³re nie majÄ… sensu lub powodujÄ… bÅ‚Ä™dy, poniewaÅ¼ metody nie majÄ… zastosowania do podklasy. Ponadto, niektÃ³re jÄ™zyki zezwalajÄ… tylko na *pojedyncze dziedziczenie* (co oznacza, Å¼e podklasa moÅ¼e dziedziczyÄ‡ tylko z jednej klasy), co dodatkowo ogranicza elastycznoÅ›Ä‡ projektu programu.\n\nZ tych powodÃ³w Rust przyjmuje inne podejÅ›cie, uÅ¼ywajÄ…c obiektÃ³w cech zamiast dziedziczenia, aby osiÄ…gnÄ…Ä‡ polimorfizm w czasie wykonania. Przyjrzyjmy siÄ™, jak dziaÅ‚ajÄ… obiekty cech.",
        "chapter_title": "Charakterystyka JÄ™zykÃ³w Zorientowanych Obiektowo"
    },
    {
        "file_path": "ch18-02-trait-objects.md",
        "content": "<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"using-trait-objects-that-allow-for-values-of-different-types\"></a>\n\n## UÅ¼ywanie ObiektÃ³w Trait do Abstrakcji nad WspÃ³lnym Zachowaniem\n\nW Rozdziale 8 wspomnieliÅ›my, Å¼e jednym z ograniczeÅ„ wektorÃ³w jest to, Å¼e mogÄ… przechowywaÄ‡ elementy tylko jednego typu. StworzyliÅ›my obejÅ›cie w LiÅ›cie 8-9, gdzie zdefiniowaliÅ›my wyliczenie `SpreadsheetCell` z wariantami do przechowywania liczb caÅ‚kowitych, zmiennoprzecinkowych i tekstu. OznaczaÅ‚o to, Å¼e mogliÅ›my przechowywaÄ‡ rÃ³Å¼ne typy danych w kaÅ¼dej komÃ³rce i nadal mieÄ‡ wektor reprezentujÄ…cy wiersz komÃ³rek. Jest to doskonale dobre rozwiÄ…zanie, gdy nasze wymienne elementy to staÅ‚y zestaw typÃ³w, ktÃ³re znamy w momencie kompilacji kodu.\n\nJednak czasami chcemy, aby uÅ¼ytkownik naszej biblioteki mÃ³gÅ‚ rozszerzyÄ‡ zestaw typÃ³w, ktÃ³re sÄ… prawidÅ‚owe w danej sytuacji. Aby pokazaÄ‡, jak to osiÄ…gnÄ…Ä‡, stworzymy przykÅ‚ad narzÄ™dzia graficznego interfejsu uÅ¼ytkownika (GUI), ktÃ³re iteruje przez listÄ™ elementÃ³w, wywoÅ‚ujÄ…c metodÄ™ `draw` na kaÅ¼dym z nich, aby narysowaÄ‡ go na ekranie â€” powszechna technika w narzÄ™dziach GUI. Stworzymy bibliotekÄ™ `gui`, ktÃ³ra bÄ™dzie zawieraÄ‡ strukturÄ™ biblioteki GUI. Ta biblioteka moÅ¼e zawieraÄ‡ typy dla uÅ¼ytkownikÃ³w, takie jak `Button` lub `TextField`. Ponadto uÅ¼ytkownicy `gui` bÄ™dÄ… chcieli tworzyÄ‡ wÅ‚asne typy, ktÃ³re moÅ¼na rysowaÄ‡: na przykÅ‚ad jeden programista moÅ¼e dodaÄ‡ `Image`, a inny `SelectBox`.\n\nW momencie pisania biblioteki nie moÅ¼emy znaÄ‡ i zdefiniowaÄ‡ wszystkich typÃ³w, ktÃ³re inni programiÅ›ci mogÄ… chcieÄ‡ stworzyÄ‡. Wiemy jednak, Å¼e `gui` musi Å›ledziÄ‡ wiele wartoÅ›ci rÃ³Å¼nych typÃ³w i musi wywoÅ‚ywaÄ‡ metodÄ™ `draw` na kaÅ¼dej z tych wartoÅ›ci o rÃ³Å¼nych typach. Nie musi wiedzieÄ‡ dokÅ‚adnie, co siÄ™ stanie, gdy wywoÅ‚amy metodÄ™ `draw`, tylko tyle, Å¼e wartoÅ›Ä‡ bÄ™dzie miaÅ‚a tÄ™ metodÄ™ dostÄ™pnÄ… do wywoÅ‚ania.\n\nAby to zrobiÄ‡ w jÄ™zyku z dziedziczeniem, moglibyÅ›my zdefiniowaÄ‡ klasÄ™ o nazwie `Component`, ktÃ³ra miaÅ‚aby metodÄ™ `draw`. Inne klasy, takie jak `Button`, `Image` i `SelectBox`, dziedziczyÅ‚yby po `Component` i w ten sposÃ³b dziedziczyÅ‚yby metodÄ™ `draw`. KaÅ¼da z nich mogÅ‚aby nadpisaÄ‡ metodÄ™ `draw`, aby zdefiniowaÄ‡ swoje niestandardowe zachowanie, ale framework mÃ³gÅ‚by traktowaÄ‡ wszystkie typy tak, jakby byÅ‚y instancjami `Component` i wywoÅ‚ywaÄ‡ na nich `draw`. Ale poniewaÅ¼ Rust nie ma dziedziczenia, potrzebujemy innego sposobu na zbudowanie biblioteki `gui`, aby umoÅ¼liwiÄ‡ uÅ¼ytkownikom tworzenie nowych typÃ³w zgodnych z bibliotekÄ….\n\n### Definiowanie Traitu dla WspÃ³lnego Zachowania\n\nAby zaimplementowaÄ‡ zachowanie, ktÃ³re chcemy, aby `gui` miaÅ‚o, zdefiniujemy cechÄ™ `Draw`, ktÃ³ra bÄ™dzie miaÅ‚a jednÄ… metodÄ™ `draw`. NastÄ™pnie moÅ¼emy zdefiniowaÄ‡ wektor, ktÃ³ry przyjmuje obiekt cechy. *Obiekt cechy* wskazuje zarÃ³wno instancjÄ™ typu implementujÄ…cego naszÄ… okreÅ›lonÄ… cechÄ™, jak i tabelÄ™ uÅ¼ywanÄ… do wyszukiwania metod cech na tym typie w czasie wykonania. Tworzymy obiekt cechy, okreÅ›lajÄ…c jakiÅ› rodzaj wskaÅºnika, taki jak referencja lub inteligentny wskaÅºnik `Box<T>`, nastÄ™pnie sÅ‚owo kluczowe `dyn`, a nastÄ™pnie okreÅ›lajÄ…c odpowiedniÄ… cechÄ™. (O powodzie, dla ktÃ³rego obiekty cech muszÄ… uÅ¼ywaÄ‡ wskaÅºnika, porozmawiamy w sekcji [â€Typy o dynamicznym rozmiarze i cecha `Sized`â€][dynamically-sized]<!-- ignore --> w Rozdziale 20.) MoÅ¼emy uÅ¼ywaÄ‡ obiektÃ³w cech zamiast typu generycznego lub konkretnego. WszÄ™dzie, gdzie uÅ¼ywamy obiektu cechy, system typÃ³w Rust zapewni w czasie kompilacji, Å¼e kaÅ¼da wartoÅ›Ä‡ uÅ¼yta w tym kontekÅ›cie bÄ™dzie implementowaÄ‡ cechÄ™ obiektu cechy. W konsekwencji nie musimy znaÄ‡ wszystkich moÅ¼liwych typÃ³w w czasie kompilacji.\n\nWspomnieliÅ›my, Å¼e w Rust powstrzymujemy siÄ™ od nazywania struktur i wyliczeÅ„ â€obiektamiâ€, aby odrÃ³Å¼niÄ‡ je od obiektÃ³w z innych jÄ™zykÃ³w. W strukturze lub wyliczeniu dane w polach struktury i zachowanie w blokach `impl` sÄ… oddzielone, podczas gdy w innych jÄ™zykach dane i zachowanie poÅ‚Ä…czone w jednÄ… koncepcjÄ™ sÄ… czÄ™sto nazywane obiektem. Obiekty cech rÃ³Å¼niÄ… siÄ™ od obiektÃ³w w innych jÄ™zykach tym, Å¼e nie moÅ¼emy dodawaÄ‡ danych do obiektu cechy. Obiekty cech nie sÄ… tak ogÃ³lnie uÅ¼yteczne jak obiekty w innych jÄ™zykach: ich specyficznym celem jest umoÅ¼liwienie abstrakcji nad wspÃ³lnym zachowaniem.\n\nLista 18-3 pokazuje, jak zdefiniowaÄ‡ cechÄ™ `Draw` z jednÄ… metodÄ… `draw`.\n\n<figure class=\"listing\" id=\"listing-18-3\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\npub trait Draw {\n    fn draw(&self);\n}\n````\n\n<figcaption><a href=\"#listing-18-3\">Lista 18-3</a>: Definicja cechy <code>Draw</code></figcaption>\n</figure>\n\nTa skÅ‚adnia powinna byÄ‡ znana z naszych dyskusji na temat definiowania cech w Rozdziale 10. Dalej pojawia siÄ™ nowa skÅ‚adnia: Lista 18-4 definiuje strukturÄ™ o nazwie `Screen`, ktÃ³ra zawiera wektor o nazwie `components`. Ten wektor jest typu `Box<dyn Draw>`, czyli obiektu cechy; jest to zastÄ™pstwo dla dowolnego typu wewnÄ…trz `Box`, ktÃ³ry implementuje cechÄ™ `Draw`.\n\n<figure class=\"listing\" id=\"listing-18-4\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\n# pub trait Draw {\n#     fn draw(&self);\n# }\n# \npub struct Screen {\n    pub components: Vec<Box<dyn Draw>>,\n}\n````\n\n<figcaption><a href=\"#listing-18-4\">Lista 18-4</a>: Definicja struktury <code>Screen</code> z polem <code>components</code> zawierajÄ…cym wektor obiektÃ³w cech, ktÃ³re implementujÄ… cechÄ™ <code>Draw</code></figcaption>\n</figure>\n\nW strukturze `Screen` zdefiniujemy metodÄ™ `run`, ktÃ³ra wywoÅ‚a metodÄ™ `draw` na kaÅ¼dym z jej `components`, jak pokazano na LiÅ›cie 18-5.\n\n<figure class=\"listing\" id=\"listing-18-5\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\n# pub trait Draw {\n#     fn draw(&self);\n# }\n# \n# pub struct Screen {\n#     pub components: Vec<Box<dyn Draw>>,\n# }\n# \nimpl Screen {\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\n````\n\n<figcaption><a href=\"#listing-18-5\">Lista 18-5</a>: Metoda <code>run</code> w <code>Screen</code>, ktÃ³ra wywoÅ‚uje metodÄ™ <code>draw</code> na kaÅ¼dym komponencie</figcaption>\n</figure>\n\nDziaÅ‚a to inaczej niÅ¼ definiowanie struktury, ktÃ³ra uÅ¼ywa generycznego parametru typu z ograniczeniami cech. Generyczny parametr typu moÅ¼e byÄ‡ podstawiony tylko jednym konkretnym typem na raz, podczas gdy obiekty cech pozwalajÄ… na wypeÅ‚nienie obiektu cechy wieloma konkretnymi typami w czasie wykonania. Na przykÅ‚ad, moglibyÅ›my zdefiniowaÄ‡ strukturÄ™ `Screen` uÅ¼ywajÄ…c generycznego typu i ograniczenia cech, jak na LiÅ›cie 18-6.\n\n<figure class=\"listing\" id=\"listing-18-6\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\n# pub trait Draw {\n#     fn draw(&self);\n# }\n# \npub struct Screen<T: Draw> {\n    pub components: Vec<T>,\n}\n\nimpl<T> Screen<T>\nwhere\n    T: Draw,\n{\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\n````\n\n<figcaption><a href=\"#listing-18-6\">Lista 18-6</a>: Alternatywna implementacja struktury <code>Screen</code> i jej metody <code>run</code> za pomocÄ… generykÃ³w i ograniczeÅ„ cech</figcaption>\n</figure>\n\nTo ogranicza nas do instancji `Screen`, ktÃ³ra ma listÄ™ komponentÃ³w wszystkich typu `Button` lub wszystkich typu `TextField`. JeÅ›li zawsze bÄ™dziesz mieÄ‡ tylko jednorodne kolekcje, uÅ¼ycie generykÃ³w i ograniczeÅ„ cech jest preferowane, poniewaÅ¼ definicje zostanÄ… zmonomorfizowane w czasie kompilacji, aby uÅ¼ywaÄ‡ konkretnych typÃ³w.\n\nZ drugiej strony, w metodzie uÅ¼ywajÄ…cej obiektÃ³w cech, jedna instancja `Screen` moÅ¼e przechowywaÄ‡ `Vec<T>`, ktÃ³ry zawiera `Box<Button>` oraz `Box<TextField>`. Przyjrzyjmy siÄ™, jak to dziaÅ‚a, a nastÄ™pnie omÃ³wimy implikacje dla wydajnoÅ›ci w czasie wykonania.\n\n### Implementowanie Traitu\n\nTeraz dodamy kilka typÃ³w, ktÃ³re implementujÄ… cechÄ™ `Draw`. Zapewnimy typ `Button`. Ponownie, faktyczne zaimplementowanie biblioteki GUI wykracza poza zakres tej ksiÄ…Å¼ki, wiÄ™c metoda `draw` nie bÄ™dzie miaÅ‚a Å¼adnej uÅ¼ytecznej implementacji w swoim ciele. Aby wyobraziÄ‡ sobie, jak mogÅ‚aby wyglÄ…daÄ‡ implementacja, struktura `Button` mogÅ‚aby mieÄ‡ pola `width`, `height` i `label`, jak pokazano na LiÅ›cie 18-7.\n\n<figure class=\"listing\" id=\"listing-18-7\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\n# pub trait Draw {\n#     fn draw(&self);\n# }\n# \n# pub struct Screen {\n#     pub components: Vec<Box<dyn Draw>>,\n# }\n# \n# impl Screen {\n#     pub fn run(&self) {\n#         for component in self.components.iter() {\n#             component.draw();\n#         }\n#     }\n# }\n# \npub struct Button {\n    pub width: u32,\n    pub height: u32,\n    pub label: String,\n}\n\nimpl Draw for Button {\n    fn draw(&self) {\n        // code to actually draw a button\n    }\n}\n````\n\n<figcaption><a href=\"#listing-18-7\">Lista 18-7</a>: Struktura <code>Button</code>, ktÃ³ra implementuje cechÄ™ <code>Draw</code></figcaption>\n</figure>\n\nPola `width`, `height` i `label` w `Button` bÄ™dÄ… siÄ™ rÃ³Å¼niÄ‡ od pÃ³l w innych komponentach; na przykÅ‚ad, typ `TextField` mÃ³gÅ‚by mieÄ‡ te same pola plus pole `placeholder`. KaÅ¼dy z typÃ³w, ktÃ³re chcemy narysowaÄ‡ na ekranie, bÄ™dzie implementowaÅ‚ cechÄ™ `Draw`, ale uÅ¼yje innego kodu w metodzie `draw`, aby zdefiniowaÄ‡, jak narysowaÄ‡ dany typ, jak to ma miejsce w `Button` (bez faktycznego kodu GUI, jak wspomniano). Typ `Button`, na przykÅ‚ad, mÃ³gÅ‚by mieÄ‡ dodatkowy blok `impl` zawierajÄ…cy metody zwiÄ…zane z tym, co dzieje siÄ™, gdy uÅ¼ytkownik kliknie przycisk. Tego rodzaju metody nie bÄ™dÄ… miaÅ‚y zastosowania do typÃ³w takich jak `TextField`.\n\nJeÅ›li ktoÅ› uÅ¼ywajÄ…cy naszej biblioteki zdecyduje siÄ™ zaimplementowaÄ‡ strukturÄ™ `SelectBox`, ktÃ³ra ma pola `width`, `height` i `options`, zaimplementuje rÃ³wnieÅ¼ cechÄ™ `Draw` dla typu `SelectBox`, jak pokazano na LiÅ›cie 18-8.\n\n<figure class=\"listing\" id=\"listing-18-8\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore\nuse gui::Draw;\n\nstruct SelectBox {\n    width: u32,\n    height: u32,\n    options: Vec<String>,\n}\n\nimpl Draw for SelectBox {\n    fn draw(&self) {\n        // code to actually draw a select box\n    }\n}\n# \n# fn main() {}\n````\n\n<figcaption><a href=\"#listing-18-8\">Lista 18-8</a>: Inny crate uÅ¼ywajÄ…cy <code>gui</code> i implementujÄ…cy cechÄ™ <code>Draw</code> na strukturze <code>SelectBox</code></figcaption>\n</figure>\n\nUÅ¼ytkownik naszej biblioteki moÅ¼e teraz napisaÄ‡ swojÄ… funkcjÄ™ `main`, aby utworzyÄ‡ instancjÄ™ `Screen`. Do instancji `Screen` mogÄ… dodaÄ‡ `SelectBox` i `Button`, umieszczajÄ…c kaÅ¼dy w `Box<T>`, aby staÅ‚ siÄ™ obiektem cechy. NastÄ™pnie mogÄ… wywoÅ‚aÄ‡ metodÄ™ `run` na instancji `Screen`, ktÃ³ra wywoÅ‚a `draw` na kaÅ¼dym z komponentÃ³w. Lista 18-9 pokazuje tÄ™ implementacjÄ™.\n\n<figure class=\"listing\" id=\"listing-18-9\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore\n# use gui::Draw;\n# \n# struct SelectBox {\n#     width: u32,\n#     height: u32,\n#     options: Vec<String>,\n# }\n# \n# impl Draw for SelectBox {\n#     fn draw(&self) {\n#         // code to actually draw a select box\n#     }\n# }\n# \nuse gui::{Button, Screen};\n\nfn main() {\n    let screen = Screen {\n        components: vec![\n            Box::new(SelectBox {\n                width: 75,\n                height: 10,\n                options: vec![\n                    String::from(\"Yes\"),\n                    String::from(\"Maybe\"),\n                    String::from(\"No\"),\n                ],\n            }),\n            Box::new(Button {\n                width: 50,\n                height: 10,\n                label: String::from(\"OK\"),\n            }),\n        ],\n    };\n\n    screen.run();\n}\n````\n\n<figcaption><a href=\"#listing-18-9\">Lista 18-9</a>: UÅ¼ywanie obiektÃ³w cech do przechowywania wartoÅ›ci rÃ³Å¼nych typÃ³w, ktÃ³re implementujÄ… tÄ™ samÄ… cechÄ™</figcaption>\n</figure>\n\nKiedy pisaliÅ›my bibliotekÄ™, nie wiedzieliÅ›my, Å¼e ktoÅ› moÅ¼e dodaÄ‡ typ `SelectBox`, ale nasza implementacja `Screen` byÅ‚a w stanie operowaÄ‡ na nowym typie i go rysowaÄ‡, poniewaÅ¼ `SelectBox` implementuje cechÄ™ `Draw`, co oznacza, Å¼e implementuje metodÄ™ `draw`.\n\nTa koncepcja â€” zajmowanie siÄ™ tylko wiadomoÅ›ciami, na ktÃ³re wartoÅ›Ä‡ odpowiada, a nie konkretnym typem wartoÅ›ci â€” jest podobna do koncepcji *duck typing* w jÄ™zykach z dynamicznym typowaniem: jeÅ›li chodzi jak kaczka i kwacze jak kaczka, to musi byÄ‡ kaczka! W implementacji `run` na `Screen` na LiÅ›cie 18-5, `run` nie musi wiedzieÄ‡, jaki jest konkretny typ kaÅ¼dego komponentu. Nie sprawdza, czy komponent jest instancjÄ… `Button` czy `SelectBox`, po prostu wywoÅ‚uje metodÄ™ `draw` na komponencie. Poprzez okreÅ›lenie `Box<dyn Draw>` jako typu wartoÅ›ci w wektorze `components`, zdefiniowaliÅ›my, Å¼e `Screen` potrzebuje wartoÅ›ci, na ktÃ³rych moÅ¼emy wywoÅ‚aÄ‡ metodÄ™ `draw`.\n\nZaletÄ… uÅ¼ywania obiektÃ³w cech i systemu typÃ³w Rust do pisania kodu podobnego do kodu uÅ¼ywajÄ…cego duck typingu jest to, Å¼e nigdy nie musimy sprawdzaÄ‡, czy wartoÅ›Ä‡ implementuje konkretnÄ… metodÄ™ w czasie wykonania, ani martwiÄ‡ siÄ™ o bÅ‚Ä™dy, jeÅ›li wartoÅ›Ä‡ nie implementuje metody, ale mimo to jÄ… wywoÅ‚ujemy. Rust nie skompiluje naszego kodu, jeÅ›li wartoÅ›ci nie implementujÄ… cech, ktÃ³rych potrzebujÄ… obiekty cech.\n\nNa przykÅ‚ad, Lista 18-10 pokazuje, co siÄ™ dzieje, gdy prÃ³bujemy stworzyÄ‡ `Screen` ze `String` jako komponentem.\n\n<figure class=\"listing\" id=\"listing-18-10\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore,does_not_compile\nuse gui::Screen;\n\nfn main() {\n    let screen = Screen {\n        components: vec![Box::new(String::from(\"Hi\"))],\n    };\n\n    screen.run();\n}\n````\n\n<figcaption><a href=\"#listing-18-10\">Lista 18-10</a>: PrÃ³ba uÅ¼ycia typu, ktÃ³ry nie implementuje cechy obiektu cechy</figcaption>\n</figure>\n\nOtrzymamy ten bÅ‚Ä…d, poniewaÅ¼ `String` nie implementuje cechy `Draw`:\n\n````console\n$ cargo run\n   Compiling gui v0.1.0 (file:///projects/gui)\nerror[E0277]: the trait bound `String: Draw` is not satisfied\n --> src/main.rs:5:26\n  |\n5 |         components: vec![Box::new(String::from(\"Hi\"))],\n  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` is not implemented for `String`\n  |\n  = help: the trait `Draw` is implemented for `Button`\n  = note: required for the cast from `Box<String>` to `Box<dyn Draw>`\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `gui` (bin \"gui\") due to 1 previous error\n````\n\nTen bÅ‚Ä…d informuje nas, Å¼e albo przekazujemy coÅ› do `Screen`, czego nie zamierzaliÅ›my przekazaÄ‡ i dlatego powinniÅ›my przekazaÄ‡ inny typ, albo powinniÅ›my zaimplementowaÄ‡ `Draw` na `String`, aby `Screen` byÅ‚ w stanie wywoÅ‚aÄ‡ na nim `draw`.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"trait-objects-perform-dynamic-dispatch\"></a>\n\n### Wykonywanie Dynamicznego WysyÅ‚ania\n\nPrzypomnijmy sobie dyskusjÄ™ w sekcji [â€WydajnoÅ›Ä‡ kodu uÅ¼ywajÄ…cego generykÃ³wâ€][performance-of-code-using-generics]<!-- ignore --> w Rozdziale 10 na temat procesu monomorfizacji wykonywanego przez kompilator dla generykÃ³w: kompilator generuje niegeneryczne implementacje funkcji i metod dla kaÅ¼dego konkretnego typu, ktÃ³ry uÅ¼ywamy w miejsce generycznego parametru typu. Kod, ktÃ³ry wynika z monomorfizacji, wykonuje *statyczne wysyÅ‚anie*, czyli sytuacjÄ™, w ktÃ³rej kompilator wie, ktÃ³rÄ… metodÄ™ wywoÅ‚ujesz w czasie kompilacji. Jest to przeciwieÅ„stwo *dynamicznego wysyÅ‚ania*, czyli sytuacji, w ktÃ³rej kompilator nie moÅ¼e w czasie kompilacji okreÅ›liÄ‡, ktÃ³rÄ… metodÄ™ wywoÅ‚ujesz. W przypadkach dynamicznego wysyÅ‚ania kompilator emituje kod, ktÃ³ry w czasie wykonania bÄ™dzie wiedziaÅ‚, ktÃ³rÄ… metodÄ™ wywoÅ‚aÄ‡.\n\nKiedy uÅ¼ywamy obiektÃ³w cech, Rust musi uÅ¼yÄ‡ dynamicznego wysyÅ‚ania. Kompilator nie zna wszystkich typÃ³w, ktÃ³re mogÄ… byÄ‡ uÅ¼yte z kodem uÅ¼ywajÄ…cym obiektÃ³w cech, wiÄ™c nie wie, ktÃ³ra metoda zaimplementowana na ktÃ³rym typie ma byÄ‡ wywoÅ‚ana. Zamiast tego, w czasie wykonania, Rust uÅ¼ywa wskaÅºnikÃ³w w obiekcie cechy, aby wiedzieÄ‡, ktÃ³rÄ… metodÄ™ wywoÅ‚aÄ‡. To wyszukiwanie wiÄ…Å¼e siÄ™ z kosztem wykonania, ktÃ³ry nie wystÄ™puje przy statycznym wysyÅ‚aniu. Dynamiczne wysyÅ‚anie uniemoÅ¼liwia rÃ³wnieÅ¼ kompilatorowi wstawienie kodu metody, co z kolei uniemoÅ¼liwia niektÃ³re optymalizacje, a Rust ma pewne zasady dotyczÄ…ce tego, gdzie moÅ¼na, a gdzie nie moÅ¼na uÅ¼ywaÄ‡ dynamicznego wysyÅ‚ania, zwane *kompatybilnoÅ›ciÄ… dyn*. Te zasady wykraczajÄ… poza zakres tej dyskusji, ale moÅ¼esz przeczytaÄ‡ o nich wiÄ™cej [w referencji][dyn-compatibility]<!-- ignore -->. JednakÅ¼e uzyskaliÅ›my dodatkowÄ… elastycznoÅ›Ä‡ w kodzie, ktÃ³ry napisaliÅ›my na LiÅ›cie 18-5 i byliÅ›my w stanie obsÅ‚ugiwaÄ‡ na LiÅ›cie 18-9, wiÄ™c jest to kompromis do rozwaÅ¼enia.\n\n[dynamically-sized]: ch20-03-advanced-types.html#dynamically-sized-types-and-the-sized-trait\n[performance-of-code-using-generics]: ch10-01-syntax.html#performance-of-code-using-generics\n[dyn-compatibility]: https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility",
        "chapter_title": "UÅ¼ywanie ObiektÃ³w Trait do Abstrakcji nad WspÃ³lnym Zachowaniem"
    },
    {
        "file_path": "ch18-03-oo-design-patterns.md",
        "content": "## Implementacja Obiektowo Zorientowanego Wzorca Projektowego\n\n*Wzorzec stanu* to obiektowo zorientowany wzorzec projektowy. IstotÄ… wzorca jest to, Å¼e definiujemy zestaw stanÃ³w, ktÃ³re wartoÅ›Ä‡ moÅ¼e mieÄ‡ wewnÄ™trznie. Stany sÄ… reprezentowane przez zestaw *obiektÃ³w stanu*, a zachowanie wartoÅ›ci zmienia siÄ™ w zaleÅ¼noÅ›ci od jej stanu. Przejdziemy przez przykÅ‚ad struktury wpisu na blogu, ktÃ³ra ma pole do przechowywania swojego stanu, ktÃ³ry bÄ™dzie obiektem stanu z zestawu â€szkicâ€, â€do recenzjiâ€ lub â€opublikowanyâ€.\n\nObiekty stanu dzielÄ… funkcjonalnoÅ›Ä‡: w Rust, oczywiÅ›cie, uÅ¼ywamy struktur i cech zamiast obiektÃ³w i dziedziczenia. KaÅ¼dy obiekt stanu jest odpowiedzialny za wÅ‚asne zachowanie i za to, kiedy powinien zmieniÄ‡ siÄ™ w inny stan. WartoÅ›Ä‡, ktÃ³ra przechowuje obiekt stanu, nic nie wie o rÃ³Å¼nych zachowaniach stanÃ³w ani o tym, kiedy przechodziÄ‡ miÄ™dzy stanami.\n\nZaletÄ… stosowania wzorca stanu jest to, Å¼e gdy zmieniÄ… siÄ™ wymagania biznesowe programu, nie bÄ™dziemy musieli zmieniaÄ‡ kodu wartoÅ›ci przechowujÄ…cej stan ani kodu, ktÃ³ry uÅ¼ywa tej wartoÅ›ci. BÄ™dziemy musieli jedynie zaktualizowaÄ‡ kod wewnÄ…trz jednego z obiektÃ³w stanu, aby zmieniÄ‡ jego zasady lub ewentualnie dodaÄ‡ wiÄ™cej obiektÃ³w stanu.\n\nNajpierw zaimplementujemy wzorzec stanu w bardziej tradycyjny, obiektowy sposÃ³b. NastÄ™pnie uÅ¼yjemy podejÅ›cia, ktÃ³re jest nieco bardziej naturalne w Rust. ZagÅ‚Ä™bimy siÄ™ w stopniowÄ… implementacjÄ™ przepÅ‚ywu pracy wpisu na blogu, uÅ¼ywajÄ…c wzorca stanu.\n\nKoÅ„cowa funkcjonalnoÅ›Ä‡ bÄ™dzie wyglÄ…daÄ‡ tak:\n\n1. Wpis na blogu zaczyna siÄ™ jako pusty szkic.\n1. Po zakoÅ„czeniu szkicu, prosi siÄ™ o jego recenzjÄ™.\n1. Po zatwierdzeniu wpis zostaje opublikowany.\n1. Tylko opublikowane wpisy na blogu zwracajÄ… treÅ›Ä‡ do wydrukowania, aby niezaprobowane wpisy nie mogÅ‚y zostaÄ‡ przypadkowo opublikowane.\n\nWszelkie inne prÃ³by zmian we wpisie nie powinny mieÄ‡ Å¼adnego efektu. Na przykÅ‚ad, jeÅ›li sprÃ³bujemy zatwierdziÄ‡ szkic wpisu na blogu, zanim poprosimy o recenzjÄ™, wpis powinien pozostaÄ‡ nieopublikowanym szkicem.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"a-traditional-object-oriented-attempt\"></a>\n\n### PrÃ³ba w Tradycyjnym Stylu Obiektowym\n\nIstnieje nieskoÅ„czenie wiele sposobÃ³w strukturyzowania kodu w celu rozwiÄ…zania tego samego problemu, kaÅ¼dy z rÃ³Å¼nymi kompromisami. Implementacja w tej sekcji jest bardziej tradycyjnym stylem obiektowym, ktÃ³ry jest moÅ¼liwy do napisania w Rust, ale nie wykorzystuje niektÃ³rych mocnych stron Rust. PÃ³Åºniej zademonstrujemy inne rozwiÄ…zanie, ktÃ³re nadal uÅ¼ywa wzorca projektowego zorientowanego obiektowo, ale jest skonstruowane w sposÃ³b, ktÃ³ry moÅ¼e wydawaÄ‡ siÄ™ mniej znajomy programistom z doÅ›wiadczeniem w programowaniu obiektowym. PorÃ³wnamy oba rozwiÄ…zania, aby doÅ›wiadczyÄ‡ kompromisÃ³w zwiÄ…zanych z projektowaniem kodu Rust inaczej niÅ¼ w innych jÄ™zykach.\n\nLista 18-11 pokazuje ten przepÅ‚yw pracy w formie kodu: jest to przykÅ‚ad uÅ¼ycia API, ktÃ³re zaimplementujemy w bibliotece o nazwie `blog`. To siÄ™ jeszcze nie skompiluje, poniewaÅ¼ nie zaimplementowaliÅ›my crate `blog`.\n\n<figure class=\"listing\" id=\"listing-18-11\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore,does_not_compile\nuse blog::Post;\n\nfn main() {\n    let mut post = Post::new();\n\n    post.add_text(\"I ate a salad for lunch today\");\n    assert_eq!(\"\", post.content());\n\n    post.request_review();\n    assert_eq!(\"\", post.content());\n\n    post.approve();\n    assert_eq!(\"I ate a salad for lunch today\", post.content());\n}\n````\n\n<figcaption><a href=\"#listing-18-11\">Lista 18-11</a>: Kod demonstrujÄ…cy poÅ¼Ä…dane zachowanie, ktÃ³re chcemy, aby posiadaÅ‚a nasza biblioteka <code>blog</code></figcaption>\n</figure>\n\nChcemy umoÅ¼liwiÄ‡ uÅ¼ytkownikowi utworzenie nowego szkicu wpisu na blogu za pomocÄ… `Post::new`. Chcemy umoÅ¼liwiÄ‡ dodawanie tekstu do wpisu na blogu. JeÅ›li sprÃ³bujemy natychmiast uzyskaÄ‡ treÅ›Ä‡ wpisu, przed zatwierdzeniem, nie powinniÅ›my otrzymaÄ‡ Å¼adnego tekstu, poniewaÅ¼ wpis jest nadal szkicem. DodaliÅ›my `assert_eq!` w kodzie w celach demonstracyjnych. DoskonaÅ‚ym testem jednostkowym byÅ‚oby sprawdzenie, czy szkic wpisu na blogu zwraca pusty ciÄ…g z metody `content`, ale nie bÄ™dziemy pisaÄ‡ testÃ³w dla tego przykÅ‚adu.\n\nNastÄ™pnie chcemy umoÅ¼liwiÄ‡ proÅ›bÄ™ o recenzjÄ™ wpisu i chcemy, aby `content` zwracaÅ‚o pusty ciÄ…g, podczas gdy czekamy na recenzjÄ™. Kiedy wpis zostanie zatwierdzony, powinien zostaÄ‡ opublikowany, co oznacza, Å¼e tekst wpisu zostanie zwrÃ³cony, gdy wywoÅ‚ana zostanie metoda `content`.\n\nZauwaÅ¼, Å¼e jedynym typem, z ktÃ³rym wchodzimy w interakcjÄ™ z biblioteki, jest typ `Post`. Ten typ bÄ™dzie uÅ¼ywaÅ‚ wzorca stanu i bÄ™dzie przechowywaÅ‚ wartoÅ›Ä‡, ktÃ³ra bÄ™dzie jednym z trzech obiektÃ³w stanu reprezentujÄ…cych rÃ³Å¼ne stany, w jakich moÅ¼e znajdowaÄ‡ siÄ™ wpis â€” szkic, do recenzji lub opublikowany. Zmiana z jednego stanu na drugi bÄ™dzie zarzÄ…dzana wewnÄ™trznie w typie `Post`. Stany zmieniajÄ… siÄ™ w odpowiedzi na metody wywoÅ‚ywane przez uÅ¼ytkownikÃ³w naszej biblioteki na instancji `Post`, ale nie muszÄ… oni bezpoÅ›rednio zarzÄ…dzaÄ‡ zmianami stanu. Ponadto uÅ¼ytkownicy nie mogÄ… popeÅ‚niÄ‡ bÅ‚Ä™du ze stanami, na przykÅ‚ad publikujÄ…c wpis przed jego zrecenzowaniem.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"defining-post-and-creating-a-new-instance-in-the-draft-state\"></a>\n\n#### Definiowanie `Post` i Tworzenie Nowej Instancji\n\nRozpocznijmy implementacjÄ™ biblioteki! Wiemy, Å¼e potrzebujemy publicznej struktury `Post`, ktÃ³ra przechowuje pewnÄ… zawartoÅ›Ä‡, wiÄ™c zaczniemy od definicji struktury i powiÄ…zanej publicznej funkcji `new` do tworzenia instancji `Post`, jak pokazano na LiÅ›cie 18-12. Stworzymy rÃ³wnieÅ¼ prywatnÄ… cechÄ™ `State`, ktÃ³ra zdefiniuje zachowanie, ktÃ³re muszÄ… mieÄ‡ wszystkie obiekty stanu dla `Post`.\n\nNastÄ™pnie `Post` bÄ™dzie przechowywaÄ‡ obiekt cechy `Box<dyn State>` wewnÄ…trz `Option<T>` w prywatnym polu o nazwie `state`, aby przechowywaÄ‡ obiekt stanu. Za chwilÄ™ zobaczysz, dlaczego `Option<T>` jest konieczny.\n\n<figure class=\"listing\" id=\"listing-18-12\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\npub struct Post {\n    state: Option<Box<dyn State>>,\n    content: String,\n}\n\nimpl Post {\n    pub fn new() -> Post {\n        Post {\n            state: Some(Box::new(Draft {})),\n            content: String::new(),\n        }\n    }\n}\n\ntrait State {}\n\nstruct Draft {}\n\nimpl State for Draft {}\n````\n\n<figcaption><a href=\"#listing-18-12\">Lista 18-12</a>: Definicja struktury <code>Post</code> i funkcji <code>new</code>, ktÃ³ra tworzy nowÄ… instancjÄ™ <code>Post</code>, cechy <code>State</code> i struktury <code>Draft</code></figcaption>\n</figure>\n\nCecha `State` definiuje zachowanie dzielone przez rÃ³Å¼ne stany wpisu. Obiekty stanu to `Draft`, `PendingReview` i `Published`, i wszystkie one bÄ™dÄ… implementowaÄ‡ cechÄ™ `State`. Na razie cecha nie ma Å¼adnych metod, a zaczniemy od zdefiniowania tylko stanu `Draft`, poniewaÅ¼ to jest stan, w ktÃ³rym chcemy, aby wpis zaczynaÅ‚ siÄ™.\n\nKiedy tworzymy nowy `Post`, ustawiamy jego pole `state` na wartoÅ›Ä‡ `Some`, ktÃ³ra zawiera `Box`. Ten `Box` wskazuje na nowÄ… instancjÄ™ struktury `Draft`. To zapewnia, Å¼e za kaÅ¼dym razem, gdy tworzymy nowÄ… instancjÄ™ `Post`, zaczyna ona jako szkic. PoniewaÅ¼ pole `state` w `Post` jest prywatne, nie ma moÅ¼liwoÅ›ci utworzenia `Post` w Å¼adnym innym stanie! W funkcji `Post::new` ustawiamy pole `content` na nowy, pusty `String`.\n\n#### Przechowywanie Tekstu TreÅ›ci Wpisu\n\nWidzieliÅ›my w LiÅ›cie 18-11, Å¼e chcemy mieÄ‡ moÅ¼liwoÅ›Ä‡ wywoÅ‚ania metody `add_text` i przekazania jej `&str`, ktÃ³ry jest nastÄ™pnie dodawany jako tekstowa zawartoÅ›Ä‡ wpisu na blogu. Implementujemy to jako metodÄ™, zamiast udostÄ™pniaÄ‡ pole `content` jako `pub`, aby pÃ³Åºniej mÃ³c zaimplementowaÄ‡ metodÄ™, ktÃ³ra bÄ™dzie kontrolowaÄ‡, w jaki sposÃ³b odczytywane sÄ… dane pola `content`. Metoda `add_text` jest doÅ›Ä‡ prosta, wiÄ™c dodajmy implementacjÄ™ z Listy 18-13 do bloku `impl Post`.\n\n<figure class=\"listing\" id=\"listing-18-13\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\n# pub struct Post {\n#     state: Option<Box<dyn State>>,\n#     content: String,\n# }\n# \nimpl Post {\n    // --snip--\n#     pub fn new() -> Post {\n#         Post {\n#             state: Some(Box::new(Draft {})),\n#             content: String::new(),\n#         }\n#     }\n# \n    pub fn add_text(&mut self, text: &str) {\n        self.content.push_str(text);\n    }\n}\n# \n# trait State {}\n# \n# struct Draft {}\n# \n# impl State for Draft {}\n````\n\n<figcaption><a href=\"#listing-18-13\">Lista 18-13</a>: Implementacja metody <code>add_text</code> do dodawania tekstu do <code>content</code> wpisu</figcaption>\n</figure>\n\nMetoda `add_text` przyjmuje zmiennÄ… referencjÄ™ do `self`, poniewaÅ¼ zmieniamy instancjÄ™ `Post`, na ktÃ³rej wywoÅ‚ujemy `add_text`. NastÄ™pnie wywoÅ‚ujemy `push_str` na `String` w `content` i przekazujemy argument `text`, aby dodaÄ‡ go do zapisanej `content`. To zachowanie nie zaleÅ¼y od stanu, w jakim znajduje siÄ™ wpis, wiÄ™c nie jest czÄ™Å›ciÄ… wzorca stanu. Metoda `add_text` w ogÃ³le nie wchodzi w interakcje z polem `state`, ale jest czÄ™Å›ciÄ… zachowania, ktÃ³re chcemy wspieraÄ‡.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"ensuring-the-content-of-a-draft-post-is-empty\"></a>\n\n#### Zapewnienie, Å¼e ZawartoÅ›Ä‡ Szkicu Wpisu Jest Pusta\n\nNawet po wywoÅ‚aniu `add_text` i dodaniu treÅ›ci do naszego wpisu, nadal chcemy, aby metoda `content` zwracaÅ‚a pusty fragment ciÄ…gu, poniewaÅ¼ wpis jest nadal w stanie szkicu, jak pokazano przez pierwsze `assert_eq!` na LiÅ›cie 18-11. Na razie zaimplementujmy metodÄ™ `content` w najprostszy sposÃ³b, ktÃ³ry speÅ‚ni to wymaganie: zawsze zwracajÄ…c pusty fragment ciÄ…gu. Zmienimy to pÃ³Åºniej, gdy zaimplementujemy moÅ¼liwoÅ›Ä‡ zmiany stanu wpisu, tak aby mÃ³gÅ‚ zostaÄ‡ opublikowany. Do tej pory wpisy mogÄ… byÄ‡ tylko w stanie szkicu, wiÄ™c zawartoÅ›Ä‡ wpisu powinna byÄ‡ zawsze pusta. Lista 18-14 pokazuje tÄ™ implementacjÄ™ zastÄ™pczÄ….\n\n<figure class=\"listing\" id=\"listing-18-14\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\n# pub struct Post {\n#     state: Option<Box<dyn State>>,\n#     content: String,\n# }\n# \nimpl Post {\n    // --snip--\n#     pub fn new() -> Post {\n#         Post {\n#             state: Some(Box::new(Draft {})),\n#             content: String::new(),\n#         }\n#     }\n# \n#     pub fn add_text(&mut self, text: &str) {\n#         self.content.push_str(text);\n#     }\n# \n    pub fn content(&self) -> &str {\n        \"\"\n    }\n}\n# \n# trait State {}\n# \n# struct Draft {}\n# \n# impl State for Draft {}\n````\n\n<figcaption><a href=\"#listing-18-14\">Lista 18-14</a>: Dodanie implementacji zastÄ™pczej dla metody <code>content</code> w <code>Post</code>, ktÃ³ra zawsze zwraca pusty fragment ciÄ…gu</figcaption>\n</figure>\n\nDziÄ™ki tej dodanej metodzie `content` wszystko z Listy 18-11 aÅ¼ do pierwszego `assert_eq!` dziaÅ‚a zgodnie z przeznaczeniem.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"requesting-a-review-of-the-post-changes-its-state\"></a>\n<a id=\"requesting-a-review-changes-the-posts-state\"></a>\n\n#### Zlecenie recenzji, ktÃ³ra zmienia stan wpisu\n\nNastÄ™pnie musimy dodaÄ‡ funkcjonalnoÅ›Ä‡ do Å¼Ä…dania recenzji wpisu, co powinno zmieniÄ‡ jego stan ze `Draft` na `PendingReview`. Lista 18-15 pokazuje ten kod.\n\n<figure class=\"listing\" id=\"listing-18-15\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\n# pub struct Post {\n#     state: Option<Box<dyn State>>,\n#     content: String,\n# }\n# \nimpl Post {\n    // --snip--\n#     pub fn new() -> Post {\n#         Post {\n#             state: Some(Box::new(Draft {})),\n#             content: String::new(),\n#         }\n#     }\n# \n#     pub fn add_text(&mut self, text: &str) {\n#         self.content.push_str(text);\n#     }\n# \n#     pub fn content(&self) -> &str {\n#         \"\"\n#     }\n# \n    pub fn request_review(&mut self) {\n        if let Some(s) = self.state.take() {\n            self.state = Some(s.request_review())\n        }\n    }\n}\n\ntrait State {\n    fn request_review(self: Box<Self>) -> Box<dyn State>;\n}\n\nstruct Draft {}\n\nimpl State for Draft {\n    fn request_review(self: Box<Self>) -> Box<dyn State> {\n        Box::new(PendingReview {})\n    }\n}\n\nstruct PendingReview {}\n\nimpl State for PendingReview {\n    fn request_review(self: Box<Self>) -> Box<dyn State> {\n        self\n    }\n}\n````\n\n<figcaption><a href=\"#listing-18-15\">Lista 18-15</a>: Implementacja metod <code>request_review</code> w <code>Post</code> i cechy <code>State</code></figcaption>\n</figure>\n\nDajemy `Post` publicznÄ… metodÄ™ `request_review`, ktÃ³ra przyjmuje zmiennÄ… referencjÄ™ do `self`. NastÄ™pnie wywoÅ‚ujemy wewnÄ™trznÄ… metodÄ™ `request_review` na bieÅ¼Ä…cym stanie `Post`, a ta druga metoda `request_review` konsumuje bieÅ¼Ä…cy stan i zwraca nowy stan.\n\nDodajemy metodÄ™ `request_review` do cechy `State`; wszystkie typy, ktÃ³re implementujÄ… tÄ™ cechÄ™, bÄ™dÄ… teraz musiaÅ‚y zaimplementowaÄ‡ metodÄ™ `request_review`. ZauwaÅ¼, Å¼e zamiast `self`, `&self` lub `&mut self` jako pierwszego parametru metody, mamy `self: Box<Self>`. Ta skÅ‚adnia oznacza, Å¼e metoda jest prawidÅ‚owa tylko wtedy, gdy jest wywoÅ‚ywana na `Box` zawierajÄ…cym ten typ. Ta skÅ‚adnia przejmuje wÅ‚asnoÅ›Ä‡ `Box<Self>`, uniewaÅ¼niajÄ…c stary stan, tak aby wartoÅ›Ä‡ stanu `Post` mogÅ‚a przeksztaÅ‚ciÄ‡ siÄ™ w nowy stan.\n\nAby skonsumowaÄ‡ stary stan, metoda `request_review` musi przejÄ…Ä‡ wÅ‚asnoÅ›Ä‡ wartoÅ›ci stanu. To tutaj wchodzi w grÄ™ `Option` w polu `state` struktury `Post`: wywoÅ‚ujemy metodÄ™ `take`, aby pobraÄ‡ wartoÅ›Ä‡ `Some` z pola `state` i pozostawiÄ‡ `None` na jej miejscu, poniewaÅ¼ Rust nie pozwala nam mieÄ‡ niezapelnionych pÃ³l w strukturach. To pozwala nam przenieÅ›Ä‡ wartoÅ›Ä‡ `state` z `Post`, zamiast jej poÅ¼yczaÄ‡. NastÄ™pnie ustawimy wartoÅ›Ä‡ `state` wpisu na wynik tej operacji.\n\nMusimy tymczasowo ustawiÄ‡ `state` na `None`, zamiast ustawiaÄ‡ go bezpoÅ›rednio kodem takim jak `self.state = self.state.request_review();`, aby uzyskaÄ‡ wÅ‚asnoÅ›Ä‡ wartoÅ›ci `state`. Zapewnia to, Å¼e `Post` nie moÅ¼e uÅ¼ywaÄ‡ starej wartoÅ›ci `state` po tym, jak przeksztaÅ‚ciliÅ›my jÄ… w nowy stan.\n\nMetoda `request_review` w `Draft` zwraca nowÄ…, opakowanÄ… instancjÄ™ nowej struktury `PendingReview`, ktÃ³ra reprezentuje stan, gdy wpis oczekuje na recenzjÄ™. Struktura `PendingReview` rÃ³wnieÅ¼ implementuje metodÄ™ `request_review`, ale nie wykonuje Å¼adnych transformacji. Zamiast tego zwraca siebie, poniewaÅ¼ gdy prosimy o recenzjÄ™ wpisu, ktÃ³ry jest juÅ¼ w stanie `PendingReview`, powinien on pozostaÄ‡ w stanie `PendingReview`.\n\nTeraz moÅ¼emy zaczÄ…Ä‡ dostrzegaÄ‡ zalety wzorca stanu: metoda `request_review` w `Post` jest taka sama niezaleÅ¼nie od jej wartoÅ›ci `state`. KaÅ¼dy stan jest odpowiedzialny za wÅ‚asne reguÅ‚y.\n\nPozostawimy metodÄ™ `content` w `Post` w niezmienionej postaci, zwracajÄ…c pusty fragment ciÄ…gu. MoÅ¼emy teraz mieÄ‡ `Post` w stanie `PendingReview`, a takÅ¼e w stanie `Draft`, ale chcemy tego samego zachowania w stanie `PendingReview`. Lista 18-11 dziaÅ‚a teraz aÅ¼ do drugiego wywoÅ‚ania `assert_eq!`!\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"adding-the-approve-method-that-changes-the-behavior-of-content\"></a>\n<a id=\"adding-approve-to-change-the-behavior-of-content\"></a>\n\n#### Dodawanie `approve` w celu zmiany zachowania `content`\n\nMetoda `approve` bÄ™dzie podobna do metody `request_review`: ustawi `state` na wartoÅ›Ä‡, ktÃ³rÄ… bieÅ¼Ä…cy stan powinien mieÄ‡ po zatwierdzeniu, jak pokazano na LiÅ›cie 18-16.\n\n<figure class=\"listing\" id=\"listing-18-16\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\n# pub struct Post {\n#     state: Option<Box<dyn State>>,\n#     content: String,\n# }\n# \nimpl Post {\n    // --snip--\n#     pub fn new() -> Post {\n#         Post {\n#             state: Some(Box::new(Draft {})),\n#             content: String::new(),\n#         }\n#     }\n# \n#     pub fn add_text(&mut self, text: &str) {\n#         self.content.push_str(text);\n#     }\n# \n#     pub fn content(&self) -> &str {\n#         \"\"\n#     }\n# \n#     pub fn request_review(&mut self) {\n#         if let Some(s) = self.state.take() {\n#             self.state = Some(s.request_review())\n#         }\n#     }\n# \n    pub fn approve(&mut self) {\n        if let Some(s) = self.state.take() {\n            self.state = Some(s.approve())\n        }\n    }\n}\n\ntrait State {\n    fn request_review(self: Box<Self>) -> Box<dyn State>;\n    fn approve(self: Box<Self>) -> Box<dyn State>;\n}\n\nstruct Draft {}\n\nimpl State for Draft {\n    // --snip--\n#     fn request_review(self: Box<Self>) -> Box<dyn State> {\n#         Box::new(PendingReview {})\n#     }\n# \n    fn approve(self: Box<Self>) -> Box<dyn State> {\n        self\n    }\n}\n\nstruct PendingReview {}\n\nimpl State for PendingReview {\n    // --snip--\n#     fn request_review(self: Box<Self>) -> Box<dyn State> {\n#         self\n#     }\n# \n    fn approve(self: Box<Self>) -> Box<dyn State> {\n        Box::new(Published {})\n    }\n}\n\nstruct Published {}\n\nimpl State for Published {\n    fn request_review(self: Box<Self>) -> Box<dyn State> {\n        self\n    }\n\n    fn approve(self: Box<Self>) -> Box<dyn State> {\n        self\n    }\n}\n````\n\n<figcaption><a href=\"#listing-18-16\">Lista 18-16</a>: Implementacja metody <code>approve</code> w <code>Post</code> i cechy <code>State</code></figcaption>\n</figure>\n\nDodajemy metodÄ™ `approve` do cechy `State` i nowÄ… strukturÄ™, ktÃ³ra implementuje `State`, czyli stan `Published`.\n\nPodobnie jak dziaÅ‚a `request_review` w `PendingReview`, jeÅ›li wywoÅ‚amy metodÄ™ `approve` na `Draft`, nie bÄ™dzie to miaÅ‚o Å¼adnego efektu, poniewaÅ¼ `approve` zwrÃ³ci `self`. Kiedy wywoÅ‚amy `approve` na `PendingReview`, zwrÃ³ci nowÄ…, spakowanÄ… instancjÄ™ struktury `Published`. Struktura `Published` implementuje cechÄ™ `State`, a dla obu metod `request_review` i `approve` zwraca siebie, poniewaÅ¼ w tych przypadkach wpis powinien pozostaÄ‡ w stanie `Published`.\n\nTeraz musimy zaktualizowaÄ‡ metodÄ™ `content` w `Post`. Chcemy, aby wartoÅ›Ä‡ zwracana przez `content` zaleÅ¼aÅ‚a od bieÅ¼Ä…cego stanu `Post`, dlatego `Post` bÄ™dzie delegowaÄ‡ do metody `content` zdefiniowanej na swoim `state`, jak pokazano na LiÅ›cie 18-17.\n\n<figure class=\"listing\" id=\"listing-18-17\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,ignore,does_not_compile\n# pub struct Post {\n#     state: Option<Box<dyn State>>,\n#     content: String,\n# }\n# \nimpl Post {\n    // --snip--\n#     pub fn new() -> Post {\n#         Post {\n#             state: Some(Box::new(Draft {})),\n#             content: String::new(),\n#         }\n#     }\n# \n#     pub fn add_text(&mut self, text: &str) {\n#         self.content.push_str(text);\n#     }\n# \n    pub fn content(&self) -> &str {\n        self.state.as_ref().unwrap().content(self)\n    }\n    // --snip--\n# \n#     pub fn request_review(&mut self) {\n#         if let Some(s) = self.state.take() {\n#             self.state = Some(s.request_review())\n#         }\n#     }\n# \n#     pub fn approve(&mut self) {\n#         if let Some(s) = self.state.take() {\n#             self.state = Some(s.approve())\n#         }\n#     }\n}\n# \n# trait State {\n#     fn request_review(self: Box<Self>) -> Box<dyn State>;\n#     fn approve(self: Box<Self>) -> Box<dyn State>;\n# }\n# \n# struct Draft {}\n# \n# impl State for Draft {\n#     fn request_review(self: Box<Self>) -> Box<dyn State> {\n#         Box::new(PendingReview {})\n#     }\n# \n#     fn approve(self: Box<Self>) -> Box<dyn State> {\n#         self\n#     }\n# }\n# \n# struct PendingReview {}\n# \n# impl State for PendingReview {\n#     fn request_review(self: Box<Self>) -> Box<dyn State> {\n#         self\n#     }\n# \n#     fn approve(self: Box<Self>) -> Box<dyn State> {\n#         Box::new(Published {})\n#     }\n# }\n# \n# struct Published {}\n# \n# impl State for Published {\n#     fn request_review(self: Box<Self>) -> Box<dyn State> {\n#         self\n#     }\n# \n#     fn approve(self: Box<Self>) -> Box<dyn State> {\n#         self\n#     }\n# }\n````\n\n<figcaption><a href=\"#listing-18-17\">Lista 18-17</a>: Aktualizacja metody <code>content</code> w <code>Post</code> w celu delegowania do metody <code>content</code> w <code>State</code></figcaption>\n</figure>\n\nPoniewaÅ¼ celem jest utrzymanie wszystkich tych zasad wewnÄ…trz struktur implementujÄ…cych `State`, wywoÅ‚ujemy metodÄ™ `content` na wartoÅ›ci w `state` i przekazujemy instancjÄ™ wpisu (czyli `self`) jako argument. NastÄ™pnie zwracamy wartoÅ›Ä‡ zwrÃ³conÄ… przez uÅ¼ycie metody `content` na wartoÅ›ci `state`.\n\nWywoÅ‚ujemy metodÄ™ `as_ref` na `Option`, poniewaÅ¼ chcemy referencjÄ™ do wartoÅ›ci wewnÄ…trz `Option`, a nie wÅ‚asnoÅ›ci wartoÅ›ci. PoniewaÅ¼ `state` jest `Option<Box<dyn State>>`, po wywoÅ‚aniu `as_ref` zwracane jest `Option<&Box<dyn State>>`. GdybyÅ›my nie wywoÅ‚ali `as_ref`, otrzymalibyÅ›my bÅ‚Ä…d, poniewaÅ¼ nie moÅ¼emy przenieÅ›Ä‡ `state` poza poÅ¼yczone `&self` z parametru funkcji.\n\nNastÄ™pnie wywoÅ‚ujemy metodÄ™ `unwrap`, o ktÃ³rej wiemy, Å¼e nigdy nie spowoduje paniki, poniewaÅ¼ wiemy, Å¼e metody w `Post` zapewniajÄ…, Å¼e `state` zawsze bÄ™dzie zawieraÄ‡ wartoÅ›Ä‡ `Some` po zakoÅ„czeniu tych metod. Jest to jeden z przypadkÃ³w, o ktÃ³rych mÃ³wiliÅ›my w sekcji [â€Kiedy masz wiÄ™cej informacji niÅ¼ kompilatorâ€][more-info-than-rustc]<!-- ignore --> w Rozdziale 9, kiedy wiemy, Å¼e wartoÅ›Ä‡ `None` nigdy nie jest moÅ¼liwa, mimo Å¼e kompilator nie jest w stanie tego zrozumieÄ‡.\n\nW tym momencie, gdy wywoÅ‚amy `content` na `&Box<dyn State>`, nastÄ…pi koercja dereferencji na `&` i `Box`, tak Å¼e metoda `content` zostanie ostatecznie wywoÅ‚ana na typie, ktÃ³ry implementuje cechÄ™ `State`. Oznacza to, Å¼e musimy dodaÄ‡ `content` do definicji cechy `State`, i to tam umieÅ›cimy logikÄ™ dotyczÄ…cÄ… tego, jakÄ… zawartoÅ›Ä‡ zwrÃ³ciÄ‡ w zaleÅ¼noÅ›ci od posiadanego stanu, jak pokazano na LiÅ›cie 18-18.\n\n<figure class=\"listing\" id=\"listing-18-18\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\n# pub struct Post {\n#     state: Option<Box<dyn State>>,\n#     content: String,\n# }\n# \n# impl Post {\n#     pub fn new() -> Post {\n#         Post {\n#             state: Some(Box::new(Draft {})),\n#             content: String::new(),\n#         }\n#     }\n# \n#     pub fn add_text(&mut self, text: &str) {\n#         self.content.push_str(text);\n#     }\n# \n#     pub fn content(&self) -> &str {\n#         self.state.as_ref().unwrap().content(self)\n#     }\n# \n#     pub fn request_review(&mut self) {\n#         if let Some(s) = self.state.take() {\n#             self.state = Some(s.request_review())\n#         }\n#     }\n# \n#     pub fn approve(&mut self) {\n#         if let Some(s) = self.state.take() {\n#             self.state = Some(s.approve())\n#         }\n#     }\n# }\n# \ntrait State {\n    // --snip--\n#     fn request_review(self: Box<Self>) -> Box<dyn State>;\n#     fn approve(self: Box<Self>) -> Box<dyn State>;\n# \n    fn content<'a>(&self, post: &'a Post) -> &'a str {\n        \"\"\n    }\n}\n\n// --snip--\n# \n# struct Draft {}\n# \n# impl State for Draft {\n#     fn request_review(self: Box<Self>) -> Box<dyn State> {\n#         Box::new(PendingReview {})\n#     }\n# \n#     fn approve(self: Box<Self>) -> Box<dyn State> {\n#         self\n#     }\n# }\n# \n# struct PendingReview {}\n# \n# impl State for PendingReview {\n#     fn request_review(self: Box<Self>) -> Box<dyn State> {\n#         self\n#     }\n# \n#     fn approve(self: Box<Self>) -> Box<dyn State> {\n#         Box::new(Published {})\n#     }\n# }\n# \nstruct Published {}\n\nimpl State for Published {\n    // --snip--\n#     fn request_review(self: Box<Self>) -> Box<dyn State> {\n#         self\n#     }\n# \n#     fn approve(self: Box<Self>) -> Box<dyn State> {\n#         self\n#     }\n# \n    fn content<'a>(&self, post: &'a Post) -> &'a str {\n        &post.content\n    }\n}\n````\n\n<figcaption><a href=\"#listing-18-18\">Lista 18-18</a>: Dodanie metody <code>content</code> do cechy <code>State</code></figcaption>\n</figure>\n\nDodajemy domyÅ›lnÄ… implementacjÄ™ metody `content`, ktÃ³ra zwraca pusty fragment ciÄ…gu. Oznacza to, Å¼e nie musimy implementowaÄ‡ `content` w strukturach `Draft` i `PendingReview`. Struktura `Published` nadpisze metodÄ™ `content` i zwrÃ³ci wartoÅ›Ä‡ z `post.content`. ChoÄ‡ wygodne, posiadanie metody `content` w `State`, ktÃ³ra okreÅ›la zawartoÅ›Ä‡ `Post`, zaciera granice miÄ™dzy odpowiedzialnoÅ›ciÄ… `State` a odpowiedzialnoÅ›ciÄ… `Post`.\n\nZauwaÅ¼, Å¼e potrzebujemy adnotacji dotyczÄ…cych czasu Å¼ycia w tej metodzie, jak omÃ³wiliÅ›my w Rozdziale 10. Przyjmujemy referencjÄ™ do `post` jako argument i zwracamy referencjÄ™ do czÄ™Å›ci tego `post`, wiÄ™c czas Å¼ycia zwrÃ³conej referencji jest zwiÄ…zany z czasem Å¼ycia argumentu `post`.\n\nI gotowe â€” caÅ‚a Lista 18-11 dziaÅ‚a! ZaimplementowaliÅ›my wzorzec stanu z zasadami przepÅ‚ywu pracy wpisu na blogu. Logika zwiÄ…zana z zasadami znajduje siÄ™ w obiektach stanu, a nie jest rozproszona po `Post`.\n\n<section class=\"note\" aria-role=\"note\">\n\n\n\n### Dlaczego Nie Wyliczenie (Enum)?\n\nByÄ‡ moÅ¼e zastanawiaÅ‚eÅ› siÄ™, dlaczego nie uÅ¼yliÅ›my wyliczenia (enum) z rÃ³Å¼nymi moÅ¼liwymi stanami wpisu jako wariantami. To z pewnoÅ›ciÄ… moÅ¼liwe rozwiÄ…zanie; sprÃ³buj go i porÃ³wnaj ostateczne wyniki, aby zobaczyÄ‡, ktÃ³re wolisz! JednÄ… z wad uÅ¼ywania wyliczenia jest to, Å¼e kaÅ¼de miejsce, ktÃ³re sprawdza wartoÅ›Ä‡ wyliczenia, bÄ™dzie potrzebowaÅ‚o wyraÅ¼enia `match` lub podobnego, aby obsÅ‚uÅ¼yÄ‡ kaÅ¼dy moÅ¼liwy wariant. To mogÅ‚oby staÄ‡ siÄ™ bardziej powtarzalne niÅ¼ to rozwiÄ…zanie z obiektem cechy.\n\n</section>\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"trade-offs-of-the-state-pattern\"></a>\n\n#### Ocena Wzorca Stanu\n\nPokazaliÅ›my, Å¼e Rust jest zdolny do implementacji obiektowo zorientowanego wzorca stanu w celu hermetyzacji rÃ³Å¼nych rodzajÃ³w zachowaÅ„, jakie powinien mieÄ‡ wpis w kaÅ¼dym stanie. Metody w `Post` nic nie wiedzÄ… o rÃ³Å¼nych zachowaniach. DziÄ™ki temu, jak zorganizowaliÅ›my kod, musimy patrzeÄ‡ tylko w jedno miejsce, aby poznaÄ‡ rÃ³Å¼ne sposoby zachowania opublikowanego wpisu: implementacjÄ™ cechy `State` na strukturze `Published`.\n\nGdybyÅ›my stworzyli alternatywnÄ… implementacjÄ™, ktÃ³ra nie uÅ¼ywaÅ‚aby wzorca stanu, moglibyÅ›my zamiast tego uÅ¼yÄ‡ wyraÅ¼eÅ„ `match` w metodach w `Post` lub nawet w kodzie `main`, ktÃ³ry sprawdza stan wpisu i zmienia zachowanie w tych miejscach. OznaczaÅ‚oby to, Å¼e musielibyÅ›my patrzeÄ‡ w kilku miejscach, aby zrozumieÄ‡ wszystkie implikacje bycia w stanie opublikowanym.\n\nPrzy uÅ¼yciu wzorca stanu, metody `Post` i miejsca, w ktÃ³rych uÅ¼ywamy `Post`, nie potrzebujÄ… wyraÅ¼eÅ„ `match`, a aby dodaÄ‡ nowy stan, wystarczyÅ‚oby dodaÄ‡ nowÄ… strukturÄ™ i zaimplementowaÄ‡ metody cech na tej jednej strukturze w jednym miejscu.\n\nImplementacja wykorzystujÄ…ca wzorzec stanu jest Å‚atwa do rozszerzenia o dodatkowÄ… funkcjonalnoÅ›Ä‡. Aby zobaczyÄ‡ prostotÄ™ utrzymywania kodu, ktÃ³ry uÅ¼ywa wzorca stanu, wyprÃ³buj kilka z tych sugestii:\n\n* Dodaj metodÄ™ `reject`, ktÃ³ra zmienia stan wpisu z `PendingReview` z powrotem na `Draft`.\n* Wymagaj dwÃ³ch wywoÅ‚aÅ„ `approve`, zanim stan bÄ™dzie mÃ³gÅ‚ zostaÄ‡ zmieniony na `Published`.\n* Zezwalaj uÅ¼ytkownikom na dodawanie treÅ›ci tekstowej tylko wtedy, gdy wpis jest w stanie `Draft`.\n  WskazÃ³wka: niech obiekt stanu bÄ™dzie odpowiedzialny za to, co moÅ¼e siÄ™ zmieniÄ‡ w treÅ›ci, ale nie za modyfikowanie `Post`.\n\nJednÄ… z wad wzorca stanu jest to, Å¼e poniewaÅ¼ stany implementujÄ… przejÅ›cia miÄ™dzy stanami, niektÃ³re stany sÄ… ze sobÄ… powiÄ…zane. GdybyÅ›my dodali inny stan miÄ™dzy `PendingReview` a `Published`, taki jak `Scheduled`, musielibyÅ›my zmieniÄ‡ kod w `PendingReview`, aby przejÅ›Ä‡ do `Scheduled`. ByÅ‚oby to mniej pracy, gdyby `PendingReview` nie wymagaÅ‚o zmian wraz z dodaniem nowego stanu, ale to oznaczaÅ‚oby przejÅ›cie na inny wzorzec projektowy.\n\nInnÄ… wadÄ… jest to, Å¼e powieliliÅ›my trochÄ™ logiki. Aby wyeliminowaÄ‡ czÄ™Å›Ä‡ powtÃ³rzeÅ„, moglibyÅ›my sprÃ³bowaÄ‡ stworzyÄ‡ domyÅ›lne implementacje dla metod `request_review` i `approve` w cechy `State`, ktÃ³re zwracajÄ… `self`. Jednak to by nie zadziaÅ‚aÅ‚o: uÅ¼ywajÄ…c `State` jako obiektu cechy, cecha nie wie dokÅ‚adnie, czym bÄ™dzie konkretny `self`, wiÄ™c typ zwracany nie jest znany w czasie kompilacji. (To jedna z wczeÅ›niej wspomnianych reguÅ‚ kompatybilnoÅ›ci `dyn`).\n\nInne powtÃ³rzenia obejmujÄ… podobne implementacje metod `request_review` i `approve` w `Post`. Obie metody uÅ¼ywajÄ… `Option::take` z polem `state` z `Post`, a jeÅ›li `state` jest `Some`, delegujÄ… do implementacji tej samej metody przez owiniÄ™tÄ… wartoÅ›Ä‡ i ustawiajÄ… nowÄ… wartoÅ›Ä‡ pola `state` na wynik. GdybyÅ›my mieli wiele metod w `Post`, ktÃ³re postÄ™powaÅ‚yby zgodnie z tym wzorcem, moglibyÅ›my rozwaÅ¼yÄ‡ zdefiniowanie makra, aby wyeliminowaÄ‡ powtÃ³rzenia (patrz sekcja [â€Makrodefinicjeâ€][macros]<!-- ignore --> w Rozdziale 20).\n\nImplementujÄ…c wzorzec stanu dokÅ‚adnie tak, jak jest zdefiniowany dla jÄ™zykÃ³w zorientowanych obiektowo, nie wykorzystujemy w peÅ‚ni mocnych stron Rust. Przyjrzyjmy siÄ™ kilku zmianom, ktÃ³re moÅ¼emy wprowadziÄ‡ w bibliotece `blog`, aby nieprawidÅ‚owe stany i przejÅ›cia staÅ‚y siÄ™ bÅ‚Ä™dami w czasie kompilacji.\n\n### Kodowanie StanÃ³w i Zachowania jako Typy\n\nPokaÅ¼emy, jak przemyÅ›leÄ‡ wzorzec stanu, aby uzyskaÄ‡ inny zestaw kompromisÃ³w. Zamiast caÅ‚kowicie hermetyzowaÄ‡ stany i przejÅ›cia, tak aby zewnÄ™trzny kod nie miaÅ‚ o nich wiedzy, zakodujemy stany w rÃ³Å¼nych typach. W konsekwencji system sprawdzania typÃ³w Rust zapobiegnie prÃ³bom uÅ¼ycia szkicÃ³w wpisÃ³w tam, gdzie dozwolone sÄ… tylko opublikowane wpisy, zgÅ‚aszajÄ…c bÅ‚Ä…d kompilacji.\n\nRozwaÅ¼my pierwszÄ… czÄ™Å›Ä‡ `main` na LiÅ›cie 18-11:\n\n<figure class=\"listing\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore\n# use blog::Post;\n# \nfn main() {\n    let mut post = Post::new();\n\n    post.add_text(\"I ate a salad for lunch today\");\n    assert_eq!(\"\", post.content());\n# \n#     post.request_review();\n#     assert_eq!(\"\", post.content());\n# \n#     post.approve();\n#     assert_eq!(\"I ate a salad for lunch today\", post.content());\n}\n````\n\n</figure>\n\nDalej umoÅ¼liwiamy tworzenie nowych wpisÃ³w w stanie szkicu za pomocÄ… `Post::new` oraz moÅ¼liwoÅ›Ä‡ dodawania tekstu do treÅ›ci wpisu. Ale zamiast mieÄ‡ metodÄ™ `content` w szkicu wpisu, ktÃ³ra zwraca pusty ciÄ…g, sprawimy, Å¼e szkice wpisÃ³w w ogÃ³le nie bÄ™dÄ… miaÅ‚y metody `content`. W ten sposÃ³b, jeÅ›li sprÃ³bujemy uzyskaÄ‡ treÅ›Ä‡ szkicu wpisu, otrzymamy bÅ‚Ä…d kompilatora informujÄ…cy nas, Å¼e metoda nie istnieje. W rezultacie niemoÅ¼liwe bÄ™dzie przypadkowe wyÅ›wietlenie treÅ›ci szkicu wpisu w produkcji, poniewaÅ¼ ten kod nawet siÄ™ nie skompiluje. Lista 18-19 pokazuje definicjÄ™ struktury `Post` i struktury `DraftPost`, a takÅ¼e metody na kaÅ¼dej z nich.\n\n<figure class=\"listing\" id=\"listing-18-19\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\npub struct Post {\n    content: String,\n}\n\npub struct DraftPost {\n    content: String,\n}\n\nimpl Post {\n    pub fn new() -> DraftPost {\n        DraftPost {\n            content: String::new(),\n        }\n    }\n\n    pub fn content(&self) -> &str {\n        &self.content\n    }\n}\n\nimpl DraftPost {\n    pub fn add_text(&mut self, text: &str) {\n        self.content.push_str(text);\n    }\n}\n````\n\n<figcaption><a href=\"#listing-18-19\">Lista 18-19</a>: <code>Post</code> z metodÄ… <code>content</code> i <code>DraftPost</code> bez metody <code>content</code></figcaption>\n</figure>\n\nZarÃ³wno struktury `Post`, jak i `DraftPost` majÄ… prywatne pole `content`, ktÃ³re przechowuje tekst wpisu na blogu. Struktury nie majÄ… juÅ¼ pola `state`, poniewaÅ¼ przenosimy kodowanie stanu do typÃ³w struktur. Struktura `Post` bÄ™dzie reprezentowaÄ‡ opublikowany wpis i ma metodÄ™ `content`, ktÃ³ra zwraca `content`.\n\nDalej mamy funkcjÄ™ `Post::new`, ale zamiast zwracaÄ‡ instancjÄ™ `Post`, zwraca instancjÄ™ `DraftPost`. PoniewaÅ¼ `content` jest prywatne i nie ma Å¼adnych funkcji zwracajÄ…cych `Post`, obecnie nie jest moÅ¼liwe utworzenie instancji `Post`.\n\nStruktura `DraftPost` posiada metodÄ™ `add_text`, wiÄ™c moÅ¼emy dodawaÄ‡ tekst do `content` tak jak wczeÅ›niej, ale zauwaÅ¼, Å¼e `DraftPost` nie ma zdefiniowanej metody `content`! Teraz program zapewnia, Å¼e wszystkie wpisy zaczynajÄ… siÄ™ jako szkice wpisÃ³w, a szkice wpisÃ³w nie majÄ… dostÄ™pnej treÅ›ci do wyÅ›wietlenia. KaÅ¼da prÃ³ba obejÅ›cia tych ograniczeÅ„ spowoduje bÅ‚Ä…d kompilatora.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"implementing-transitions-as-transformations-into-different-types\"></a>\n\nWiÄ™c jak zdobyÄ‡ opublikowany wpis? Chcemy wymusiÄ‡ zasadÄ™, Å¼e szkic wpisu musi zostaÄ‡ zrecenzowany i zatwierdzony, zanim zostanie opublikowany. Wpis w stanie oczekiwania na recenzjÄ™ nadal nie powinien wyÅ›wietlaÄ‡ Å¼adnej treÅ›ci. Zaimplementujmy te ograniczenia, dodajÄ…c kolejnÄ… strukturÄ™, `PendingReviewPost`, definiujÄ…c metodÄ™ `request_review` w `DraftPost`, aby zwracaÅ‚a `PendingReviewPost`, i definiujÄ…c metodÄ™ `approve` w `PendingReviewPost`, aby zwracaÅ‚a `Post`, jak pokazano na LiÅ›cie 18-20.\n\n<figure class=\"listing\" id=\"listing-18-20\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\n# pub struct Post {\n#     content: String,\n# }\n# \n# pub struct DraftPost {\n#     content: String,\n# }\n# \n# impl Post {\n#     pub fn new() -> DraftPost {\n#         DraftPost {\n#             content: String::new(),\n#         }\n#     }\n# \n#     pub fn content(&self) -> &str {\n#         &self.content\n#     }\n# }\n# \nimpl DraftPost {\n    // --snip--\n#     pub fn add_text(&mut self, text: &str) {\n#         self.content.push_str(text);\n#     }\n# \n    pub fn request_review(self) -> PendingReviewPost {\n        PendingReviewPost {\n            content: self.content,\n        }\n    }\n}\n\npub struct PendingReviewPost {\n    content: String,\n}\n\nimpl PendingReviewPost {\n    pub fn approve(self) -> Post {\n        Post {\n            content: self.content,\n        }\n    }\n}\n````\n\n<figcaption><a href=\"#listing-18-20\">Lista 18-20</a>: Struktura <code>PendingReviewPost</code>, ktÃ³ra jest tworzona poprzez wywoÅ‚anie <code>request_review</code> na <code>DraftPost</code>, oraz metoda <code>approve</code>, ktÃ³ra zamienia <code>PendingReviewPost</code> w opublikowany <code>Post</code></figcaption>\n</figure>\n\nMetody `request_review` i `approve` przejmujÄ… wÅ‚asnoÅ›Ä‡ `self`, konsumujÄ…c w ten sposÃ³b instancje `DraftPost` i `PendingReviewPost` i przeksztaÅ‚cajÄ…c je odpowiednio w `PendingReviewPost` i opublikowany `Post`. W ten sposÃ³b nie bÄ™dziemy mieÄ‡ Å¼adnych pozostaÅ‚ych instancji `DraftPost` po wywoÅ‚aniu na nich `request_review` i tak dalej. Struktura `PendingReviewPost` nie ma zdefiniowanej metody `content`, wiÄ™c prÃ³ba odczytania jej treÅ›ci skutkuje bÅ‚Ä™dem kompilacji, podobnie jak w przypadku `DraftPost`. PoniewaÅ¼ jedynym sposobem na uzyskanie opublikowanej instancji `Post`, ktÃ³ra ma zdefiniowanÄ… metodÄ™ `content`, jest wywoÅ‚anie metody `approve` na `PendingReviewPost`, a jedynym sposobem na uzyskanie `PendingReviewPost` jest wywoÅ‚anie metody `request_review` na `DraftPost`, zakodowaliÅ›my teraz przepÅ‚yw pracy wpisu na blogu w systemie typÃ³w.\n\nMusimy jednak wprowadziÄ‡ rÃ³wnieÅ¼ niewielkie zmiany w `main`. Metody `request_review` i `approve` zwracajÄ… nowe instancje zamiast modyfikowaÄ‡ strukturÄ™, na ktÃ³rej sÄ… wywoÅ‚ywane, wiÄ™c musimy dodaÄ‡ wiÄ™cej przypisaÅ„ `let post =` w celu zapisania zwrÃ³conych instancji. Nie moÅ¼emy teÅ¼ mieÄ‡ asercji dotyczÄ…cych pustych ciÄ…gÃ³w w treÅ›ci szkicÃ³w i wpisÃ³w oczekujÄ…cych na recenzjÄ™, ani ich nie potrzebujemy: nie moÅ¼emy juÅ¼ skompilowaÄ‡ kodu, ktÃ³ry prÃ³buje uÅ¼yÄ‡ treÅ›ci wpisÃ³w w tych stanach. Zaktualizowany kod w `main` pokazano na LiÅ›cie 18-21.\n\n<figure class=\"listing\" id=\"listing-18-21\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore\nuse blog::Post;\n\nfn main() {\n    let mut post = Post::new();\n\n    post.add_text(\"I ate a salad for lunch today\");\n\n    let post = post.request_review();\n\n    let post = post.approve();\n\n    assert_eq!(\"I ate a salad for lunch today\", post.content());\n}\n````\n\n<figcaption><a href=\"#listing-18-21\">Lista 18-21</a>: Modyfikacje w <code>main</code> w celu uÅ¼ycia nowej implementacji przepÅ‚ywu pracy wpisu na blogu</figcaption>\n</figure>\n\nZmiany, ktÃ³re musieliÅ›my wprowadziÄ‡ w `main`, aby ponownie przypisaÄ‡ `post`, oznaczajÄ…, Å¼e ta implementacja nie do koÅ„ca juÅ¼ odpowiada wzorcowi stanu zorientowanemu obiektowo: transformacje miÄ™dzy stanami nie sÄ… juÅ¼ w peÅ‚ni hermetyzowane w implementacji `Post`. Jednak naszym zyskiem jest to, Å¼e nieprawidÅ‚owe stany sÄ… teraz niemoÅ¼liwe dziÄ™ki systemowi typÃ³w i sprawdzaniu typÃ³w, ktÃ³re odbywa siÄ™ w czasie kompilacji! To zapewnia, Å¼e pewne bÅ‚Ä™dy, takie jak wyÅ›wietlanie treÅ›ci nieopublikowanego wpisu, zostanÄ… wykryte, zanim trafiÄ… do produkcji.\n\nWyprÃ³buj zadania sugerowane na poczÄ…tku tej sekcji na bibliotece `blog` w stanie po LiÅ›cie 18-21, aby zobaczyÄ‡, co myÅ›lisz o projekcie tej wersji kodu. ZauwaÅ¼, Å¼e niektÃ³re zadania mogÄ… byÄ‡ juÅ¼ ukoÅ„czone w tym projekcie.\n\nWidzieliÅ›my, Å¼e chociaÅ¼ Rust jest w stanie implementowaÄ‡ obiektowo zorientowane wzorce projektowe, inne wzorce, takie jak kodowanie stanu w systemie typÃ³w, sÄ… rÃ³wnieÅ¼ dostÄ™pne w Rust. Te wzorce majÄ… rÃ³Å¼ne kompromisy. ChociaÅ¼ moÅ¼esz byÄ‡ bardzo zaznajomiony z obiektowo zorientowanymi wzorcami, ponowne przemyÅ›lenie problemu w celu wykorzystania funkcji Rust moÅ¼e przynieÅ›Ä‡ korzyÅ›ci, takie jak zapobieganie niektÃ³rym bÅ‚Ä™dom w czasie kompilacji. Wzorce obiektowo zorientowane nie zawsze bÄ™dÄ… najlepszym rozwiÄ…zaniem w Rust ze wzglÄ™du na pewne cechy, takie jak wÅ‚asnoÅ›Ä‡, ktÃ³rych jÄ™zyki obiektowo zorientowane nie posiadajÄ….\n\n## Podsumowanie\n\nNiezaleÅ¼nie od tego, czy uwaÅ¼asz Rust za jÄ™zyk obiektowy po przeczytaniu tego rozdziaÅ‚u, wiesz juÅ¼, Å¼e moÅ¼esz uÅ¼ywaÄ‡ obiektÃ³w cech, aby uzyskaÄ‡ niektÃ³re cechy obiektowe w Rust. Dynamiczne wysyÅ‚anie moÅ¼e zapewniÄ‡ Twojemu kodowi pewnÄ… elastycznoÅ›Ä‡ w zamian za niewielki koszt wydajnoÅ›ci w czasie wykonania. MoÅ¼esz wykorzystaÄ‡ tÄ™ elastycznoÅ›Ä‡ do implementacji obiektowych wzorcÃ³w, ktÃ³re mogÄ… pomÃ³c w utrzymaniu kodu. Rust ma rÃ³wnieÅ¼ inne cechy, takie jak wÅ‚asnoÅ›Ä‡, ktÃ³rych jÄ™zyki obiektowe nie majÄ…. Wzorzec obiektowy nie zawsze bÄ™dzie najlepszym sposobem na wykorzystanie mocnych stron Rust, ale jest to dostÄ™pna opcja.\n\nNastÄ™pnie przyjrzymy siÄ™ wzorcom, ktÃ³re sÄ… kolejnÄ… z funkcji Rust, ktÃ³re umoÅ¼liwiajÄ… duÅ¼Ä… elastycznoÅ›Ä‡. PrzyglÄ…daliÅ›my siÄ™ im krÃ³tko w caÅ‚ej ksiÄ…Å¼ce, ale nie widzieliÅ›my jeszcze ich peÅ‚nych moÅ¼liwoÅ›ci. Zacznijmy!\n\n[more-info-than-rustc]: ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler\n[macros]: ch20-05-macros.html#macros",
        "chapter_title": "Implementacja Obiektowo Zorientowanego Wzorca Projektowego"
    },
    {
        "file_path": "ch19-00-patterns.md",
        "content": "# Wzorce i Dopasowywanie\n\nWzorce to specjalna skÅ‚adnia w Rust sÅ‚uÅ¼Ä…ca do dopasowywania struktury typÃ³w, zarÃ³wno zÅ‚oÅ¼onych, jak i prostych. UÅ¼ywanie wzorcÃ³w w poÅ‚Ä…czeniu z wyraÅ¼eniami `match` i innymi konstrukcjami daje wiÄ™kszÄ… kontrolÄ™ nad przepÅ‚ywem sterowania programu. Wzorzec skÅ‚ada siÄ™ z pewnej kombinacji nastÄ™pujÄ…cych elementÃ³w:\n\n* LiteraÅ‚y\n* Zdekonstruowane tablice, wyliczenia, struktury lub krotki\n* Zmienne\n* Symbole wieloznaczne\n* ZastÄ™pcze miejsca\n\nPrzykÅ‚adowe wzorce to `x`, `(a, 3)` i `Some(Color::Red)`. W kontekstach, w ktÃ³rych wzorce sÄ… prawidÅ‚owe, te komponenty opisujÄ… ksztaÅ‚t danych. Nasz program dopasowuje wartoÅ›ci do wzorcÃ³w, aby okreÅ›liÄ‡, czy ma prawidÅ‚owy ksztaÅ‚t danych do kontynuowania wykonywania okreÅ›lonego fragmentu kodu.\n\nAby uÅ¼yÄ‡ wzorca, porÃ³wnujemy go z pewnÄ… wartoÅ›ciÄ…. JeÅ›li wzorzec pasuje do wartoÅ›ci, uÅ¼ywamy czÄ™Å›ci wartoÅ›ci w naszym kodzie. Przypomnij sobie wyraÅ¼enia `match` z RozdziaÅ‚u 6, ktÃ³re uÅ¼ywaÅ‚y wzorcÃ³w, takie jak przykÅ‚ad maszyny do sortowania monet. JeÅ›li wartoÅ›Ä‡ pasuje do ksztaÅ‚tu wzorca, moÅ¼emy uÅ¼yÄ‡ nazwanych elementÃ³w. JeÅ›li nie, kod powiÄ…zany ze wzorcem nie zostanie uruchomiony.\n\nTen rozdziaÅ‚ jest referencjÄ… do wszystkiego, co zwiÄ…zane ze wzorcami. OmÃ³wimy prawidÅ‚owe miejsca uÅ¼ycia wzorcÃ³w, rÃ³Å¼nicÄ™ miÄ™dzy wzorcami odrzucalnymi i nieodrzucalnymi oraz rÃ³Å¼ne rodzaje skÅ‚adni wzorcÃ³w, ktÃ³re moÅ¼esz zobaczyÄ‡. Pod koniec rozdziaÅ‚u bÄ™dziesz wiedzieÄ‡, jak uÅ¼ywaÄ‡ wzorcÃ³w do wyraÅ¼ania wielu koncepcji w jasny sposÃ³b.",
        "chapter_title": "Wzorce i Dopasowywanie"
    },
    {
        "file_path": "ch19-01-all-the-places-for-patterns.md",
        "content": "## Wszystkie Miejsca, w KtÃ³rych MoÅ¼na UÅ¼ywaÄ‡ WzorcÃ³w\n\nWzorce pojawiajÄ… siÄ™ w wielu miejscach w Rust, a Ty uÅ¼ywaÅ‚eÅ› ich wiele razy, nie zdajÄ…c sobie z tego sprawy! Ta sekcja omawia wszystkie miejsca, w ktÃ³rych wzorce sÄ… prawidÅ‚owe.\n\n### Ramiona `match`\n\nJak omÃ³wiono w Rozdziale 6, uÅ¼ywamy wzorcÃ³w w ramionach wyraÅ¼eÅ„ `match`. Formalnie wyraÅ¼enia `match` sÄ… definiowane jako sÅ‚owo kluczowe `match`, wartoÅ›Ä‡ do dopasowania i jedno lub wiÄ™cej ramion dopasowania, ktÃ³re skÅ‚adajÄ… siÄ™ ze wzorca i wyraÅ¼enia do uruchomienia, jeÅ›li wartoÅ›Ä‡ pasuje do wzorca tego ramienia, w ten sposÃ³b:\n\n<!--\n  Manually formatted rather than using Markdown intentionally: Markdown does not\n  support italicizing code in the body of a block like this!\n-->\n\n<pre><code>match <em>WARTOÅšÄ†</em> {\n    <em>WZORZEC</em> => <em>WYRAÅ»ENIE</em>,\n    <em>WZORZEC</em> => <em>WYRAÅ»ENIE</em>,\n    <em>WZORZEC</em> => <em>WYRAÅ»ENIE</em>,\n}</code></pre>\n\nNa przykÅ‚ad, oto wyraÅ¼enie `match` z Listy 6-5, ktÃ³re dopasowuje wartoÅ›Ä‡ `Option<i32>` w zmiennej `x`:\n\n````rust,ignore\nmatch x {\n    None => None,\n    Some(i) => Some(i + 1),\n}\n````\n\nWzorce w tym wyraÅ¼eniu `match` to `None` i `Some(i)` po lewej stronie kaÅ¼dej strzaÅ‚ki.\n\nJednym z wymagaÅ„ dla wyraÅ¼eÅ„ `match` jest to, Å¼e muszÄ… byÄ‡ wyczerpujÄ…ce w tym sensie, Å¼e wszystkie moÅ¼liwoÅ›ci dla wartoÅ›ci w wyraÅ¼eniu `match` muszÄ… byÄ‡ uwzglÄ™dnione. Jednym ze sposobÃ³w zapewnienia, Å¼e pokryÅ‚eÅ› kaÅ¼dÄ… moÅ¼liwoÅ›Ä‡, jest posiadanie wzorca catch-all dla ostatniego ramienia: na przykÅ‚ad nazwa zmiennej pasujÄ…ca do dowolnej wartoÅ›ci nigdy nie moÅ¼e siÄ™ nie powieÅ›Ä‡ i tym samym pokrywa kaÅ¼dy pozostaÅ‚y przypadek.\n\nKonkretny wzorzec `_` pasuje do wszystkiego, ale nigdy nie wiÄ…Å¼e siÄ™ ze zmiennÄ…, wiÄ™c czÄ™sto jest uÅ¼ywany w ostatnim ramieniu `match`. Wzorzec `_` moÅ¼e byÄ‡ uÅ¼yteczny, gdy chcesz zignorowaÄ‡ dowolnÄ… nieokreÅ›lonÄ… wartoÅ›Ä‡, na przykÅ‚ad. OmÃ³wimy wzorzec `_` bardziej szczegÃ³Å‚owo w sekcji [â€Ignorowanie wartoÅ›ci we wzorcuâ€][ignoring-values-in-a-pattern]<!-- ignore --> w dalszej czÄ™Å›ci tego rozdziaÅ‚u.\n\n### Instrukcje `let`\n\nPrzed tym rozdziaÅ‚em jawnie omawialiÅ›my uÅ¼ywanie wzorcÃ³w tylko z `match` i `if let`, ale w rzeczywistoÅ›ci uÅ¼ywaliÅ›my wzorcÃ³w rÃ³wnieÅ¼ w innych miejscach, w tym w instrukcjach `let`. Na przykÅ‚ad, rozwaÅ¼ to proste przypisanie zmiennej za pomocÄ… `let`:\n\n````rust\nlet x = 5;\n````\n\nZa kaÅ¼dym razem, gdy uÅ¼ywaÅ‚eÅ› instrukcji `let` w ten sposÃ³b, uÅ¼ywaÅ‚eÅ› wzorcÃ³w, chociaÅ¼ mogÅ‚eÅ› tego nie zdawaÄ‡ sobie sprawy! Bardziej formalnie, instrukcja `let` wyglÄ…da tak:\n\n<!--\n  Manually formatted rather than using Markdown intentionally: Markdown does not\n  support italicizing code in the body of a block like this!\n-->\n\n<pre>\n<code>let <em>WZORZEC</em> = <em>WYRAÅ»ENIE</em>;</code>\n</pre>\n\nW instrukcjach takich jak `let x = 5;` z nazwÄ… zmiennej w miejscu PATTERN, nazwa zmiennej jest po prostu szczegÃ³lnie prostÄ… formÄ… wzorca. Rust porÃ³wnuje wyraÅ¼enie ze wzorcem i przypisuje wszystkie znalezione nazwy. Tak wiÄ™c, w przykÅ‚adzie `let x = 5;`, `x` jest wzorcem, ktÃ³ry oznacza â€zwiÄ…Å¼ to, co pasuje tutaj, ze zmiennÄ… `x`â€. PoniewaÅ¼ nazwa `x` jest caÅ‚ym wzorcem, ten wzorzec skutecznie oznacza â€zwiÄ…Å¼ wszystko ze zmiennÄ… `x`, niezaleÅ¼nie od wartoÅ›ciâ€.\n\nAby wyraÅºniej zobaczyÄ‡ aspekt dopasowywania wzorcÃ³w w `let`, rozwaÅ¼ ListÄ™ 19-1, ktÃ³ra uÅ¼ywa wzorca z `let` do dekonstrukcji krotki.\n\n<figure class=\"listing\" id=\"listing-19-1\">\n\n````rust\n# fn main() {\n    let (x, y, z) = (1, 2, 3);\n# }\n````\n\n<figcaption><a href=\"#listing-19-1\">Lista 19-1</a>: UÅ¼ycie wzorca do dekonstrukcji krotki i jednoczesnego utworzenia trzech zmiennych</figcaption>\n</figure>\n\nTutaj dopasowujemy krotkÄ™ do wzorca. Rust porÃ³wnuje wartoÅ›Ä‡ `(1, 2, 3)` ze wzorcem `(x, y, z)` i widzi, Å¼e wartoÅ›Ä‡ pasuje do wzorca â€” to znaczy, widzi, Å¼e liczba elementÃ³w jest taka sama w obu â€” wiÄ™c Rust wiÄ…Å¼e `1` z `x`, `2` z `y` i `3` z `z`. MoÅ¼esz myÅ›leÄ‡ o tym wzorcu krotki jako o zagnieÅ¼dÅ¼eniu w nim trzech pojedynczych wzorcÃ³w zmiennych.\n\nJeÅ›li liczba elementÃ³w we wzorcu nie odpowiada liczbie elementÃ³w w krotce, ogÃ³lny typ nie bÄ™dzie pasowaÅ‚ i otrzymamy bÅ‚Ä…d kompilacji. Na przykÅ‚ad, Lista 19-2 pokazuje prÃ³bÄ™ dekompozycji krotki z trzema elementami na dwie zmienne, co nie zadziaÅ‚a.\n\n<figure class=\"listing\" id=\"listing-19-2\">\n\n````rust,ignore,does_not_compile\n# fn main() {\n    let (x, y) = (1, 2, 3);\n# }\n````\n\n<figcaption><a href=\"#listing-19-2\">Lista 19-2</a>: NieprawidÅ‚owe konstruowanie wzorca, ktÃ³rego zmienne nie pasujÄ… do liczby elementÃ³w w krotce</figcaption>\n</figure>\n\nPrÃ³ba skompilowania tego kodu skutkuje bÅ‚Ä™dem typu:\n\n````console\n$ cargo run\n   Compiling patterns v0.1.0 (file:///projects/patterns)\nerror[E0308]: mismatched types\n --> src/main.rs:2:9\n  |\n2 |     let (x, y) = (1, 2, 3);\n  |         ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`\n  |         |\n  |         expected a tuple with 3 elements, found one with 2 elements\n  |\n  = note: expected tuple `({integer}, {integer}, {integer})`\n             found tuple `(_, _)`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `patterns` (bin \"patterns\") due to 1 previous error\n````\n\nAby naprawiÄ‡ bÅ‚Ä…d, moglibyÅ›my zignorowaÄ‡ jednÄ… lub wiÄ™cej wartoÅ›ci w krotce za pomocÄ… `_` lub `..`, jak zobaczysz w sekcji [â€Ignorowanie wartoÅ›ci we wzorcuâ€][ignoring-values-in-a-pattern]<!-- ignore -->. JeÅ›li problem polega na tym, Å¼e mamy zbyt wiele zmiennych we wzorcu, rozwiÄ…zaniem jest dopasowanie typÃ³w poprzez usuniÄ™cie zmiennych, tak aby liczba zmiennych byÅ‚a rÃ³wna liczbie elementÃ³w w krotce.\n\n### Warunkowe WyraÅ¼enia `if let`\n\nW Rozdziale 6 omÃ³wiliÅ›my, jak uÅ¼ywaÄ‡ wyraÅ¼eÅ„ `if let` gÅ‚Ã³wnie jako krÃ³tszego sposobu na zapisanie odpowiednika `match`, ktÃ³ry pasuje tylko do jednego przypadku. Opcjonalnie, `if let` moÅ¼e mieÄ‡ odpowiadajÄ…cy mu `else` zawierajÄ…cy kod do uruchomienia, jeÅ›li wzorzec w `if let` nie pasuje.\n\nLista 19-3 pokazuje, Å¼e moÅ¼liwe jest rÃ³wnieÅ¼ mieszanie i dopasowywanie wyraÅ¼eÅ„ `if let`, `else if` i `else if let`. DziaÅ‚anie to daje nam wiÄ™kszÄ… elastycznoÅ›Ä‡ niÅ¼ wyraÅ¼enie `match`, w ktÃ³rym moÅ¼emy wyraziÄ‡ tylko jednÄ… wartoÅ›Ä‡ do porÃ³wnania ze wzorcami. Ponadto Rust nie wymaga, aby warunki w serii ramion `if let`, `else if` i `else if let` byÅ‚y ze sobÄ… powiÄ…zane.\n\nKod na LiÅ›cie 19-3 okreÅ›la kolor tÅ‚a na podstawie serii sprawdzeÅ„ kilku warunkÃ³w. W tym przykÅ‚adzie stworzyliÅ›my zmienne z zakodowanymi na staÅ‚e wartoÅ›ciami, ktÃ³re w rzeczywistym programie mogÅ‚yby pochodziÄ‡ z danych wejÅ›ciowych uÅ¼ytkownika.\n\n<figure class=\"listing\" id=\"listing-19-3\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\nfn main() {\n    let favorite_color: Option<&str> = None;\n    let is_tuesday = false;\n    let age: Result<u8, _> = \"34\".parse();\n\n    if let Some(color) = favorite_color {\n        println!(\"Using your favorite color, {color}, as the background\");\n    } else if is_tuesday {\n        println!(\"Tuesday is green day!\");\n    } else if let Ok(age) = age {\n        if age > 30 {\n            println!(\"Using purple as the background color\");\n        } else {\n            println!(\"Using orange as the background color\");\n        }\n    } else {\n        println!(\"Using blue as the background color\");\n    }\n}\n````\n\n<figcaption><a href=\"#listing-19-3\">Lista 19-3</a>: Mieszanie <code>if let</code>, <code>else if</code>, <code>else if let</code> i <code>else</code></figcaption>\n</figure>\n\nJeÅ›li uÅ¼ytkownik okreÅ›li ulubiony kolor, ten kolor zostanie uÅ¼yty jako tÅ‚o. JeÅ›li nie okreÅ›lono ulubionego koloru i dziÅ› jest wtorek, kolor tÅ‚a jest zielony. W przeciwnym razie, jeÅ›li uÅ¼ytkownik poda swÃ³j wiek jako ciÄ…g znakÃ³w i uda nam siÄ™ go poprawnie sparsowaÄ‡ jako liczbÄ™, kolor bÄ™dzie fioletowy lub pomaraÅ„czowy w zaleÅ¼noÅ›ci od wartoÅ›ci liczby. JeÅ›li Å¼aden z tych warunkÃ³w nie zostanie speÅ‚niony, kolor tÅ‚a bÄ™dzie niebieski.\n\nTa struktura warunkowa pozwala nam obsÅ‚ugiwaÄ‡ zÅ‚oÅ¼one wymagania. Z zakodowanymi na staÅ‚e wartoÅ›ciami, ten przykÅ‚ad wydrukuje `Using purple as the background color`.\n\nWidzisz, Å¼e `if let` moÅ¼e rÃ³wnieÅ¼ wprowadzaÄ‡ nowe zmienne, ktÃ³re zacieniajÄ… istniejÄ…ce zmienne w taki sam sposÃ³b, jak ramiona `match`: linia `if let Ok(age) = age` wprowadza nowÄ… zmiennÄ… `age`, ktÃ³ra zawiera wartoÅ›Ä‡ wewnÄ…trz wariantu `Ok`, zacieniajÄ…c istniejÄ…cÄ… zmiennÄ… `age`. Oznacza to, Å¼e musimy umieÅ›ciÄ‡ warunek `if age > 30` w tym bloku: nie moÅ¼emy poÅ‚Ä…czyÄ‡ tych dwÃ³ch warunkÃ³w w `if let Ok(age) = age && age > 30`. Nowa zmienna `age`, ktÃ³rÄ… chcemy porÃ³wnaÄ‡ z 30, nie jest prawidÅ‚owa, dopÃ³ki nowy zakres nie zacznie siÄ™ od nawiasu klamrowego.\n\nWadÄ… stosowania wyraÅ¼eÅ„ `if let` jest to, Å¼e kompilator nie sprawdza wyczerpujÄ…co wszystkich moÅ¼liwoÅ›ci, w przeciwieÅ„stwie do wyraÅ¼eÅ„ `match`. GdybyÅ›my pominÄ™li ostatni blok `else`, a tym samym nie obsÅ‚uÅ¼yli niektÃ³rych przypadkÃ³w, kompilator nie ostrzegÅ‚by nas o moÅ¼liwym bÅ‚Ä™dzie logicznym.\n\n### PÄ™tle Warunkowe `while let`\n\nPodobnie jak w przypadku `if let`, pÄ™tla warunkowa `while let` pozwala na dziaÅ‚anie pÄ™tli `while` tak dÅ‚ugo, jak wzorzec pasuje. Na LiÅ›cie 19-4 pokazujemy pÄ™tlÄ™ `while let`, ktÃ³ra czeka na wiadomoÅ›ci wysyÅ‚ane miÄ™dzy wÄ…tkami, ale w tym przypadku sprawdza `Result` zamiast `Option`.\n\n<figure class=\"listing\" id=\"listing-19-4\">\n\n````rust\n# fn main() {\n    let (tx, rx) = std::sync::mpsc::channel();\n    std::thread::spawn(move || {\n        for val in [1, 2, 3] {\n            tx.send(val).unwrap();\n        }\n    });\n\n    while let Ok(value) = rx.recv() {\n        println!(\"{value}\");\n    }\n# }\n````\n\n<figcaption><a href=\"#listing-19-4\">Lista 19-4</a>: UÅ¼ycie pÄ™tli <code>while let</code> do drukowania wartoÅ›ci tak dÅ‚ugo, jak <code>rx.recv()</code> zwraca <code>Ok</code></figcaption>\n</figure>\n\nTen przykÅ‚ad wypisuje `1`, `2`, a nastÄ™pnie `3`. Metoda `recv` pobiera pierwszÄ… wiadomoÅ›Ä‡ z odbiornika kanaÅ‚u i zwraca `Ok(value)`. Kiedy po raz pierwszy widzieliÅ›my `recv` w Rozdziale 16, bezpoÅ›rednio rozpakowaliÅ›my bÅ‚Ä…d lub wchodziliÅ›my z nim w interakcjÄ™ jako z iteratorem za pomocÄ… pÄ™tli `for`. Jak pokazuje Lista 19-4, moÅ¼emy jednak rÃ³wnieÅ¼ uÅ¼yÄ‡ `while let`, poniewaÅ¼ metoda `recv` zwraca `Ok` za kaÅ¼dym razem, gdy nadejdzie wiadomoÅ›Ä‡, dopÃ³ki nadawca istnieje, a nastÄ™pnie generuje `Err`, gdy strona nadawcy siÄ™ rozÅ‚Ä…czy.\n\n### PÄ™tle `for`\n\nW pÄ™tli `for` wartoÅ›Ä‡, ktÃ³ra bezpoÅ›rednio nastÄ™puje po sÅ‚owie kluczowym `for`, jest wzorcem. Na przykÅ‚ad w `for x in y`, `x` jest wzorcem. Lista 19-5 demonstruje, jak uÅ¼yÄ‡ wzorca w pÄ™tli `for` do dekonstrukcji, czyli rozÅ‚oÅ¼enia, krotki jako czÄ™Å›Ä‡ pÄ™tli `for`.\n\n<figure class=\"listing\" id=\"listing-19-5\">\n\n````rust\n# fn main() {\n    let v = vec!['a', 'b', 'c'];\n\n    for (index, value) in v.iter().enumerate() {\n        println!(\"{value} is at index {index}\");\n    }\n# }\n````\n\n<figcaption><a href=\"#listing-19-5\">Lista 19-5</a>: UÅ¼ycie wzorca w pÄ™tli <code>for</code> do dekonstrukcji krotki</figcaption>\n</figure>\n\nKod na LiÅ›cie 19-5 wypisze nastÄ™pujÄ…ce informacje:\n\n````console\n$ cargo run\n   Compiling patterns v0.1.0 (file:///projects/patterns)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.52s\n     Running `target/debug/patterns`\na is at index 0\nb is at index 1\nc is at index 2\n````\n\nAdaptujemy iterator za pomocÄ… metody `enumerate` tak, aby produkowaÅ‚a ona wartoÅ›Ä‡ i indeks dla tej wartoÅ›ci, umieszczone w krotce. Pierwsza wyprodukowana wartoÅ›Ä‡ to krotka `(0, 'a')`. Gdy ta wartoÅ›Ä‡ zostanie dopasowana do wzorca `(index, value)`, `index` bÄ™dzie `0`, a `value` bÄ™dzie `'a'`, drukujÄ…c pierwszÄ… liniÄ™ wyjÅ›cia.\n\n### Parametry Funkcji\n\nParametry funkcji rÃ³wnieÅ¼ mogÄ… byÄ‡ wzorcami. Kod z Listy 19-6, ktÃ³ry deklaruje funkcjÄ™ `foo` przyjmujÄ…cÄ… jeden parametr `x` typu `i32`, powinien byÄ‡ juÅ¼ znany.\n\n<figure class=\"listing\" id=\"listing-19-6\">\n\n````rust\nfn foo(x: i32) {\n    // code goes here\n}\n# \n# fn main() {}\n````\n\n<figcaption><a href=\"#listing-19-6\">Lista 19-6</a>: Sygnatura funkcji uÅ¼ywajÄ…ca wzorcÃ³w w parametrach</figcaption>\n</figure>\n\nCzÄ™Å›Ä‡ `x` to wzorzec! Tak jak w przypadku `let`, moglibyÅ›my dopasowaÄ‡ krotkÄ™ w argumentach funkcji do wzorca. Lista 19-7 rozdziela wartoÅ›ci w krotce, gdy przekazujemy jÄ… do funkcji.\n\n<figure class=\"listing\" id=\"listing-19-7\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\nfn print_coordinates(&(x, y): &(i32, i32)) {\n    println!(\"Current location: ({x}, {y})\");\n}\n\nfn main() {\n    let point = (3, 5);\n    print_coordinates(&point);\n}\n````\n\n<figcaption><a href=\"#listing-19-7\">Lista 19-7</a>: Funkcja z parametrami, ktÃ³re dekonstruujÄ… krotkÄ™</figcaption>\n</figure>\n\nTen kod wypisuje `Current location: (3, 5)`. WartoÅ›ci `&(3, 5)` pasujÄ… do wzorca `&(x, y)`, wiÄ™c `x` ma wartoÅ›Ä‡ `3`, a `y` ma wartoÅ›Ä‡ `5`.\n\nMoÅ¼emy rÃ³wnieÅ¼ uÅ¼ywaÄ‡ wzorcÃ³w w listach parametrÃ³w domkniÄ™Ä‡ w taki sam sposÃ³b, jak w listach parametrÃ³w funkcji, poniewaÅ¼ domkniÄ™cia sÄ… podobne do funkcji, jak omÃ³wiono w Rozdziale 13.\n\nDo tej pory widziaÅ‚eÅ› kilka sposobÃ³w uÅ¼ycia wzorcÃ³w, ale wzorce nie dziaÅ‚ajÄ… tak samo w kaÅ¼dym miejscu, w ktÃ³rym moÅ¼emy ich uÅ¼yÄ‡. W niektÃ³rych miejscach wzorce muszÄ… byÄ‡ nieodrzucalne; w innych okolicznoÅ›ciach mogÄ… byÄ‡ odrzucalne. NastÄ™pnie omÃ³wimy te dwie koncepcje.\n\n[ignoring-values-in-a-pattern]: ch19-03-pattern-syntax.html#ignoring-values-in-a-pattern",
        "chapter_title": "Wszystkie Miejsca, w KtÃ³rych MoÅ¼na UÅ¼ywaÄ‡ WzorcÃ³w"
    },
    {
        "file_path": "ch19-02-refutability.md",
        "content": "## OdrzucalnoÅ›Ä‡: Czy Wzorzec MoÅ¼e Nie PasowaÄ‡\n\nWzorce wystÄ™pujÄ… w dwÃ³ch formach: odrzucalne i nieodrzucalne. Wzorce, ktÃ³re pasujÄ… do kaÅ¼dej moÅ¼liwej przekazanej wartoÅ›ci, sÄ… *nieodrzucalne*. PrzykÅ‚adem moÅ¼e byÄ‡ `x` w instrukcji `let x = 5;`, poniewaÅ¼ `x` pasuje do wszystkiego i dlatego nie moÅ¼e siÄ™ nie dopasowaÄ‡. Wzorce, ktÃ³re mogÄ… nie pasowaÄ‡ do pewnej moÅ¼liwej wartoÅ›ci, sÄ… *odrzucalne*. PrzykÅ‚adem moÅ¼e byÄ‡ `Some(x)` w wyraÅ¼eniu `if let Some(x) = a_value`, poniewaÅ¼ jeÅ›li wartoÅ›Ä‡ w zmiennej `a_value` to `None`, a nie `Some`, wzorzec `Some(x)` nie zostanie dopasowany.\n\nParametry funkcji, instrukcje `let` i pÄ™tle `for` mogÄ… akceptowaÄ‡ tylko wzorce nieodrzucalne, poniewaÅ¼ program nie moÅ¼e nic znaczÄ…cego zrobiÄ‡, gdy wartoÅ›ci nie pasujÄ…. WyraÅ¼enia `if let` i `while let` oraz instrukcja `let...else` akceptujÄ… wzorce odrzucalne i nieodrzucalne, ale kompilator ostrzega przed wzorcami nieodrzucalnymi, poniewaÅ¼ z definicji sÄ… przeznaczone do obsÅ‚ugi moÅ¼liwych bÅ‚Ä™dÃ³w: funkcjonalnoÅ›Ä‡ warunku polega na jego zdolnoÅ›ci do dziaÅ‚ania inaczej w zaleÅ¼noÅ›ci od sukcesu lub poraÅ¼ki.\n\nOgÃ³lnie rzecz biorÄ…c, nie powinieneÅ› martwiÄ‡ siÄ™ rozrÃ³Å¼nieniem miÄ™dzy wzorcami odrzucalnymi i nieodrzucalnymi; jednak musisz byÄ‡ zaznajomiony z koncepcjÄ… odrzucalnoÅ›ci, aby mÃ³c reagowaÄ‡, gdy zobaczysz jÄ… w komunikacie o bÅ‚Ä™dzie. W takich przypadkach bÄ™dziesz musiaÅ‚ zmieniÄ‡ albo wzorzec, albo konstrukcjÄ™, z ktÃ³rÄ… uÅ¼ywasz wzorca, w zaleÅ¼noÅ›ci od zamierzonego zachowania kodu.\n\nPrzyjrzyjmy siÄ™ przykÅ‚adowi, co siÄ™ dzieje, gdy prÃ³bujemy uÅ¼yÄ‡ wzorca odrzucalnego tam, gdzie Rust wymaga wzorca nieodrzucalnego, i odwrotnie. Lista 19-8 pokazuje instrukcjÄ™ `let`, ale dla wzorca okreÅ›liliÅ›my `Some(x)`, wzorzec odrzucalny. Jak moÅ¼na siÄ™ spodziewaÄ‡, ten kod siÄ™ nie skompiluje.\n\n<figure class=\"listing\" id=\"listing-19-8\">\n\n````rust,ignore,does_not_compile\n# fn main() {\n#     let some_option_value: Option<i32> = None;\n    let Some(x) = some_option_value;\n# }\n````\n\n<figcaption><a href=\"#listing-19-8\">Lista 19-8</a>: PrÃ³ba uÅ¼ycia wzorca odrzucalnego z <code>let</code></figcaption>\n</figure>\n\nGdyby `some_option_value` miaÅ‚o wartoÅ›Ä‡ `None`, nie pasowaÅ‚oby do wzorca `Some(x)`, co oznacza, Å¼e wzorzec jest odrzucalny. Jednak instrukcja `let` moÅ¼e przyjmowaÄ‡ tylko wzorzec nieodrzucalny, poniewaÅ¼ nie ma niczego waÅ¼nego, co kod mÃ³gÅ‚by zrobiÄ‡ z wartoÅ›ciÄ… `None`. W czasie kompilacji Rust skarÅ¼y siÄ™, Å¼e prÃ³bowaliÅ›my uÅ¼yÄ‡ wzorca odrzucalnego tam, gdzie wymagany jest wzorzec nieodrzucalny:\n\n````console\n$ cargo run\n   Compiling patterns v0.1.0 (file:///projects/patterns)\nerror[E0005]: refutable pattern in local binding\n --> src/main.rs:3:9\n  |\n3 |     let Some(x) = some_option_value;\n  |         ^^^^^^^ pattern `None` not covered\n  |\n  = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n  = note: for more information, visit https://doc.rust-lang.org/book/ch19-02-refutability.html\n  = note: the matched value is of type `Option<i32>`\nhelp: you might want to use `let else` to handle the variant that isn't matched\n  |\n3 |     let Some(x) = some_option_value else { todo!() };\n  |                                     ++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0005`.\nerror: could not compile `patterns` (bin \"patterns\") due to 1 previous error\n````\n\nPoniewaÅ¼ nie pokryliÅ›my (i nie mogliÅ›my pokryÄ‡!) kaÅ¼dej prawidÅ‚owej wartoÅ›ci wzorcem `Some(x)`, Rust sÅ‚usznie zwraca bÅ‚Ä…d kompilacji.\n\nJeÅ›li mamy wzorzec odrzucalny tam, gdzie potrzebny jest wzorzec nieodrzucalny, moÅ¼emy to naprawiÄ‡, zmieniajÄ…c kod, ktÃ³ry uÅ¼ywa wzorca: zamiast uÅ¼ywaÄ‡ `let`, moÅ¼emy uÅ¼yÄ‡ `let...else`. Wtedy, jeÅ›li wzorzec nie pasuje, kod w nawiasach klamrowych obsÅ‚uÅ¼y wartoÅ›Ä‡. Lista 19-9 pokazuje, jak naprawiÄ‡ kod z Listy 19-8.\n\n<figure class=\"listing\" id=\"listing-19-9\">\n\n````rust\n# fn main() {\n#     let some_option_value: Option<i32> = None;\n    let Some(x) = some_option_value else {\n        return;\n    };\n# }\n````\n\n<figcaption><a href=\"#listing-19-9\">Lista 19-9</a>: UÅ¼ycie <code>let...else</code> i bloku z wzorcami odrzucalnymi zamiast <code>let</code></figcaption>\n</figure>\n\nDaliÅ›my kodowi wyjÅ›cie! Ten kod jest caÅ‚kowicie poprawny, chociaÅ¼ oznacza to, Å¼e nie moÅ¼emy uÅ¼yÄ‡ wzorca nieodrzucalnego bez otrzymywania ostrzeÅ¼enia. JeÅ›li damy `let...else` wzorzec, ktÃ³ry zawsze bÄ™dzie pasowaÅ‚, taki jak `x`, jak pokazano na LiÅ›cie 19-10, kompilator wyÅ›wietli ostrzeÅ¼enie.\n\n<figure class=\"listing\" id=\"listing-19-10\">\n\n````rust\n# fn main() {\n    let x = 5 else {\n        return;\n    };\n# }\n````\n\n<figcaption><a href=\"#listing-19-10\">Lista 19-10</a>: PrÃ³ba uÅ¼ycia wzorca nieodrzucalnego z <code>let...else</code></figcaption>\n</figure>\n\nRust skarÅ¼y siÄ™, Å¼e uÅ¼ycie `let...else` z wzorcem nieodrzucalnym nie ma sensu:\n\n````console\n$ cargo run\n   Compiling patterns v0.1.0 (file:///projects/patterns)\nwarning: irrefutable `let...else` pattern\n --> src/main.rs:2:5\n  |\n2 |     let x = 5 else {\n  |     ^^^^^^^^^\n  |\n  = note: this pattern will always match, so the `else` clause is useless\n  = help: consider removing the `else` clause\n  = note: `#[warn(irrefutable_let_patterns)]` on by default\n\nwarning: `patterns` (bin \"patterns\") generated 1 warning\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.39s\n     Running `target/debug/patterns`\n````\n\nZ tego powodu ramiona `match` muszÄ… uÅ¼ywaÄ‡ wzorcÃ³w odrzucalnych, z wyjÄ…tkiem ostatniego ramienia, ktÃ³re powinno pasowaÄ‡ do wszystkich pozostaÅ‚ych wartoÅ›ci za pomocÄ… wzorca nieodrzucalnego. Rust pozwala nam uÅ¼ywaÄ‡ wzorca nieodrzucalnego w `match` z tylko jednym ramieniem, ale ta skÅ‚adnia nie jest szczegÃ³lnie uÅ¼yteczna i mogÅ‚aby byÄ‡ zastÄ…piona prostszÄ… instrukcjÄ… `let`.\n\nTeraz, gdy wiesz, gdzie uÅ¼ywaÄ‡ wzorcÃ³w i jaka jest rÃ³Å¼nica miÄ™dzy wzorcami odrzucalnymi i nieodrzucalnymi, przejdÅºmy do omÃ³wienia caÅ‚ej skÅ‚adni, ktÃ³rej moÅ¼emy uÅ¼yÄ‡ do tworzenia wzorcÃ³w.",
        "chapter_title": "OdrzucalnoÅ›Ä‡: Czy Wzorzec MoÅ¼e Nie PasowaÄ‡"
    },
    {
        "file_path": "ch19-03-pattern-syntax.md",
        "content": "## SkÅ‚adnia WzorcÃ³w\n\nW tej sekcji zbieramy caÅ‚Ä… skÅ‚adniÄ™, ktÃ³ra jest prawidÅ‚owa we wzorcach, i omawiamy, dlaczego i kiedy warto uÅ¼ywaÄ‡ kaÅ¼dej z nich.\n\n### Dopasowywanie LiteraÅ‚Ã³w\n\nJak widziaÅ‚eÅ› w Rozdziale 6, moÅ¼esz dopasowywaÄ‡ wzorce bezpoÅ›rednio do literaÅ‚Ã³w. PoniÅ¼szy kod przedstawia kilka przykÅ‚adÃ³w:\n\n````rust\n# fn main() {\n    let x = 1;\n\n    match x {\n        1 => println!(\"one\"),\n        2 => println!(\"two\"),\n        3 => println!(\"three\"),\n        _ => println!(\"anything\"),\n    }\n# }\n````\n\nTen kod wypisuje `one`, poniewaÅ¼ wartoÅ›Ä‡ w `x` wynosi `1`. Ta skÅ‚adnia jest uÅ¼yteczna, gdy chcesz, aby TwÃ³j kod podjÄ…Å‚ dziaÅ‚anie, jeÅ›li otrzyma konkretnÄ… wartoÅ›Ä‡.\n\n### Dopasowywanie Nazwanych Zmiennych\n\nNazwane zmienne to nieodrzucalne wzorce, ktÃ³re pasujÄ… do dowolnej wartoÅ›ci, i uÅ¼ywaliÅ›my ich wiele razy w tej ksiÄ…Å¼ce. JednakÅ¼e, pojawia siÄ™ komplikacja, gdy uÅ¼ywasz nazwanych zmiennych w wyraÅ¼eniach `match`, `if let` lub `while let`. PoniewaÅ¼ kaÅ¼dy z tych rodzajÃ³w wyraÅ¼eÅ„ rozpoczyna nowy zakres, zmienne zadeklarowane jako czÄ™Å›Ä‡ wzorca wewnÄ…trz tych wyraÅ¼eÅ„ bÄ™dÄ… zasÅ‚aniaÄ‡ te o tej samej nazwie poza konstrukcjami, tak jak to ma miejsce w przypadku wszystkich zmiennych. Na LiÅ›cie 19-11 deklarujemy zmiennÄ… `x` o wartoÅ›ci `Some(5)` i zmiennÄ… `y` o wartoÅ›ci `10`. NastÄ™pnie tworzymy wyraÅ¼enie `match` na wartoÅ›ci `x`. SpÃ³jrz na wzorce w ramionach `match` i `println!` na koÅ„cu, a sprÃ³buj odgadnÄ…Ä‡, co kod wydrukuje, zanim uruchomisz ten kod lub przeczytasz dalej.\n\n<figure class=\"listing\" id=\"listing-19-11\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\n# fn main() {\n    let x = Some(5);\n    let y = 10;\n\n    match x {\n        Some(50) => println!(\"Got 50\"),\n        Some(y) => println!(\"Matched, y = {y}\"),\n        _ => println!(\"Default case, x = {x:?}\"),\n    }\n\n    println!(\"at the end: x = {x:?}, y = {y}\");\n# }\n````\n\n<figcaption><a href=\"#listing-19-11\">Lista 19-11</a>: WyraÅ¼enie <code>match</code> z ramieniem, ktÃ³re wprowadza nowÄ… zmiennÄ…, ktÃ³ra zasÅ‚ania istniejÄ…cÄ… zmiennÄ… <code>y</code></figcaption>\n</figure>\n\nPrzeanalizujmy, co dzieje siÄ™, gdy uruchamia siÄ™ wyraÅ¼enie `match`. Wzorzec w pierwszym ramieniu `match` nie pasuje do zdefiniowanej wartoÅ›ci `x`, wiÄ™c kod kontynuuje dziaÅ‚anie.\n\nWzorzec w drugim ramieniu `match` wprowadza nowÄ… zmiennÄ… o nazwie `y`, ktÃ³ra bÄ™dzie pasowaÄ‡ do dowolnej wartoÅ›ci wewnÄ…trz wartoÅ›ci `Some`. PoniewaÅ¼ jesteÅ›my w nowym zakresie wewnÄ…trz wyraÅ¼enia `match`, jest to nowa zmienna `y`, a nie `y`, ktÃ³rÄ… zadeklarowaliÅ›my na poczÄ…tku z wartoÅ›ciÄ… `10`. To nowe powiÄ…zanie `y` bÄ™dzie pasowaÄ‡ do wewnÄ™trznej wartoÅ›ci `Some` w `x`. Ta wartoÅ›Ä‡ to `5`, wiÄ™c wyraÅ¼enie dla tego ramienia wykonuje siÄ™ i wypisuje `Matched, y = 5`.\n\nGdyby `x` byÅ‚o wartoÅ›ciÄ… `None` zamiast `Some(5)`, wzorce w dwÃ³ch pierwszych ramionach nie pasowaÅ‚yby, wiÄ™c wartoÅ›Ä‡ pasowaÅ‚aby do podkreÅ›lenia. Nie wprowadziliÅ›my zmiennej `x` do wzorca ramienia podkreÅ›lenia, wiÄ™c `x` w wyraÅ¼eniu jest nadal zewnÄ™trznym `x`, ktÃ³re nie zostaÅ‚o zacienione. W tym hipotetycznym przypadku `match` wypisaÅ‚by `Default case, x = None`.\n\nPo zakoÅ„czeniu wyraÅ¼enia `match`, jego zakres siÄ™ koÅ„czy, podobnie jak zakres wewnÄ™trznego `y`. Ostatnie `println!` wypisuje `at the end: x = Some(5), y = 10`.\n\nAby stworzyÄ‡ wyraÅ¼enie `match`, ktÃ³re porÃ³wnuje wartoÅ›ci zewnÄ™trznych `x` i `y`, zamiast wprowadzaÄ‡ nowÄ… zmiennÄ…, ktÃ³ra zasÅ‚ania istniejÄ…cÄ… zmiennÄ… `y`, musielibyÅ›my uÅ¼yÄ‡ warunkowego ograniczenia dopasowania. O match guardach porozmawiamy pÃ³Åºniej w sekcji [â€Dodawanie warunkÃ³w za pomocÄ… match guardÃ³wâ€](#adding-conditionals-with-match-guards)<!-- ignore -->.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"multiple-patterns\"></a>\n\n### Dopasowywanie Wielu WzorcÃ³w\n\nW wyraÅ¼eniach `match` moÅ¼esz dopasowywaÄ‡ wiele wzorcÃ³w za pomocÄ… skÅ‚adni `|`, ktÃ³ra jest operatorem *lub* wzorca. Na przykÅ‚ad, w poniÅ¼szym kodzie dopasowujemy wartoÅ›Ä‡ `x` do ramion `match`, z ktÃ³rych pierwsze ma opcjÄ™ *lub*, co oznacza, Å¼e jeÅ›li wartoÅ›Ä‡ `x` pasuje do ktÃ³rejkolwiek z wartoÅ›ci w tym ramieniu, kod tego ramienia zostanie uruchomiony:\n\n````rust\n# fn main() {\n    let x = 1;\n\n    match x {\n        1 | 2 => println!(\"one or two\"),\n        3 => println!(\"three\"),\n        _ => println!(\"anything\"),\n    }\n# }\n````\n\nTen kod wypisuje `one or two`.\n\n### Dopasowywanie ZakresÃ³w WartoÅ›ci za pomocÄ… `..=`\n\nSkÅ‚adnia `..=` pozwala nam dopasowywaÄ‡ do wÅ‚Ä…cznie zakresu wartoÅ›ci. W poniÅ¼szym kodzie, gdy wzorzec pasuje do ktÃ³rejkolwiek z wartoÅ›ci w danym zakresie, to ramiÄ™ zostanie wykonane:\n\n````rust\n# fn main() {\n    let x = 5;\n\n    match x {\n        1..=5 => println!(\"one through five\"),\n        _ => println!(\"something else\"),\n    }\n# }\n````\n\nJeÅ›li `x` wynosi `1`, `2`, `3`, `4` lub `5`, pierwsze ramiÄ™ zostanie dopasowane. Ta skÅ‚adnia jest wygodniejsza dla wielu wartoÅ›ci dopasowania niÅ¼ uÅ¼ywanie operatora `|` do wyraÅ¼enia tej samej idei; gdybyÅ›my mieli uÅ¼yÄ‡ `|`, musielibyÅ›my okreÅ›liÄ‡ `1 | 2 | 3 | 4 | 5`. OkreÅ›lanie zakresu jest znacznie krÃ³tsze, zwÅ‚aszcza jeÅ›li chcemy dopasowaÄ‡, powiedzmy, dowolnÄ… liczbÄ™ od 1 do 1000!\n\nKompilator sprawdza w czasie kompilacji, czy zakres nie jest pusty, a poniewaÅ¼ jedynymi typami, dla ktÃ³rych Rust moÅ¼e stwierdziÄ‡, czy zakres jest pusty, sÄ… `char` i wartoÅ›ci liczbowe, zakresy sÄ… dozwolone tylko z wartoÅ›ciami liczbowymi lub `char`.\n\nOto przykÅ‚ad uÅ¼ycia zakresÃ³w wartoÅ›ci `char`:\n\n````rust\n# fn main() {\n    let x = 'c';\n\n    match x {\n        'a'..='j' => println!(\"early ASCII letter\"),\n        'k'..='z' => println!(\"late ASCII letter\"),\n        _ => println!(\"something else\"),\n    }\n# }\n````\n\nRust moÅ¼e stwierdziÄ‡, Å¼e `'c'` znajduje siÄ™ w zakresie pierwszego wzorca i wypisuje `early ASCII letter`.\n\n### Dekonstrukcja w Celu Rozbicia WartoÅ›ci\n\nMoÅ¼emy rÃ³wnieÅ¼ uÅ¼ywaÄ‡ wzorcÃ³w do dekonstrukcji struktur, wyliczeÅ„ i krotek, aby uÅ¼ywaÄ‡ rÃ³Å¼nych czÄ™Å›ci tych wartoÅ›ci. PrzejdÅºmy przez kaÅ¼dÄ… wartoÅ›Ä‡.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"destructuring-structs\"></a>\n\n#### Struktury\n\nLista 19-12 pokazuje strukturÄ™ `Point` z dwoma polami, `x` i `y`, ktÃ³re moÅ¼emy rozdzieliÄ‡ za pomocÄ… wzorca z instrukcjÄ… `let`.\n\n<figure class=\"listing\" id=\"listing-19-12\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    let Point { x: a, y: b } = p;\n    assert_eq!(0, a);\n    assert_eq!(7, b);\n}\n````\n\n<figcaption><a href=\"#listing-19-12\">Lista 19-12</a>: Dekonstrukcja pÃ³l struktury na osobne zmienne</figcaption>\n</figure>\n\nTen kod tworzy zmienne `a` i `b`, ktÃ³re odpowiadajÄ… wartoÅ›ciom pÃ³l `x` i `y` struktury `p`. Ten przykÅ‚ad pokazuje, Å¼e nazwy zmiennych we wzorcu nie muszÄ… odpowiadaÄ‡ nazwom pÃ³l struktury. Jednak czÄ™sto dopasowuje siÄ™ nazwy zmiennych do nazw pÃ³l, aby Å‚atwiej byÅ‚o zapamiÄ™taÄ‡, ktÃ³re zmienne pochodzÄ… z ktÃ³rych pÃ³l. Z powodu tego powszechnego uÅ¼ycia i poniewaÅ¼ pisanie `let Point { x: x, y: y } = p;` zawiera wiele powtÃ³rzeÅ„, Rust ma skrÃ³t dla wzorcÃ³w, ktÃ³re dopasowujÄ… pola struktury: wystarczy wymieniÄ‡ nazwÄ™ pola struktury, a zmienne utworzone na podstawie wzorca bÄ™dÄ… miaÅ‚y te same nazwy. Lista 19-13 dziaÅ‚a tak samo jak kod z Listy 19-12, ale zmienne utworzone we wzorcu `let` to `x` i `y` zamiast `a` i `b`.\n\n<figure class=\"listing\" id=\"listing-19-13\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    let Point { x, y } = p;\n    assert_eq!(0, x);\n    assert_eq!(7, y);\n}\n````\n\n<figcaption><a href=\"#listing-19-13\">Lista 19-13</a>: Dekonstrukcja pÃ³l struktury za pomocÄ… skrÃ³tu pÃ³l struktury</figcaption>\n</figure>\n\nTen kod tworzy zmienne `x` i `y`, ktÃ³re pasujÄ… do pÃ³l `x` i `y` zmiennej `p`. Wynikiem jest to, Å¼e zmienne `x` i `y` zawierajÄ… wartoÅ›ci ze struktury `p`.\n\nMoÅ¼emy rÃ³wnieÅ¼ dokonywaÄ‡ dekonstrukcji z uÅ¼yciem wartoÅ›ci literaÅ‚owych jako czÄ™Å›ci wzorca struktury, zamiast tworzyÄ‡ zmienne dla wszystkich pÃ³l. Pozwala nam to testowaÄ‡ niektÃ³re pola pod kÄ…tem okreÅ›lonych wartoÅ›ci, jednoczeÅ›nie tworzÄ…c zmienne do dekonstrukcji pozostaÅ‚ych pÃ³l.\n\nNa LiÅ›cie 19-14 mamy wyraÅ¼enie `match`, ktÃ³re dzieli wartoÅ›ci `Point` na trzy przypadki: punkty leÅ¼Ä…ce bezpoÅ›rednio na osi `x` (co jest prawdÄ…, gdy `y = 0`), na osi `y` (`x = 0`) lub na Å¼adnej z osi.\n\n<figure class=\"listing\" id=\"listing-19-14\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\n# struct Point {\n#     x: i32,\n#     y: i32,\n# }\n# \nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    match p {\n        Point { x, y: 0 } => println!(\"On the x axis at {x}\"),\n        Point { x: 0, y } => println!(\"On the y axis at {y}\"),\n        Point { x, y } => {\n            println!(\"On neither axis: ({x}, {y})\");\n        }\n    }\n}\n````\n\n<figcaption><a href=\"#listing-19-14\">Lista 19-14</a>: Dekonstrukcja i dopasowywanie wartoÅ›ci literaÅ‚owych w jednym wzorcu</figcaption>\n</figure>\n\nPierwsze ramiÄ™ dopasuje kaÅ¼dy punkt leÅ¼Ä…cy na osi `x`, okreÅ›lajÄ…c, Å¼e pole `y` pasuje, jeÅ›li jego wartoÅ›Ä‡ odpowiada literaÅ‚owi `0`. Wzorzec nadal tworzy zmiennÄ… `x`, ktÃ³rej moÅ¼emy uÅ¼yÄ‡ w kodzie dla tego ramienia.\n\nPodobnie, drugie ramiÄ™ pasuje do kaÅ¼dego punktu na osi `y`, okreÅ›lajÄ…c, Å¼e pole `x` pasuje, jeÅ›li jego wartoÅ›Ä‡ wynosi `0`, i tworzy zmiennÄ… `y` dla wartoÅ›ci pola `y`. Trzecie ramiÄ™ nie okreÅ›la Å¼adnych literaÅ‚Ã³w, wiÄ™c pasuje do kaÅ¼dego innego `Point` i tworzy zmienne dla pÃ³l `x` i `y`.\n\nW tym przykÅ‚adzie wartoÅ›Ä‡ `p` pasuje do drugiego ramienia dziÄ™ki temu, Å¼e `x` zawiera `0`, wiÄ™c ten kod wypisze `On the y axis at 7`.\n\nPamiÄ™taj, Å¼e wyraÅ¼enie `match` przestaje sprawdzaÄ‡ ramiona, gdy tylko znajdzie pierwszy pasujÄ…cy wzorzec, wiÄ™c nawet jeÅ›li `Point { x: 0, y: 0 }` znajduje siÄ™ na osi `x` i osi `y`, ten kod wydrukowaÅ‚by tylko `On the x axis at 0`.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"destructuring-enums\"></a>\n\n#### Wyliczenia (Enums)\n\nDekonstruowaliÅ›my wyliczenia w tej ksiÄ…Å¼ce (na przykÅ‚ad Lista 6-5 w Rozdziale 6), ale nie omÃ³wiliÅ›my jeszcze wyraÅºnie, Å¼e wzorzec do dekonstrukcji wyliczenia odpowiada sposobowi definiowania danych przechowywanych w wyliczeniu. Jako przykÅ‚ad, na LiÅ›cie 19-15 uÅ¼ywamy wyliczenia `Message` z Listy 6-2 i piszemy `match` z wzorcami, ktÃ³re dekonstruujÄ… kaÅ¼dÄ… wewnÄ™trznÄ… wartoÅ›Ä‡.\n\n<figure class=\"listing\" id=\"listing-19-15\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(0, 160, 255);\n\n    match msg {\n        Message::Quit => {\n            println!(\"The Quit variant has no data to destructure.\");\n        }\n        Message::Move { x, y } => {\n            println!(\"Move in the x direction {x} and in the y direction {y}\");\n        }\n        Message::Write(text) => {\n            println!(\"Text message: {text}\");\n        }\n        Message::ChangeColor(r, g, b) => {\n            println!(\"Change color to red {r}, green {g}, and blue {b}\");\n        }\n    }\n}\n````\n\n<figcaption><a href=\"#listing-19-15\">Lista 19-15</a>: Dekonstrukcja wariantÃ³w wyliczenia, ktÃ³re zawierajÄ… rÃ³Å¼ne rodzaje wartoÅ›ci</figcaption>\n</figure>\n\nTen kod wypisze `Change color to red 0, green 160, and blue 255`. SprÃ³buj zmieniÄ‡ wartoÅ›Ä‡ `msg`, aby zobaczyÄ‡, jak dziaÅ‚a kod z innych ramion.\n\nDla wariantÃ³w wyliczeniowych bez Å¼adnych danych, takich jak `Message::Quit`, nie moÅ¼emy dalej dekonstruowaÄ‡ wartoÅ›ci. MoÅ¼emy dopasowaÄ‡ tylko literaÅ‚ `Message::Quit`, a w tym wzorcu nie ma Å¼adnych zmiennych.\n\nDla wariantÃ³w wyliczeÅ„ podobnych do struktur, takich jak `Message::Move`, moÅ¼emy uÅ¼yÄ‡ wzorca podobnego do wzorca, ktÃ³ry okreÅ›lamy w celu dopasowania struktur. Po nazwie wariantu umieszczamy nawiasy klamrowe, a nastÄ™pnie wymieniamy pola ze zmiennymi, tak abyÅ›my rozdzielili elementy do uÅ¼ycia w kodzie dla tego ramienia. Tutaj uÅ¼ywamy skrÃ³conej formy, tak jak na LiÅ›cie 19-13.\n\nDla wariantÃ³w wyliczeniowych typu krotka, takich jak `Message::Write`, ktÃ³re przechowuje krotkÄ™ z jednym elementem, oraz `Message::ChangeColor`, ktÃ³re przechowuje krotkÄ™ z trzema elementami, wzorzec jest podobny do wzorca, ktÃ³ry okreÅ›lamy, aby dopasowaÄ‡ krotki. Liczba zmiennych we wzorcu musi odpowiadaÄ‡ liczbie elementÃ³w w wariancie, ktÃ³ry dopasowujemy.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"destructuring-nested-structs-and-enums\"></a>\n\n#### ZagnieÅ¼dÅ¼one Struktury i Wyliczenia\n\nDo tej pory wszystkie nasze przykÅ‚ady dotyczyÅ‚y dopasowywania struktur lub wyliczeÅ„ na jednym poziomie, ale dopasowywanie moÅ¼e dziaÅ‚aÄ‡ rÃ³wnieÅ¼ na zagnieÅ¼dÅ¼onych elementach! Na przykÅ‚ad, moÅ¼emy refaktoryzowaÄ‡ kod z Listy 19-15, aby obsÅ‚ugiwaÅ‚ kolory RGB i HSV w wiadomoÅ›ci `ChangeColor`, jak pokazano na LiÅ›cie 19-16.\n\n<figure class=\"listing\" id=\"listing-19-16\">\n\n````rust\nenum Color {\n    Rgb(i32, i32, i32),\n    Hsv(i32, i32, i32),\n}\n\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(Color),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));\n\n    match msg {\n        Message::ChangeColor(Color::Rgb(r, g, b)) => {\n            println!(\"Change color to red {r}, green {g}, and blue {b}\");\n        }\n        Message::ChangeColor(Color::Hsv(h, s, v)) => {\n            println!(\"Change color to hue {h}, saturation {s}, value {v}\");\n        }\n        _ => (),\n    }\n}\n````\n\n<figcaption><a href=\"#listing-19-16\">Lista 19-16</a>: Dopasowywanie zagnieÅ¼dÅ¼onych wyliczeÅ„</figcaption>\n</figure>\n\nWzorzec pierwszego ramienia w wyraÅ¼eniu `match` pasuje do wariantu wyliczeniowego `Message::ChangeColor`, ktÃ³ry zawiera wariant `Color::Rgb`; nastÄ™pnie wzorzec wiÄ…Å¼e siÄ™ z trzema wewnÄ™trznymi wartoÅ›ciami `i32`. Wzorzec drugiego ramienia rÃ³wnieÅ¼ pasuje do wariantu wyliczeniowego `Message::ChangeColor`, ale wewnÄ™trzne wyliczenie pasuje zamiast tego do `Color::Hsv`. MoÅ¼emy okreÅ›liÄ‡ te zÅ‚oÅ¼one warunki w jednym wyraÅ¼eniu `match`, mimo Å¼e biorÄ… w nim udziaÅ‚ dwa wyliczenia.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"destructuring-structs-and-tuples\"></a>\n\n#### Struktury i Krotki\n\nMoÅ¼emy mieszaÄ‡, dopasowywaÄ‡ i zagnieÅ¼dÅ¼aÄ‡ wzorce dekonstrukcji na jeszcze bardziej zÅ‚oÅ¼one sposoby. PoniÅ¼szy przykÅ‚ad pokazuje skomplikowanÄ… dekonstrukcjÄ™, w ktÃ³rej zagnieÅ¼dÅ¼amy struktury i krotki wewnÄ…trz krotki i dekonstruujemy wszystkie wartoÅ›ci pierwotne:\n\n````rust\n# fn main() {\n#     struct Point {\n#         x: i32,\n#         y: i32,\n#     }\n# \n    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });\n# }\n````\n\nTen kod pozwala nam rozbiÄ‡ zÅ‚oÅ¼one typy na ich czÄ™Å›ci skÅ‚adowe, abyÅ›my mogli osobno uÅ¼ywaÄ‡ wartoÅ›ci, ktÃ³re nas interesujÄ….\n\nDekonstrukcja za pomocÄ… wzorcÃ³w to wygodny sposÃ³b na uÅ¼ywanie czÄ™Å›ci wartoÅ›ci, takich jak wartoÅ›Ä‡ z kaÅ¼dego pola w strukturze, oddzielnie od siebie.\n\n### Ignorowanie WartoÅ›ci we Wzorcu\n\nWidziaÅ‚eÅ›, Å¼e czasami przydatne jest ignorowanie wartoÅ›ci we wzorcu, na przykÅ‚ad w ostatnim ramieniu `match`, aby uzyskaÄ‡ catch-all, ktÃ³ry faktycznie nic nie robi, ale uwzglÄ™dnia wszystkie pozostaÅ‚e moÅ¼liwe wartoÅ›ci. Istnieje kilka sposobÃ³w ignorowania caÅ‚ych wartoÅ›ci lub czÄ™Å›ci wartoÅ›ci we wzorcu: uÅ¼ycie wzorca `_` (ktÃ³ry juÅ¼ widziaÅ‚eÅ›), uÅ¼ycie wzorca `_` w innym wzorcu, uÅ¼ycie nazwy zaczynajÄ…cej siÄ™ od podkreÅ›lenia lub uÅ¼ycie `..`, aby zignorowaÄ‡ pozostaÅ‚e czÄ™Å›ci wartoÅ›ci. Przyjrzyjmy siÄ™, jak i dlaczego uÅ¼ywaÄ‡ kaÅ¼dego z tych wzorcÃ³w.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"ignoring-an-entire-value-with-_\"></a>\n\n#### CaÅ‚a WartoÅ›Ä‡ za pomocÄ… `_`\n\nUÅ¼ywaliÅ›my podkreÅ›lenia jako wzorca wieloznacznego, ktÃ³ry bÄ™dzie pasowaÅ‚ do dowolnej wartoÅ›ci, ale nie bÄ™dzie wiÄ…zaÅ‚ siÄ™ z wartoÅ›ciÄ…. Jest to szczegÃ³lnie przydatne jako ostatnie ramiÄ™ w wyraÅ¼eniu `match`, ale moÅ¼emy go rÃ³wnieÅ¼ uÅ¼ywaÄ‡ w dowolnym wzorcu, w tym w parametrach funkcji, jak pokazano na LiÅ›cie 19-17.\n\n<figure class=\"listing\" id=\"listing-19-17\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\nfn foo(_: i32, y: i32) {\n    println!(\"This code only uses the y parameter: {y}\");\n}\n\nfn main() {\n    foo(3, 4);\n}\n````\n\n<figcaption><a href=\"#listing-19-17\">Lista 19-17</a>: UÅ¼ycie <code>_</code> w sygnaturze funkcji</figcaption>\n</figure>\n\nTen kod caÅ‚kowicie zignoruje wartoÅ›Ä‡ `3` przekazanÄ… jako pierwszy argument i wydrukuje `This code only uses the y parameter: 4`.\n\nW wiÄ™kszoÅ›ci przypadkÃ³w, gdy nie potrzebujesz juÅ¼ konkretnego parametru funkcji, zmieniÅ‚byÅ› sygnaturÄ™ tak, aby nie zawieraÅ‚a nieuÅ¼ywanego parametru. Ignorowanie parametru funkcji moÅ¼e byÄ‡ szczegÃ³lnie przydatne w przypadkach, gdy na przykÅ‚ad implementujesz cechÄ™, gdy potrzebujesz okreÅ›lonej sygnatury typu, ale ciaÅ‚o funkcji w Twojej implementacji nie potrzebuje jednego z parametrÃ³w. Wtedy unikasz ostrzeÅ¼enia kompilatora o nieuÅ¼ywanych parametrach funkcji, tak jakbyÅ› uÅ¼yÅ‚ nazwy zamiast.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"ignoring-parts-of-a-value-with-a-nested-_\"></a>\n\n#### Fragmenty WartoÅ›ci z ZagnieÅ¼dÅ¼onym `_`\n\nMoÅ¼emy rÃ³wnieÅ¼ uÅ¼ywaÄ‡ `_` wewnÄ…trz innego wzorca, aby zignorowaÄ‡ tylko czÄ™Å›Ä‡ wartoÅ›ci, na przykÅ‚ad, gdy chcemy przetestowaÄ‡ tylko czÄ™Å›Ä‡ wartoÅ›ci, ale nie mamy zastosowania dla pozostaÅ‚ych czÄ™Å›ci w odpowiadajÄ…cym kodzie, ktÃ³ry chcemy uruchomiÄ‡. Lista 19-18 pokazuje kod odpowiedzialny za zarzÄ…dzanie wartoÅ›ciÄ… ustawienia. Wymagania biznesowe sÄ… takie, Å¼e uÅ¼ytkownikowi nie wolno nadpisywaÄ‡ istniejÄ…cej dostosowanej wartoÅ›ci ustawienia, ale moÅ¼e anulowaÄ‡ ustawienie i nadaÄ‡ mu wartoÅ›Ä‡, jeÅ›li jest ono obecnie niezdefiniowane.\n\n<figure class=\"listing\" id=\"listing-19-18\">\n\n````rust\n# fn main() {\n    let mut setting_value = Some(5);\n    let new_setting_value = Some(10);\n\n    match (setting_value, new_setting_value) {\n        (Some(_), Some(_)) => {\n            println!(\"Can't overwrite an existing customized value\");\n        }\n        _ => {\n            setting_value = new_setting_value;\n        }\n    }\n\n    println!(\"setting is {setting_value:?}\");\n# }\n````\n\n<figcaption><a href=\"#listing-19-18\">Lista 19-18</a>: UÅ¼ycie podkreÅ›lenia w wzorcach pasujÄ…cych do wariantÃ³w <code>Some</code>, gdy nie musimy uÅ¼ywaÄ‡ wartoÅ›ci wewnÄ…trz <code>Some</code></figcaption>\n</figure>\n\nTen kod wypisze `Can't overwrite an existing customized value`, a nastÄ™pnie `setting is Some(5)`. W pierwszym ramieniu `match` nie musimy dopasowywaÄ‡ ani uÅ¼ywaÄ‡ wartoÅ›ci wewnÄ…trz Å¼adnego z wariantÃ³w `Some`, ale musimy sprawdziÄ‡ przypadek, gdy `setting_value` i `new_setting_value` sÄ… wariantem `Some`. W takim przypadku wypisujemy powÃ³d, dla ktÃ³rego `setting_value` nie zostanie zmienione, i nie zostanie ono zmienione.\n\nWe wszystkich innych przypadkach (jeÅ›li `setting_value` lub `new_setting_value` jest `None`), wyraÅ¼onych wzorcem `_` w drugim ramieniu, chcemy, aby `new_setting_value` staÅ‚o siÄ™ `setting_value`.\n\nMoÅ¼emy rÃ³wnieÅ¼ uÅ¼ywaÄ‡ podkreÅ›leÅ„ w wielu miejscach w jednym wzorcu, aby ignorowaÄ‡ okreÅ›lone wartoÅ›ci. Lista 19-19 pokazuje przykÅ‚ad ignorowania drugiej i czwartej wartoÅ›ci w krotce piÄ™ciu elementÃ³w.\n\n<figure class=\"listing\" id=\"listing-19-19\">\n\n````rust\n# fn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (first, _, third, _, fifth) => {\n            println!(\"Some numbers: {first}, {third}, {fifth}\");\n        }\n    }\n# }\n````\n\n<figcaption><a href=\"#listing-19-19\">Lista 19-19</a>: Ignorowanie wielu czÄ™Å›ci krotki</figcaption>\n</figure>\n\nTen kod wypisze `Some numbers: 2, 8, 32`, a wartoÅ›ci `4` i `16` zostanÄ… zignorowane.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"ignoring-an-unused-variable-by-starting-its-name-with-_\"></a>\n\n#### NieuÅ¼ywana Zmienna, ZaczynajÄ…ca SiÄ™ od `_`\n\nJeÅ›li utworzysz zmiennÄ…, ale nie uÅ¼yjesz jej nigdzie, Rust zazwyczaj wyÅ›wietli ostrzeÅ¼enie, poniewaÅ¼ nieuÅ¼ywana zmienna moÅ¼e byÄ‡ bÅ‚Ä™dem. Czasami jednak przydatne jest stworzenie zmiennej, ktÃ³rej jeszcze nie uÅ¼yjesz, na przykÅ‚ad podczas prototypowania lub rozpoczynania projektu. W tej sytuacji moÅ¼esz powiedzieÄ‡ Rust, aby nie ostrzegaÅ‚ CiÄ™ o nieuÅ¼ywanej zmiennej, zaczynajÄ…c nazwÄ™ zmiennej od podkreÅ›lenia. Na LiÅ›cie 19-20 tworzymy dwie nieuÅ¼ywane zmienne, ale po skompilowaniu tego kodu powinniÅ›my otrzymaÄ‡ ostrzeÅ¼enie tylko o jednej z nich.\n\n<figure class=\"listing\" id=\"listing-19-20\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\nfn main() {\n    let _x = 5;\n    let y = 10;\n}\n````\n\n<figcaption><a href=\"#listing-19-20\">Lista 19-20</a>: Rozpoczynanie nazwy zmiennej od podkreÅ›lenia w celu unikniÄ™cia ostrzeÅ¼eÅ„ o nieuÅ¼ywanych zmiennych</figcaption>\n</figure>\n\nTutaj otrzymujemy ostrzeÅ¼enie o nieuÅ¼ywaniu zmiennej `y`, ale nie otrzymujemy ostrzeÅ¼enia o nieuÅ¼ywaniu `_x`.\n\nZauwaÅ¼, Å¼e istnieje subtelna rÃ³Å¼nica miÄ™dzy uÅ¼ywaniem samego `_` a uÅ¼ywaniem nazwy zaczynajÄ…cej siÄ™ od podkreÅ›lenia. SkÅ‚adnia `_x` nadal wiÄ…Å¼e wartoÅ›Ä‡ ze zmiennÄ…, podczas gdy `_` w ogÃ³le nie wiÄ…Å¼e. Aby pokazaÄ‡ przypadek, w ktÃ³rym ta rÃ³Å¼nica ma znaczenie, Lista 19-21 dostarczy nam bÅ‚Ä™du.\n\n<figure class=\"listing\" id=\"listing-19-21\">\n\n````rust,ignore,does_not_compile\n# fn main() {\n    let s = Some(String::from(\"Hello!\"));\n\n    if let Some(_s) = s {\n        println!(\"found a string\");\n    }\n\n    println!(\"{s:?}\");\n# }\n````\n\n<figcaption><a href=\"#listing-19-21\">Lista 19-21</a>: NieuÅ¼ywana zmienna zaczynajÄ…ca siÄ™ od podkreÅ›lenia nadal wiÄ…Å¼e wartoÅ›Ä‡, co moÅ¼e przejÄ…Ä‡ wÅ‚asnoÅ›Ä‡ wartoÅ›ci.</figcaption>\n</figure>\n\nOtrzymamy bÅ‚Ä…d, poniewaÅ¼ wartoÅ›Ä‡ `s` zostanie nadal przeniesiona do `_s`, co uniemoÅ¼liwi nam ponowne uÅ¼ycie `s`. Jednak uÅ¼ycie samego podkreÅ›lenia nigdy nie wiÄ…Å¼e siÄ™ z wartoÅ›ciÄ…. Lista 19-22 skompiluje siÄ™ bez bÅ‚Ä™dÃ³w, poniewaÅ¼ `s` nie zostanie przeniesione do `_`.\n\n<figure class=\"listing\" id=\"listing-19-22\">\n\n````rust\n# fn main() {\n    let s = Some(String::from(\"Hello!\"));\n\n    if let Some(_) = s {\n        println!(\"found a string\");\n    }\n\n    println!(\"{s:?}\");\n# }\n````\n\n<figcaption><a href=\"#listing-19-22\">Lista 19-22</a>: UÅ¼ycie podkreÅ›lenia nie wiÄ…Å¼e wartoÅ›ci.</figcaption>\n</figure>\n\nTen kod dziaÅ‚a bez zarzutu, poniewaÅ¼ nigdy nie wiÄ…Å¼emy `s` z niczym; nie zostaje przeniesione.\n\n<a id=\"ignoring-remaining-parts-of-a-value-with-\"></a>\n\n#### PozostaÅ‚e CzÄ™Å›ci WartoÅ›ci za pomocÄ… `..`\n\nW przypadku wartoÅ›ci, ktÃ³re majÄ… wiele czÄ™Å›ci, moÅ¼emy uÅ¼yÄ‡ skÅ‚adni `..`, aby uÅ¼yÄ‡ konkretnych czÄ™Å›ci i zignorowaÄ‡ resztÄ™, unikajÄ…c koniecznoÅ›ci wymieniania podkreÅ›leÅ„ dla kaÅ¼dej ignorowanej wartoÅ›ci. Wzorzec `..` ignoruje wszystkie czÄ™Å›ci wartoÅ›ci, ktÃ³rych nie dopasowaliÅ›my jawnie w pozostaÅ‚ej czÄ™Å›ci wzorca. Na LiÅ›cie 19-23 mamy strukturÄ™ `Point`, ktÃ³ra przechowuje wspÃ³Å‚rzÄ™dnÄ… w trÃ³jwymiarowej przestrzeni. W wyraÅ¼eniu `match` chcemy operowaÄ‡ tylko na wspÃ³Å‚rzÄ™dnej `x` i ignorowaÄ‡ wartoÅ›ci w polach `y` i `z`.\n\n<figure class=\"listing\" id=\"listing-19-23\">\n\n````rust\n# fn main() {\n    struct Point {\n        x: i32,\n        y: i32,\n        z: i32,\n    }\n\n    let origin = Point { x: 0, y: 0, z: 0 };\n\n    match origin {\n        Point { x, .. } => println!(\"x is {x}\"),\n    }\n# }\n````\n\n<figcaption><a href=\"#listing-19-23\">Lista 19-23</a>: Ignorowanie wszystkich pÃ³l <code>Point</code> oprÃ³cz <code>x</code> za pomocÄ… <code>..</code></figcaption>\n</figure>\n\nWypisujemy wartoÅ›Ä‡ `x`, a nastÄ™pnie po prostu dodajemy wzorzec `..`. Jest to szybsze niÅ¼ koniecznoÅ›Ä‡ wypisywania `y: _` i `z: _`, szczegÃ³lnie gdy pracujemy ze strukturami, ktÃ³re majÄ… wiele pÃ³l w sytuacjach, gdy tylko jedno lub dwa pola sÄ… istotne.\n\nSkÅ‚adnia `..` rozszerzy siÄ™ do tylu wartoÅ›ci, ile potrzebuje. Lista 19-24 pokazuje, jak uÅ¼ywaÄ‡ `..` z krotkÄ….\n\n<figure class=\"listing\" id=\"listing-19-24\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\nfn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (first, .., last) => {\n            println!(\"Some numbers: {first}, {last}\");\n        }\n    }\n}\n````\n\n<figcaption><a href=\"#listing-19-24\">Lista 19-24</a>: Dopasowywanie tylko pierwszej i ostatniej wartoÅ›ci w krotce i ignorowanie wszystkich pozostaÅ‚ych wartoÅ›ci</figcaption>\n</figure>\n\nW tym kodzie pierwsza i ostatnia wartoÅ›Ä‡ sÄ… dopasowywane do `first` i `last`. `..` dopasuje i zignoruje wszystko poÅ›rodku.\n\nJednakÅ¼e, uÅ¼ywanie `..` musi byÄ‡ jednoznaczne. JeÅ›li nie jest jasne, ktÃ³re wartoÅ›ci sÄ… przeznaczone do dopasowania, a ktÃ³re powinny zostaÄ‡ zignorowane, Rust zgÅ‚osi bÅ‚Ä…d. Lista 19-25 pokazuje przykÅ‚ad niejednoznacznego uÅ¼ycia `..`, dlatego nie skompiluje siÄ™.\n\n<figure class=\"listing\" id=\"listing-19-25\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore,does_not_compile\nfn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (.., second, ..) => {\n            println!(\"Some numbers: {second}\")\n        },\n    }\n}\n````\n\n<figcaption><a href=\"#listing-19-25\">Lista 19-25</a>: PrÃ³ba uÅ¼ycia <code>..</code> w sposÃ³b niejednoznaczny</figcaption>\n</figure>\n\nKiedy skompilujemy ten przykÅ‚ad, otrzymamy ten bÅ‚Ä…d:\n\n````console\n$ cargo run\n   Compiling patterns v0.1.0 (file:///projects/patterns)\nerror: `..` can only be used once per tuple pattern\n --> src/main.rs:5:22\n  |\n5 |         (.., second, ..) => {\n  |          --          ^^ can only be used once per tuple pattern\n  |          |\n  |          previously used here\n\nerror: could not compile `patterns` (bin \"patterns\") due to 1 previous error\n````\n\nRust nie jest w stanie okreÅ›liÄ‡, ile wartoÅ›ci w krotce naleÅ¼y zignorowaÄ‡ przed dopasowaniem wartoÅ›ci do `second`, a nastÄ™pnie ile dalszych wartoÅ›ci naleÅ¼y zignorowaÄ‡. Ten kod mÃ³gÅ‚by oznaczaÄ‡, Å¼e chcemy zignorowaÄ‡ `2`, powiÄ…zaÄ‡ `second` z `4`, a nastÄ™pnie zignorowaÄ‡ `8`, `16` i `32`; albo Å¼e chcemy zignorowaÄ‡ `2` i `4`, powiÄ…zaÄ‡ `second` z `8`, a nastÄ™pnie zignorowaÄ‡ `16` i `32`; i tak dalej. Nazwa zmiennej `second` nie oznacza niczego specjalnego dla Rust, wiÄ™c otrzymujemy bÅ‚Ä…d kompilatora, poniewaÅ¼ uÅ¼ycie `..` w dwÃ³ch miejscach w ten sposÃ³b jest niejednoznaczne.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"extra-conditionals-with-match-guards\"></a>\n\n### Dodawanie WarunkÃ³w za pomocÄ… Match GuardÃ³w\n\n*Match guard* to dodatkowy warunek `if`, okreÅ›lony po wzorcu w ramieniu `match`, ktÃ³ry rÃ³wnieÅ¼ musi zostaÄ‡ speÅ‚niony, aby to ramiÄ™ zostaÅ‚o wybrane. Match guardy sÄ… przydatne do wyraÅ¼ania bardziej zÅ‚oÅ¼onych idei niÅ¼ sam wzorzec. ZauwaÅ¼ jednak, Å¼e sÄ… one dostÄ™pne tylko w wyraÅ¼eniach `match`, a nie w wyraÅ¼eniach `if let` ani `while let`.\n\nWarunek moÅ¼e uÅ¼ywaÄ‡ zmiennych utworzonych we wzorcu. Lista 19-26 pokazuje `match`, gdzie pierwsze ramiÄ™ ma wzorzec `Some(x)` i dodatkowo match guard `if x % 2 == 0` (ktÃ³ry bÄ™dzie `true`, jeÅ›li liczba jest parzysta).\n\n<figure class=\"listing\" id=\"listing-19-26\">\n\n````rust\n# fn main() {\n    let num = Some(4);\n\n    match num {\n        Some(x) if x % 2 == 0 => println!(\"The number {x} is even\"),\n        Some(x) => println!(\"The number {x} is odd\"),\n        None => (),\n    }\n# }\n````\n\n<figcaption><a href=\"#listing-19-26\">Lista 19-26</a>: Dodawanie match guarda do wzorca</figcaption>\n</figure>\n\nTen przykÅ‚ad wypisze `The number 4 is even`. Gdy `num` jest porÃ³wnywane z wzorcem w pierwszym ramieniu, pasuje, poniewaÅ¼ `Some(4)` pasuje do `Some(x)`. NastÄ™pnie match guard sprawdza, czy reszta z dzielenia `x` przez 2 jest rÃ³wna 0, a poniewaÅ¼ tak jest, wybrane zostaje pierwsze ramiÄ™.\n\nGdyby `num` byÅ‚o `Some(5)` zamiast tego, match guard w pierwszym ramieniu byÅ‚by `false`, poniewaÅ¼ reszta z dzielenia 5 przez 2 wynosi 1, co nie jest rÃ³wne 0. Rust nastÄ™pnie przeszedÅ‚by do drugiego ramienia, ktÃ³re by pasowaÅ‚o, poniewaÅ¼ drugie ramiÄ™ nie ma match guarda i dlatego pasuje do dowolnego wariantu `Some`.\n\nNie ma sposobu, aby wyraziÄ‡ warunek `if x % 2 == 0` w ramach wzorca, wiÄ™c match guard daje nam moÅ¼liwoÅ›Ä‡ wyraÅ¼enia tej logiki. WadÄ… tej dodatkowej ekspresywnoÅ›ci jest to, Å¼e kompilator nie prÃ³buje sprawdzaÄ‡ kompletnoÅ›ci, gdy w grÄ™ wchodzÄ… wyraÅ¼enia match guard.\n\nPodczas omawiania Listy 19-11, wspomnieliÅ›my, Å¼e moglibyÅ›my uÅ¼yÄ‡ match guardÃ³w do rozwiÄ…zania naszego problemu z zasÅ‚anianiem wzorcÃ³w. Przypomnijmy, Å¼e stworzyliÅ›my nowÄ… zmiennÄ… wewnÄ…trz wzorca w wyraÅ¼eniu `match` zamiast uÅ¼ywaÄ‡ zmiennej poza `match`. Ta nowa zmienna oznaczaÅ‚a, Å¼e nie mogliÅ›my testowaÄ‡ wartoÅ›ci zmiennej zewnÄ™trznej. Lista 19-27 pokazuje, jak moÅ¼emy uÅ¼yÄ‡ match guarda, aby naprawiÄ‡ ten problem.\n\n<figure class=\"listing\" id=\"listing-19-27\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\nfn main() {\n    let x = Some(5);\n    let y = 10;\n\n    match x {\n        Some(50) => println!(\"Got 50\"),\n        Some(n) if n == y => println!(\"Matched, n = {n}\"),\n        _ => println!(\"Default case, x = {x:?}\"),\n    }\n\n    println!(\"at the end: x = {x:?}, y = {y}\");\n}\n````\n\n<figcaption><a href=\"#listing-19-27\">Lista 19-27</a>: UÅ¼ycie match guarda do testowania rÃ³wnoÅ›ci z zewnÄ™trznÄ… zmiennÄ…</figcaption>\n</figure>\n\nTen kod wydrukuje teraz `Default case, x = Some(5)`. Wzorzec w drugim ramieniu `match` nie wprowadza nowej zmiennej `y`, ktÃ³ra zasÅ‚aniaÅ‚aby zewnÄ™trznÄ… `y`, co oznacza, Å¼e moÅ¼emy uÅ¼yÄ‡ zewnÄ™trznej `y` w match guardzie. Zamiast okreÅ›laÄ‡ wzorzec jako `Some(y)`, co zasÅ‚oniÅ‚oby zewnÄ™trznÄ… `y`, okreÅ›lamy `Some(n)`. Tworzy to nowÄ… zmiennÄ… `n`, ktÃ³ra niczego nie zasÅ‚ania, poniewaÅ¼ poza `match` nie ma zmiennej `n`.\n\nMatch guard `if n == y` nie jest wzorcem i dlatego nie wprowadza nowych zmiennych. To `y` *jest* zewnÄ™trznym `y`, a nie nowym `y` je zasÅ‚aniajÄ…cym, i moÅ¼emy szukaÄ‡ wartoÅ›ci, ktÃ³ra ma takÄ… samÄ… wartoÅ›Ä‡ jak zewnÄ™trzne `y`, porÃ³wnujÄ…c `n` z `y`.\n\nMoÅ¼esz rÃ³wnieÅ¼ uÅ¼yÄ‡ operatora *lub* `|` w match guardzie, aby okreÅ›liÄ‡ wiele wzorcÃ³w; warunek match guarda bÄ™dzie miaÅ‚ zastosowanie do wszystkich wzorcÃ³w. Lista 19-28 pokazuje pierwszeÅ„stwo przy Å‚Ä…czeniu wzorca uÅ¼ywajÄ…cego `|` z match guardem. WaÅ¼nÄ… czÄ™Å›ciÄ… tego przykÅ‚adu jest to, Å¼e match guard `if y` ma zastosowanie do `4`, `5` *i* `6`, mimo Å¼e moÅ¼e wydawaÄ‡ siÄ™, Å¼e `if y` ma zastosowanie tylko do `6`.\n\n<figure class=\"listing\" id=\"listing-19-28\">\n\n````rust\n# fn main() {\n    let x = 4;\n    let y = false;\n\n    match x {\n        4 | 5 | 6 if y => println!(\"yes\"),\n        _ => println!(\"no\"),\n    }\n# }\n````\n\n<figcaption><a href=\"#listing-19-28\">Lista 19-28</a>: ÅÄ…czenie wielu wzorcÃ³w z match guardem</figcaption>\n</figure>\n\nWarunek dopasowania stwierdza, Å¼e ramiÄ™ pasuje tylko wtedy, gdy wartoÅ›Ä‡ `x` jest rÃ³wna `4`, `5` lub `6` *i* jeÅ›li `y` jest `true`. Kiedy ten kod siÄ™ uruchamia, wzorzec pierwszego ramienia pasuje, poniewaÅ¼ `x` wynosi `4`, ale match guard `if y` jest `false`, wiÄ™c pierwsze ramiÄ™ nie zostaje wybrane. Kod przechodzi do drugiego ramienia, ktÃ³re pasuje, a program wypisuje `no`. Powodem jest to, Å¼e warunek `if` ma zastosowanie do caÅ‚ego wzorca `4 | 5 | 6`, a nie tylko do ostatniej wartoÅ›ci `6`. Innymi sÅ‚owy, pierwszeÅ„stwo match guarda w stosunku do wzorca zachowuje siÄ™ w ten sposÃ³b:\n\n````text\n(4 | 5 | 6) if y => ...\n````\n\nzamiast tego:\n\n````text\n4 | 5 | (6 if y) => ...\n````\n\nPo uruchomieniu kodu zachowanie pierwszeÅ„stwa jest oczywiste: gdyby match guard byÅ‚ stosowany tylko do ostatniej wartoÅ›ci na liÅ›cie wartoÅ›ci okreÅ›lonych za pomocÄ… operatora `|`, ramiÄ™ pasowaÅ‚oby, a program wydrukowaÅ‚by `yes`.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"-bindings\"></a>\n\n### UÅ¼ywanie WiÄ…zaÅ„ `@`\n\nOperator *at* `@` pozwala nam utworzyÄ‡ zmiennÄ…, ktÃ³ra przechowuje wartoÅ›Ä‡ w tym samym czasie, gdy testujemy tÄ™ wartoÅ›Ä‡ pod kÄ…tem dopasowania wzorca. Na LiÅ›cie 19-29 chcemy sprawdziÄ‡, czy pole `id` w `Message::Hello` mieÅ›ci siÄ™ w zakresie `3..=7`. Chcemy rÃ³wnieÅ¼ powiÄ…zaÄ‡ wartoÅ›Ä‡ ze zmiennÄ… `id`, aby mÃ³c jej uÅ¼yÄ‡ w kodzie skojarzonym z ramieniem.\n\n<figure class=\"listing\" id=\"listing-19-29\">\n\n````rust\n# fn main() {\n    enum Message {\n        Hello { id: i32 },\n    }\n\n    let msg = Message::Hello { id: 5 };\n\n    match msg {\n        Message::Hello { id: id @ 3..=7 } => {\n            println!(\"Found an id in range: {id}\")\n        }\n        Message::Hello { id: 10..=12 } => {\n            println!(\"Found an id in another range\")\n        }\n        Message::Hello { id } => println!(\"Found some other id: {id}\"),\n    }\n# }\n````\n\n<figcaption><a href=\"#listing-19-29\">Lista 19-29</a>: UÅ¼ycie <code>@</code> do zwiÄ…zania siÄ™ z wartoÅ›ciÄ… we wzorcu, jednoczeÅ›nie jÄ… testujÄ…c</figcaption>\n</figure>\n\nTen przykÅ‚ad wydrukuje `Found an id in range: 5`. OkreÅ›lajÄ…c `id @` przed zakresem `3..=7`, przechwytujemy dowolnÄ… wartoÅ›Ä‡, ktÃ³ra pasuje do zakresu, w zmiennej nazwanej `id`, jednoczeÅ›nie testujÄ…c, czy wartoÅ›Ä‡ pasuje do wzorca zakresu.\n\nW drugim ramieniu, gdzie we wzorcu mamy okreÅ›lony tylko zakres, kod skojarzony z ramieniem nie ma zmiennej zawierajÄ…cej faktycznÄ… wartoÅ›Ä‡ pola `id`. WartoÅ›Ä‡ pola `id` mogÅ‚a wynosiÄ‡ 10, 11 lub 12, ale kod, ktÃ³ry towarzyszy temu wzorcowi, nie wie, ktÃ³ra to jest. Kod wzorca nie jest w stanie uÅ¼yÄ‡ wartoÅ›ci z pola `id`, poniewaÅ¼ nie zapisaliÅ›my wartoÅ›ci `id` w zmiennej.\n\nW ostatnim ramieniu, gdzie okreÅ›liliÅ›my zmiennÄ… bez zakresu, mamy dostÄ™pnÄ… wartoÅ›Ä‡ do uÅ¼ycia w kodzie ramienia w zmiennej o nazwie `id`. Powodem jest to, Å¼e uÅ¼yliÅ›my skrÃ³conej skÅ‚adni pÃ³l struktury. Ale w tym ramieniu nie zastosowaliÅ›my Å¼adnego testu do wartoÅ›ci w polu `id`, tak jak zrobiliÅ›my to w dwÃ³ch pierwszych ramionach: dowolna wartoÅ›Ä‡ pasowaÅ‚aby do tego wzorca.\n\nUÅ¼ywanie `@` pozwala nam testowaÄ‡ wartoÅ›Ä‡ i zapisywaÄ‡ jÄ… w zmiennej w ramach jednego wzorca.\n\n## Podsumowanie\n\nWzorce Rust sÄ… bardzo przydatne w rozrÃ³Å¼nianiu rÃ³Å¼nych rodzajÃ³w danych. UÅ¼ywane w wyraÅ¼eniach `match`, Rust zapewnia, Å¼e Twoje wzorce obejmujÄ… kaÅ¼dÄ… moÅ¼liwÄ… wartoÅ›Ä‡, w przeciwnym razie TwÃ³j program siÄ™ nie skompiluje. Wzorce w instrukcjach `let` i parametrach funkcji czyniÄ… te konstrukcje bardziej uÅ¼ytecznymi, umoÅ¼liwiajÄ…c dekonstrukcjÄ™ wartoÅ›ci na mniejsze czÄ™Å›ci i przypisywanie tych czÄ™Å›ci do zmiennych. MoÅ¼emy tworzyÄ‡ proste lub zÅ‚oÅ¼one wzorce, aby sprostaÄ‡ naszym potrzebom.\n\nNastÄ™pnie, w przedostatnim rozdziale ksiÄ…Å¼ki, przyjrzymy siÄ™ niektÃ³rym zaawansowanym aspektom rÃ³Å¼nych funkcji Rust.",
        "chapter_title": "SkÅ‚adnia WzorcÃ³w"
    },
    {
        "file_path": "ch20-00-advanced-features.md",
        "content": "# Zaawansowane Funkcje\n\nDo tej pory poznaÅ‚eÅ› najczÄ™Å›ciej uÅ¼ywane czÄ™Å›ci jÄ™zyka programowania Rust. Zanim przejdziemy do kolejnego projektu w Rozdziale 21, przyjrzymy siÄ™ kilku aspektom jÄ™zyka, z ktÃ³rymi moÅ¼esz siÄ™ od czasu do czasu spotkaÄ‡, ale ktÃ³rych byÄ‡ moÅ¼e nie bÄ™dziesz uÅ¼ywaÄ‡ na co dzieÅ„. MoÅ¼esz uÅ¼ywaÄ‡ tego rozdziaÅ‚u jako odniesienia, gdy napotkasz jakieÅ› niewiadome. Funkcje omÃ³wione tutaj sÄ… przydatne w bardzo specyficznych sytuacjach. ChociaÅ¼ moÅ¼esz nie siÄ™gaÄ‡ po nie czÄ™sto, chcemy upewniÄ‡ siÄ™, Å¼e rozumiesz wszystkie funkcje, ktÃ³re Rust ma do zaoferowania.\n\nW tym rozdziale omÃ³wimy:\n\n* Niebezpieczny Rust: Jak zrezygnowaÄ‡ z niektÃ³rych gwarancji Rust i wziÄ…Ä‡ odpowiedzialnoÅ›Ä‡ za rÄ™czne ich utrzymanie\n* Zaawansowane traity: Typy stowarzyszone, domyÅ›lne parametry typÃ³w, w peÅ‚ni kwalifikowana skÅ‚adnia, supertraity i wzorzec newtype w odniesieniu do traitÃ³w\n* Zaawansowane typy: WiÄ™cej o wzorcu newtype, aliasach typÃ³w, typie nigdy i typach o dynamicznym rozmiarze\n* Zaawansowane funkcje i domkniÄ™cia: WskaÅºniki funkcji i zwracanie domkniÄ™Ä‡\n* Makrodefinicje: Sposoby definiowania kodu, ktÃ³ry definiuje wiÄ™cej kodu w czasie kompilacji\n\nTo prawdziwa paleta funkcji Rust, w ktÃ³rej kaÅ¼dy znajdzie coÅ› dla siebie! Zanurzmy siÄ™!",
        "chapter_title": "Zaawansowane Funkcje"
    },
    {
        "file_path": "ch20-01-unsafe-rust.md",
        "content": "## Niebezpieczny Rust\n\nWszystkie omawiane do tej pory kody miaÅ‚y gwarancje bezpieczeÅ„stwa pamiÄ™ci Rust egzekwowane w czasie kompilacji. Jednak Rust ma w sobie drugi, ukryty jÄ™zyk, ktÃ³ry nie egzekwuje tych gwarancji bezpieczeÅ„stwa pamiÄ™ci: nazywa siÄ™ go *niebezpiecznym Rustem* i dziaÅ‚a dokÅ‚adnie tak samo jak zwykÅ‚y Rust, ale daje nam dodatkowe supermoce.\n\nNiebezpieczny Rust istnieje, poniewaÅ¼ z natury analiza statyczna jest konserwatywna. Kiedy kompilator prÃ³buje okreÅ›liÄ‡, czy kod speÅ‚nia gwarancje, lepiej jest, aby odrzuciÅ‚ niektÃ³re prawidÅ‚owe programy, niÅ¼ zaakceptowaÅ‚ niektÃ³re nieprawidÅ‚owe programy. ChociaÅ¼ kod *moÅ¼e* byÄ‡ w porzÄ…dku, jeÅ›li kompilator Rust nie ma wystarczajÄ…cych informacji, aby byÄ‡ pewnym, odrzuci kod. W takich przypadkach moÅ¼esz uÅ¼yÄ‡ kodu niebezpiecznego, aby powiedzieÄ‡ kompilatorowi: â€Zaufaj mi, wiem, co robiÄ™â€. Ostrzegamy jednak, Å¼e uÅ¼ywasz niebezpiecznego Rust na wÅ‚asne ryzyko: jeÅ›li uÅ¼yjesz kodu niebezpiecznego niepoprawnie, mogÄ… wystÄ…piÄ‡ problemy z powodu niebezpieczeÅ„stwa pamiÄ™ci, takie jak dereferencja wskaÅºnika null.\n\nInnym powodem, dla ktÃ³rego Rust ma swoje niebezpieczne alter ego, jest to, Å¼e podstawowy sprzÄ™t komputerowy jest z natury niebezpieczny. Gdyby Rust nie pozwalaÅ‚ na wykonywanie niebezpiecznych operacji, nie moÅ¼na by wykonywaÄ‡ pewnych zadaÅ„. Rust musi pozwalaÄ‡ na programowanie systemÃ³w niskiego poziomu, takie jak bezpoÅ›rednia interakcja z systemem operacyjnym, a nawet pisanie wÅ‚asnego systemu operacyjnego. Praca z programowaniem systemÃ³w niskiego poziomu jest jednym z celÃ³w jÄ™zyka. Przyjrzyjmy siÄ™, co moÅ¼emy zrobiÄ‡ z niebezpiecznym Rust i jak to zrobiÄ‡.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"unsafe-superpowers\"></a>\n\n### Wykonywanie Niebezpiecznych Supermocy\n\nAby przeÅ‚Ä…czyÄ‡ siÄ™ na niebezpieczny Rust, uÅ¼yj sÅ‚owa kluczowego `unsafe`, a nastÄ™pnie rozpocznij nowy blok, ktÃ³ry zawiera niebezpieczny kod. W niebezpiecznym Rust moÅ¼esz wykonaÄ‡ piÄ™Ä‡ akcji, ktÃ³rych nie moÅ¼esz w bezpiecznym Rust, ktÃ³re nazywamy *niebezpiecznymi supermocami*. Te supermoce obejmujÄ… zdolnoÅ›Ä‡ do:\n\n1. Dereferencji surowego wskaÅºnika.\n1. WywoÅ‚ania niebezpiecznej funkcji lub metody.\n1. DostÄ™pu lub modyfikacji zmiennej statycznej zmiennej.\n1. Implementacji niebezpiecznej cechy.\n1. DostÄ™pu do pÃ³l `union`Ã³w.\n\nWaÅ¼ne jest, aby zrozumieÄ‡, Å¼e `unsafe` nie wyÅ‚Ä…cza sprawdzania poÅ¼yczania (borrow checker) ani nie wyÅ‚Ä…cza Å¼adnych innych kontroli bezpieczeÅ„stwa Rust: jeÅ›li uÅ¼yjesz referencji w kodzie niebezpiecznym, nadal bÄ™dzie ona sprawdzana. SÅ‚owo kluczowe `unsafe` daje jedynie dostÄ™p do tych piÄ™ciu funkcji, ktÃ³re nastÄ™pnie nie sÄ… sprawdzane przez kompilator pod kÄ…tem bezpieczeÅ„stwa pamiÄ™ci. Nadal uzyskasz pewien stopieÅ„ bezpieczeÅ„stwa wewnÄ…trz bloku `unsafe`.\n\nPonadto, `unsafe` nie oznacza, Å¼e kod wewnÄ…trz bloku jest koniecznie niebezpieczny lub Å¼e na pewno bÄ™dzie miaÅ‚ problemy z bezpieczeÅ„stwem pamiÄ™ci: intencjÄ… jest, aby jako programista zapewniÅ‚, Å¼e kod wewnÄ…trz bloku `unsafe` bÄ™dzie miaÅ‚ dostÄ™p do pamiÄ™ci w prawidÅ‚owy sposÃ³b.\n\nLudzie sÄ… omylni i bÅ‚Ä™dy siÄ™ zdarzÄ…, ale wymagajÄ…c, aby te piÄ™Ä‡ niebezpiecznych operacji znajdowaÅ‚o siÄ™ w blokach opatrzonych adnotacjÄ… `unsafe`, bÄ™dziesz wiedzieÄ‡, Å¼e wszelkie bÅ‚Ä™dy zwiÄ…zane z bezpieczeÅ„stwem pamiÄ™ci muszÄ… znajdowaÄ‡ siÄ™ w bloku `unsafe`. PamiÄ™taj, aby bloki `unsafe` byÅ‚y maÅ‚e; bÄ™dziesz za to wdziÄ™czny pÃ³Åºniej, gdy bÄ™dziesz badaÄ‡ bÅ‚Ä™dy pamiÄ™ci.\n\nAby jak najbardziej izolowaÄ‡ niebezpieczny kod, najlepiej jest umieÅ›ciÄ‡ go w bezpiecznej abstrakcji i udostÄ™pniÄ‡ bezpieczne API, co omÃ³wimy pÃ³Åºniej w rozdziale, gdy bÄ™dziemy badaÄ‡ niebezpieczne funkcje i metody. CzÄ™Å›ci biblioteki standardowej sÄ… implementowane jako bezpieczne abstrakcje nad niebezpiecznym kodem, ktÃ³ry zostaÅ‚ poddany audytowi. Opakowanie niebezpiecznego kodu w bezpiecznÄ… abstrakcjÄ™ zapobiega wyciekaniu uÅ¼ycia `unsafe` do wszystkich miejsc, w ktÃ³rych Ty lub Twoi uÅ¼ytkownicy moglibyÅ›cie chcieÄ‡ uÅ¼yÄ‡ funkcjonalnoÅ›ci zaimplementowanej za pomocÄ… kodu `unsafe`, poniewaÅ¼ uÅ¼ycie bezpiecznej abstrakcji jest bezpieczne.\n\nPrzyjrzyjmy siÄ™ z kolei kaÅ¼dej z piÄ™ciu niebezpiecznych supermocy. Przyjrzymy siÄ™ rÃ³wnieÅ¼ niektÃ³rym abstrakcjom, ktÃ³re zapewniajÄ… bezpieczny interfejs do niebezpiecznego kodu.\n\n### Dereferencja Surowego WskaÅºnika\n\nW Rozdziale 4, w sekcji [â€WiszÄ…ce referencjeâ€][dangling-references]<!-- ignore -->, wspomnieliÅ›my, Å¼e kompilator zapewnia, Å¼e referencje sÄ… zawsze prawidÅ‚owe. Niebezpieczny Rust ma dwa nowe typy zwane *surowymi wskaÅºnikami*, ktÃ³re sÄ… podobne do referencji. Podobnie jak referencje, surowe wskaÅºniki mogÄ… byÄ‡ niemodyfikowalne lub modyfikowalne i sÄ… zapisywane odpowiednio jako `*const T` i `*mut T`. Gwiazdka nie jest operatorem dereferencji; jest czÄ™Å›ciÄ… nazwy typu. W kontekÅ›cie surowych wskaÅºnikÃ³w, *niemodyfikowalne* oznacza, Å¼e wskaÅºnik nie moÅ¼e byÄ‡ bezpoÅ›rednio przypisany po dereferencji.\n\nRÃ³Å¼niÄ…ce siÄ™ od referencji i inteligentnych wskaÅºnikÃ³w, surowe wskaÅºniki:\n\n* MogÄ… ignorowaÄ‡ zasady poÅ¼yczania, posiadajÄ…c zarÃ³wno niemodyfikowalne, jak i modyfikowalne wskaÅºniki, lub wiele modyfikowalnych wskaÅºnikÃ³w do tej samej lokalizacji\n* Nie majÄ… gwarancji, Å¼e wskazujÄ… na prawidÅ‚owÄ… pamiÄ™Ä‡\n* MogÄ… byÄ‡ null\n* Nie implementujÄ… Å¼adnego automatycznego czyszczenia\n\nRezygnujÄ…c z egzekwowania tych gwarancji przez Rust, moÅ¼esz zrezygnowaÄ‡ z gwarantowanego bezpieczeÅ„stwa w zamian za wiÄ™kszÄ… wydajnoÅ›Ä‡ lub moÅ¼liwoÅ›Ä‡ wspÃ³Å‚pracy z innym jÄ™zykiem lub sprzÄ™tem, gdzie gwarancje Rust nie majÄ… zastosowania.\n\nLista 20-1 pokazuje, jak utworzyÄ‡ niemodyfikowalny i modyfikowalny surowy wskaÅºnik.\n\n<figure class=\"listing\" id=\"listing-20-1\">\n\n````rust\n# fn main() {\n    let mut num = 5;\n\n    let r1 = &raw const num;\n    let r2 = &raw mut num;\n# }\n````\n\n<figcaption><a href=\"#listing-20-1\">Lista 20-1</a>: Tworzenie surowych wskaÅºnikÃ³w za pomocÄ… operatorÃ³w surowego poÅ¼yczania</figcaption>\n</figure>\n\nZauwaÅ¼, Å¼e w tym kodzie nie uÅ¼ywamy sÅ‚owa kluczowego `unsafe`. MoÅ¼emy tworzyÄ‡ surowe wskaÅºniki w bezpiecznym kodzie; po prostu nie moÅ¼emy dereferencjonowaÄ‡ surowych wskaÅºnikÃ³w poza blokiem unsafe, jak zobaczysz za chwilÄ™.\n\nStworzyliÅ›my surowe wskaÅºniki za pomocÄ… operatorÃ³w surowego poÅ¼yczania: `&raw const num` tworzy niemodyfikowalny surowy wskaÅºnik `*const i32`, a `&raw mut num` tworzy modyfikowalny surowy wskaÅºnik `*mut i32`. PoniewaÅ¼ stworzyliÅ›my je bezpoÅ›rednio ze zmiennej lokalnej, wiemy, Å¼e te konkretne surowe wskaÅºniki sÄ… prawidÅ‚owe, ale nie moÅ¼emy zakÅ‚adaÄ‡ tego samego o kaÅ¼dym surowym wskaÅºniku.\n\nAby to zademonstrowaÄ‡, nastÄ™pnie stworzymy surowy wskaÅºnik, ktÃ³rego waÅ¼noÅ›ci nie moÅ¼emy byÄ‡ tak pewni, uÅ¼ywajÄ…c sÅ‚owa kluczowego `as` do rzutowania wartoÅ›ci zamiast operatora surowego poÅ¼yczenia. Lista 20-2 pokazuje, jak stworzyÄ‡ surowy wskaÅºnik do dowolnej lokalizacji w pamiÄ™ci. PrÃ³ba uÅ¼ycia dowolnej pamiÄ™ci jest niezdefiniowana: pod tym adresem mogÄ… byÄ‡ dane lub nie, kompilator moÅ¼e zoptymalizowaÄ‡ kod tak, Å¼e nie ma dostÄ™pu do pamiÄ™ci, lub program moÅ¼e zakoÅ„czyÄ‡ siÄ™ bÅ‚Ä™dem segmentacji. Zazwyczaj nie ma dobrego powodu do pisania takiego kodu, zwÅ‚aszcza w przypadkach, gdy zamiast tego moÅ¼na uÅ¼yÄ‡ operatora surowego poÅ¼yczenia, ale jest to moÅ¼liwe.\n\n<figure class=\"listing\" id=\"listing-20-2\">\n\n````rust\n# fn main() {\n    let address = 0x012345usize;\n    let r = address as *const i32;\n# }\n````\n\n<figcaption><a href=\"#listing-20-2\">Lista 20-2</a>: Tworzenie surowego wskaÅºnika do dowolnego adresu pamiÄ™ci</figcaption>\n</figure>\n\nPrzypomnij sobie, Å¼e moÅ¼emy tworzyÄ‡ surowe wskaÅºniki w bezpiecznym kodzie, ale nie moÅ¼emy ich dereferencjonowaÄ‡ i odczytywaÄ‡ wskazywanych danych. Na LiÅ›cie 20-3 uÅ¼ywamy operatora dereferencji `*` na surowym wskaÅºniku, co wymaga bloku `unsafe`.\n\n<figure class=\"listing\" id=\"listing-20-3\">\n\n````rust\n# fn main() {\n    let mut num = 5;\n\n    let r1 = &raw const num;\n    let r2 = &raw mut num;\n\n    unsafe {\n        println!(\"r1 is: {}\", *r1);\n        println!(\"r2 is: {}\", *r2);\n    }\n# }\n````\n\n<figcaption><a href=\"#listing-20-3\">Lista 20-3</a>: Dereferencja surowych wskaÅºnikÃ³w wewnÄ…trz bloku <code>unsafe</code></figcaption>\n</figure>\n\nTworzenie wskaÅºnika nie szkodzi; dopiero gdy prÃ³bujemy uzyskaÄ‡ dostÄ™p do wartoÅ›ci, na ktÃ³rÄ… wskazuje, moÅ¼emy skoÅ„czyÄ‡ z nieprawidÅ‚owÄ… wartoÅ›ciÄ….\n\nZauwaÅ¼ rÃ³wnieÅ¼, Å¼e na LiÅ›cie 20-1 i 20-3 stworzyliÅ›my surowe wskaÅºniki `*const i32` i `*mut i32`, ktÃ³re oba wskazywaÅ‚y na tÄ™ samÄ… lokalizacjÄ™ w pamiÄ™ci, gdzie przechowywany jest `num`. GdybyÅ›my zamiast tego sprÃ³bowali stworzyÄ‡ niemodyfikowalnÄ… i modyfikowalnÄ… referencjÄ™ do `num`, kod nie skompilowaÅ‚by siÄ™, poniewaÅ¼ zasady wÅ‚asnoÅ›ci Rust nie pozwalajÄ… na jednoczesne istnienie modyfikowalnej referencji i niemodyfikowalnych referencji. Z surowymi wskaÅºnikami moÅ¼emy stworzyÄ‡ modyfikowalny wskaÅºnik i niemodyfikowalny wskaÅºnik do tej samej lokalizacji i zmieniaÄ‡ dane za pomocÄ… modyfikowalnego wskaÅºnika, potencjalnie tworzÄ…c wyÅ›cig danych. BÄ…dÅº ostroÅ¼ny!\n\nPrzy wszystkich tych niebezpieczeÅ„stwach, dlaczego w ogÃ³le miaÅ‚byÅ› uÅ¼ywaÄ‡ surowych wskaÅºnikÃ³w? Jednym z gÅ‚Ã³wnych przypadkÃ³w uÅ¼ycia jest interakcja z kodem C, jak zobaczysz w nastÄ™pnej sekcji. Innym przypadkiem jest budowanie bezpiecznych abstrakcji, ktÃ³rych sprawdzajÄ…cy poÅ¼yczanie nie rozumie. Przedstawimy niebezpieczne funkcje, a nastÄ™pnie przyjrzymy siÄ™ przykÅ‚adowi bezpiecznej abstrakcji, ktÃ³ra uÅ¼ywa niebezpiecznego kodu.\n\n### WywoÅ‚ywanie Niebezpiecznej Funkcji lub Metody\n\nDrugi rodzaj operacji, ktÃ³rÄ… moÅ¼na wykonaÄ‡ w bloku unsafe, to wywoÅ‚anie niebezpiecznych funkcji. Niebezpieczne funkcje i metody wyglÄ…dajÄ… dokÅ‚adnie tak samo jak zwykÅ‚e funkcje i metody, ale majÄ… dodatkowe `unsafe` przed resztÄ… definicji. SÅ‚owo kluczowe `unsafe` w tym kontekÅ›cie wskazuje, Å¼e funkcja ma wymagania, ktÃ³re musimy speÅ‚niÄ‡, gdy jÄ… wywoÅ‚ujemy, poniewaÅ¼ Rust nie moÅ¼e zagwarantowaÄ‡, Å¼e speÅ‚niliÅ›my te wymagania. WywoÅ‚ujÄ…c niebezpiecznÄ… funkcjÄ™ w bloku `unsafe`, mÃ³wimy, Å¼e przeczytaliÅ›my dokumentacjÄ™ tej funkcji i bierzemy odpowiedzialnoÅ›Ä‡ za przestrzeganie jej kontraktÃ³w.\n\nOto niebezpieczna funkcja o nazwie `dangerous`, ktÃ³ra nic nie robi w swoim ciele:\n\n````rust\n# fn main() {\n    unsafe fn dangerous() {}\n\n    unsafe {\n        dangerous();\n    }\n# }\n````\n\nMusimy wywoÅ‚aÄ‡ funkcjÄ™ `dangerous` w osobnym bloku `unsafe`. JeÅ›li sprÃ³bujemy wywoÅ‚aÄ‡ `dangerous` bez bloku `unsafe`, otrzymamy bÅ‚Ä…d:\n\n````console\n$ cargo run\n   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)\nerror[E0133]: call to unsafe function `dangerous` is unsafe and requires unsafe block\n --> src/main.rs:4:5\n  |\n4 |     dangerous();\n  |     ^^^^^^^^^^^ call to unsafe function\n  |\n  = note: consult the function's documentation for information on how to avoid undefined behavior\n\nFor more information about this error, try `rustc --explain E0133`.\nerror: could not compile `unsafe-example` (bin \"unsafe-example\") due to 1 previous error\n````\n\nDziÄ™ki blokowi `unsafe` zapewniamy Rust, Å¼e przeczytaliÅ›my dokumentacjÄ™ funkcji, rozumiemy, jak jej wÅ‚aÅ›ciwie uÅ¼ywaÄ‡, i zweryfikowaliÅ›my, Å¼e speÅ‚niamy kontrakt funkcji.\n\nAby wykonywaÄ‡ niebezpieczne operacje w ciele funkcji `unsafe`, nadal musisz uÅ¼yÄ‡ bloku `unsafe`, tak jak w zwykÅ‚ej funkcji, a kompilator ostrzeÅ¼e CiÄ™, jeÅ›li zapomnisz. Pomaga to nam utrzymywaÄ‡ bloki `unsafe` tak maÅ‚e, jak to moÅ¼liwe, poniewaÅ¼ operacje niebezpieczne mogÄ… nie byÄ‡ potrzebne w caÅ‚ym ciele funkcji.\n\n#### Tworzenie Bezpiecznej Abstrakcji nad Niebezpiecznym Kodem\n\nTo, Å¼e funkcja zawiera niebezpieczny kod, nie oznacza, Å¼e musimy oznaczyÄ‡ caÅ‚Ä… funkcjÄ™ jako niebezpiecznÄ…. W rzeczywistoÅ›ci, opakowywanie niebezpiecznego kodu w bezpiecznÄ… funkcjÄ™ jest powszechnÄ… abstrakcjÄ…. Jako przykÅ‚ad, przeanalizujmy funkcjÄ™ `split_at_mut` z biblioteki standardowej, ktÃ³ra wymaga pewnego niebezpiecznego kodu. Zbadamy, jak moglibyÅ›my jÄ… zaimplementowaÄ‡. Ta bezpieczna metoda jest zdefiniowana dla zmiennych wycinkÃ³w: bierze jeden wycinek i tworzy z niego dwa, dzielÄ…c wycinek na indeksie podanym jako argument. Lista 20-4 pokazuje, jak uÅ¼ywaÄ‡ `split_at_mut`.\n\n<figure class=\"listing\" id=\"listing-20-4\">\n\n````rust\n# fn main() {\n    let mut v = vec![1, 2, 3, 4, 5, 6];\n\n    let r = &mut v[..];\n\n    let (a, b) = r.split_at_mut(3);\n\n    assert_eq!(a, &mut [1, 2, 3]);\n    assert_eq!(b, &mut [4, 5, 6]);\n# }\n````\n\n<figcaption><a href=\"#listing-20-4\">Lista 20-4</a>: UÅ¼ycie bezpiecznej funkcji <code>split_at_mut</code></figcaption>\n</figure>\n\nNie moÅ¼emy zaimplementowaÄ‡ tej funkcji uÅ¼ywajÄ…c wyÅ‚Ä…cznie bezpiecznego Rust. PrÃ³ba mogÅ‚aby wyglÄ…daÄ‡ mniej wiÄ™cej jak Lista 20-5, ktÃ³ra siÄ™ nie skompiluje. Dla uproszczenia, zaimplementujemy `split_at_mut` jako funkcjÄ™, a nie metodÄ™, i tylko dla wycinkÃ³w wartoÅ›ci `i32`, a nie dla generycznego typu `T`.\n\n<figure class=\"listing\" id=\"listing-20-5\">\n\n````rust,ignore,does_not_compile\nfn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {\n    let len = values.len();\n\n    assert!(mid <= len);\n\n    (&mut values[..mid], &mut values[mid..])\n}\n# \n# fn main() {\n#     let mut vector = vec![1, 2, 3, 4, 5, 6];\n#     let (left, right) = split_at_mut(&mut vector, 3);\n# }\n````\n\n<figcaption><a href=\"#listing-20-5\">Lista 20-5</a>: PrÃ³ba implementacji <code>split_at_mut</code> uÅ¼ywajÄ…c wyÅ‚Ä…cznie bezpiecznego Rust</figcaption>\n</figure>\n\nTa funkcja najpierw pobiera caÅ‚kowitÄ… dÅ‚ugoÅ›Ä‡ wycinka. NastÄ™pnie sprawdza, czy indeks podany jako parametr mieÅ›ci siÄ™ w wycinku, sprawdzajÄ…c, czy jest mniejszy lub rÃ³wny dÅ‚ugoÅ›ci. Asercja oznacza, Å¼e jeÅ›li przekaÅ¼emy indeks wiÄ™kszy niÅ¼ dÅ‚ugoÅ›Ä‡ do podziaÅ‚u wycinka, funkcja spanikuje, zanim sprÃ³buje uÅ¼yÄ‡ tego indeksu.\n\nNastÄ™pnie zwracamy dwa modyfikowalne wycinki w krotce: jeden od poczÄ…tku oryginalnego wycinka do indeksu `mid` i drugi od `mid` do koÅ„ca wycinka.\n\nKiedy sprÃ³bujemy skompilowaÄ‡ kod z Listy 20-5, otrzymamy bÅ‚Ä…d:\n\n````console\n$ cargo run\n   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)\nerror[E0499]: cannot borrow `*values` as mutable more than once at a time\n --> src/main.rs:6:31\n  |\n1 | fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {\n  |                         - let's call the lifetime of this reference `'1`\n...\n6 |     (&mut values[..mid], &mut values[mid..])\n  |     --------------------------^^^^^^--------\n  |     |     |                   |\n  |     |     |                   second mutable borrow occurs here\n  |     |     first mutable borrow occurs here\n  |     returning this value requires that `*values` is borrowed for `'1`\n  |\n  = help: use `.split_at_mut(position)` to obtain two mutable non-overlapping sub-slices\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `unsafe-example` (bin \"unsafe-example\") due to 1 previous error\n````\n\nSprawdzajÄ…cy poÅ¼yczanie Rust nie moÅ¼e zrozumieÄ‡, Å¼e poÅ¼yczamy rÃ³Å¼ne czÄ™Å›ci wycinka; wie tylko, Å¼e poÅ¼yczamy z tego samego wycinka dwa razy. PoÅ¼yczanie rÃ³Å¼nych czÄ™Å›ci wycinka jest zasadniczo w porzÄ…dku, poniewaÅ¼ te dwa wycinki nie nakÅ‚adajÄ… siÄ™ na siebie, ale Rust nie jest na tyle sprytny, aby to wiedzieÄ‡. Kiedy wiemy, Å¼e kod jest w porzÄ…dku, ale Rust nie, nadszedÅ‚ czas, aby siÄ™gnÄ…Ä‡ po niebezpieczny kod.\n\nLista 20-6 pokazuje, jak uÅ¼yÄ‡ bloku `unsafe`, surowego wskaÅºnika i kilku wywoÅ‚aÅ„ niebezpiecznych funkcji, aby implementacja `split_at_mut` dziaÅ‚aÅ‚a.\n\n<figure class=\"listing\" id=\"listing-20-6\">\n\n````rust\nuse std::slice;\n\nfn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {\n    let len = values.len();\n    let ptr = values.as_mut_ptr();\n\n    assert!(mid <= len);\n\n    unsafe {\n        (\n            slice::from_raw_parts_mut(ptr, mid),\n            slice::from_raw_parts_mut(ptr.add(mid), len - mid),\n        )\n    }\n}\n# \n# fn main() {\n#     let mut vector = vec![1, 2, 3, 4, 5, 6];\n#     let (left, right) = split_at_mut(&mut vector, 3);\n# }\n````\n\n<figcaption><a href=\"#listing-20-6\">Lista 20-6</a>: UÅ¼ycie niebezpiecznego kodu w implementacji funkcji <code>split_at_mut</code></figcaption>\n</figure>\n\nPrzypomnij sobie z sekcji [â€Typ wycinkaâ€][the-slice-type]<!-- ignore --> w Rozdziale 4, Å¼e wycinek jest wskaÅºnikiem do pewnych danych i dÅ‚ugoÅ›ciÄ… wycinka. UÅ¼ywamy metody `len`, aby uzyskaÄ‡ dÅ‚ugoÅ›Ä‡ wycinka, i metody `as_mut_ptr`, aby uzyskaÄ‡ dostÄ™p do surowego wskaÅºnika wycinka. W tym przypadku, poniewaÅ¼ mamy modyfikowalny wycinek wartoÅ›ci `i32`, `as_mut_ptr` zwraca surowy wskaÅºnik typu `*mut i32`, ktÃ³ry zapisaliÅ›my w zmiennej `ptr`.\n\nUtrzymujemy asercjÄ™, Å¼e indeks `mid` znajduje siÄ™ w zakresie wycinka. NastÄ™pnie przechodzimy do kodu niebezpiecznego: funkcja `slice::from_raw_parts_mut` przyjmuje surowy wskaÅºnik i dÅ‚ugoÅ›Ä‡ i tworzy wycinek. UÅ¼ywamy tej funkcji do stworzenia wycinka, ktÃ³ry zaczyna siÄ™ od `ptr` i ma dÅ‚ugoÅ›Ä‡ `mid` elementÃ³w. NastÄ™pnie wywoÅ‚ujemy metodÄ™ `add` na `ptr` z `mid` jako argumentem, aby uzyskaÄ‡ surowy wskaÅºnik, ktÃ³ry zaczyna siÄ™ na `mid`, i tworzymy wycinek uÅ¼ywajÄ…c tego wskaÅºnika i pozostaÅ‚ej liczby elementÃ³w po `mid` jako dÅ‚ugoÅ›ci.\n\nFunkcja `slice::from_raw_parts_mut` jest niebezpieczna, poniewaÅ¼ przyjmuje surowy wskaÅºnik i musi ufaÄ‡, Å¼e ten wskaÅºnik jest prawidÅ‚owy. Metoda `add` na surowych wskaÅºnikach jest rÃ³wnieÅ¼ niebezpieczna, poniewaÅ¼ musi ufaÄ‡, Å¼e lokalizacja offsetu jest rÃ³wnieÅ¼ prawidÅ‚owym wskaÅºnikiem. Dlatego musieliÅ›my umieÅ›ciÄ‡ blok `unsafe` wokÃ³Å‚ naszych wywoÅ‚aÅ„ `slice::from_raw_parts_mut` i `add`, aby mÃ³c je wywoÅ‚aÄ‡. PatrzÄ…c na kod i dodajÄ…c asercjÄ™, Å¼e `mid` musi byÄ‡ mniejsze lub rÃ³wne `len`, moÅ¼emy stwierdziÄ‡, Å¼e wszystkie surowe wskaÅºniki uÅ¼yte w bloku `unsafe` bÄ™dÄ… prawidÅ‚owe i bÄ™dÄ… wskazywaÄ‡ na dane wewnÄ…trz wycinka. Jest to dopuszczalne i odpowiednie uÅ¼ycie `unsafe`.\n\nZauwaÅ¼, Å¼e nie musimy oznaczaÄ‡ wynikowej funkcji `split_at_mut` jako `unsafe`, a moÅ¼emy wywoÅ‚aÄ‡ tÄ™ funkcjÄ™ z bezpiecznego Rust. StworzyliÅ›my bezpiecznÄ… abstrakcjÄ™ dla niebezpiecznego kodu z implementacjÄ… funkcji, ktÃ³ra uÅ¼ywa kodu `unsafe` w bezpieczny sposÃ³b, poniewaÅ¼ tworzy tylko prawidÅ‚owe wskaÅºniki z danych, do ktÃ³rych ta funkcja ma dostÄ™p.\n\nW przeciwieÅ„stwie do tego, uÅ¼ycie `slice::from_raw_parts_mut` na LiÅ›cie 20-7 prawdopodobnie spowodowaÅ‚oby awariÄ™ programu, gdy wycinek zostaÅ‚by uÅ¼yty. Ten kod pobiera dowolnÄ… lokalizacjÄ™ w pamiÄ™ci i tworzy wycinek o dÅ‚ugoÅ›ci 10 000 elementÃ³w.\n\n<figure class=\"listing\" id=\"listing-20-7\">\n\n````rust\n# fn main() {\n    use std::slice;\n\n    let address = 0x01234usize;\n    let r = address as *mut i32;\n\n    let values: &[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };\n# }\n````\n\n<figcaption><a href=\"#listing-20-7\">Lista 20-7</a>: Tworzenie wycinka z dowolnej lokalizacji w pamiÄ™ci</figcaption>\n</figure>\n\nNie posiadamy pamiÄ™ci w tej dowolnej lokalizacji i nie ma gwarancji, Å¼e wycinek, ktÃ³ry ten kod tworzy, zawiera prawidÅ‚owe wartoÅ›ci `i32`. PrÃ³ba uÅ¼ycia `values` tak, jakby byÅ‚ to prawidÅ‚owy wycinek, prowadzi do niezdefiniowanego zachowania.\n\n#### UÅ¼ywanie funkcji `extern` do wywoÅ‚ywania zewnÄ™trznego kodu\n\nCzasami kod w Rust moÅ¼e potrzebowaÄ‡ interakcji z kodem napisanym w innym jÄ™zyku. W tym celu Rust posiada sÅ‚owo kluczowe `extern`, ktÃ³re uÅ‚atwia tworzenie i uÅ¼ywanie *interfejsu funkcji obcych (FFI)*, czyli sposobu, w jaki jÄ™zyk programowania moÅ¼e definiowaÄ‡ funkcje i umoÅ¼liwiaÄ‡ innemu (obcemu) jÄ™zykowi programowania wywoÅ‚ywanie tych funkcji.\n\nLista 20-8 demonstruje, jak skonfigurowaÄ‡ integracjÄ™ z funkcjÄ… `abs` z biblioteki standardowej C. Funkcje zadeklarowane w blokach `extern` sÄ… zazwyczaj niebezpieczne do wywoÅ‚ywania z kodu Rust, dlatego bloki `extern` muszÄ… byÄ‡ rÃ³wnieÅ¼ oznaczone jako `unsafe`. Powodem jest to, Å¼e inne jÄ™zyki nie egzekwujÄ… zasad i gwarancji Rust, a Rust nie moÅ¼e ich sprawdziÄ‡, wiÄ™c odpowiedzialnoÅ›Ä‡ za zapewnienie bezpieczeÅ„stwa spoczywa na programiÅ›cie.\n\n<figure class=\"listing\" id=\"listing-20-8\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\nunsafe extern \"C\" {\n    fn abs(input: i32) -> i32;\n}\n\nfn main() {\n    unsafe {\n        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n    }\n}\n````\n\n<figcaption><a href=\"#listing-20-8\">Lista 20-8</a>: Deklarowanie i wywoÅ‚ywanie funkcji <code>extern</code> zdefiniowanej w innym jÄ™zyku</figcaption>\n</figure>\n\nW bloku `unsafe extern \"C\"` wymieniamy nazwy i sygnatury funkcji zewnÄ™trznych z innego jÄ™zyka, ktÃ³re chcemy wywoÅ‚aÄ‡. CzÄ™Å›Ä‡ `\"C\"` definiuje, ktÃ³ry *interfejs binarny aplikacji (ABI)* uÅ¼ywa funkcja zewnÄ™trzna: ABI definiuje, jak wywoÅ‚aÄ‡ funkcjÄ™ na poziomie asemblera. ABI `\"C\"` jest najpopularniejsze i jest zgodne z ABI jÄ™zyka programowania C. Informacje o wszystkich ABI obsÅ‚ugiwanych przez Rust sÄ… dostÄ™pne w [referencji Rust][ABI].\n\nKaÅ¼dy element zadeklarowany w bloku `unsafe extern` jest domyÅ›lnie niebezpieczny. Jednak niektÃ³re funkcje FFI *sÄ…* bezpieczne do wywoÅ‚ania. Na przykÅ‚ad funkcja `abs` z biblioteki standardowej C nie ma Å¼adnych ograniczeÅ„ bezpieczeÅ„stwa pamiÄ™ci i wiemy, Å¼e moÅ¼na jÄ… wywoÅ‚aÄ‡ z dowolnÄ… `i32`. W takich przypadkach moÅ¼emy uÅ¼yÄ‡ sÅ‚owa kluczowego `safe`, aby powiedzieÄ‡, Å¼e ta konkretna funkcja jest bezpieczna do wywoÅ‚ania, nawet jeÅ›li znajduje siÄ™ w bloku `unsafe extern`. Po dokonaniu tej zmiany, wywoÅ‚anie jej nie wymaga juÅ¼ bloku `unsafe`, jak pokazano na LiÅ›cie 20-9.\n\n<figure class=\"listing\" id=\"listing-20-9\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\nunsafe extern \"C\" {\n    safe fn abs(input: i32) -> i32;\n}\n\nfn main() {\n    println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n}\n````\n\n<figcaption><a href=\"#listing-20-9\">Lista 20-9</a>: Jawne oznaczanie funkcji jako <code>safe</code> w bloku <code>unsafe extern</code> i bezpieczne jej wywoÅ‚ywanie</figcaption>\n</figure>\n\nOznaczenie funkcji jako `safe` nie czyni jej z natury bezpiecznÄ…! Zamiast tego, jest to obietnica, ktÃ³rÄ… skÅ‚adasz Rust, Å¼e jest bezpieczna. Nadal Twoim obowiÄ…zkiem jest upewnienie siÄ™, Å¼e ta obietnica jest dotrzymana!\n\n#### WywoÅ‚ywanie funkcji Rust z innych jÄ™zykÃ³w\n\nMoÅ¼emy rÃ³wnieÅ¼ uÅ¼yÄ‡ `extern` do stworzenia interfejsu, ktÃ³ry pozwala innym jÄ™zykom wywoÅ‚ywaÄ‡ funkcje Rust. Zamiast tworzyÄ‡ caÅ‚y blok `extern`, dodajemy sÅ‚owo kluczowe `extern` i okreÅ›lamy ABI do uÅ¼ycia tuÅ¼ przed sÅ‚owem kluczowym `fn` dla odpowiedniej funkcji. Musimy rÃ³wnieÅ¼ dodaÄ‡ adnotacjÄ™ `#[unsafe(no_mangle)]`, aby powiedzieÄ‡ kompilatorowi Rust, aby nie zmieniaÅ‚ nazwy tej funkcji. *Mangling* to proces, w ktÃ³rym kompilator zmienia nazwÄ™, ktÃ³rÄ… nadaliÅ›my funkcji, na innÄ… nazwÄ™, ktÃ³ra zawiera wiÄ™cej informacji dla innych czÄ™Å›ci procesu kompilacji, ale jest mniej czytelna dla czÅ‚owieka. KaÅ¼dy kompilator jÄ™zyka programowania nieco inaczej znieksztaÅ‚ca nazwy, wiÄ™c aby funkcja Rust mogÅ‚a byÄ‡ nazwana przez inne jÄ™zyki, musimy wyÅ‚Ä…czyÄ‡ znieksztaÅ‚canie nazw przez kompilator Rust. Jest to niebezpieczne, poniewaÅ¼ bez wbudowanego znieksztaÅ‚cania mogÄ… wystÄ™powaÄ‡ kolizje nazw w bibliotekach, wiÄ™c naszym obowiÄ…zkiem jest upewnienie siÄ™, Å¼e wybrana nazwa jest bezpieczna do eksportu bez znieksztaÅ‚cania.\n\nW poniÅ¼szym przykÅ‚adzie udostÄ™pniamy funkcjÄ™ `call_from_c` z kodu C, po skompilowaniu jej do biblioteki wspÃ³Å‚dzielonej i poÅ‚Ä…czeniu z C:\n\n````\n#[unsafe(no_mangle)]\npub extern \"C\" fn call_from_c() {\n    println!(\"Just called a Rust function from C!\");\n}\n````\n\nTo uÅ¼ycie `extern` wymaga `unsafe` tylko w atrybucie, a nie w bloku `extern`.\n\n### DostÄ™p do Zmiennej Statycznej Modyfikowalnej lub Jej Modyfikowanie\n\nW tej ksiÄ…Å¼ce nie mÃ³wiliÅ›my jeszcze o zmiennych globalnych, ktÃ³re Rust obsÅ‚uguje, ale ktÃ³re mogÄ… byÄ‡ problematyczne z zasadami wÅ‚asnoÅ›ci Rust. JeÅ›li dwa wÄ…tki uzyskujÄ… dostÄ™p do tej samej zmiennej globalnej, moÅ¼e to spowodowaÄ‡ wyÅ›cig danych.\n\nW Rust zmienne globalne nazywane sÄ… zmiennymi *statycznymi*. Lista 20-10 pokazuje przykÅ‚ad deklaracji i uÅ¼ycia zmiennej statycznej z fragmentem ciÄ…gu jako wartoÅ›ciÄ….\n\n<figure class=\"listing\" id=\"listing-20-10\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\nstatic HELLO_WORLD: &str = \"Hello, world!\";\n\nfn main() {\n    println!(\"value is: {HELLO_WORLD}\");\n}\n````\n\n<figcaption><a href=\"#listing-20-10\">Lista 20-10</a>: Definiowanie i uÅ¼ywanie niemodyfikowalnej zmiennej statycznej</figcaption>\n</figure>\n\nZmienne statyczne sÄ… podobne do staÅ‚ych, ktÃ³re omÃ³wiliÅ›my w sekcji [â€Deklarowanie staÅ‚ychâ€][constants]<!-- ignore --> w Rozdziale 3. Nazwy zmiennych statycznych sÄ… konwencjonalnie zapisywane w formacie `SCREAMING_SNAKE_CASE`. Zmienne statyczne mogÄ… przechowywaÄ‡ tylko referencje z czasem Å¼ycia `'static`, co oznacza, Å¼e kompilator Rust moÅ¼e okreÅ›liÄ‡ czas Å¼ycia i nie musimy go jawnie adnotowaÄ‡. DostÄ™p do niemodyfikowalnej zmiennej statycznej jest bezpieczny.\n\nSubtelna rÃ³Å¼nica miÄ™dzy staÅ‚ymi a niemodyfikowalnymi zmiennymi statycznymi polega na tym, Å¼e wartoÅ›ci w zmiennej statycznej majÄ… staÅ‚y adres w pamiÄ™ci. UÅ¼ycie wartoÅ›ci zawsze bÄ™dzie odwoÅ‚ywaÄ‡ siÄ™ do tych samych danych. StaÅ‚e natomiast mogÄ… duplikowaÄ‡ swoje dane za kaÅ¼dym razem, gdy sÄ… uÅ¼ywane. InnÄ… rÃ³Å¼nicÄ… jest to, Å¼e zmienne statyczne mogÄ… byÄ‡ zmienne. DostÄ™p i modyfikacja zmiennych statycznych zmiennych jest *niebezpieczna*. Lista 20-11 pokazuje, jak zadeklarowaÄ‡, uzyskaÄ‡ dostÄ™p i zmodyfikowaÄ‡ zmiennÄ… statycznÄ… zmiennÄ… o nazwie `COUNTER`.\n\n<figure class=\"listing\" id=\"listing-20-11\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\nstatic mut COUNTER: u32 = 0;\n\n/// SAFETY: Calling this from more than a single thread at a time is undefined\n/// behavior, so you *must* guarantee you only call it from a single thread at\n/// a time.\nunsafe fn add_to_count(inc: u32) {\n    unsafe {\n        COUNTER += inc;\n    }\n}\n\nfn main() {\n    unsafe {\n        // SAFETY: This is only called from a single thread in `main`.\n        add_to_count(3);\n        println!(\"COUNTER: {}\", *(&raw const COUNTER));\n    }\n}\n````\n\n<figcaption><a href=\"#listing-20-11\">Lista 20-11</a>: Odczytywanie lub zapisywanie do zmiennej statycznej zmiennej jest niebezpieczne.</figcaption>\n</figure>\n\nPodobnie jak w przypadku zwykÅ‚ych zmiennych, mutowalnoÅ›Ä‡ okreÅ›lamy za pomocÄ… sÅ‚owa kluczowego `mut`. KaÅ¼dy kod, ktÃ³ry odczytuje lub zapisuje z `COUNTER`, musi znajdowaÄ‡ siÄ™ w bloku `unsafe`. Kod z Listy 20-11 kompiluje siÄ™ i wypisuje `COUNTER: 3`, tak jak byÅ›my siÄ™ spodziewali, poniewaÅ¼ jest jednowÄ…tkowy. DostÄ™p do `COUNTER` z wielu wÄ…tkÃ³w prawdopodobnie skutkowaÅ‚by wyÅ›cigami danych, wiÄ™c jest to niezdefiniowane zachowanie. Dlatego musimy oznaczyÄ‡ caÅ‚Ä… funkcjÄ™ jako `unsafe` i udokumentowaÄ‡ ograniczenie bezpieczeÅ„stwa, aby kaÅ¼dy, kto wywoÅ‚uje funkcjÄ™, wiedziaÅ‚, co mu wolno, a czego nie wolno bezpiecznie robiÄ‡.\n\nZawsze, gdy piszemy funkcjÄ™ `unsafe`, idiomatyczne jest umieszczenie komentarza zaczynajÄ…cego siÄ™ od `SAFETY` i wyjaÅ›niajÄ…cego, co wywoÅ‚ujÄ…cy musi zrobiÄ‡, aby bezpiecznie wywoÅ‚aÄ‡ funkcjÄ™. Podobnie, zawsze, gdy wykonujemy operacjÄ™ `unsafe`, idiomatyczne jest umieszczenie komentarza zaczynajÄ…cego siÄ™ od `SAFETY`, aby wyjaÅ›niÄ‡, w jaki sposÃ³b zasady bezpieczeÅ„stwa sÄ… przestrzegane.\n\nPonadto, kompilator domyÅ›lnie odrzuci wszelkie prÃ³by tworzenia referencji do zmiennej statycznej zmiennej za pomocÄ… lintu kompilatora. Musisz albo jawnie zrezygnowaÄ‡ z ochrony tego lintu, dodajÄ…c adnotacjÄ™ `#[allow(static_mut_refs)]`, albo uzyskaÄ‡ dostÄ™p do zmiennej statycznej zmiennej za poÅ›rednictwem surowego wskaÅºnika utworzonego za pomocÄ… jednego z operatorÃ³w surowego poÅ¼yczania. Obejmuje to przypadki, w ktÃ³rych referencja jest tworzona niewidocznie, jak w przypadku jej uÅ¼ycia w `println!` w tej liÅ›cie kodu. Wymaganie, aby referencje do zmiennych statycznych zmiennych byÅ‚y tworzone za poÅ›rednictwem surowych wskaÅºnikÃ³w, pomaga uczyniÄ‡ wymagania bezpieczeÅ„stwa ich uÅ¼ycia bardziej oczywistymi.\n\nPrzy zmiennych danych, ktÃ³re sÄ… globalnie dostÄ™pne, trudno jest zapewniÄ‡, Å¼e nie ma wyÅ›cigÃ³w danych, dlatego Rust uwaÅ¼a zmienne statyczne zmienne za niebezpieczne. Tam, gdzie to moÅ¼liwe, lepiej jest uÅ¼ywaÄ‡ technik wspÃ³Å‚bieÅ¼noÅ›ci i inteligentnych wskaÅºnikÃ³w bezpiecznych dla wÄ…tkÃ³w, ktÃ³re omÃ³wiliÅ›my w Rozdziale 16, aby kompilator sprawdzaÅ‚, czy dostÄ™p do danych z rÃ³Å¼nych wÄ…tkÃ³w odbywa siÄ™ bezpiecznie.\n\n### Implementowanie Niebezpiecznej Cechy\n\nMoÅ¼emy uÅ¼yÄ‡ `unsafe` do zaimplementowania niebezpiecznej cechy. Cecha jest niebezpieczna, gdy co najmniej jedna z jej metod ma jakÄ…Å› niezmiennÄ…, ktÃ³rej kompilator nie moÅ¼e zweryfikowaÄ‡. Deklarujemy, Å¼e cecha jest `unsafe`, dodajÄ…c sÅ‚owo kluczowe `unsafe` przed `trait` i oznaczajÄ…c implementacjÄ™ cechy jako `unsafe`, jak pokazano na LiÅ›cie 20-12.\n\n<figure class=\"listing\" id=\"listing-20-12\">\n\n````rust\nunsafe trait Foo {\n    // methods go here\n}\n\nunsafe impl Foo for i32 {\n    // method implementations go here\n}\n# \n# fn main() {}\n````\n\n<figcaption><a href=\"#listing-20-12\">Lista 20-12</a>: Definiowanie i implementacja niebezpiecznej cechy</figcaption>\n</figure>\n\nUÅ¼ywajÄ…c `unsafe impl`, obiecujemy, Å¼e bÄ™dziemy przestrzegaÄ‡ niezmiennych, ktÃ³rych kompilator nie moÅ¼e zweryfikowaÄ‡.\n\nJako przykÅ‚ad, przypomnijmy cechy znacznikÃ³w `Send` i `Sync`, ktÃ³re omÃ³wiliÅ›my w sekcji [â€Rozszerzalna wspÃ³Å‚bieÅ¼noÅ›Ä‡ z `Send` i `Sync`â€][send-and-sync]<!-- ignore --> w Rozdziale 16: kompilator implementuje te cechy automatycznie, jeÅ›li nasze typy skÅ‚adajÄ… siÄ™ wyÅ‚Ä…cznie z innych typÃ³w, ktÃ³re implementujÄ… `Send` i `Sync`. JeÅ›li zaimplementujemy typ zawierajÄ…cy typ, ktÃ³ry nie implementuje `Send` lub `Sync`, taki jak surowe wskaÅºniki, i chcemy oznaczyÄ‡ ten typ jako `Send` lub `Sync`, musimy uÅ¼yÄ‡ `unsafe`. Rust nie moÅ¼e zweryfikowaÄ‡, czy nasz typ speÅ‚nia gwarancje, Å¼e moÅ¼e byÄ‡ bezpiecznie przesyÅ‚any miÄ™dzy wÄ…tkami lub dostÄ™pny z wielu wÄ…tkÃ³w; dlatego musimy rÄ™cznie wykonaÄ‡ te sprawdzenia i wskazaÄ‡ to za pomocÄ… `unsafe`.\n\n### DostÄ™p do PÃ³l Unii\n\nOstatniÄ… akcjÄ…, ktÃ³ra dziaÅ‚a tylko z `unsafe`, jest dostÄ™p do pÃ³l unii. *Unia* jest podobna do `struct`, ale tylko jedno zadeklarowane pole jest uÅ¼ywane w danej instancji w danym momencie. Unie sÄ… uÅ¼ywane gÅ‚Ã³wnie do interfejsu z uniami w kodzie C. DostÄ™p do pÃ³l unii jest niebezpieczny, poniewaÅ¼ Rust nie moÅ¼e zagwarantowaÄ‡ typu danych aktualnie przechowywanych w instancji unii. MoÅ¼esz dowiedzieÄ‡ siÄ™ wiÄ™cej o uniach w [referencji Rust][unions].\n\n### UÅ¼ywanie Miri do Sprawdzania Niebezpiecznego Kodu\n\nPodczas pisania kodu niebezpiecznego, moÅ¼esz chcieÄ‡ sprawdziÄ‡, czy to, co napisaÅ‚eÅ›, jest faktycznie bezpieczne i poprawne. Jednym z najlepszych sposobÃ³w na to jest uÅ¼ycie Miri, oficjalnego narzÄ™dzia Rust do wykrywania niezdefiniowanego zachowania. Podczas gdy sprawdzajÄ…cy poÅ¼yczanie (borrow checker) jest narzÄ™dziem *statycznym*, ktÃ³re dziaÅ‚a w czasie kompilacji, Miri jest narzÄ™dziem *dynamicznym*, ktÃ³re dziaÅ‚a w czasie wykonania. Sprawdza TwÃ³j kod, uruchamiajÄ…c TwÃ³j program lub jego pakiet testowy i wykrywajÄ…c, kiedy naruszasz zasady, ktÃ³re rozumie, jak Rust powinien dziaÅ‚aÄ‡.\n\nUÅ¼ywanie Miri wymaga nocnej (nightly) wersji Rust (o ktÃ³rej wiÄ™cej mÃ³wimy w [Dodatku G: Jak powstaje Rust i â€Nocny Rustâ€][nightly]<!-- ignore -->). MoÅ¼esz zainstalowaÄ‡ zarÃ³wno nocnÄ… wersjÄ™ Rust, jak i narzÄ™dzie Miri, wpisujÄ…c `rustup +nightly component add miri`. Nie zmienia to wersji Rust uÅ¼ywanej w Twoim projekcie; dodaje tylko narzÄ™dzie do Twojego systemu, abyÅ› mÃ³gÅ‚ go uÅ¼ywaÄ‡, kiedy zechcesz. Miri moÅ¼esz uruchomiÄ‡ na projekcie, wpisujÄ…c `cargo +nightly miri run` lub `cargo +nightly miri test`.\n\nNa przykÅ‚adzie, jak bardzo to moÅ¼e byÄ‡ pomocne, rozwaÅ¼my, co siÄ™ dzieje, gdy uruchomimy go na LiÅ›cie 20-7.\n\n````console\n$ cargo +nightly miri run\n   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.01s\n     Running `file:///home/.rustup/toolchains/nightly/bin/cargo-miri runner target/miri/debug/unsafe-example`\nwarning: integer-to-pointer cast\n --> src/main.rs:5:13\n  |\n5 |     let r = address as *mut i32;\n  |             ^^^^^^^^^^^^^^^^^^^ integer-to-pointer cast\n  |\n  = help: this program is using integer-to-pointer casts or (equivalently) `ptr::with_exposed_provenance`, which means that Miri might miss pointer bugs in this program\n  = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.with_exposed_provenance.html for more details on that operation\n  = help: to ensure that Miri does not miss bugs in your program, use Strict Provenance APIs (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance, https://crates.io/crates/sptr) instead\n  = help: you can then set `MIRIFLAGS=-Zmiri-strict-provenance` to ensure you are not relying on `with_exposed_provenance` semantics\n  = help: alternatively, `MIRIFLAGS=-Zmiri-permissive-provenance` disables this warning\n  = note: BACKTRACE:\n  = note: inside `main` at src/main.rs:5:13: 5:32\n\nerror: Undefined Behavior: pointer not dereferenceable: pointer must be dereferenceable for 40000 bytes, but got 0x1234[noalloc] which is a dangling pointer (it has no provenance)\n --> src/main.rs:7:35\n  |\n7 |     let values: &[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };\n  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Undefined Behavior occurred here\n  |\n  = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n  = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n  = note: BACKTRACE:\n  = note: inside `main` at src/main.rs:7:35: 7:70\n\nnote: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n````\n\nMiri poprawnie ostrzega nas, Å¼e rzutujemy liczbÄ™ caÅ‚kowitÄ… na wskaÅºnik, co moÅ¼e byÄ‡ problemem, ale Miri nie moÅ¼e ustaliÄ‡, czy problem istnieje, poniewaÅ¼ nie wie, skÄ…d pochodzi wskaÅºnik. NastÄ™pnie Miri zwraca bÅ‚Ä…d, gdzie Lista 20-7 ma niezdefiniowane zachowanie, poniewaÅ¼ mamy wiszÄ…cy wskaÅºnik. DziÄ™ki Miri wiemy teraz, Å¼e istnieje ryzyko niezdefiniowanego zachowania i moÅ¼emy zastanowiÄ‡ siÄ™, jak uczyniÄ‡ kod bezpiecznym. W niektÃ³rych przypadkach Miri moÅ¼e nawet zaleciÄ‡, jak naprawiÄ‡ bÅ‚Ä™dy.\n\nMiri nie wychwytuje wszystkiego, co moÅ¼esz zrobiÄ‡ Åºle podczas pisania niebezpiecznego kodu. Miri to narzÄ™dzie do analizy dynamicznej, wiÄ™c wykrywa problemy tylko w kodzie, ktÃ³ry faktycznie zostaje uruchomiony. Oznacza to, Å¼e bÄ™dziesz musiaÅ‚ uÅ¼ywaÄ‡ go w poÅ‚Ä…czeniu z dobrymi technikami testowania, aby zwiÄ™kszyÄ‡ swojÄ… pewnoÅ›Ä‡ co do napisanego niebezpiecznego kodu. Miri nie obejmuje rÃ³wnieÅ¼ wszystkich moÅ¼liwych sposobÃ³w, w jaki TwÃ³j kod moÅ¼e byÄ‡ niestabilny.\n\nInaczej mÃ³wiÄ…c: jeÅ›li Miri *znajdzie* problem, wiesz, Å¼e jest bÅ‚Ä…d, ale to, Å¼e Miri *nie znajdzie* bÅ‚Ä™du, nie oznacza, Å¼e problemu nie ma. MoÅ¼e jednak wychwyciÄ‡ wiele. SprÃ³buj uruchomiÄ‡ go na innych przykÅ‚adach niebezpiecznego kodu w tym rozdziale i zobacz, co powie!\n\nWiÄ™cej o Miri dowiesz siÄ™ w [repozytorium GitHub][miri].\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"when-to-use-unsafe-code\"></a>\n\n### Poprawne UÅ¼ycie Kodu Niebezpiecznego\n\nUÅ¼ycie `unsafe` do wykorzystania jednej z piÄ™ciu omÃ³wionych wÅ‚aÅ›nie supermocy nie jest bÅ‚Ä™dem ani nawet czymÅ›, na co patrzy siÄ™ krzywo, ale poprawne napisanie kodu `unsafe` jest trudniejsze, poniewaÅ¼ kompilator nie moÅ¼e pomÃ³c w utrzymaniu bezpieczeÅ„stwa pamiÄ™ci. Kiedy masz powÃ³d, aby uÅ¼yÄ‡ kodu `unsafe`, moÅ¼esz to zrobiÄ‡, a jawna adnotacja `unsafe` uÅ‚atwia Å›ledzenie ÅºrÃ³dÅ‚a problemÃ³w, gdy siÄ™ pojawiÄ…. Zawsze, gdy piszesz kod `unsafe`, moÅ¼esz uÅ¼yÄ‡ Miri, aby zwiÄ™kszyÄ‡ pewnoÅ›Ä‡, Å¼e napisany kod przestrzega zasad Rust.\n\nAby uzyskaÄ‡ znacznie gÅ‚Ä™bsze poznanie, jak efektywnie pracowaÄ‡ z niebezpiecznym Rust, przeczytaj oficjalny przewodnik Rust dotyczÄ…cy `unsafe`, [The Rustonomicon][nomicon].\n\n[dangling-references]: ch04-02-references-and-borrowing.html#dangling-references\n[the-slice-type]: ch04-03-slices.html#the-slice-type\n[ABI]: ../reference/items/external-blocks.html#abi\n[constants]: ch03-01-variables-and-mutability.html#declaring-constants\n[send-and-sync]: ch16-04-extensible-concurrency-sync-and-send.html\n[unions]: ../reference/items/unions.html\n[nightly]: appendix-07-nightly-rust.html\n[miri]: https://github.com/rust-lang/miri\n[nomicon]: https://doc.rust-lang.org/nomicon/",
        "chapter_title": "Niebezpieczny Rust"
    },
    {
        "file_path": "ch20-02-advanced-traits.md",
        "content": "## Zaawansowane Traity\n\nPo raz pierwszy omÃ³wiliÅ›my traity w sekcji [â€Definiowanie wspÃ³lnego zachowania za pomocÄ… traitÃ³wâ€][traits]<!-- ignore --> w Rozdziale 10, ale nie omÃ³wiliÅ›my bardziej zaawansowanych szczegÃ³Å‚Ã³w. Teraz, gdy wiesz wiÄ™cej o Rust, moÅ¼emy przejÅ›Ä‡ do sedna.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"specifying-placeholder-types-in-trait-definitions-with-associated-types\"></a>\n<a id=\"associated-types\"></a>\n\n### Definiowanie TraitÃ³w z Typami Stowarzyszonymi\n\n*Typy stowarzyszone* Å‚Ä…czÄ… typ zastÄ™pczy z traitem w taki sposÃ³b, Å¼e definicje metod traitÃ³w mogÄ… uÅ¼ywaÄ‡ tych typÃ³w zastÄ™pczych w swoich sygnaturach. Implementator traitu okreÅ›li konkretny typ, ktÃ³ry ma byÄ‡ uÅ¼yty zamiast typu zastÄ™pczego dla konkretnej implementacji. W ten sposÃ³b moÅ¼emy zdefiniowaÄ‡ trait, ktÃ³ry uÅ¼ywa pewnych typÃ³w, bez koniecznoÅ›ci dokÅ‚adnego poznania tych typÃ³w, dopÃ³ki trait nie zostanie zaimplementowany.\n\nWiÄ™kszoÅ›Ä‡ zaawansowanych funkcji w tym rozdziale opisaliÅ›my jako rzadko potrzebne. Typy stowarzyszone znajdujÄ… siÄ™ gdzieÅ› poÅ›rodku: sÄ… uÅ¼ywane rzadziej niÅ¼ funkcje wyjaÅ›nione w pozostaÅ‚ej czÄ™Å›ci ksiÄ…Å¼ki, ale czÄ™Å›ciej niÅ¼ wiele innych funkcji omÃ³wionych w tym rozdziale.\n\nJednym z przykÅ‚adÃ³w traitu z typem stowarzyszonym jest trait `Iterator`, ktÃ³ry udostÄ™pnia biblioteka standardowa. Typ stowarzyszony nazywa siÄ™ `Item` i zastÄ™puje typ wartoÅ›ci, po ktÃ³rych iteruje typ implementujÄ…cy trait `Iterator`. Definicja traitu `Iterator` jest pokazana na LiÅ›cie 20-13.\n\n<figure class=\"listing\" id=\"listing-20-13\">\n\n````rust,noplayground\npub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n}\n````\n\n<figcaption><a href=\"#listing-20-13\">Lista 20-13</a>: Definicja traitu <code>Iterator</code>, ktÃ³ry ma stowarzyszony typ <code>Item</code></figcaption>\n</figure>\n\nTyp `Item` jest zastÄ™pczy, a definicja metody `next` pokazuje, Å¼e zwrÃ³ci ona wartoÅ›ci typu `Option<Self::Item>`. Implementatorzy traitu `Iterator` okreÅ›lÄ… konkretny typ dla `Item`, a metoda `next` zwrÃ³ci `Option` zawierajÄ…cy wartoÅ›Ä‡ tego konkretnego typu.\n\nTypy stowarzyszone mogÄ… wydawaÄ‡ siÄ™ podobnÄ… koncepcjÄ… do generykÃ³w, w tym sensie, Å¼e te ostatnie pozwalajÄ… nam zdefiniowaÄ‡ funkcjÄ™ bez okreÅ›lania, jakie typy moÅ¼e obsÅ‚ugiwaÄ‡. Aby zbadaÄ‡ rÃ³Å¼nicÄ™ miÄ™dzy tymi dwoma koncepcjami, przyjrzymy siÄ™ implementacji traitu `Iterator` na typie o nazwie `Counter`, ktÃ³ry okreÅ›la, Å¼e typ `Item` to `u32`:\n\n<figure class=\"listing\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,ignore\n# struct Counter {\n#     count: u32,\n# }\n# \n# impl Counter {\n#     fn new() -> Counter {\n#         Counter { count: 0 }\n#     }\n# }\n# \nimpl Iterator for Counter {\n    type Item = u32;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        // --snip--\n#         if self.count < 5 {\n#             self.count += 1;\n#             Some(self.count)\n#         } else {\n#             None\n#         }\n#     }\n# }\n````\n\n</figure>\n\nTa skÅ‚adnia wydaje siÄ™ porÃ³wnywalna do skÅ‚adni generykÃ³w. WiÄ™c dlaczego nie zdefiniowaÄ‡ cechy `Iterator` za pomocÄ… generykÃ³w, jak pokazano na LiÅ›cie 20-14?\n\n<figure class=\"listing\" id=\"listing-20-14\">\n\n````rust,noplayground\npub trait Iterator<T> {\n    fn next(&mut self) -> Option<T>;\n}\n````\n\n<figcaption><a href=\"#listing-20-14\">Lista 20-14</a>: Hipotetyczna definicja traitu <code>Iterator</code> uÅ¼ywajÄ…cego generykÃ³w</figcaption>\n</figure>\n\nRÃ³Å¼nica polega na tym, Å¼e uÅ¼ywajÄ…c generykÃ³w, jak na LiÅ›cie 20-14, musimy adnotowaÄ‡ typy w kaÅ¼dej implementacji; poniewaÅ¼ moÅ¼emy rÃ³wnieÅ¼ zaimplementowaÄ‡ `Iterator<String> for Counter` lub dowolny inny typ, moglibyÅ›my mieÄ‡ wiele implementacji `Iterator` dla `Counter`. Innymi sÅ‚owy, gdy trait ma parametr generyczny, moÅ¼e byÄ‡ implementowany dla typu wiele razy, zmieniajÄ…c konkretne typy generycznych parametrÃ³w typu za kaÅ¼dym razem. Kiedy uÅ¼ywamy metody `next` na `Counter`, musielibyÅ›my podaÄ‡ adnotacje typÃ³w, aby wskazaÄ‡, ktÃ³rÄ… implementacjÄ™ `Iterator` chcemy uÅ¼yÄ‡.\n\nZ typami stowarzyszonymi nie musimy adnotowaÄ‡ typÃ³w, poniewaÅ¼ nie moÅ¼emy zaimplementowaÄ‡ traitu na typie wiele razy. Na LiÅ›cie 20-13 z definicjÄ… uÅ¼ywajÄ…cÄ… typÃ³w stowarzyszonych, moÅ¼emy wybraÄ‡ typ `Item` tylko raz, poniewaÅ¼ moÅ¼e istnieÄ‡ tylko jedna `impl Iterator for Counter`. Nie musimy okreÅ›laÄ‡, Å¼e chcemy iteratora wartoÅ›ci `u32` wszÄ™dzie tam, gdzie wywoÅ‚ujemy `next` na `Counter`.\n\nTypy stowarzyszone stajÄ… siÄ™ rÃ³wnieÅ¼ czÄ™Å›ciÄ… kontraktu traitu: Implementatorzy traitu muszÄ… dostarczyÄ‡ typ, ktÃ³ry zastÄ…pi symbol zastÄ™pczy typu stowarzyszonego. Typy stowarzyszone czÄ™sto majÄ… nazwÄ™ opisujÄ…cÄ… sposÃ³b uÅ¼ycia typu, a dokumentowanie typu stowarzyszonego w dokumentacji API jest dobrÄ… praktykÄ….\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"default-generic-type-parameters-and-operator-overloading\"></a>\n\n### UÅ¼ywanie DomyÅ›lnych ParametrÃ³w TypÃ³w Generycznych i PrzeciÄ…Å¼anie OperatorÃ³w\n\nKiedy uÅ¼ywamy generycznych parametrÃ³w typu, moÅ¼emy okreÅ›liÄ‡ domyÅ›lny konkretny typ dla typu generycznego. Eliminuje to potrzebÄ™ okreÅ›lania konkretnego typu przez implementatorÃ³w cechy, jeÅ›li domyÅ›lny typ dziaÅ‚a. DomyÅ›lny typ okreÅ›la siÄ™ podczas deklarowania typu generycznego za pomocÄ… skÅ‚adni `<PlaceholderType=ConcreteType>`.\n\nÅšwietnym przykÅ‚adem sytuacji, w ktÃ³rej ta technika jest przydatna, jest *przeciÄ…Å¼anie operatorÃ³w*, w ktÃ³rym dostosowujesz zachowanie operatora (takiego jak `+`) w okreÅ›lonych sytuacjach.\n\nRust nie pozwala na tworzenie wÅ‚asnych operatorÃ³w ani na przeciÄ…Å¼anie dowolnych operatorÃ³w. MoÅ¼esz jednak przeciÄ…Å¼aÄ‡ operacje i odpowiadajÄ…ce im traity wymienione w `std::ops`, implementujÄ…c traity powiÄ…zane z operatorem. Na przykÅ‚ad, na LiÅ›cie 20-15 przeciÄ…Å¼amy operator `+`, aby dodawaÄ‡ dwie instancje `Point`. Robimy to, implementujÄ…c trait `Add` na strukturze `Point`.\n\n<figure class=\"listing\" id=\"listing-20-15\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\nuse std::ops::Add;\n\n#[derive(Debug, Copy, Clone, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, other: Point) -> Point {\n        Point {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n\nfn main() {\n    assert_eq!(\n        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n        Point { x: 3, y: 3 }\n    );\n}\n````\n\n<figcaption><a href=\"#listing-20-15\">Lista 20-15</a>: Implementacja traitu <code>Add</code> w celu przeciÄ…Å¼enia operatora <code>+</code> dla instancji <code>Point</code></figcaption>\n</figure>\n\nMetoda `add` dodaje wartoÅ›ci `x` dwÃ³ch instancji `Point` i wartoÅ›ci `y` dwÃ³ch instancji `Point`, aby stworzyÄ‡ nowÄ… `Point`. Trait `Add` ma stowarzyszony typ o nazwie `Output`, ktÃ³ry okreÅ›la typ zwracany przez metodÄ™ `add`.\n\nDomyÅ›lny typ generyczny w tym kodzie znajduje siÄ™ wewnÄ…trz traitu `Add`. Oto jego definicja:\n\n````rust\ntrait Add<Rhs=Self> {\n    type Output;\n\n    fn add(self, rhs: Rhs) -> Self::Output;\n}\n````\n\nTen kod powinien byÄ‡ ogÃ³lnie znany: trait z jednÄ… metodÄ… i stowarzyszonym typem. Nowa czÄ™Å›Ä‡ to `Rhs=Self`: ta skÅ‚adnia nazywa siÄ™ *domyÅ›lnymi parametrami typu*. Generyczny parametr typu `Rhs` (skrÃ³t od â€right-hand sideâ€ â€“ prawa strona) definiuje typ parametru `rhs` w metodzie `add`. JeÅ›li nie okreÅ›limy konkretnego typu dla `Rhs` podczas implementacji traitu `Add`, typ `Rhs` domyÅ›lnie przyjmie `Self`, czyli typ, na ktÃ³rym implementujemy `Add`.\n\nKiedy implementowaliÅ›my `Add` dla `Point`, uÅ¼yliÅ›my domyÅ›lnego `Rhs`, poniewaÅ¼ chcieliÅ›my dodaÄ‡ dwie instancje `Point`. Przyjrzyjmy siÄ™ przykÅ‚adowi implementacji traitu `Add`, gdzie chcemy dostosowaÄ‡ typ `Rhs`, zamiast uÅ¼ywaÄ‡ wartoÅ›ci domyÅ›lnej.\n\nMamy dwie struktury, `Millimeters` i `Meters`, przechowujÄ…ce wartoÅ›ci w rÃ³Å¼nych jednostkach. To cienkie opakowanie istniejÄ…cego typu w innÄ… strukturÄ™ jest znane jako *wzorzec newtype*, ktÃ³ry szczegÃ³Å‚owo opisujemy w sekcji [â€Implementowanie zewnÄ™trznych traitÃ³w za pomocÄ… wzorca newtypeâ€][newtype]<!-- ignore -->. Chcemy dodawaÄ‡ wartoÅ›ci w milimetrach do wartoÅ›ci w metrach i chcemy, aby implementacja `Add` poprawnie wykonywaÅ‚a konwersjÄ™. MoÅ¼emy zaimplementowaÄ‡ `Add` dla `Millimeters` z `Meters` jako `Rhs`, jak pokazano na LiÅ›cie 20-16.\n\n<figure class=\"listing\" id=\"listing-20-16\">\n<span class=\"file-name\">Nazwa pliku: src/lib.rs</span>\n\n````rust,noplayground\nuse std::ops::Add;\n\nstruct Millimeters(u32);\nstruct Meters(u32);\n\nimpl Add<Meters> for Millimeters {\n    type Output = Millimeters;\n\n    fn add(self, other: Meters) -> Millimeters {\n        Millimeters(self.0 + (other.0 * 1000))\n    }\n}\n````\n\n<figcaption><a href=\"#listing-20-16\">Lista 20-16</a>: Implementacja traitu <code>Add</code> na <code>Millimeters</code> w celu dodawania <code>Millimeters</code> i <code>Meters</code></figcaption>\n</figure>\n\nAby dodaÄ‡ `Millimeters` i `Meters`, okreÅ›lamy `impl Add<Meters>`, aby ustawiÄ‡ wartoÅ›Ä‡ parametru typu `Rhs` zamiast uÅ¼ywaÄ‡ domyÅ›lnego `Self`.\n\nParametry typu domyÅ›lnego bÄ™dziesz uÅ¼ywaÄ‡ na dwa gÅ‚Ã³wne sposoby:\n\n1. Aby rozszerzyÄ‡ typ bez naruszania istniejÄ…cego kodu\n1. Aby umoÅ¼liwiÄ‡ dostosowanie w konkretnych przypadkach, ktÃ³rych wiÄ™kszoÅ›Ä‡ uÅ¼ytkownikÃ³w nie bÄ™dzie potrzebowaÄ‡\n\nTrait `Add` z biblioteki standardowej jest przykÅ‚adem drugiego celu: zazwyczaj dodajesz dwa podobne typy, ale trait `Add` zapewnia moÅ¼liwoÅ›Ä‡ dostosowania wykraczajÄ…cego poza to. UÅ¼ycie domyÅ›lnego parametru typu w definicji traitu `Add` oznacza, Å¼e nie musisz okreÅ›laÄ‡ dodatkowego parametru przez wiÄ™kszoÅ›Ä‡ czasu. Innymi sÅ‚owy, nie jest potrzebna pewna iloÅ›Ä‡ kodu boilerplate, co uÅ‚atwia uÅ¼ywanie traitu.\n\nPierwszy cel jest podobny do drugiego, ale odwrotnie: jeÅ›li chcesz dodaÄ‡ parametr typu do istniejÄ…cego traitu, moÅ¼esz nadaÄ‡ mu wartoÅ›Ä‡ domyÅ›lnÄ…, aby umoÅ¼liwiÄ‡ rozszerzenie funkcjonalnoÅ›ci traitu bez naruszania istniejÄ…cego kodu implementacji.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name\"></a>\n<a id=\"disambiguating-between-methods-with-the-same-name\"></a>\n\n### RozrÃ³Å¼nianie Metod o Identycznych Nazwach\n\nNic w Rust nie zapobiega temu, aby trait miaÅ‚ metodÄ™ o tej samej nazwie co metoda innego traitu, ani Rust nie zapobiega implementowaniu obu traitÃ³w na jednym typie. MoÅ¼liwe jest rÃ³wnieÅ¼ zaimplementowanie metody bezpoÅ›rednio na typie z tÄ… samÄ… nazwÄ… co metody z traitÃ³w.\n\nPodczas wywoÅ‚ywania metod o tej samej nazwie, bÄ™dziesz musiaÅ‚ powiedzieÄ‡ Rust, ktÃ³rej chcesz uÅ¼yÄ‡. RozwaÅ¼ kod na LiÅ›cie 20-17, gdzie zdefiniowaliÅ›my dwa traity, `Pilot` i `Wizard`, ktÃ³re oba majÄ… metodÄ™ `fly`. NastÄ™pnie implementujemy oba traity na typie `Human`, ktÃ³ry juÅ¼ ma zaimplementowanÄ… metodÄ™ `fly`. KaÅ¼da metoda `fly` robi coÅ› innego.\n\n<figure class=\"listing\" id=\"listing-20-17\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\ntrait Pilot {\n    fn fly(&self);\n}\n\ntrait Wizard {\n    fn fly(&self);\n}\n\nstruct Human;\n\nimpl Pilot for Human {\n    fn fly(&self) {\n        println!(\"This is your captain speaking.\");\n    }\n}\n\nimpl Wizard for Human {\n    fn fly(&self) {\n        println!(\"Up!\");\n    }\n}\n\nimpl Human {\n    fn fly(&self) {\n        println!(\"*waving arms furiously*\");\n    }\n}\n# \n# fn main() {}\n````\n\n<figcaption><a href=\"#listing-20-17\">Lista 20-17</a>: Dwa traity zdefiniowane jako posiadajÄ…ce metodÄ™ <code>fly</code> i zaimplementowane na typie <code>Human</code>, oraz metoda <code>fly</code> zaimplementowana bezpoÅ›rednio na <code>Human</code>.</figcaption>\n</figure>\n\nKiedy wywoÅ‚ujemy `fly` na instancji `Human`, kompilator domyÅ›lnie wywoÅ‚uje metodÄ™, ktÃ³ra jest bezpoÅ›rednio zaimplementowana na typie, jak pokazano na LiÅ›cie 20-18.\n\n<figure class=\"listing\" id=\"listing-20-18\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\n# trait Pilot {\n#     fn fly(&self);\n# }\n# \n# trait Wizard {\n#     fn fly(&self);\n# }\n# \n# struct Human;\n# \n# impl Pilot for Human {\n#     fn fly(&self) {\n#         println!(\"This is your captain speaking.\");\n#     }\n# }\n# \n# impl Wizard for Human {\n#     fn fly(&self) {\n#         println!(\"Up!\");\n#     }\n# }\n# \n# impl Human {\n#     fn fly(&self) {\n#         println!(\"*waving arms furiously*\");\n#     }\n# }\n# \nfn main() {\n    let person = Human;\n    person.fly();\n}\n````\n\n<figcaption><a href=\"#listing-20-18\">Lista 20-18</a>: WywoÅ‚ywanie <code>fly</code> na instancji <code>Human</code></figcaption>\n</figure>\n\nUruchomienie tego kodu wydrukuje `*waving arms furiously*`, pokazujÄ…c, Å¼e Rust wywoÅ‚aÅ‚ metodÄ™ `fly` zaimplementowanÄ… bezpoÅ›rednio na `Human`.\n\nAby wywoÅ‚aÄ‡ metody `fly` z traitu `Pilot` lub traitu `Wizard`, musimy uÅ¼yÄ‡ bardziej jawnej skÅ‚adni, aby okreÅ›liÄ‡, ktÃ³rÄ… metodÄ™ `fly` mamy na myÅ›li. Lista 20-19 demonstruje tÄ™ skÅ‚adniÄ™.\n\n<figure class=\"listing\" id=\"listing-20-19\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\n# trait Pilot {\n#     fn fly(&self);\n# }\n# \n# trait Wizard {\n#     fn fly(&self);\n# }\n# \n# struct Human;\n# \n# impl Pilot for Human {\n#     fn fly(&self) {\n#         println!(\"This is your captain speaking.\");\n#     }\n# }\n# \n# impl Wizard for Human {\n#     fn fly(&self) {\n#         println!(\"Up!\");\n#     }\n# }\n# \n# impl Human {\n#     fn fly(&self) {\n#         println!(\"*waving arms furiously*\");\n#     }\n# }\n# \nfn main() {\n    let person = Human;\n    Pilot::fly(&person);\n    Wizard::fly(&person);\n    person.fly();\n}\n````\n\n<figcaption><a href=\"#listing-20-19\">Lista 20-19</a>: OkreÅ›lanie, ktÃ³rÄ… metodÄ™ <code>fly</code> z traitu chcemy wywoÅ‚aÄ‡</figcaption>\n</figure>\n\nOkreÅ›lenie nazwy traitu przed nazwÄ… metody wyjaÅ›nia Rust, ktÃ³rÄ… implementacjÄ™ `fly` chcemy wywoÅ‚aÄ‡. MoglibyÅ›my rÃ³wnieÅ¼ napisaÄ‡ `Human::fly(&person)`, co jest rÃ³wnowaÅ¼ne `person.fly()`, ktÃ³rego uÅ¼yliÅ›my na LiÅ›cie 20-19, ale jest to nieco dÅ‚uÅ¼sze do napisania, jeÅ›li nie musimy rozrÃ³Å¼niaÄ‡.\n\nUruchomienie tego kodu wypisuje nastÄ™pujÄ…ce informacje:\n\n````console\n$ cargo run\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.46s\n     Running `target/debug/traits-example`\nThis is your captain speaking.\nUp!\n*waving arms furiously*\n````\n\nPoniewaÅ¼ metoda `fly` przyjmuje parametr `self`, gdybyÅ›my mieli dwa *typy*, ktÃ³re oba implementujÄ… jeden *trait*, Rust mÃ³gÅ‚by ustaliÄ‡, ktÃ³rÄ… implementacjÄ™ traitu uÅ¼yÄ‡ na podstawie typu `self`.\n\nJednak funkcje stowarzyszone, ktÃ³re nie sÄ… metodami, nie majÄ… parametru `self`. Gdy istnieje wiele typÃ³w lub cech, ktÃ³re definiujÄ… funkcje niestowarzyszone z tÄ… samÄ… nazwÄ… funkcji, Rust nie zawsze wie, o ktÃ³ry typ chodzi, chyba Å¼e uÅ¼yjesz w peÅ‚ni kwalifikowanej skÅ‚adni. Na przykÅ‚ad na LiÅ›cie 20-20 tworzymy cechÄ™ dla schroniska dla zwierzÄ…t, ktÃ³re chce nazwaÄ‡ wszystkie szczeniÄ™ta Spot. Tworzymy cechÄ™ `Animal` z powiÄ…zanÄ… funkcjÄ… niestowarzyszonÄ… `baby_name`. Cecha `Animal` jest zaimplementowana dla struktury `Dog`, dla ktÃ³rej rÃ³wnieÅ¼ udostÄ™pniamy bezpoÅ›rednio powiÄ…zanÄ… funkcjÄ™ niestowarzyszonÄ… `baby_name`.\n\n<figure class=\"listing\" id=\"listing-20-20\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\ntrait Animal {\n    fn baby_name() -> String;\n}\n\nstruct Dog;\n\nimpl Dog {\n    fn baby_name() -> String {\n        String::from(\"Spot\")\n    }\n}\n\nimpl Animal for Dog {\n    fn baby_name() -> String {\n        String::from(\"puppy\")\n    }\n}\n\nfn main() {\n    println!(\"A baby dog is called a {}\", Dog::baby_name());\n}\n````\n\n<figcaption><a href=\"#listing-20-20\">Lista 20-20</a>: Trait z funkcjÄ… stowarzyszonÄ… i typ z funkcjÄ… stowarzyszonÄ… o tej samej nazwie, ktÃ³ra rÃ³wnieÅ¼ implementuje trait</figcaption>\n</figure>\n\nImplementujemy kod do nazywania wszystkich szczeniÄ…t Spot w funkcji stowarzyszonej `baby_name`, ktÃ³ra jest zdefiniowana na `Dog`. Typ `Dog` implementuje rÃ³wnieÅ¼ trait `Animal`, ktÃ³ry opisuje cechy, ktÃ³re majÄ… wszystkie zwierzÄ™ta. MÅ‚ode psy nazywane sÄ… szczeniÄ™tami, co jest wyraÅ¼one w implementacji traitu `Animal` na `Dog` w funkcji `baby_name` stowarzyszonej z traitem `Animal`.\n\nW `main` wywoÅ‚ujemy funkcjÄ™ `Dog::baby_name`, ktÃ³ra wywoÅ‚uje bezpoÅ›rednio funkcjÄ™ stowarzyszonÄ… zdefiniowanÄ… na `Dog`. Ten kod wypisuje nastÄ™pujÄ…ce informacje:\n\n````console\n$ cargo run\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s\n     Running `target/debug/traits-example`\nA baby dog is called a Spot\n````\n\nTen wynik nie jest tym, czego chcieliÅ›my. Chcemy wywoÅ‚aÄ‡ funkcjÄ™ `baby_name`, ktÃ³ra jest czÄ™Å›ciÄ… cechy `Animal`, ktÃ³rÄ… zaimplementowaliÅ›my na `Dog`, tak aby kod wypisywaÅ‚ `A baby dog is called a puppy`. Technika okreÅ›lania nazwy cechy, ktÃ³rej uÅ¼yliÅ›my na LiÅ›cie 20-19, nie pomaga tutaj; jeÅ›li zmienimy `main` na kod z Listy 20-21, otrzymamy bÅ‚Ä…d kompilacji.\n\n<figure class=\"listing\" id=\"listing-20-21\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore,does_not_compile\n# trait Animal {\n#     fn baby_name() -> String;\n# }\n# \n# struct Dog;\n# \n# impl Dog {\n#     fn baby_name() -> String {\n#         String::from(\"Spot\")\n#     }\n# }\n# \n# impl Animal for Dog {\n#     fn baby_name() -> String {\n#         String::from(\"puppy\")\n#     }\n# }\n# \nfn main() {\n    println!(\"A baby dog is called a {}\", Animal::baby_name());\n}\n````\n\n<figcaption><a href=\"#listing-20-21\">Lista 20-21</a>: PrÃ³ba wywoÅ‚ania funkcji <code>baby_name</code> z traitu <code>Animal</code>, ale Rust nie wie, ktÃ³rej implementacji uÅ¼yÄ‡</figcaption>\n</figure>\n\nPoniewaÅ¼ `Animal::baby_name` nie ma parametru `self`, a mogÄ… istnieÄ‡ inne typy, ktÃ³re implementujÄ… cechÄ™ `Animal`, Rust nie moÅ¼e ustaliÄ‡, ktÃ³rÄ… implementacjÄ™ `Animal::baby_name` chcemy. Otrzymamy ten bÅ‚Ä…d kompilacji:\n\n````console\n$ cargo run\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\nerror[E0790]: cannot call associated function on trait without specifying the corresponding `impl` type\n  --> src/main.rs:20:43\n   |\n 2 |     fn baby_name() -> String;\n   |     ------------------------- `Animal::baby_name` defined here\n...\n20 |     println!(\"A baby dog is called a {}\", Animal::baby_name());\n   |                                           ^^^^^^^^^^^^^^^^^^^ cannot call associated function of trait\n   |\nhelp: use the fully-qualified path to the only available implementation\n   |\n20 |     println!(\"A baby dog is called a {}\", <Dog as Animal>::baby_name());\n   |                                           +++++++       +\n\nFor more information about this error, try `rustc --explain E0790`.\nerror: could not compile `traits-example` (bin \"traits-example\") due to 1 previous error\n````\n\nAby rozrÃ³Å¼niÄ‡ i powiedzieÄ‡ Rust, Å¼e chcemy uÅ¼yÄ‡ implementacji `Animal` dla `Dog` w przeciwieÅ„stwie do implementacji `Animal` dla jakiegoÅ› innego typu, musimy uÅ¼yÄ‡ w peÅ‚ni kwalifikowanej skÅ‚adni. Lista 20-22 demonstruje, jak uÅ¼ywaÄ‡ w peÅ‚ni kwalifikowanej skÅ‚adni.\n\n<figure class=\"listing\" id=\"listing-20-22\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\n# trait Animal {\n#     fn baby_name() -> String;\n# }\n# \n# struct Dog;\n# \n# impl Dog {\n#     fn baby_name() -> String {\n#         String::from(\"Spot\")\n#     }\n# }\n# \n# impl Animal for Dog {\n#     fn baby_name() -> String {\n#         String::from(\"puppy\")\n#     }\n# }\n# \nfn main() {\n    println!(\"A baby dog is called a {}\", <Dog as Animal>::baby_name());\n}\n````\n\n<figcaption><a href=\"#listing-20-22\">Lista 20-22</a>: UÅ¼ycie w peÅ‚ni kwalifikowanej skÅ‚adni, aby okreÅ›liÄ‡, Å¼e chcemy wywoÅ‚aÄ‡ funkcjÄ™ <code>baby_name</code> z traitu <code>Animal</code> zaimplementowanego na <code>Dog</code></figcaption>\n</figure>\n\nDostarczamy Rust adnotacjÄ™ typu w nawiasach ostrych, ktÃ³ra wskazuje, Å¼e chcemy wywoÅ‚aÄ‡ metodÄ™ `baby_name` z cechy `Animal` zaimplementowanej na `Dog`, mÃ³wiÄ…c, Å¼e chcemy traktowaÄ‡ typ `Dog` jako `Animal` dla tego wywoÅ‚ania funkcji. Ten kod wydrukuje teraz to, czego chcemy:\n\n````console\n$ cargo run\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s\n     Running `target/debug/traits-example`\nA baby dog is called a puppy\n````\n\nOgÃ³lnie, w peÅ‚ni kwalifikowana skÅ‚adnia jest zdefiniowana nastÄ™pujÄ…co:\n\n````rust,ignore\n<Typ jako Trait>::funkcja(odbiorca_jeÅ›li_metoda, nastÄ™pny_argument, ...);\n````\n\nDla funkcji stowarzyszonych, ktÃ³re nie sÄ… metodami, nie byÅ‚oby `odbiorcy`: byÅ‚aby tylko lista innych argumentÃ³w. MoÅ¼na by uÅ¼ywaÄ‡ w peÅ‚ni kwalifikowanej skÅ‚adni wszÄ™dzie tam, gdzie wywoÅ‚uje siÄ™ funkcje lub metody. JednakÅ¼e, moÅ¼na pominÄ…Ä‡ dowolnÄ… czÄ™Å›Ä‡ tej skÅ‚adni, ktÃ³rÄ… Rust moÅ¼e ustaliÄ‡ na podstawie innych informacji w programie. TÄ™ bardziej rozbudowanÄ… skÅ‚adniÄ™ trzeba uÅ¼ywaÄ‡ tylko w przypadkach, gdy istnieje wiele implementacji, ktÃ³re uÅ¼ywajÄ… tej samej nazwy, a Rust potrzebuje pomocy w zidentyfikowaniu, ktÃ³rÄ… implementacjÄ™ chcesz wywoÅ‚aÄ‡.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"using-supertraits-to-require-one-traits-functionality-within-another-trait\"></a>\n\n### UÅ¼ywanie SupertraitÃ³w\n\nCzasami moÅ¼esz napisaÄ‡ definicjÄ™ traitu, ktÃ³ra zaleÅ¼y od innego traitu: Aby typ implementowaÅ‚ pierwszy trait, chcesz wymagaÄ‡, aby ten typ rÃ³wnieÅ¼ implementowaÅ‚ drugi trait. Robisz to po to, aby Twoja definicja traitu mogÅ‚a korzystaÄ‡ ze stowarzyszonych elementÃ³w drugiego traitu. Trait, na ktÃ³rym opiera siÄ™ Twoja definicja traitu, nazywany jest *supertraitem* Twojego traitu.\n\nNa przykÅ‚ad, powiedzmy, Å¼e chcemy stworzyÄ‡ cechÄ™ `OutlinePrint` z metodÄ… `outline_print`, ktÃ³ra bÄ™dzie drukowaÄ‡ podanÄ… wartoÅ›Ä‡ sformatowanÄ… tak, aby byÅ‚a obramowana gwiazdkami. Oznacza to, Å¼e biorÄ…c pod uwagÄ™ strukturÄ™ `Point`, ktÃ³ra implementuje standardowÄ… cechÄ™ `Display`, aby uzyskaÄ‡ `(x, y)`, gdy wywoÅ‚amy `outline_print` na instancji `Point`, ktÃ³ra ma `1` dla `x` i `3` dla `y`, powinna ona wydrukowaÄ‡ nastÄ™pujÄ…ce:\n\n````text\n**********\n*        *\n* (1, 3) *\n*        *\n**********\n````\n\nW implementacji metody `outline_print` chcemy uÅ¼yÄ‡ funkcjonalnoÅ›ci cechy `Display`. Dlatego musimy okreÅ›liÄ‡, Å¼e cecha `OutlinePrint` bÄ™dzie dziaÅ‚aÄ‡ tylko dla typÃ³w, ktÃ³re rÃ³wnieÅ¼ implementujÄ… `Display` i dostarczajÄ… funkcjonalnoÅ›Ä‡, ktÃ³rej potrzebuje `OutlinePrint`. MoÅ¼emy to zrobiÄ‡ w definicji cechy, okreÅ›lajÄ…c `OutlinePrint: Display`. Ta technika jest podobna do dodawania ograniczenia cechy do cechy. Lista 20-23 pokazuje implementacjÄ™ cechy `OutlinePrint`.\n\n<figure class=\"listing\" id=\"listing-20-23\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\nuse std::fmt;\n\ntrait OutlinePrint: fmt::Display {\n    fn outline_print(&self) {\n        let output = self.to_string();\n        let len = output.len();\n        println!(\"{}\", \"*\".repeat(len + 4));\n        println!(\"*{}*\", \" \".repeat(len + 2));\n        println!(\"* {output} *\");\n        println!(\"*{}*\", \" \".repeat(len + 2));\n        println!(\"{}\", \"*\".repeat(len + 4));\n    }\n}\n# \n# fn main() {}\n````\n\n<figcaption><a href=\"#listing-20-23\">Lista 20-23</a>: Implementacja traitu <code>OutlinePrint</code>, ktÃ³ry wymaga funkcjonalnoÅ›ci z <code>Display</code></figcaption>\n</figure>\n\nPoniewaÅ¼ okreÅ›liliÅ›my, Å¼e `OutlinePrint` wymaga traitu `Display`, moÅ¼emy uÅ¼yÄ‡ funkcji `to_string`, ktÃ³ra jest automatycznie implementowana dla kaÅ¼dego typu, ktÃ³ry implementuje `Display`. GdybyÅ›my sprÃ³bowali uÅ¼yÄ‡ `to_string` bez dodania dwukropka i okreÅ›lenia traitu `Display` po nazwie traitu, otrzymalibyÅ›my bÅ‚Ä…d mÃ³wiÄ…cy, Å¼e w bieÅ¼Ä…cym zakresie nie znaleziono metody o nazwie `to_string` dla typu `&Self`.\n\nZobaczmy, co siÄ™ stanie, gdy sprÃ³bujemy zaimplementowaÄ‡ `OutlinePrint` na typie, ktÃ³ry nie implementuje `Display`, takim jak struktura `Point`:\n\n<figure class=\"listing\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust,ignore,does_not_compile\n# use std::fmt;\n# \n# trait OutlinePrint: fmt::Display {\n#     fn outline_print(&self) {\n#         let output = self.to_string();\n#         let len = output.len();\n#         println!(\"{}\", \"*\".repeat(len + 4));\n#         println!(\"*{}*\", \" \".repeat(len + 2));\n#         println!(\"* {output} *\");\n#         println!(\"*{}*\", \" \".repeat(len + 2));\n#         println!(\"{}\", \"*\".repeat(len + 4));\n#     }\n# }\n# \nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl OutlinePrint for Point {}\n# \n# fn main() {\n#     let p = Point { x: 1, y: 3 };\n#     p.outline_print();\n# }\n````\n\n</figure>\n\nOtrzymujemy bÅ‚Ä…d mÃ³wiÄ…cy, Å¼e `Display` jest wymagane, ale nie zaimplementowane:\n\n````console\n$ cargo run\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\nerror[E0277]: `Point` doesn't implement `std::fmt::Display`\n  --> src/main.rs:20:23\n   |\n20 | impl OutlinePrint for Point {}\n   |                       ^^^^^ the trait `std::fmt::Display` is not implemented for `Point`\n   |\nnote: required by a bound in `OutlinePrint`\n  --> src/main.rs:3:21\n   |\n 3 | trait OutlinePrint: fmt::Display {\n   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`\n\nerror[E0277]: `Point` doesn't implement `std::fmt::Display`\n  --> src/main.rs:24:7\n   |\n24 |     p.outline_print();\n   |       ^^^^^^^^^^^^^ the trait `std::fmt::Display` is not implemented for `Point`\n   |\nnote: required by a bound in `OutlinePrint::outline_print`\n  --> src/main.rs:3:21\n   |\n 3 | trait OutlinePrint: fmt::Display {\n   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint::outline_print`\n 4 |     fn outline_print(&self) {\n   |        ------------- required by a bound in this associated function\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `traits-example` (bin \"traits-example\") due to 2 previous errors\n````\n\nAby to naprawiÄ‡, implementujemy `Display` na `Point` i speÅ‚niamy ograniczenie, ktÃ³rego wymaga `OutlinePrint`, w ten sposÃ³b:\n\n<figure class=\"listing\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\n# trait OutlinePrint: fmt::Display {\n#     fn outline_print(&self) {\n#         let output = self.to_string();\n#         let len = output.len();\n#         println!(\"{}\", \"*\".repeat(len + 4));\n#         println!(\"*{}*\", \" \".repeat(len + 2));\n#         println!(\"* {output} *\");\n#         println!(\"*{}*\", \" \".repeat(len + 2));\n#         println!(\"{}\", \"*\".repeat(len + 4));\n#     }\n# }\n# \n# struct Point {\n#     x: i32,\n#     y: i32,\n# }\n# \n# impl OutlinePrint for Point {}\n# \nuse std::fmt;\n\nimpl fmt::Display for Point {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"({}, {})\", self.x, self.y)\n    }\n}\n# \n# fn main() {\n#     let p = Point { x: 1, y: 3 };\n#     p.outline_print();\n# }\n````\n\n</figure>\n\nWtedy implementacja cechy `OutlinePrint` na `Point` skompiluje siÄ™ pomyÅ›lnie, i bÄ™dziemy mogli wywoÅ‚aÄ‡ `outline_print` na instancji `Point`, aby wyÅ›wietliÄ‡ jÄ… w obramowaniu z gwiazdek.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"using-the-newtype-pattern-to-implement-external-traits-on-external-types\"></a>\n<a id=\"using-the-newtype-pattern-to-implement-external-traits\"></a>\n\n### Implementowanie ZewnÄ™trznych TraitÃ³w za pomocÄ… Wzorca Newtype\n\nW sekcji [â€Implementowanie traitu na typieâ€][implementing-a-trait-on-a-type]<!-- ignore --> w Rozdziale 10 wspomnieliÅ›my o regule sieroty, ktÃ³ra stanowi, Å¼e moÅ¼emy implementowaÄ‡ trait na typie tylko wtedy, gdy albo trait, albo typ, albo oba, sÄ… lokalne dla naszego crateâ€™u. MoÅ¼liwe jest obejÅ›cie tego ograniczenia za pomocÄ… wzorca newtype, ktÃ³ry polega na utworzeniu nowego typu w strukturze krotkowej. (Struktury krotkowe omÃ³wiliÅ›my w sekcji [â€Tworzenie rÃ³Å¼nych typÃ³w za pomocÄ… struktur krotkowychâ€][tuple-structs]<!-- ignore --> w Rozdziale 5.) Struktura krotkowa bÄ™dzie miaÅ‚a jedno pole i bÄ™dzie cienkim opakowaniem wokÃ³Å‚ typu, dla ktÃ³rego chcemy zaimplementowaÄ‡ trait. Wtedy typ opakowujÄ…cy jest lokalny dla naszego crateâ€™u, i moÅ¼emy zaimplementowaÄ‡ trait na opakowaniu. *Newtype* to termin, ktÃ³ry pochodzi z jÄ™zyka programowania Haskell. Nie ma kary za wydajnoÅ›Ä‡ w czasie wykonania za uÅ¼ycie tego wzorca, a typ opakowujÄ…cy jest pomijany w czasie kompilacji.\n\nNa przykÅ‚ad, zaÅ‚Ã³Å¼my, Å¼e chcemy zaimplementowaÄ‡ `Display` na `Vec<T>`, czego reguÅ‚a sieroty uniemoÅ¼liwia nam bezpoÅ›rednio, poniewaÅ¼ trait `Display` i typ `Vec<T>` sÄ… zdefiniowane poza naszym crate. MoÅ¼emy stworzyÄ‡ strukturÄ™ `Wrapper`, ktÃ³ra przechowuje instancjÄ™ `Vec<T>`; nastÄ™pnie moÅ¼emy zaimplementowaÄ‡ `Display` na `Wrapper` i uÅ¼yÄ‡ wartoÅ›ci `Vec<T>`, jak pokazano na LiÅ›cie 20-24.\n\n<figure class=\"listing\" id=\"listing-20-24\">\n<span class=\"file-name\">Nazwa pliku: src/main.rs</span>\n\n````rust\nuse std::fmt;\n\nstruct Wrapper(Vec<String>);\n\nimpl fmt::Display for Wrapper {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"[{}]\", self.0.join(\", \"))\n    }\n}\n\nfn main() {\n    let w = Wrapper(vec![String::from(\"hello\"), String::from(\"world\")]);\n    println!(\"w = {w}\");\n}\n````\n\n<figcaption><a href=\"#listing-20-24\">Lista 20-24</a>: Tworzenie typu <code>Wrapper</code> wokÃ³Å‚ <code>Vec&lt;String&gt;</code> w celu implementacji <code>Display</code></figcaption>\n</figure>\n\nImplementacja `Display` uÅ¼ywa `self.0` do dostÄ™pu do wewnÄ™trznego `Vec<T>`, poniewaÅ¼ `Wrapper` jest strukturÄ… krotkowÄ…, a `Vec<T>` jest elementem o indeksie 0 w krotce. NastÄ™pnie moÅ¼emy uÅ¼yÄ‡ funkcjonalnoÅ›ci cechy `Display` na `Wrapper`.\n\nWadÄ… stosowania tej techniki jest to, Å¼e `Wrapper` jest nowym typem, wiÄ™c nie ma metod wartoÅ›ci, ktÃ³rÄ… przechowuje. MusielibyÅ›my zaimplementowaÄ‡ wszystkie metody `Vec<T>` bezpoÅ›rednio na `Wrapper`, tak aby metody delegowaÅ‚y do `self.0`, co pozwoliÅ‚oby nam traktowaÄ‡ `Wrapper` dokÅ‚adnie tak jak `Vec<T>`. GdybyÅ›my chcieli, aby nowy typ miaÅ‚ kaÅ¼dÄ… metodÄ™, ktÃ³rÄ… ma typ wewnÄ™trzny, zaimplementowanie cechy `Deref` na `Wrapper`, aby zwracaÅ‚a typ wewnÄ™trzny, byÅ‚oby rozwiÄ…zaniem (omÃ³wiliÅ›my implementacjÄ™ cechy `Deref` w sekcji [â€Traktowanie inteligentnych wskaÅºnikÃ³w jak zwykÅ‚ych referencjiâ€][smart-pointer-deref]<!-- ignore --> w Rozdziale 15). GdybyÅ›my nie chcieli, aby typ `Wrapper` miaÅ‚ wszystkie metody typu wewnÄ™trznego â€” na przykÅ‚ad, aby ograniczyÄ‡ zachowanie typu `Wrapper` â€” musielibyÅ›my rÄ™cznie zaimplementowaÄ‡ tylko te metody, ktÃ³re chcemy.\n\nTen wzorzec newtype jest rÃ³wnieÅ¼ uÅ¼yteczny nawet wtedy, gdy traity nie sÄ… zaangaÅ¼owane. ZmieÅ„my fokus i przyjrzyjmy siÄ™ niektÃ³rym zaawansowanym sposobom interakcji z systemem typÃ³w Rust.\n\n[traits]: ch10-02-traits.html\n[newtype]: ch20-02-advanced-traits.html#implementing-external-traits-with-the-newtype-pattern\n[implementing-a-trait-on-a-type]: ch10-02-traits.html#implementing-a-trait-on-a-type\n[tuple-structs]: ch05-01-defining-structs.html#creating-different-types-with-tuple-structs\n[smart-pointer-deref]: ch15-02-deref.html#treating-smart-pointers-like-regular-references",
        "chapter_title": "Zaawansowane Traity"
    },
    {
        "file_path": "ch20-03-advanced-types.md",
        "content": "## Zaawansowane Typy\n\nSystem typÃ³w Rust posiada pewne funkcje, o ktÃ³rych wspominaliÅ›my, ale jeszcze\nnie omawialiÅ›my. Zaczniemy od omÃ³wienia ogÃ³lnych \"nowych typÃ³w\" (newtypes),\nbadajÄ…c, dlaczego sÄ… one przydatne jako typy. NastÄ™pnie przejdziemy do aliasÃ³w\ntypÃ³w, funkcji podobnej do \"nowych typÃ³w\", ale z nieco odmiennÄ… semantykÄ….\nOmÃ³wimy takÅ¼e typ `!` oraz typy o dynamicznym rozmiarze.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"using-the-newtype-pattern-for-type-safety-and-abstraction\"></a>\n\n### BezpieczeÅ„stwo typÃ³w i abstrakcja z wzorcem nowego typu\n\nTa sekcja zakÅ‚ada, Å¼e przeczytaÅ‚eÅ› wczeÅ›niejszÄ… sekcjÄ™ [â€Implementowanie cech\nzewnÄ™trznych za pomocÄ… wzorca nowego typuâ€][newtype]<!-- ignore -->. Wzorzec\nnowego typu jest rÃ³wnieÅ¼ przydatny do zadaÅ„ wykraczajÄ…cych poza te, ktÃ³re\nomÃ³wiliÅ›my do tej pory, w tym do statycznego egzekwowania, aby wartoÅ›ci nigdy\nnie byÅ‚y mylone, oraz do wskazywania jednostek wartoÅ›ci. PrzykÅ‚ad uÅ¼ycia\nnowych typÃ³w do wskazywania jednostek widziaÅ‚eÅ› w Listing 20-16: Przypomnij\nsobie, Å¼e struktury `Millimeters` i `Meters` opakowywaÅ‚y wartoÅ›ci `u32` w nowy\ntyp. GdybyÅ›my napisali funkcjÄ™ z parametrem typu `Millimeters`, nie bylibyÅ›my\nw stanie skompilowaÄ‡ programu, ktÃ³ry przypadkowo prÃ³bowaÅ‚by wywoÅ‚aÄ‡ tÄ™ funkcjÄ™\nz wartoÅ›ciÄ… typu `Meters` lub zwykÅ‚ym `u32`.\n\nMoÅ¼emy rÃ³wnieÅ¼ uÅ¼yÄ‡ wzorca nowego typu, aby odseparowaÄ‡ niektÃ³re szczegÃ³Å‚y\nimplementacji typu: Nowy typ moÅ¼e ujawniaÄ‡ publiczne API, ktÃ³re rÃ³Å¼ni siÄ™ od\nAPI prywatnego typu wewnÄ™trznego.\n\nNowe typy mogÄ… rÃ³wnieÅ¼ ukrywaÄ‡ wewnÄ™trznÄ… implementacjÄ™. Na przykÅ‚ad, moglibyÅ›my\ndostarczyÄ‡ typ `People`, aby opakowaÄ‡ `HashMap<i32, String>`, ktÃ³ry przechowuje\nID osoby skojarzone z jej imieniem. Kod uÅ¼ywajÄ…cy `People` wchodziÅ‚by w\ninterakcjÄ™ tylko z publicznym API, ktÃ³re dostarczamy, takim jak metoda\ndodawania ciÄ…gu znakÃ³w z imieniem do kolekcji `People`; ten kod nie musiaÅ‚by\nwiedzieÄ‡, Å¼e wewnÄ™trznie przypisujemy imionom ID typu `i32`. Wzorzec nowego\ntypu to lekki sposÃ³b na osiÄ…gniÄ™cie hermetyzacji w celu ukrycia szczegÃ³Å‚Ã³w\nimplementacji, co omÃ³wiliÅ›my w sekcji [â€Hermetyzacja ukrywajÄ…ca szczegÃ³Å‚y\nimplementacjiâ€][encapsulation-that-hides-implementation-details]<!-- ignore -->\nw Rozdziale 18.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"creating-type-synonyms-with-type-aliases\"></a>\n\n### Synonimy typÃ³w i aliasy typÃ³w\n\nRust umoÅ¼liwia deklarowanie *aliasu typu*, aby nadaÄ‡ istniejÄ…cemu typowi\ninne imiÄ™. UÅ¼ywamy do tego sÅ‚owa kluczowego `type`. Na przykÅ‚ad, moÅ¼emy\nutworzyÄ‡ alias `Kilometers` dla `i32` w nastÄ™pujÄ…cy sposÃ³b:\n\n````rust\n# fn main() {\n    type Kilometers = i32;\n# \n#     let x: i32 = 5;\n#     let y: Kilometers = 5;\n# \n#     println!(\"x + y = {}\", x + y);\n# }\n````\n\nTeraz alias `Kilometers` jest *synonimem* dla `i32`; w przeciwieÅ„stwie do\ntypÃ³w `Millimeters` i `Meters`, ktÃ³re stworzyliÅ›my w Listing 20-16,\n`Kilometers` nie jest osobnym, nowym typem. WartoÅ›ci, ktÃ³re majÄ… typ\n`Kilometers`, bÄ™dÄ… traktowane tak samo jak wartoÅ›ci typu `i32`:\n\n````rust\n# fn main() {\n    type Kilometers = i32;\n\n    let x: i32 = 5;\n    let y: Kilometers = 5;\n\n    println!(\"x + y = {}\", x + y);\n# }\n````\n\nPoniewaÅ¼ `Kilometers` i `i32` sÄ… tego samego typu, moÅ¼emy dodawaÄ‡ wartoÅ›ci obu\ntypÃ³w i przekazywaÄ‡ wartoÅ›ci `Kilometers` do funkcji, ktÃ³re przyjmujÄ…\nparametry `i32`. JednakÅ¼e, uÅ¼ywajÄ…c tej metody, nie uzyskujemy korzyÅ›ci z\nkontroli typÃ³w, ktÃ³re daje wzorzec nowego typu omÃ³wiony wczeÅ›niej. Innymi\nsÅ‚owy, jeÅ›li gdzieÅ› pomylimy wartoÅ›ci `Kilometers` i `i32`, kompilator nie\nzgÅ‚osi nam bÅ‚Ä™du.\n\nGÅ‚Ã³wnym przypadkiem uÅ¼ycia synonimÃ³w typÃ³w jest zmniejszenie powtÃ³rzeÅ„. Na\nprzykÅ‚ad, moÅ¼emy mieÄ‡ dÅ‚ugi typ, taki jak ten:\n\n````rust,ignore\nBox<dyn Fn() + Send + 'static>\n````\n\nPisanie tego dÅ‚ugiego typu w sygnaturach funkcji i jako adnotacji typÃ³w w\ncaÅ‚ym kodzie moÅ¼e byÄ‡ mÄ™czÄ…ce i podatne na bÅ‚Ä™dy. WyobraÅº sobie projekt\npeÅ‚en kodu takiego jak w Listing 20-25.\n\n<figure class=\"listing\" id=\"listing-20-25\">\n\n````rust\n# fn main() {\n    let f: Box<dyn Fn() + Send + 'static> = Box::new(|| println!(\"hi\"));\n\n    fn takes_long_type(f: Box<dyn Fn() + Send + 'static>) {\n        // --snip--\n    }\n\n    fn returns_long_type() -> Box<dyn Fn() + Send + 'static> {\n        // --snip--\n#         Box::new(|| ())\n    }\n# }\n````\n\n<figcaption><a href=\"#listing-20-25\">Listing 20-25</a>: UÅ¼ycie dÅ‚ugiego typu w wielu miejscach</figcaption>\n</figure>\n\nAlias typu sprawia, Å¼e ten kod jest Å‚atwiejszy do zarzÄ…dzania, redukujÄ…c\npowtÃ³rzenia. W Listing 20-26 wprowadziliÅ›my alias nazwany `Thunk` dla\nobszernego typu i moÅ¼emy zastÄ…piÄ‡ wszystkie uÅ¼ycia typu krÃ³tszym aliasem\n`Thunk`.\n\n<figure class=\"listing\" id=\"listing-20-26\">\n\n````rust\n# fn main() {\n    type Thunk = Box<dyn Fn() + Send + 'static>;\n\n    let f: Thunk = Box::new(|| println!(\"hi\"));\n\n    fn takes_long_type(f: Thunk) {\n        // --snip--\n    }\n\n    fn returns_long_type() -> Thunk {\n        // --snip--\n#         Box::new(|| ())\n    }\n# }\n````\n\n<figcaption><a href=\"#listing-20-26\">Listing 20-26</a>: Wprowadzenie aliasu typu, <code>Thunk</code>, w celu zmniejszenia powtÃ³rzeÅ„</figcaption>\n</figure>\n\nTen kod jest znacznie Å‚atwiejszy do czytania i pisania! Wybranie znaczÄ…cej\nnazwy dla aliasu typu moÅ¼e pomÃ³c w komunikowaniu intencji (*thunk* to sÅ‚owo\nopisujÄ…ce kod, ktÃ³ry ma byÄ‡ ewaluowany w pÃ³Åºniejszym czasie, wiÄ™c jest to\nodpowiednia nazwa dla przechowywanego domkniÄ™cia).\n\nAliasy typÃ³w sÄ… rÃ³wnieÅ¼ powszechnie uÅ¼ywane z typem `Result<T, E>` w celu\nzmniejszenia powtÃ³rzeÅ„. RozwaÅ¼ moduÅ‚ `std::io` w standardowej bibliotece.\nOperacje wejÅ›cia/wyjÅ›cia czÄ™sto zwracajÄ… `Result<T, E>`, aby obsÅ‚ugiwaÄ‡\nsytuacje, gdy operacje koÅ„czÄ… siÄ™ niepowodzeniem. Ta biblioteka posiada\nstrukturÄ™ `std::io::Error`, ktÃ³ra reprezentuje wszystkie moÅ¼liwe bÅ‚Ä™dy I/O.\nWiele funkcji w `std::io` bÄ™dzie zwracaÄ‡ `Result<T, E>`, gdzie `E` to\n`std::io::Error`, takie jak te funkcje w cesze `Write`:\n\n````rust,noplayground\nuse std::fmt;\nuse std::io::Error;\n\npub trait Write {\n    fn write(&mut self, buf: &[u8]) -> Result<usize, Error>;\n    fn flush(&mut self) -> Result<(), Error>;\n\n    fn write_all(&mut self, buf: &[u8]) -> Result<(), Error>;\n    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<(), Error>;\n}\n````\n\n`Result<..., Error>` powtarza siÄ™ czÄ™sto. W zwiÄ…zku z tym `std::io` ma tÄ™\ndeklaracjÄ™ aliasu typu:\n\n````rust,noplayground\n# use std::fmt;\n# \ntype Result<T> = std::result::Result<T, std::io::Error>;\n# \n# pub trait Write {\n#     fn write(&mut self, buf: &[u8]) -> Result<usize>;\n#     fn flush(&mut self) -> Result<()>;\n# \n#     fn write_all(&mut self, buf: &[u8]) -> Result<()>;\n#     fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()>;\n# }\n````\n\nPoniewaÅ¼ ta deklaracja znajduje siÄ™ w module `std::io`, moÅ¼emy uÅ¼yÄ‡ w peÅ‚ni\nkwalifikowanego aliasu `std::io::Result<T>`; to znaczy `Result<T, E>`, gdzie\n`E` jest wypeÅ‚nione jako `std::io::Error`. Sygnatury funkcji cechy `Write`\nwyglÄ…dajÄ… tak:\n\n````rust,noplayground\n# use std::fmt;\n# \n# type Result<T> = std::result::Result<T, std::io::Error>;\n# \npub trait Write {\n    fn write(&mut self, buf: &[u8]) -> Result<usize>;\n    fn flush(&mut self) -> Result<()>;\n\n    fn write_all(&mut self, buf: &[u8]) -> Result<()>;\n    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()>;\n}\n````\n\nAlias typu pomaga na dwa sposoby: uÅ‚atwia pisanie kodu *i* zapewnia nam\nspÃ³jny interfejs w caÅ‚ym `std::io`. PoniewaÅ¼ jest to alias, jest to po\nprostu kolejny `Result<T, E>`, co oznacza, Å¼e moÅ¼emy z nim uÅ¼ywaÄ‡ dowolnych\nmetod dziaÅ‚ajÄ…cych na `Result<T, E>`, a takÅ¼e specjalnej skÅ‚adni, takiej jak\noperator `?`.\n\n### Typ Nigdy, ktÃ³ry nigdy nie zwraca\n\nRust posiada specjalny typ nazwany `!`, ktÃ³ry w terminologii teorii typÃ³w\nnazywany jest *typem pustym*, poniewaÅ¼ nie posiada Å¼adnych wartoÅ›ci. My\nwolimy nazywaÄ‡ go *typem nigdy*, poniewaÅ¼ zajmuje on miejsce typu zwracanego,\ngdy funkcja nigdy nie zwraca wartoÅ›ci. Oto przykÅ‚ad:\n\n````rust,noplayground\nfn bar() -> ! {\n    // --snip--\n#     panic!();\n}\n````\n\nTen kod czytamy jako â€funkcja `bar` nigdy nie zwracaâ€. Funkcje, ktÃ³re nigdy nie\nzwracajÄ…, nazywane sÄ… *funkcjami rozbieÅ¼nymi*. Nie moÅ¼emy tworzyÄ‡ wartoÅ›ci\ntypu `!`, wiÄ™c `bar` nigdy nie moÅ¼e zwrÃ³ciÄ‡ wartoÅ›ci.\n\nAle jakie jest zastosowanie typu, dla ktÃ³rego nigdy nie moÅ¼na stworzyÄ‡ wartoÅ›ci?\nPrzypomnijmy kod z Listing 2-5, czÄ™Å›Ä‡ gry w zgadywanie liczb; odtworzyliÅ›my\njego fragment tutaj w Listing 20-27.\n\n<figure class=\"listing\" id=\"listing-20-27\">\n\n````rust,ignore\n# use std::cmp::Ordering;\n# use std::io;\n# \n# use rand::Rng;\n# \n# fn main() {\n#     println!(\"Guess the number!\");\n# \n#     let secret_number = rand::thread_rng().gen_range(1..=100);\n# \n#     println!(\"The secret number is: {secret_number}\");\n# \n#     loop {\n#         println!(\"Please input your guess.\");\n# \n#         let mut guess = String::new();\n# \n#         // --snip--\n# \n#         io::stdin()\n#             .read_line(&mut guess)\n#             .expect(\"Failed to read line\");\n# \n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n# \n#         println!(\"You guessed: {guess}\");\n# \n#         // --snip--\n# \n#         match guess.cmp(&secret_number) {\n#             Ordering::Less => println!(\"Too small!\"),\n#             Ordering::Greater => println!(\"Too big!\"),\n#             Ordering::Equal => {\n#                 println!(\"You win!\");\n#                 break;\n#             }\n#         }\n#     }\n# }\n````\n\n<figcaption><a href=\"#listing-20-27\">Listing 20-27</a>: <code>match</code> z ramieniem, ktÃ³re koÅ„czy siÄ™ na <code>continue</code></figcaption>\n</figure>\n\nWÃ³wczas pominÄ™liÅ›my pewne szczegÃ³Å‚y tego kodu. W sekcji [â€Konstrukcja przepÅ‚ywu\nsterowania `match`â€][the-match-control-flow-construct]<!-- ignore --> w\nRozdziale 6 omÃ³wiliÅ›my, Å¼e ramiona `match` muszÄ… zwracaÄ‡ ten sam typ. Na\nprzykÅ‚ad, poniÅ¼szy kod nie dziaÅ‚a:\n\n````rust,ignore,does_not_compile\n# fn main() {\n#     let guess = \"3\";\n    let guess = match guess.trim().parse() {\n        Ok(_) => 5,\n        Err(_) => \"hello\",\n    };\n# }\n````\n\nTyp `guess` w tym kodzie musiaÅ‚by byÄ‡ liczbÄ… caÅ‚kowitÄ… *i* ciÄ…giem znakÃ³w,\na Rust wymaga, aby `guess` miaÅ‚ tylko jeden typ. Zatem, co zwraca `continue`?\nJak mogliÅ›my zwrÃ³ciÄ‡ `u32` z jednego ramienia i mieÄ‡ drugie ramiÄ™, ktÃ³re koÅ„czy\nsiÄ™ na `continue` w Listing 20-27?\n\nJak siÄ™ domyÅ›lasz, `continue` ma wartoÅ›Ä‡ `!`. Oznacza to, Å¼e gdy Rust\noblicza typ `guess`, patrzy na oba ramiona `match`, pierwsze z wartoÅ›ciÄ… `u32`\ni drugie z wartoÅ›ciÄ… `!`. PoniewaÅ¼ `!` nigdy nie moÅ¼e mieÄ‡ wartoÅ›ci, Rust\nprzyjmuje, Å¼e typ `guess` to `u32`.\n\nFormalny sposÃ³b opisu tego zachowania jest taki, Å¼e wyraÅ¼enia typu `!` mogÄ…\nbyÄ‡ konwertowane na dowolny inny typ. MoÅ¼emy zakoÅ„czyÄ‡ to ramiÄ™ `match` za\npomocÄ… `continue`, poniewaÅ¼ `continue` nie zwraca wartoÅ›ci; zamiast tego\nprzenosi sterowanie na poczÄ…tek pÄ™tli, wiÄ™c w przypadku `Err` nigdy nie\nprzypisujemy wartoÅ›ci do `guess`.\n\nTyp nigdy jest rÃ³wnieÅ¼ przydatny z makrem `panic!`. Przypomnij sobie funkcjÄ™\n`unwrap`, ktÃ³rÄ… wywoÅ‚ujemy na wartoÅ›ciach `Option<T>`, aby wyprodukowaÄ‡\nwartoÅ›Ä‡ lub wywoÅ‚aÄ‡ panikÄ™, z nastÄ™pujÄ…cÄ… definicjÄ…:\n\n````rust,ignore\n# enum Option<T> {\n#     Some(T),\n#     None,\n# }\n# \n# use crate::Option::*;\n# \nimpl<T> Option<T> {\n    pub fn unwrap(self) -> T {\n        match self {\n            Some(val) => val,\n            None => panic!(\"called `Option::unwrap()` on a `None` value\"),\n        }\n    }\n}\n````\n\nW tym kodzie dzieje siÄ™ to samo, co w `match` w Listing 20-27: Rust widzi,\nÅ¼e `val` ma typ `T`, a `panic!` ma typ `!`, wiÄ™c wynikiem caÅ‚ego wyraÅ¼enia\n`match` jest `T`. Ten kod dziaÅ‚a, poniewaÅ¼ `panic!` nie produkuje wartoÅ›ci;\nkoÅ„czy program. W przypadku `None` nie zwrÃ³cimy wartoÅ›ci z `unwrap`, wiÄ™c ten\nkod jest poprawny.\n\nOstatnie wyraÅ¼enie, ktÃ³re ma typ `!`, to pÄ™tla:\n\n````rust,ignore\n# fn main() {\n    print!(\"forever \");\n\n    loop {\n        print!(\"and ever \");\n    }\n# }\n````\n\nTutaj pÄ™tla nigdy siÄ™ nie koÅ„czy, wiÄ™c `!` jest wartoÅ›ciÄ… wyraÅ¼enia. JednakÅ¼e,\nnie byÅ‚oby to prawdÄ…, gdybyÅ›my dodali `break`, poniewaÅ¼ pÄ™tla zakoÅ„czyÅ‚aby siÄ™\nwtedy, gdy doszÅ‚aby do `break`.\n\n### Typy o dynamicznym rozmiarze i cecha `Sized`\n\nRust musi znaÄ‡ pewne szczegÃ³Å‚y dotyczÄ…ce swoich typÃ³w, takie jak ile miejsca\nprzydzieliÄ‡ dla wartoÅ›ci konkretnego typu. To pozostawia jeden zakÄ…tek jego\nsystemu typÃ³w na poczÄ…tku nieco mylÄ…cy: koncepcjÄ™ *typÃ³w o dynamicznym\nrozmiarze*. Czasami nazywane *DST* lub *typami bez rozmiaru*, te typy\numoÅ¼liwiajÄ… pisanie kodu z uÅ¼yciem wartoÅ›ci, ktÃ³rych rozmiar moÅ¼emy poznaÄ‡\ntylko w czasie wykonania.\n\nZagÅ‚Ä™bmy siÄ™ w szczegÃ³Å‚y typu o dynamicznym rozmiarze o nazwie `str`, ktÃ³rego\nuÅ¼ywaliÅ›my w caÅ‚ej ksiÄ…Å¼ce. Zgadza siÄ™, nie `&str`, ale `str` sam w sobie,\njest DST. W wielu przypadkach, takich jak przechowywanie tekstu wprowadzonego\nprzez uÅ¼ytkownika, nie moÅ¼emy wiedzieÄ‡, jak dÅ‚ugi jest ciÄ…g, dopÃ³ki program\nsiÄ™ nie uruchomi. Oznacza to, Å¼e nie moÅ¼emy utworzyÄ‡ zmiennej typu `str`,\nani przyjÄ…Ä‡ argumentu typu `str`. RozwaÅ¼ poniÅ¼szy kod, ktÃ³ry nie dziaÅ‚a:\n\n````rust,ignore,does_not_compile\n# fn main() {\n    let s1: str = \"Hello there!\";\n    let s2: str = \"How's it going?\";\n# }\n````\n\nRust musi wiedzieÄ‡, ile pamiÄ™ci przydzieliÄ‡ dla kaÅ¼dej wartoÅ›ci danego typu,\ni wszystkie wartoÅ›ci danego typu muszÄ… uÅ¼ywaÄ‡ tej samej iloÅ›ci pamiÄ™ci. Gdyby\nRust pozwoliÅ‚ nam napisaÄ‡ ten kod, te dwie wartoÅ›ci `str` musiaÅ‚yby zajmowaÄ‡\ntÄ™ samÄ… iloÅ›Ä‡ miejsca. Ale majÄ… one rÃ³Å¼ne dÅ‚ugoÅ›ci: `s1` potrzebuje 12 bajtÃ³w\npamiÄ™ci, a `s2` potrzebuje 15. Dlatego nie jest moÅ¼liwe utworzenie zmiennej\nprzechowujÄ…cej typ o dynamicznym rozmiarze.\n\nWiÄ™c co robimy? W tym przypadku znasz juÅ¼ odpowiedÅº: Zmieniamy typ `s1` i `s2`\nna wycinek ciÄ…gu znakÃ³w (`&str`), a nie `str`. Przypomnij sobie z sekcji\n[â€Wycinki ciÄ…gÃ³w znakÃ³wâ€][string-slices]<!-- ignore --> w Rozdziale 4,\nÅ¼e struktura danych wycinka przechowuje tylko pozycjÄ™ poczÄ…tkowÄ… i dÅ‚ugoÅ›Ä‡\nwycinka. Zatem, chociaÅ¼ `&T` jest pojedynczÄ… wartoÅ›ciÄ…, ktÃ³ra przechowuje\nadres pamiÄ™ci, gdzie znajduje siÄ™ `T`, wycinek ciÄ…gu znakÃ³w to *dwie* wartoÅ›ci:\nadres `str` i jego dÅ‚ugoÅ›Ä‡. W zwiÄ…zku z tym moÅ¼emy znaÄ‡ rozmiar wartoÅ›ci\nwycinka ciÄ…gu znakÃ³w w czasie kompilacji: Jest to dwukrotnoÅ›Ä‡ dÅ‚ugoÅ›ci `usize`.\nOznacza to, Å¼e zawsze znamy rozmiar wycinka ciÄ…gu znakÃ³w, niezaleÅ¼nie od tego,\njak dÅ‚ugi jest ciÄ…g, do ktÃ³rego siÄ™ odnosi. OgÃ³lnie rzecz biorÄ…c, w ten sposÃ³b\nuÅ¼ywa siÄ™ typÃ³w o dynamicznym rozmiarze w Rust: PosiadajÄ… dodatkowy bit\nmetadanych, ktÃ³ry przechowuje rozmiar dynamicznych informacji. ZÅ‚otÄ… zasadÄ…\ntypÃ³w o dynamicznym rozmiarze jest to, Å¼e zawsze musimy umieszczaÄ‡ wartoÅ›ci\ntypÃ³w o dynamicznym rozmiarze za wskaÅºnikiem jakiegoÅ› rodzaju.\n\nMoÅ¼emy Å‚Ä…czyÄ‡ `str` z rÃ³Å¼nymi rodzajami wskaÅºnikÃ³w: na przykÅ‚ad `Box<str>` lub\n`Rc<str>`. W rzeczywistoÅ›ci widziaÅ‚eÅ› to juÅ¼ wczeÅ›niej, ale z innym typem\no dynamicznym rozmiarze: cechami. KaÅ¼da cecha jest typem o dynamicznym\nrozmiarze, do ktÃ³rego moÅ¼emy siÄ™ odwoÅ‚ywaÄ‡, uÅ¼ywajÄ…c nazwy cechy. W sekcji\n[â€UÅ¼ywanie obiektÃ³w cech do abstrakcji nad wspÃ³lnym\nzachowaniemâ€][using-trait-objects-to-abstract-over-shared-behavior]<!--\nignore --> w Rozdziale 18 wspomnieliÅ›my, Å¼e aby uÅ¼ywaÄ‡ cech jako obiektÃ³w\ncech, musimy umieÅ›ciÄ‡ je za wskaÅºnikiem, takim jak `&dyn Trait` lub `Box<dyn Trait>`\n(`Rc<dyn Trait>` rÃ³wnieÅ¼ by dziaÅ‚aÅ‚o).\n\nAby pracowaÄ‡ z DST, Rust udostÄ™pnia cechÄ™ `Sized`, aby okreÅ›liÄ‡, czy rozmiar\ntypu jest znany w czasie kompilacji. Ta cecha jest automatycznie\nimplementowana dla wszystkiego, czego rozmiar jest znany w czasie kompilacji.\nDodatkowo, Rust niejawnie dodaje ograniczenie na `Sized` do kaÅ¼dej funkcji\ngenerycznej. Oznacza to, Å¼e definicja funkcji generycznej, taka jak ta:\n\n````rust,ignore\nfn generic<T>(t: T) {\n    // --snip--\n}\n````\n\njest w rzeczywistoÅ›ci traktowana tak, jakbyÅ›my napisali to:\n\n````rust,ignore\nfn generic<T: Sized>(t: T) {\n    // --snip--\n}\n````\n\nDomyÅ›lnie funkcje generyczne bÄ™dÄ… dziaÅ‚aÄ‡ tylko na typach, ktÃ³re majÄ… znany\nrozmiar w czasie kompilacji. MoÅ¼esz jednak uÅ¼yÄ‡ nastÄ™pujÄ…cej specjalnej\nskÅ‚adni, aby zÅ‚agodziÄ‡ to ograniczenie:\n\n````rust,ignore\nfn generic<T: ?Sized>(t: &T) {\n    // --snip--\n}\n````\n\nOgraniczenie cechy na `?Sized` oznacza â€`T` moÅ¼e, ale nie musi byÄ‡ `Sized`â€,\na ta notacja zastÄ™puje domyÅ›lnÄ… zasadÄ™, Å¼e typy generyczne muszÄ… mieÄ‡ znany\nrozmiar w czasie kompilacji. SkÅ‚adnia `?Trait` z tym znaczeniem jest dostÄ™pna\ntylko dla `Sized`, a nie dla Å¼adnych innych cech.\n\nZauwaÅ¼ rÃ³wnieÅ¼, Å¼e zmieniliÅ›my typ parametru `t` z `T` na `&T`. PoniewaÅ¼ typ\nmoÅ¼e nie byÄ‡ `Sized`, musimy uÅ¼ywaÄ‡ go za wskaÅºnikiem jakiegoÅ› rodzaju. W tym\nprzypadku wybraliÅ›my referencjÄ™.\n\nNastÄ™pnie porozmawiamy o funkcjach i domkniÄ™ciach!\n\n[newtype]: ch20-02-advanced-traits.html#implementing-external-traits-with-the-newtype-pattern\n[encapsulation-that-hides-implementation-details]: ch18-01-what-is-oo.html#encapsulation-that-hides-implementation-details\n[the-match-control-flow-construct]: ch06-02-match.html#the-match-control-flow-construct\n[string-slices]: ch04-03-slices.html#string-slices\n[using-trait-objects-to-abstract-over-shared-behavior]: ch18-02-trait-objects.html#using-trait-objects-to-abstract-over-shared-behavior",
        "chapter_title": "Zaawansowane Typy"
    },
    {
        "file_path": "ch20-04-advanced-functions-and-closures.md",
        "content": "## Zaawansowane Funkcje i DomkniÄ™cia\n\nTa sekcja omawia niektÃ³re zaawansowane funkcje zwiÄ…zane z funkcjami i\ndomkniÄ™ciami, w tym wskaÅºniki na funkcje i zwracanie domkniÄ™Ä‡.\n\n### WskaÅºniki na Funkcje\n\nMÃ³wiliÅ›my o tym, jak przekazywaÄ‡ domkniÄ™cia do funkcji; moÅ¼esz rÃ³wnieÅ¼\nprzekazywaÄ‡ do funkcji zwykÅ‚e funkcje! Ta technika jest przydatna, gdy chcesz\nprzekazaÄ‡ funkcjÄ™, ktÃ³rÄ… juÅ¼ zdefiniowaÅ‚eÅ›, zamiast definiowaÄ‡ nowe domkniÄ™cie.\nFunkcje konwertujÄ… siÄ™ do typu `fn` (z maÅ‚Ä… literÄ… *f*), nie myliÄ‡ z cechÄ…\ndomkniÄ™cia `Fn`. Typ `fn` nazywany jest *wskaÅºnikiem na funkcjÄ™*. Przekazywanie\nfunkcji za pomocÄ… wskaÅºnikÃ³w na funkcje umoÅ¼liwi ci uÅ¼ywanie funkcji jako\nargumentÃ³w dla innych funkcji.\n\nSkÅ‚adnia okreÅ›lania, Å¼e parametr jest wskaÅºnikiem na funkcjÄ™, jest podobna do\ntej dla domkniÄ™Ä‡, jak pokazano w Listing 20-28, gdzie zdefiniowaliÅ›my funkcjÄ™\n`add_one`, ktÃ³ra dodaje 1 do swojego parametru. Funkcja `do_twice` przyjmuje\ndwa parametry: wskaÅºnik na funkcjÄ™ do dowolnej funkcji, ktÃ³ra przyjmuje\nparametr `i32` i zwraca `i32`, oraz jednÄ… wartoÅ›Ä‡ `i32`. Funkcja `do_twice`\nwywoÅ‚uje funkcjÄ™ `f` dwukrotnie, przekazujÄ…c jej wartoÅ›Ä‡ `arg`, a nastÄ™pnie\ndodaje do siebie wyniki dwÃ³ch wywoÅ‚aÅ„ funkcji. Funkcja `main` wywoÅ‚uje\n`do_twice` z argumentami `add_one` i `5`.\n\n<figure class=\"listing\" id=\"listing-20-28\">\n<span class=\"file-name\">Filename: src/main.rs</span>\n\n````rust\nfn add_one(x: i32) -> i32 {\n    x + 1\n}\n\nfn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {\n    f(arg) + f(arg)\n}\n\nfn main() {\n    let answer = do_twice(add_one, 5);\n\n    println!(\"The answer is: {answer}\");\n}\n````\n\n<figcaption><a href=\"#listing-20-28\">Listing 20-28</a>: UÅ¼ycie typu <code>fn</code> do przyjÄ™cia wskaÅºnika na funkcjÄ™ jako argumentu</figcaption>\n</figure>\n\nTen kod wyÅ›wietla `The answer is: 12`. OkreÅ›lamy, Å¼e parametr `f` w `do_twice`\njest typu `fn`, ktÃ³ry przyjmuje jeden parametr typu `i32` i zwraca `i32`.\nNastÄ™pnie moÅ¼emy wywoÅ‚aÄ‡ `f` w ciele `do_twice`. W `main` moÅ¼emy przekazaÄ‡\nnazwÄ™ funkcji `add_one` jako pierwszy argument do `do_twice`.\n\nW przeciwieÅ„stwie do domkniÄ™Ä‡, `fn` jest typem, a nie cechÄ…, wiÄ™c okreÅ›lamy `fn`\njako typ parametru bezpoÅ›rednio, zamiast deklarowaÄ‡ parametr typu generycznego\nz jednÄ… z cech domkniÄ™Ä‡ jako ograniczeniem cechy.\n\nWskaÅºniki na funkcje implementujÄ… wszystkie trzy cechy domkniÄ™Ä‡ (`Fn`, `FnMut`\ni `FnOnce`), co oznacza, Å¼e zawsze moÅ¼esz przekazaÄ‡ wskaÅºnik na funkcjÄ™ jako\nargument do funkcji, ktÃ³ra oczekuje domkniÄ™cia. Najlepiej jest pisaÄ‡ funkcje,\nuÅ¼ywajÄ…c typu generycznego i jednej z cech domkniÄ™Ä‡, aby twoje funkcje mogÅ‚y\nprzyjmowaÄ‡ zarÃ³wno funkcje, jak i domkniÄ™cia.\n\nJednakÅ¼e, jednym z przykÅ‚adÃ³w, gdzie chciaÅ‚byÅ› akceptowaÄ‡ tylko `fn`, a nie\ndomkniÄ™cia, jest interakcja z zewnÄ™trznym kodem, ktÃ³ry nie ma domkniÄ™Ä‡: Funkcje\nw C mogÄ… przyjmowaÄ‡ funkcje jako argumenty, ale C nie ma domkniÄ™Ä‡.\n\nJako przykÅ‚ad, gdzie moÅ¼na by uÅ¼yÄ‡ zarÃ³wno domkniÄ™cia zdefiniowanego inline,\njak i nazwanej funkcji, przyjrzyjmy siÄ™ zastosowaniu metody `map` dostarczonej\nprzez cechÄ™ `Iterator` w standardowej bibliotece. Aby uÅ¼yÄ‡ metody `map` do\nprzeksztaÅ‚cenia wektora liczb w wektor ciÄ…gÃ³w znakÃ³w, moglibyÅ›my uÅ¼yÄ‡\ndomkniÄ™cia, jak w Listing 20-29.\n\n<figure class=\"listing\" id=\"listing-20-29\">\n\n````rust\n# fn main() {\n    let list_of_numbers = vec![1, 2, 3];\n    let list_of_strings: Vec<String> =\n        list_of_numbers.iter().map(|i| i.to_string()).collect();\n# }\n````\n\n<figcaption><a href=\"#listing-20-29\">Listing 20-29</a>: UÅ¼ycie domkniÄ™cia z metodÄ… <code>map</code> do konwersji liczb na ciÄ…gi znakÃ³w</figcaption>\n</figure>\n\nAlbo moglibyÅ›my nazwaÄ‡ funkcjÄ™ jako argument do `map` zamiast domkniÄ™cia.\nListing 20-30 pokazuje, jak by to wyglÄ…daÅ‚o.\n\n<figure class=\"listing\" id=\"listing-20-30\">\n\n````rust\n# fn main() {\n    let list_of_numbers = vec![1, 2, 3];\n    let list_of_strings: Vec<String> =\n        list_of_numbers.iter().map(ToString::to_string).collect();\n# }\n````\n\n<figcaption><a href=\"#listing-20-30\">Listing 20-30</a>: UÅ¼ycie funkcji <code>String::to_string</code> z metodÄ… <code>map</code> do konwersji liczb na ciÄ…gi znakÃ³w</figcaption>\n</figure>\n\nZauwaÅ¼, Å¼e musimy uÅ¼yÄ‡ w peÅ‚ni kwalifikowanej skÅ‚adni, o ktÃ³rej mÃ³wiliÅ›my w\nsekcji [â€Zaawansowane Cechyâ€][advanced-traits]<!-- ignore -->, poniewaÅ¼\nistnieje wiele dostÄ™pnych funkcji o nazwie `to_string`.\n\nTutaj uÅ¼ywamy funkcji `to_string` zdefiniowanej w cesze `ToString`, ktÃ³rÄ…\nstandardowa biblioteka zaimplementowaÅ‚a dla kaÅ¼dego typu, ktÃ³ry implementuje\n`Display`.\n\nPrzypomnij sobie z sekcji [â€WartoÅ›ci enumâ€][enum-values]<!-- ignore --> w\nRozdziale 6, Å¼e nazwa kaÅ¼dego wariantu enum, ktÃ³ry definiujemy, staje siÄ™ takÅ¼e\nfunkcjÄ… inicjalizujÄ…cÄ…. MoÅ¼emy uÅ¼ywaÄ‡ tych funkcji inicjalizujÄ…cych jako\nwskaÅºnikÃ³w na funkcje, ktÃ³re implementujÄ… cechy domkniÄ™Ä‡, co oznacza, Å¼e\nmoÅ¼emy okreÅ›laÄ‡ funkcje inicjalizujÄ…ce jako argumenty dla metod, ktÃ³re przyjmujÄ…\ndomkniÄ™cia, jak pokazano w Listing 20-31.\n\n<figure class=\"listing\" id=\"listing-20-31\">\n\n````rust\n# fn main() {\n    enum Status {\n        Value(u32),\n        Stop,\n    }\n\n    let list_of_statuses: Vec<Status> = (0u32..20).map(Status::Value).collect();\n# }\n````\n\n<figcaption><a href=\"#listing-20-31\">Listing 20-31</a>: UÅ¼ycie inicjalizatora enum z metodÄ… <code>map</code> do tworzenia instancji <code>Status</code> z liczb</figcaption>\n</figure>\n\nTutaj tworzymy instancje `Status::Value` uÅ¼ywajÄ…c kaÅ¼dej wartoÅ›ci `u32` w\nzakresie, na ktÃ³rym wywoÅ‚ano `map`, poprzez uÅ¼ycie funkcji inicjalizujÄ…cej\n`Status::Value`. NiektÃ³rzy wolÄ… ten styl, a inni wolÄ… uÅ¼ywaÄ‡ domkniÄ™Ä‡.\nKompilujÄ… siÄ™ one do tego samego kodu, wiÄ™c uÅ¼ywaj stylu, ktÃ³ry jest dla ciebie\njaÅ›niejszy.\n\n### Zwracanie DomkniÄ™Ä‡\n\nDomkniÄ™cia sÄ… reprezentowane przez cechy, co oznacza, Å¼e nie moÅ¼na zwracaÄ‡\ndomkniÄ™Ä‡ bezpoÅ›rednio. W wiÄ™kszoÅ›ci przypadkÃ³w, gdy chcesz zwrÃ³ciÄ‡ cechÄ™,\nmoÅ¼esz zamiast tego uÅ¼yÄ‡ konkretnego typu, ktÃ³ry implementuje tÄ™ cechÄ™, jako\nwartoÅ›ci zwracanej funkcji. JednakÅ¼e, zazwyczaj nie moÅ¼esz tego zrobiÄ‡ z\ndomkniÄ™ciami, poniewaÅ¼ nie majÄ… one konkretnego typu, ktÃ³ry moÅ¼na zwrÃ³ciÄ‡;\nnie wolno uÅ¼ywaÄ‡ wskaÅºnika na funkcjÄ™ `fn` jako typu zwracanego, jeÅ›li\ndomkniÄ™cie przechwytuje jakiekolwiek wartoÅ›ci ze swojego zasiÄ™gu, na przykÅ‚ad.\n\nZamiast tego, zazwyczaj bÄ™dziesz uÅ¼ywaÄ‡ skÅ‚adni `impl Trait`, ktÃ³rÄ… poznaliÅ›my\nw Rozdziale 10. MoÅ¼esz zwracaÄ‡ dowolny typ funkcji, uÅ¼ywajÄ…c `Fn`, `FnOnce`\ni `FnMut`. Na przykÅ‚ad, kod z Listing 20-32 skompiluje siÄ™ bez problemu.\n\n<figure class=\"listing\" id=\"listing-20-32\">\n\n````rust\nfn returns_closure() -> impl Fn(i32) -> i32 {\n    |x| x + 1\n}\n````\n\n<figcaption><a href=\"#listing-20-32\">Listing 20-32</a>: Zwracanie domkniÄ™cia z funkcji przy uÅ¼yciu skÅ‚adni <code>impl Trait</code></figcaption>\n</figure>\n\nJednakÅ¼e, jak zauwaÅ¼yliÅ›my w sekcji [â€Wnioskowanie i adnotacje typÃ³w\ndomkniÄ™Ä‡â€][closure-types]<!-- ignore --> w Rozdziale 13, kaÅ¼de domkniÄ™cie\njest rÃ³wnieÅ¼ swoim wÅ‚asnym, odrÄ™bnym typem. JeÅ›li musisz pracowaÄ‡ z wieloma\nfunkcjami, ktÃ³re majÄ… tÄ™ samÄ… sygnaturÄ™, ale rÃ³Å¼ne implementacje, bÄ™dziesz\nmusiaÅ‚ uÅ¼yÄ‡ dla nich obiektu cechy. RozwaÅ¼, co siÄ™ stanie, jeÅ›li napiszesz\nkod taki jak pokazano w Listing 20-33.\n\n<figure class=\"listing\" id=\"listing-20-33\">\n<span class=\"file-name\">Filename: src/main.rs</span>\n\n````rust,ignore,does_not_compile\nfn main() {\n    let handlers = vec![returns_closure(), returns_initialized_closure(123)];\n    for handler in handlers {\n        let output = handler(5);\n        println!(\"{output}\");\n    }\n}\n\nfn returns_closure() -> impl Fn(i32) -> i32 {\n    |x| x + 1\n}\n\nfn returns_initialized_closure(init: i32) -> impl Fn(i32) -> i32 {\n    move |x| x + init\n}\n````\n\n<figcaption><a href=\"#listing-20-33\">Listing 20-33</a>: Tworzenie <code>Vec&lt;T&gt;</code> domkniÄ™Ä‡ zdefiniowanych przez funkcje, ktÃ³re zwracajÄ… typy <code>impl Fn</code></figcaption>\n</figure>\n\nW tym miejscu mamy dwie funkcje, `returns_closure` i `returns_initialized_closure`,\nktÃ³re obie zwracajÄ… `impl Fn(i32) -> i32`. ZauwaÅ¼, Å¼e domkniÄ™cia, ktÃ³re zwracajÄ…,\nsÄ… rÃ³Å¼ne, mimo Å¼e implementujÄ… tÄ™ samÄ… cechÄ™. JeÅ›li sprÃ³bujemy to skompilowaÄ‡,\nRust poinformuje nas, Å¼e to nie zadziaÅ‚a:\n\n````text\n$ cargo build\n   Compiling functions-example v0.1.0 (file:///projects/functions-example)\nerror[E0308]: mismatched types\n  --> src/main.rs:2:44\n   |\n 2 |     let handlers = vec![returns_closure(), returns_initialized_closure(123)];\n   |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected opaque type, found a different opaque type\n...\n 9 | fn returns_closure() -> impl Fn(i32) -> i32 {\n   |                         ------------------- the expected opaque type\n...\n13 | fn returns_initialized_closure(init: i32) -> impl Fn(i32) -> i32 {\n   |                                              ------------------- the found opaque type\n   |\n   = note: expected opaque type `impl Fn(i32) -> i32`\n              found opaque type `impl Fn(i32) -> i32`\n   = note: distinct uses of `impl Trait` result in different opaque types\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `functions-example` (bin \"functions-example\") due to 1 previous error\n````\n\nKomunikat o bÅ‚Ä™dzie informuje nas, Å¼e za kaÅ¼dym razem, gdy zwracamy `impl Trait`,\nRust tworzy unikalny *typ nieprzezroczysty* â€“ typ, w ktÃ³rego szczegÃ³Å‚y tego,\nco Rust dla nas konstruuje, nie moÅ¼emy wniknÄ…Ä‡, ani nie moÅ¼emy odgadnÄ…Ä‡\ntypu, ktÃ³ry Rust wygeneruje, aby samemu go napisaÄ‡. Zatem, mimo Å¼e te funkcje\nzwracajÄ… domkniÄ™cia, ktÃ³re implementujÄ… tÄ™ samÄ… cechÄ™, `Fn(i32) -> i32`,\nnieprzezroczyste typy, ktÃ³re Rust generuje dla kaÅ¼dego z nich, sÄ… odrÄ™bne.\n(Jest to podobne do tego, jak Rust produkuje rÃ³Å¼ne konkretne typy dla\nrÃ³Å¼nych blokÃ³w async, nawet jeÅ›li majÄ… ten sam typ wyjÅ›ciowy, jak widzieliÅ›my\nw [â€Typ `Pin` i cecha `Unpin`â€][future-types]<!-- ignore --> w Rozdziale 17.)\nRozwiÄ…zanie tego problemu widzieliÅ›my juÅ¼ kilkakrotnie: MoÅ¼emy uÅ¼yÄ‡ obiektu\ncechy, jak w Listing 20-34.\n\n<figure class=\"listing\" id=\"listing-20-34\">\n\n````rust\n# fn main() {\n#     let handlers = vec![returns_closure(), returns_initialized_closure(123)];\n#     for handler in handlers {\n#         let output = handler(5);\n#         println!(\"{output}\");\n#     }\n# }\n# \nfn returns_closure() -> Box<dyn Fn(i32) -> i32> {\n    Box::new(|x| x + 1)\n}\n\nfn returns_initialized_closure(init: i32) -> Box<dyn Fn(i32) -> i32> {\n    Box::new(move |x| x + init)\n}\n````\n\n<figcaption><a href=\"#listing-20-34\">Listing 20-34</a>: Tworzenie <code>Vec&lt;T&gt;</code> domkniÄ™Ä‡ zdefiniowanych przez funkcje, ktÃ³re zwracajÄ… <code>Box&lt;dyn Fn&gt;</code>, tak aby miaÅ‚y ten sam typ</figcaption>\n</figure>\n\nTen kod skompiluje siÄ™ bez problemu. WiÄ™cej informacji na temat obiektÃ³w\ncech znajdziesz w sekcji [â€UÅ¼ywanie obiektÃ³w cech do abstrakcji nad wspÃ³lnym\nzachowaniemâ€][trait-objects]<!-- ignore --> w Rozdziale 18.\n\nNastÄ™pnie przyjrzyjmy siÄ™ makrom!\n\n[advanced-traits]: ch20-02-advanced-traits.html#advanced-traits\n[enum-values]: ch06-01-defining-an-enum.html#enum-values\n[closure-types]: ch13-01-closures.html#closure-type-inference-and-annotation\n[future-types]: ch17-03-more-futures.html\n[trait-objects]: ch18-02-trait-objects.html",
        "chapter_title": "Zaawansowane Funkcje i DomkniÄ™cia"
    },
    {
        "file_path": "ch20-05-macros.md",
        "content": "## Makra\n\nMakr takich jak `println!` uÅ¼ywaliÅ›my w caÅ‚ej ksiÄ…Å¼ce, ale nie zbadaliÅ›my\njeszcze w peÅ‚ni, czym jest makro i jak dziaÅ‚a. Termin *makro* odnosi siÄ™ do\nrodziny funkcji w Rustâ€”makra deklaratywne z `macro_rules!` oraz trzy rodzaje\nmakr proceduralnych:\n\n* Niestandardowe makra `#[derive]`, ktÃ³re okreÅ›lajÄ… kod dodany za pomocÄ…\n  atrybutu `derive` uÅ¼ywanego w strukturach i enumach\n* Makra podobne do atrybutÃ³w, ktÃ³re definiujÄ… niestandardowe atrybuty moÅ¼liwe\n  do uÅ¼ycia z dowolnym elementem\n* Makra podobne do funkcji, ktÃ³re wyglÄ…dajÄ… jak wywoÅ‚ania funkcji, ale\n  operujÄ… na tokenach okreÅ›lonych jako ich argument\n\nBÄ™dziemy mÃ³wiÄ‡ o kaÅ¼dym z nich po kolei, ale najpierw przyjrzyjmy siÄ™,\ndlaczego w ogÃ³le potrzebujemy makr, skoro mamy juÅ¼ funkcje.\n\n### RÃ³Å¼nica miÄ™dzy makrami a funkcjami\n\nZasadniczo, makra to sposÃ³b pisania kodu, ktÃ³ry pisze inny kod, co jest znane\njako *metaprogramowanie*. W Dodatku C omawiamy atrybut `derive`, ktÃ³ry\ngeneruje implementacjÄ™ rÃ³Å¼nych cech dla ciebie. UÅ¼ywaliÅ›my rÃ³wnieÅ¼ makr\n`println!` i `vec!` w caÅ‚ej ksiÄ…Å¼ce. Wszystkie te makra *rozszerzajÄ… siÄ™*,\naby wyprodukowaÄ‡ wiÄ™cej kodu niÅ¼ ten, ktÃ³ry napisaÅ‚eÅ› rÄ™cznie.\n\nMetaprogramowanie jest przydatne do zmniejszania iloÅ›ci kodu, ktÃ³ry musisz\nnapisaÄ‡ i utrzymaÄ‡, co jest rÃ³wnieÅ¼ jednÄ… z rÃ³l funkcji. Jednak makra majÄ…\npewne dodatkowe moce, ktÃ³rych funkcje nie majÄ….\n\nSygnatura funkcji musi deklarowaÄ‡ liczbÄ™ i typ parametrÃ³w, ktÃ³re funkcja\nposiada. Makra natomiast mogÄ… przyjmowaÄ‡ zmiennÄ… liczbÄ™ parametrÃ³w: MoÅ¼emy\nwywoÅ‚aÄ‡ `println!(\"hello\")` z jednym argumentem lub `println!(\"hello {}\", name)`\nz dwoma argumentami. Ponadto, makra sÄ… rozszerzane zanim kompilator zinterpretuje\nznaczenie kodu, wiÄ™c makro moÅ¼e na przykÅ‚ad zaimplementowaÄ‡ cechÄ™ na danym\ntypie. Funkcja tego nie moÅ¼e, poniewaÅ¼ jest wywoÅ‚ywana w czasie wykonania, a\ncecha musi byÄ‡ zaimplementowana w czasie kompilacji.\n\nWadÄ… implementacji makra zamiast funkcji jest to, Å¼e definicje makr sÄ…\nbardziej zÅ‚oÅ¼one niÅ¼ definicje funkcji, poniewaÅ¼ piszesz kod Rust, ktÃ³ry\npisze kod Rust. Z powodu tej poÅ›rednioÅ›ci, definicje makr sÄ… zazwyczaj\ntrudniejsze do czytania, zrozumienia i utrzymania niÅ¼ definicje funkcji.\n\nInnÄ… waÅ¼nÄ… rÃ³Å¼nicÄ… miÄ™dzy makrami a funkcjami jest to, Å¼e musisz definiowaÄ‡\nmakra lub wprowadzaÄ‡ je do zasiÄ™gu *przed* ich wywoÅ‚aniem w pliku, w\nprzeciwieÅ„stwie do funkcji, ktÃ³re moÅ¼esz zdefiniowaÄ‡ i wywoÅ‚aÄ‡ w dowolnym\nmiejscu.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"declarative-macros-with-macro_rules-for-general-metaprogramming\"></a>\n\n### Makra deklaratywne do ogÃ³lnego metaprogramowania\n\nNajczÄ™Å›ciej uÅ¼ywanÄ… formÄ… makr w Rust sÄ… *makra deklaratywne*. Czasami sÄ…\nrÃ³wnieÅ¼ nazywane â€makrami na przykÅ‚adachâ€, â€makrami `macro_rules!`â€ lub po\nprostu â€makramiâ€. W swej istocie makra deklaratywne pozwalajÄ… na pisanie\ncodÅ› podobnego do wyraÅ¼enia `match` w Rust. Jak omÃ³wiono w Rozdziale 6,\nwyraÅ¼enia `match` sÄ… strukturami kontrolnymi, ktÃ³re przyjmujÄ… wyraÅ¼enie,\nporÃ³wnujÄ… wynikowÄ… wartoÅ›Ä‡ wyraÅ¼enia z wzorcami, a nastÄ™pnie uruchamiajÄ… kod\nskojarzony z pasujÄ…cym wzorcem. Makra rÃ³wnieÅ¼ porÃ³wnujÄ… wartoÅ›Ä‡ z wzorcami,\nktÃ³re sÄ… skojarzone z konkretnym kodem: w tej sytuacji wartoÅ›ciÄ… jest literaÅ‚\nkodu ÅºrÃ³dÅ‚owego Rust przekazany do makra; wzorce sÄ… porÃ³wnywane ze strukturÄ…\ntego kodu ÅºrÃ³dÅ‚owego; a kod skojarzony z kaÅ¼dym wzorcem, gdy zostanie dopasowany,\nzastÄ™puje kod przekazany do makra. Wszystko to dzieje siÄ™ podczas kompilacji.\n\nAby zdefiniowaÄ‡ makro, uÅ¼ywasz konstrukcji `macro_rules!`. Zbadajmy, jak uÅ¼ywaÄ‡\n`macro_rules!`, przyglÄ…dajÄ…c siÄ™, jak zdefiniowane jest makro `vec!`. RozdziaÅ‚ 8\nomÃ³wiÅ‚, jak moÅ¼emy uÅ¼ywaÄ‡ makra `vec!` do tworzenia nowego wektora z\nkonkretnymi wartoÅ›ciami. Na przykÅ‚ad, poniÅ¼sze makro tworzy nowy wektor\nzawierajÄ…cy trzy liczby caÅ‚kowite:\n\n````rust\nlet v: Vec<u32> = vec![1, 2, 3];\n````\n\nMoglibyÅ›my rÃ³wnieÅ¼ uÅ¼yÄ‡ makra `vec!`, aby stworzyÄ‡ wektor dwÃ³ch liczb\ncaÅ‚kowitych lub wektor piÄ™ciu wycinkÃ³w ciÄ…gÃ³w znakÃ³w. Nie bylibyÅ›my w stanie\nuÅ¼yÄ‡ funkcji do wykonania tego samego, poniewaÅ¼ nie znalibyÅ›my liczby ani\ntypu wartoÅ›ci z gÃ³ry.\n\nListing 20-35 pokazuje nieco uproszczonÄ… definicjÄ™ makra `vec!`.\n\n<figure class=\"listing\" id=\"listing-20-35\">\n<span class=\"file-name\">Filename: src/lib.rs</span>\n\n````rust,noplayground\n#[macro_export]\nmacro_rules! vec {\n    ( $( $x:expr ),* ) => {\n        {\n            let mut temp_vec = Vec::new();\n            $(\n                temp_vec.push($x);\n            )*\n            temp_vec\n        }\n    };\n}\n````\n\n<figcaption><a href=\"#listing-20-35\">Listing 20-35</a>: Uproszczona wersja definicji makra <code>vec!</code></figcaption>\n</figure>\n\n\n<section class=\"note\" aria-role=\"note\">\n\n\nUwaga: Rzeczywista definicja makra `vec!` w standardowej bibliotece zawiera\nkod do wczeÅ›niejszego przydzielania odpowiedniej iloÅ›ci pamiÄ™ci. Ten kod\njest optymalizacjÄ…, ktÃ³rej tutaj nie uwzglÄ™dniamy, aby przykÅ‚ad byÅ‚ prostszy.\n\n</section>\n\nAdnotacja `#[macro_export]` wskazuje, Å¼e to makro powinno byÄ‡ dostÄ™pne\nzawsze, gdy pakiet, w ktÃ³rym makro jest zdefiniowane, zostanie wprowadzony do\nzasiÄ™gu. Bez tej adnotacji makro nie moÅ¼e zostaÄ‡ wprowadzone do zasiÄ™gu.\n\nNastÄ™pnie rozpoczynamy definicjÄ™ makra od `macro_rules!` i nazwy definiowanego\nmakra *bez* wykrzyknika. Nazwa, w tym przypadku `vec`, jest poprzedzona\nnawiasami klamrowymi oznaczajÄ…cymi ciaÅ‚o definicji makra.\n\nStruktura w ciele `vec!` jest podobna do struktury wyraÅ¼enia `match`. Tutaj\nmamy jedno ramiÄ™ ze wzorcem `( $( $x:expr ),* )`, po ktÃ³rym nastÄ™puje `=>`\ni blok kodu skojarzony z tym wzorcem. JeÅ›li wzorzec pasuje, skojarzony blok\nkodu zostanie wygenerowany. BiorÄ…c pod uwagÄ™, Å¼e jest to jedyny wzorzec w tym\nmakrze, istnieje tylko jeden prawidÅ‚owy sposÃ³b dopasowania; kaÅ¼dy inny wzorzec\nspowoduje bÅ‚Ä…d. Bardziej zÅ‚oÅ¼one makra bÄ™dÄ… miaÅ‚y wiÄ™cej niÅ¼ jedno ramiÄ™.\n\nPoprawna skÅ‚adnia wzorcÃ³w w definicjach makr rÃ³Å¼ni siÄ™ od skÅ‚adni wzorcÃ³w\nomÃ³wionej w Rozdziale 19, poniewaÅ¼ wzorce makr sÄ… dopasowywane do struktury\nkodu Rust, a nie do wartoÅ›ci. PrzejdÅºmy przez to, co oznaczajÄ… fragmenty wzorcÃ³w\nw Listing 20-29; peÅ‚nÄ… skÅ‚adniÄ™ wzorcÃ³w makr znajdziesz w [Referencjach\nRust][ref].\n\nNajpierw uÅ¼ywamy zestawu nawiasÃ³w do objÄ™cia caÅ‚ego wzorca. UÅ¼ywamy znaku\ndolara (`$`), aby zadeklarowaÄ‡ zmiennÄ… w systemie makr, ktÃ³ra bÄ™dzie\nzawieraÄ‡ kod Rust pasujÄ…cy do wzorca. Znak dolara jasno wskazuje, Å¼e jest to\nzmienna makra, w przeciwieÅ„stwie do zwykÅ‚ej zmiennej Rust. NastÄ™pnie nastÄ™puje\nzestaw nawiasÃ³w, ktÃ³ry przechwytuje wartoÅ›ci pasujÄ…ce do wzorca w nawiasach\ndo wykorzystania w kodzie zastÄ™pujÄ…cym. WewnÄ…trz `$()` znajduje siÄ™ `$x:expr`,\nktÃ³ry pasuje do dowolnego wyraÅ¼enia Rust i nadaje wyraÅ¼eniu nazwÄ™ `$x`.\n\nPrzecinek po `$()` wskazuje, Å¼e dosÅ‚owny znak separatora przecinka musi\npowtarzaÄ‡ siÄ™ miÄ™dzy kaÅ¼dÄ… instancjÄ… kodu, ktÃ³ry pasuje do kodu w `$()`.\nGwiazdka `*` okreÅ›la, Å¼e wzorzec pasuje do zera lub wiÄ™cej elementÃ³w\npoprzedzajÄ…cych `*`.\n\nKiedy wywoÅ‚ujemy to makro za pomocÄ… `vec![1, 2, 3];`, wzorzec `$x` pasuje\ntrzy razy do trzech wyraÅ¼eÅ„ `1`, `2` i `3`.\n\nTeraz przyjrzyjmy siÄ™ wzorcowi w ciele kodu skojarzonego z tym ramieniem:\n`temp_vec.push()` w `$()*` jest generowane dla kaÅ¼dej czÄ™Å›ci, ktÃ³ra pasuje\ndo `$()` we wzorcu zero lub wiÄ™cej razy, w zaleÅ¼noÅ›ci od tego, ile razy wzorzec\npasuje. `$x` jest zastÄ™powane kaÅ¼dym pasujÄ…cym wyraÅ¼eniem. Kiedy wywoÅ‚ujemy\nto makro za pomocÄ… `vec![1, 2, 3];`, wygenerowany kod, ktÃ³ry zastÄ™puje to\nwywoÅ‚anie makra, bÄ™dzie nastÄ™pujÄ…cy:\n\n````rust,ignore\n{\n    let mut temp_vec = Vec::new();\n    temp_vec.push(1);\n    temp_vec.push(2);\n    temp_vec.push(3);\n    temp_vec\n}\n````\n\nZdefiniowaliÅ›my makro, ktÃ³re moÅ¼e przyjmowaÄ‡ dowolnÄ… liczbÄ™ argumentÃ³w dowolnego\ntypu i generowaÄ‡ kod do tworzenia wektora zawierajÄ…cego okreÅ›lone elementy.\n\nAby dowiedzieÄ‡ siÄ™ wiÄ™cej o tym, jak pisaÄ‡ makra, zajrzyj do dokumentacji\nonline lub innych zasobÃ³w, takich jak [â€The Little Book of Rust Macrosâ€][tlborm]\nrozpoczÄ™ta przez Daniela Keepa i kontynuowana przez Lukasa Wirtha.\n\n### Makra proceduralne do generowania kodu z atrybutÃ³w\n\nDruga forma makr to makro proceduralne, ktÃ³re dziaÅ‚a bardziej jak funkcja\n(i jest rodzajem procedury). *Makra proceduralne* przyjmujÄ… pewien kod jako\nwejÅ›cie, operujÄ… na tym kodzie i produkujÄ… pewien kod jako wyjÅ›cie, zamiast\ndopasowywaÄ‡ siÄ™ do wzorcÃ³w i zastÄ™powaÄ‡ kod innym kodem, jak to robiÄ… makra\ndeklaratywne. Trzy rodzaje makr proceduralnych to niestandardowe `derive`,\npodobne do atrybutÃ³w i podobne do funkcji, a wszystkie dziaÅ‚ajÄ… w podobny\nsposÃ³b.\n\nPodczas tworzenia makr proceduralnych definicje muszÄ… znajdowaÄ‡ siÄ™ we\nwÅ‚asnym pakiecie ze specjalnym typem pakietu. Wynika to ze zÅ‚oÅ¼onych przyczyn\ntechnicznych, ktÃ³re mamy nadziejÄ™ wyeliminowaÄ‡ w przyszÅ‚oÅ›ci. W Listing 20-36\npokazujemy, jak zdefiniowaÄ‡ makro proceduralne, gdzie `some_attribute` jest\nzastÄ™pcÄ… dla uÅ¼ycia konkretnej odmiany makra.\n\n<figure class=\"listing\" id=\"listing-20-36\">\n<span class=\"file-name\">Filename: src/lib.rs</span>\n\n````rust,ignore\nuse proc_macro::TokenStream;\n\n#[some_attribute]\npub fn some_name(input: TokenStream) -> TokenStream {\n}\n````\n\n<figcaption><a href=\"#listing-20-36\">Listing 20-36</a>: PrzykÅ‚ad definiowania makra proceduralnego</figcaption>\n</figure>\n\nFunkcja, ktÃ³ra definiuje makro proceduralne, przyjmuje `TokenStream` jako\nwejÅ›cie i produkuje `TokenStream` jako wyjÅ›cie. Typ `TokenStream` jest\nzdefiniowany przez pakiet `proc_macro`, ktÃ³ry jest doÅ‚Ä…czony do Rust i\nreprezentuje sekwencjÄ™ tokenÃ³w. To jest rdzeÅ„ makra: Kod ÅºrÃ³dÅ‚owy, na ktÃ³rym\nmakro operuje, tworzy wejÅ›ciowy `TokenStream`, a kod, ktÃ³ry makro produkuje,\njest wyjÅ›ciowym `TokenStream`. Funkcja posiada rÃ³wnieÅ¼ doÅ‚Ä…czony atrybut,\nktÃ³ry okreÅ›la, jaki rodzaj makra proceduralnego tworzymy. MoÅ¼emy mieÄ‡ wiele\nrodzajÃ³w makr proceduralnych w tym samym pakiecie.\n\nPrzyjrzyjmy siÄ™ rÃ³Å¼nym rodzajom makr proceduralnych. Zaczniemy od niestandardowego\nmakra `derive`, a nastÄ™pnie wyjaÅ›nimy maÅ‚e rÃ³Å¼nice, ktÃ³re sprawiajÄ…, Å¼e\ninne formy sÄ… odmienne.\n\n<!-- Old headings. Do not remove or links may break. -->\n\n<a id=\"how-to-write-a-custom-derive-macro\"></a>\n\n### Niestandardowe makra `derive`\n\nStwÃ³rzmy pakiet o nazwie `hello_macro`, ktÃ³ry definiuje cechÄ™ nazwanÄ…\n`HelloMacro` z jednÄ… skojarzonÄ… funkcjÄ… nazwanÄ… `hello_macro`. Zamiast\nwymagaÄ‡ od naszych uÅ¼ytkownikÃ³w implementowania cechy `HelloMacro` dla kaÅ¼dego\nz ich typÃ³w, dostarczymy makro proceduralne, aby uÅ¼ytkownicy mogli opatrzyÄ‡\nswÃ³j typ adnotacjÄ… `#[derive(HelloMacro)]`, aby uzyskaÄ‡ domyÅ›lnÄ…\nimplementacjÄ™ funkcji `hello_macro`. DomyÅ›lna implementacja wyÅ›wietli\n`Hello, Macro! My name is TypeName!`, gdzie `TypeName` to nazwa typu, na\nktÃ³rym ta cecha zostaÅ‚a zdefiniowana. Innymi sÅ‚owy, napiszemy pakiet, ktÃ³ry\numoÅ¼liwi innemu programiÅ›cie napisanie kodu takiego jak w Listing 20-37\nprzy uÅ¼yciu naszego pakietu.\n\n<figure class=\"listing\" id=\"listing-20-37\">\n<span class=\"file-name\">Filename: src/main.rs</span>\n\n````rust,ignore,does_not_compile\nuse hello_macro::HelloMacro;\nuse hello_macro_derive::HelloMacro;\n\n#[derive(HelloMacro)]\nstruct Pancakes;\n\nfn main() {\n    Pancakes::hello_macro();\n}\n````\n\n<figcaption><a href=\"#listing-20-37\">Listing 20-37</a>: Kod, ktÃ³ry uÅ¼ytkownik naszego pakietu bÄ™dzie mÃ³gÅ‚ napisaÄ‡, uÅ¼ywajÄ…c naszego makra proceduralnego</figcaption>\n</figure>\n\nTen kod wyÅ›wietli `Hello, Macro! My name is Pancakes!` po zakoÅ„czeniu. Pierwszym\nkrokiem jest stworzenie nowego pakietu bibliotecznego w ten sposÃ³b:\n\n````console\n$ cargo new hello_macro --lib\n````\n\nNastÄ™pnie, w Listing 20-38, zdefiniujemy cechÄ™ `HelloMacro` i jej skojarzonÄ…\nfunkcjÄ™.\n\n<figure class=\"listing\" id=\"listing-20-38\">\n<span class=\"file-name\">Filename: src/lib.rs</span>\n\n````rust,noplayground\npub trait HelloMacro {\n    fn hello_macro();\n}\n````\n\n<figcaption><a href=\"#listing-20-38\">Listing 20-38</a>: Prosta cecha, ktÃ³rej bÄ™dziemy uÅ¼ywaÄ‡ z makrem <code>derive</code></figcaption>\n</figure>\n\nMamy cechÄ™ i jej funkcjÄ™. W tym momencie uÅ¼ytkownik naszego pakietu mÃ³gÅ‚by\nimplementowaÄ‡ cechÄ™, aby osiÄ…gnÄ…Ä‡ poÅ¼Ä…danÄ… funkcjonalnoÅ›Ä‡, jak w Listing 20-39.\n\n<figure class=\"listing\" id=\"listing-20-39\">\n<span class=\"file-name\">Filename: src/main.rs</span>\n\n````rust,ignore\nuse hello_macro::HelloMacro;\n\nstruct Pancakes;\n\nimpl HelloMacro for Pancakes {\n    fn hello_macro() {\n        println!(\"Hello, Macro! My name is Pancakes!\");\n    }\n}\n\nfn main() {\n    Pancakes::hello_macro();\n}\n````\n\n<figcaption><a href=\"#listing-20-39\">Listing 20-39</a>: Jak by to wyglÄ…daÅ‚o, gdyby uÅ¼ytkownicy napisali rÄ™cznÄ… implementacjÄ™ cechy <code>HelloMacro</code></figcaption>\n</figure>\n\nJednak musieliby napisaÄ‡ blok implementacji dla kaÅ¼dego typu, ktÃ³rego chcieliby\nuÅ¼yÄ‡ z `hello_macro`; chcemy ich oszczÄ™dziÄ‡ tego wysiÅ‚ku.\n\nDodatkowo, nie moÅ¼emy jeszcze dostarczyÄ‡ funkcji `hello_macro` z domyÅ›lnÄ…\nimplementacjÄ…, ktÃ³ra wyÅ›wietli nazwÄ™ typu, na ktÃ³rym zaimplementowano cechÄ™:\nRust nie posiada moÅ¼liwoÅ›ci refleksji, wiÄ™c nie moÅ¼e odczytaÄ‡ nazwy typu w\nczasie wykonania. Potrzebujemy makra do generowania kodu w czasie kompilacji.\n\nNastÄ™pnym krokiem jest zdefiniowanie makra proceduralnego. W chwili pisania\ntego tekstu makra proceduralne muszÄ… znajdowaÄ‡ siÄ™ we wÅ‚asnym pakiecie.\nOstatecznie to ograniczenie moÅ¼e zostaÄ‡ zniesione. Konwencja strukturyzowania\npakietÃ³w i pakietÃ³w makr jest nastÄ™pujÄ…ca: Dla pakietu o nazwie `foo`,\npakiet makra proceduralnego `derive` nazywa siÄ™ `foo_derive`. StwÃ³rzmy nowy\npakiet o nazwie `hello_macro_derive` w projekcie `hello_macro`:\n\n````console\n$ cargo new hello_macro_derive --lib\n````\n\nNasze dwa pakiety sÄ… Å›ciÅ›le powiÄ…zane, dlatego tworzymy pakiet makra\nproceduralnego w katalogu naszego pakietu `hello_macro`. JeÅ›li zmienimy\ndefinicjÄ™ cechy w `hello_macro`, bÄ™dziemy musieli rÃ³wnieÅ¼ zmieniÄ‡ implementacjÄ™\nmakra proceduralnego w `hello_macro_derive`. Oba pakiety bÄ™dÄ… musiaÅ‚y byÄ‡\npublikowane oddzielnie, a programiÅ›ci uÅ¼ywajÄ…cy tych pakietÃ³w bÄ™dÄ… musieli\ndodaÄ‡ je oba jako zaleÅ¼noÅ›ci i wprowadziÄ‡ je oba do zasiÄ™gu. MoglibyÅ›my zamiast\ntego sprawiÄ‡, by pakiet `hello_macro` uÅ¼ywaÅ‚ `hello_macro_derive` jako zaleÅ¼noÅ›ci\ni ponownie eksportowaÅ‚ kod makra proceduralnego. Jednak sposÃ³b, w jaki\nstrukturyzowaliÅ›my projekt, umoÅ¼liwia programistom uÅ¼ywanie `hello_macro`\nnawet jeÅ›li nie chcÄ… funkcjonalnoÅ›ci `derive`.\n\nMusimy zadeklarowaÄ‡ pakiet `hello_macro_derive` jako pakiet makra\nproceduralnego. BÄ™dziemy rÃ³wnieÅ¼ potrzebowaÄ‡ funkcjonalnoÅ›ci z pakietÃ³w `syn`\ni `quote`, jak zobaczysz za chwilÄ™, wiÄ™c musimy dodaÄ‡ je jako zaleÅ¼noÅ›ci.\nDodaj nastÄ™pujÄ…ce wiersze do pliku *Cargo.toml* dla `hello_macro_derive`:\n\n<figure class=\"listing\">\n<span class=\"file-name\">Filename: hello_macro_derive/Cargo.toml</span>\n\n````toml\n[lib]\nproc-macro = true\n\n[dependencies]\nsyn = \"2.0\"\nquote = \"1.0\"\n````\n\n</figure>\n\nAby rozpoczÄ…Ä‡ definiowanie makra proceduralnego, umieÅ›Ä‡ kod z Listing 20-40\nw pliku *src/lib.rs* pakietu `hello_macro_derive`. ZauwaÅ¼, Å¼e ten kod nie\nskompiluje siÄ™, dopÃ³ki nie dodamy definicji funkcji `impl_hello_macro`.\n\n<figure class=\"listing\" id=\"listing-20-40\">\n<span class=\"file-name\">Filename: hello_macro_derive/src/lib.rs</span>\n\n````rust,ignore,does_not_compile\nuse proc_macro::TokenStream;\nuse quote::quote;\n\n#[proc_macro_derive(HelloMacro)]\npub fn hello_macro_derive(input: TokenStream) -> TokenStream {\n    // Construct a representation of Rust code as a syntax tree\n    // that we can manipulate.\n    let ast = syn::parse(input).unwrap();\n\n    // Build the trait implementation.\n    impl_hello_macro(&ast)\n}\n````\n\n<figcaption><a href=\"#listing-20-40\">Listing 20-40</a>: Kod, ktÃ³ry wiÄ™kszoÅ›Ä‡ pakietÃ³w makr proceduralnych bÄ™dzie wymagaÄ‡ do przetwarzania kodu Rust</figcaption>\n</figure>\n\nZauwaÅ¼, Å¼e podzieliliÅ›my kod na funkcjÄ™ `hello_macro_derive`, ktÃ³ra jest\nodpowiedzialna za parsowanie `TokenStream`, oraz funkcjÄ™ `impl_hello_macro`,\nktÃ³ra jest odpowiedzialna za przeksztaÅ‚canie drzewa skÅ‚adni: to sprawia,\nÅ¼e pisanie makra proceduralnego jest wygodniejsze. Kod w zewnÄ™trznej funkcji\n(w tym przypadku `hello_macro_derive`) bÄ™dzie taki sam dla prawie kaÅ¼dego\npakietu makr proceduralnych, ktÃ³ry zobaczysz lub stworzysz. Kod, ktÃ³ry okreÅ›lisz\nw ciele funkcji wewnÄ™trznej (w tym przypadku `impl_hello_macro`), bÄ™dzie\ninny w zaleÅ¼noÅ›ci od celu twojego makra proceduralnego.\n\nWprowadziliÅ›my trzy nowe pakiety: `proc_macro`, [`syn`][syn]<!-- ignore -->,\noraz [`quote`][quote]<!-- ignore -->. Pakiet `proc_macro` jest dostarczany\nz Rust, wiÄ™c nie musieliÅ›my dodawaÄ‡ go do zaleÅ¼noÅ›ci w *Cargo.toml*. Pakiet\n`proc_macro` to API kompilatora, ktÃ³re pozwala nam czytaÄ‡ i manipulowaÄ‡ kodem\nRust z naszego kodu.\n\nPakiet `syn` parsuje kod Rust ze stringa do struktury danych, na ktÃ³rej moÅ¼emy\nwykonywaÄ‡ operacje. Pakiet `quote` przeksztaÅ‚ca struktury danych `syn` z\npowrotem w kod Rust. Te pakiety znacznie upraszczajÄ… parsowanie wszelkiego\nrodzaju kodu Rust, ktÃ³ry moÅ¼emy chcieÄ‡ obsÅ‚uÅ¼yÄ‡: Napisanie peÅ‚nego parsera dla\nkodu Rust nie jest prostym zadaniem.\n\nFunkcja `hello_macro_derive` zostanie wywoÅ‚ana, gdy uÅ¼ytkownik naszej\nbiblioteki okreÅ›li `#[derive(HelloMacro)]` dla typu. Jest to moÅ¼liwe, poniewaÅ¼\notagowaliÅ›my tutaj funkcjÄ™ `hello_macro_derive` za pomocÄ… `proc_macro_derive`\ni okreÅ›liliÅ›my nazwÄ™ `HelloMacro`, ktÃ³ra pasuje do nazwy naszej cechy; jest\nto konwencja, ktÃ³rej przestrzega wiÄ™kszoÅ›Ä‡ makr proceduralnych.\n\nFunkcja `hello_macro_derive` najpierw konwertuje `input` z `TokenStream` na\nstrukturÄ™ danych, ktÃ³rÄ… moÅ¼emy nastÄ™pnie interpretowaÄ‡ i na ktÃ³rej wykonywaÄ‡\noperacje. W tym miejscu do gry wkracza `syn`. Funkcja `parse` w `syn` pobiera\n`TokenStream` i zwraca strukturÄ™ `DeriveInput` reprezentujÄ…cÄ… sparsowany kod\nRust. Listing 20-41 pokazuje odpowiednie czÄ™Å›ci struktury `DeriveInput`,\nktÃ³rÄ… otrzymujemy po sparsowaniu ciÄ…gu `struct Pancakes;`.\n\n<figure class=\"listing\" id=\"listing-20-41\">\n\n````rust,ignore\nDeriveInput {\n    // --snip--\n\n    ident: Ident {\n        ident: \"Pancakes\",\n        span: #0 bytes(95..103)\n    },\n    data: Struct(\n        DataStruct {\n            struct_token: Struct,\n            fields: Unit,\n            semi_token: Some(\n                Semi\n            )\n        }\n    )\n}\n````\n\n<figcaption><a href=\"#listing-20-41\">Listing 20-41</a>: Instancja <code>DeriveInput</code>, ktÃ³rÄ… otrzymujemy podczas parsowania kodu posiadajÄ…cego atrybut makra w Listing 20-37</figcaption>\n</figure>\n\nPola tej struktury pokazujÄ…, Å¼e sparsowany kod Rust to struktura jednostkowa\nz `ident` (*identyfikatorem*, czyli nazwÄ…) `Pancakes`. W tej strukturze jest\nwiÄ™cej pÃ³l opisujÄ…cych wszelkiego rodzaju kod Rust; sprawdÅº [dokumentacjÄ™\n`syn` dla `DeriveInput`][syn-docs] po wiÄ™cej informacji.\n\nWkrÃ³tce zdefiniujemy funkcjÄ™ `impl_hello_macro`, w ktÃ³rej zbudujemy nowy kod\nRust, ktÃ³ry chcemy uwzglÄ™dniÄ‡. Ale zanim to zrobimy, zauwaÅ¼, Å¼e wyjÅ›cie dla\nnaszego makra `derive` jest rÃ³wnieÅ¼ `TokenStream`. ZwrÃ³cony `TokenStream` jest\ndodawany do kodu, ktÃ³ry piszÄ… uÅ¼ytkownicy naszego pakietu, wiÄ™c kiedy skompilujÄ…\nswÃ³j pakiet, uzyskajÄ… dodatkowÄ… funkcjonalnoÅ›Ä‡, ktÃ³rÄ… zapewniamy w zmodyfikowanym\n`TokenStream`.\n\nByÄ‡ moÅ¼e zauwaÅ¼yÅ‚eÅ›, Å¼e wywoÅ‚ujemy `unwrap`, aby spowodowaÄ‡ panikÄ™ funkcji\n`hello_macro_derive`, jeÅ›li wywoÅ‚anie funkcji `syn::parse` tutaj zakoÅ„czy siÄ™\nniepowodzeniem. Konieczne jest, aby nasze makro proceduralne wywoÅ‚aÅ‚o panikÄ™\nw przypadku bÅ‚Ä™dÃ³w, poniewaÅ¼ funkcje `proc_macro_derive` muszÄ… zwracaÄ‡\n`TokenStream` zamiast `Result`, aby byÅ‚y zgodne z API makr proceduralnych.\nUproÅ›ciliÅ›my ten przykÅ‚ad, uÅ¼ywajÄ…c `unwrap`; w kodzie produkcyjnym powinieneÅ›\ndostarczyÄ‡ bardziej szczegÃ³Å‚owe komunikaty o bÅ‚Ä™dach, uÅ¼ywajÄ…c `panic!` lub\n`expect`.\n\nTeraz, gdy mamy kod do przeksztaÅ‚cenia adnotowanego kodu Rust z `TokenStream`\nw instancjÄ™ `DeriveInput`, wygenerujmy kod, ktÃ³ry implementuje cechÄ™\n`HelloMacro` na adnotowanym typie, jak pokazano w Listing 20-42.\n\n<figure class=\"listing\" id=\"listing-20-42\">\n<span class=\"file-name\">Filename: hello_macro_derive/src/lib.rs</span>\n\n````rust,ignore\n# use proc_macro::TokenStream;\n# use quote::quote;\n# \n# #[proc_macro_derive(HelloMacro)]\n# pub fn hello_macro_derive(input: TokenStream) -> TokenStream {\n#     // Construct a representation of Rust code as a syntax tree\n#     // that we can manipulate\n#     let ast = syn::parse(input).unwrap();\n# \n#     // Build the trait implementation\n#     impl_hello_macro(&ast)\n# }\n# \nfn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {\n    let name = &ast.ident;\n    let generated = quote! {\n        impl HelloMacro for #name {\n            fn hello_macro() {\n                println!(\"Hello, Macro! My name is {}!\", stringify!(#name));\n            }\n        }\n    };\n    generated.into()\n}\n````\n\n<figcaption><a href=\"#listing-20-42\">Listing 20-42</a>: Implementacja cechy <code>HelloMacro</code> przy uÅ¼yciu sparsowanego kodu Rust</figcaption>\n</figure>\n\nUzyskujemy instancjÄ™ struktury `Ident` zawierajÄ…cÄ… nazwÄ™ (identyfikator)\nadnotowanego typu za pomocÄ… `ast.ident`. Struktura w Listing 20-41 pokazuje,\nÅ¼e gdy uruchomimy funkcjÄ™ `impl_hello_macro` na kodzie z Listing 20-37,\n`ident`, ktÃ³ry otrzymamy, bÄ™dzie miaÅ‚ pole `ident` z wartoÅ›ciÄ… `\"Pancakes\"`.\nW ten sposÃ³b zmienna `name` w Listing 20-42 bÄ™dzie zawieraÄ‡ instancjÄ™\nstruktury `Ident`, ktÃ³ra po wydrukowaniu bÄ™dzie ciÄ…giem znakÃ³w `\"Pancakes\"`,\nnazwÄ… struktury z Listing 20-37.\n\nMakro `quote!` pozwala nam zdefiniowaÄ‡ kod Rust, ktÃ³ry chcemy zwrÃ³ciÄ‡.\nKompilator oczekuje czegoÅ› innego niÅ¼ bezpoÅ›redni wynik wykonania makra `quote!`,\nwiÄ™c musimy przekonwertowaÄ‡ go na `TokenStream`. Robimy to, wywoÅ‚ujÄ…c metodÄ™\n`into`, ktÃ³ra konsumuje tÄ™ poÅ›redniÄ… reprezentacjÄ™ i zwraca wartoÅ›Ä‡\nwymaganego typu `TokenStream`.\n\nMakro `quote!` zapewnia rÃ³wnieÅ¼ bardzo fajne mechanizmy szablonowania: MoÅ¼emy\nwpisaÄ‡ `#name`, a `quote!` zastÄ…pi to wartoÅ›ciÄ… zmiennej `name`. MoÅ¼esz nawet\nwykonywaÄ‡ pewne powtÃ³rzenia podobnie do tego, jak dziaÅ‚ajÄ… zwykÅ‚e makra.\nSprawdÅº [dokumentacjÄ™ pakietu `quote`][quote-docs] dla szczegÃ³Å‚owego\nwprowadzenia.\n\nChcemy, aby nasze makro proceduralne generowaÅ‚o implementacjÄ™ naszej cechy\n`HelloMacro` dla typu, ktÃ³ry uÅ¼ytkownik adnotowaÅ‚, co moÅ¼emy uzyskaÄ‡ za\npomocÄ… `#name`. Implementacja cechy ma jednÄ… funkcjÄ™ `hello_macro`, ktÃ³rej\nciaÅ‚o zawiera funkcjonalnoÅ›Ä‡, ktÃ³rÄ… chcemy zapewniÄ‡: wyÅ›wietlenie `Hello, Macro! My name is`,\na nastÄ™pnie nazwy adnotowanego typu.\n\nUÅ¼ywane tutaj makro `stringify!` jest wbudowane w Rust. Przyjmuje ono wyraÅ¼enie\nRust, takie jak `1 + 2`, i w czasie kompilacji zamienia to wyraÅ¼enie w literaÅ‚\nciÄ…gu znakÃ³w, taki jak `\"1 + 2\"`. RÃ³Å¼ni siÄ™ to od `format!` lub `println!`,\nktÃ³re sÄ… makrami, ktÃ³re ewaluujÄ… wyraÅ¼enie, a nastÄ™pnie zamieniajÄ… wynik na\n`String`. Istnieje moÅ¼liwoÅ›Ä‡, Å¼e wejÅ›cie `#name` moÅ¼e byÄ‡ wyraÅ¼eniem do\nwydrukowania dosÅ‚ownie, dlatego uÅ¼ywamy `stringify!`. UÅ¼ycie `stringify!`\noszczÄ™dza rÃ³wnieÅ¼ alokacjÄ™, konwertujÄ…c `#name` na literaÅ‚ ciÄ…gu znakÃ³w w\nczasie kompilacji.\n\nW tym momencie `cargo build` powinno zakoÅ„czyÄ‡ siÄ™ pomyÅ›lnie zarÃ³wno w\n`hello_macro`, jak i `hello_macro_derive`. PodÅ‚Ä…czmy te pakiety do kodu w\nListing 20-37, aby zobaczyÄ‡ makro proceduralne w akcji! UtwÃ³rz nowy projekt\nbinarny w katalogu *projects* za pomocÄ… `cargo new pancakes`. Musimy dodaÄ‡\n`hello_macro` i `hello_macro_derive` jako zaleÅ¼noÅ›ci w pliku *Cargo.toml*\npakietu `pancakes`. JeÅ›li publikujesz swoje wersje `hello_macro` i\n`hello_macro_derive` na [crates.io](https://crates.io/)<!-- ignore -->,\nbyÅ‚yby to zwykÅ‚e zaleÅ¼noÅ›ci; jeÅ›li nie, moÅ¼esz okreÅ›liÄ‡ je jako zaleÅ¼noÅ›ci\n`path` w nastÄ™pujÄ…cy sposÃ³b:\n\n````toml\n[dependencies]\nhello_macro = { path = \"../hello_macro\" }\nhello_macro_derive = { path = \"../hello_macro/hello_macro_derive\" }\n````\n\nUmieÅ›Ä‡ kod z Listing 20-37 w pliku *src/main.rs* i uruchom `cargo run`:\npowinien wyÅ›wietliÄ‡ `Hello, Macro! My name is Pancakes!`. Implementacja cechy\n`HelloMacro` z makra proceduralnego zostaÅ‚a wÅ‚Ä…czona bez koniecznoÅ›ci\nimplementowania jej przez pakiet `pancakes`; `#[derive(HelloMacro)]` dodaÅ‚o\nimplementacjÄ™ cechy.\n\nNastÄ™pnie zbadamy, jak inne rodzaje makr proceduralnych rÃ³Å¼niÄ… siÄ™ od\nniestandardowych makr `derive`.\n\n### Makra podobne do atrybutÃ³w\n\nMakra podobne do atrybutÃ³w sÄ… podobne do niestandardowych makr `derive`, ale\nzamiast generowaÄ‡ kod dla atrybutu `derive`, pozwalajÄ… tworzyÄ‡ nowe atrybuty.\nSÄ… rÃ³wnieÅ¼ bardziej elastyczne: `derive` dziaÅ‚a tylko dla struktur i enumÃ³w;\natrybuty mogÄ… byÄ‡ stosowane rÃ³wnieÅ¼ do innych elementÃ³w, takich jak funkcje.\nOto przykÅ‚ad uÅ¼ycia makra podobnego do atrybutu. Powiedzmy, Å¼e masz atrybut o\nnazwie `route`, ktÃ³ry adnotuje funkcje podczas uÅ¼ywania frameworka\naplikacji webowych:\n\n````rust,ignore\n#[route(GET, \"/\")]\nfn index() {\n````\n\nTen atrybut `#[route]` byÅ‚by zdefiniowany przez framework jako makro\nproceduralne. Sygnatura funkcji definicji makra wyglÄ…daÅ‚aby tak:\n\n````rust,ignore\n#[proc_macro_attribute]\npub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {\n````\n\nTutaj mamy dwa parametry typu `TokenStream`. Pierwszy dotyczy zawartoÅ›ci\natrybutu: czÄ™Å›Ä‡ `GET, \"/\"`. Drugi to ciaÅ‚o elementu, do ktÃ³rego atrybut jest\ndoÅ‚Ä…czony: w tym przypadku `fn index() {}` i reszta ciaÅ‚a funkcji.\n\nPoza tym, makra podobne do atrybutÃ³w dziaÅ‚ajÄ… tak samo jak niestandardowe\nmakra `derive`: Tworzysz pakiet z typem pakietu `proc-macro` i implementujesz\nfunkcjÄ™, ktÃ³ra generuje kod, ktÃ³rego potrzebujesz!\n\n### Makra podobne do funkcji\n\nMakra podobne do funkcji definiujÄ… makra, ktÃ³re wyglÄ…dajÄ… jak wywoÅ‚ania\nfunkcji. Podobnie jak makra `macro_rules!`, sÄ… bardziej elastyczne niÅ¼ funkcje;\nna przykÅ‚ad mogÄ… przyjmowaÄ‡ nieznanÄ… liczbÄ™ argumentÃ³w. Jednak makra\n`macro_rules!` mogÄ… byÄ‡ definiowane tylko za pomocÄ… skÅ‚adni podobnej do\n`match`, ktÃ³rÄ… omÃ³wiliÅ›my wczeÅ›niej w sekcji [â€Makra deklaratywne do ogÃ³lnego\nmetaprogramowaniaâ€][decl]<!-- ignore -->. Makra podobne do funkcji przyjmujÄ…\nparametr `TokenStream`, a ich definicja manipuluje tym `TokenStream` za pomocÄ…\nkodu Rust, tak jak robiÄ… to inne dwa typy makr proceduralnych. PrzykÅ‚adem\nmakra podobnego do funkcji jest makro `sql!`, ktÃ³re moÅ¼e byÄ‡ wywoÅ‚ane w\nnastÄ™pujÄ…cy sposÃ³b:\n\n````rust,ignore\nlet sql = sql!(SELECT * FROM posts WHERE id=1);\n````\n\nTo makro parsowaÅ‚oby instrukcjÄ™ SQL wewnÄ…trz i sprawdzaÅ‚oby, czy jest\nskÅ‚adniowo poprawna, co jest znacznie bardziej zÅ‚oÅ¼onym przetwarzaniem niÅ¼\nto, co moÅ¼e wykonaÄ‡ makro `macro_rules!`. Makro `sql!` byÅ‚oby zdefiniowane tak:\n\n````rust,ignore\n#[proc_macro]\npub fn sql(input: TokenStream) -> TokenStream {\n````\n\nTa definicja jest podobna do sygnatury makra `derive`: Otrzymujemy tokeny,\nktÃ³re znajdujÄ… siÄ™ w nawiasach, i zwracamy kod, ktÃ³ry chcieliÅ›my wygenerowaÄ‡.\n\n## Podsumowanie\n\nUff! Teraz masz w swoim zestawie narzÄ™dzi Rust kilka funkcji, ktÃ³rych\nprawdopodobnie nie bÄ™dziesz czÄ™sto uÅ¼ywaÄ‡, ale bÄ™dziesz wiedzieÄ‡, Å¼e sÄ…\ndostÄ™pne w bardzo szczegÃ³lnych okolicznoÅ›ciach. PrzedstawiliÅ›my kilka\nzÅ‚oÅ¼onych tematÃ³w, abyÅ› mÃ³gÅ‚ rozpoznaÄ‡ te koncepcje i skÅ‚adniÄ™, gdy napotkasz\nje w sugestiach komunikatÃ³w o bÅ‚Ä™dach lub w cudzym kodzie. UÅ¼yj tego rozdziaÅ‚u\njako odniesienia, ktÃ³re poprowadzi ciÄ™ do rozwiÄ…zaÅ„.\n\nNastÄ™pnie wprowadzimy w Å¼ycie wszystko, co omÃ³wiliÅ›my w caÅ‚ej ksiÄ…Å¼ce, i\nzrobimy jeszcze jeden projekt!\n\n[ref]: ../reference/macros-by-example.html\n[tlborm]: https://veykril.github.io/tlborm/\n[syn]: https://crates.io/crates/syn\n[quote]: https://crates.io/crates/quote\n[syn-docs]: https://docs.rs/syn/2.0/syn/struct.DeriveInput.html\n[quote-docs]: https://docs.rs/quote\n[decl]: #declarative-macros-with-macro_rules-for-general-metaprogramming",
        "chapter_title": "Makra"
    },
    {
        "file_path": "ch21-00-final-project-a-web-server.md",
        "content": "# Projekt KoÅ„cowy: Budowanie WielowÄ…tkowego Serwera WWW\n\nTo byÅ‚a dÅ‚uga podrÃ³Å¼, ale dotarliÅ›my do koÅ„ca ksiÄ…Å¼ki. W tym rozdziale\nzbudujemy razem jeszcze jeden projekt, aby zademonstrowaÄ‡ niektÃ³re z\nkoncepcji, ktÃ³re omÃ³wiliÅ›my w ostatnich rozdziaÅ‚ach, a takÅ¼e podsumowaÄ‡\nniektÃ³re wczeÅ›niejsze lekcje.\n\nNa nasz koÅ„cowy projekt stworzymy serwer WWW, ktÃ³ry wyÅ›wietla â€Witaj!â€ i\nwyglÄ…da jak na Rysunku 21-1 w przeglÄ…darce internetowej.\n\nOto nasz plan budowy serwera WWW:\n\n1. Naucz siÄ™ trochÄ™ o TCP i HTTP.\n2. NasÅ‚uchuj poÅ‚Ä…czeÅ„ TCP na gnieÅºdzie.\n3. Parsuj niewielkÄ… liczbÄ™ Å¼Ä…daÅ„ HTTP.\n4. UtwÃ³rz poprawnÄ… odpowiedÅº HTTP.\n5. Popraw przepustowoÅ›Ä‡ naszego serwera za pomocÄ… puli wÄ…tkÃ³w.\n\n<img alt=\"Zrzut ekranu przeglÄ…darki internetowej odwiedzajÄ…cej adres 127.0.0.1:8080 wyÅ›wietlajÄ…cej stronÄ™ internetowÄ… z treÅ›ciÄ… tekstowÄ… â€Hello! Hi from Rustâ€\" src=\"img/trpl21-01.png\" class=\"center\" style=\"width: 50%;\" />\n\n<span class=\"caption\">Rysunek 21-1: Nasz koÅ„cowy wspÃ³lny projekt</span>\n\nZanim zaczniemy, powinniÅ›my wspomnieÄ‡ o dwÃ³ch szczegÃ³Å‚ach. Po pierwsze, metoda,\nktÃ³rej uÅ¼yjemy, nie bÄ™dzie najlepszym sposobem na zbudowanie serwera WWW w Rust.\nCzÅ‚onkowie spoÅ‚ecznoÅ›ci opublikowali wiele gotowych do produkcji pakietÃ³w\ndostÄ™pnych na [crates.io](https://crates.io/)<!-- ignore -->, ktÃ³re\ndostarczajÄ… bardziej kompletne implementacje serwera WWW i puli wÄ…tkÃ³w niÅ¼ te,\nktÃ³re zbudujemy. Jednak naszym zamiarem w tym rozdziale jest pomoc w nauce, a\nnie wybieranie Å‚atwej drogi. PoniewaÅ¼ Rust jest jÄ™zykiem programowania\nsystemowego, moÅ¼emy wybraÄ‡ poziom abstrakcji, z ktÃ³rym chcemy pracowaÄ‡ i zejÅ›Ä‡\nna niÅ¼szy poziom, niÅ¼ jest to moÅ¼liwe lub praktyczne w innych jÄ™zykach.\n\nPo drugie, nie bÄ™dziemy tutaj uÅ¼ywaÄ‡ `async` i `await`. Budowanie puli wÄ…tkÃ³w\nto wystarczajÄ…co duÅ¼e wyzwanie samo w sobie, bez dodawania budowania\nÅ›rodowiska wykonawczego `async`! JednakÅ¼e, zauwaÅ¼ymy, jak `async` i `await`\nmogÄ… byÄ‡ stosowane do niektÃ³rych z tych samych problemÃ³w, ktÃ³re zobaczymy w\ntym rozdziale. Ostatecznie, jak zauwaÅ¼yliÅ›my w Rozdziale 17, wiele Å›rodowisk\nwykonawczych `async` uÅ¼ywa pul wÄ…tkÃ³w do zarzÄ…dzania swojÄ… pracÄ….\n\nDlatego napiszemy podstawowy serwer HTTP i pulÄ™ wÄ…tkÃ³w rÄ™cznie, abyÅ› mÃ³gÅ‚\npoznaÄ‡ ogÃ³lne idee i techniki stojÄ…ce za pakietami, ktÃ³rych moÅ¼esz uÅ¼yÄ‡ w\nprzyszÅ‚oÅ›ci.",
        "chapter_title": "Projekt KoÅ„cowy: Budowanie WielowÄ…tkowego Serwera WWW"
    }
]